// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.Animation namespace.
//     This code was generated by a tool.
//     Date : 6/25/2016 10:38:13 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.Animation {

// Disable warning : XML comment is not placed on a valid language element
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
    /// <summary>	
    /// <p> Defines methods for creating a custom interpolator.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Client applications can use the transitions provided in  <strong><see cref="SharpDX.Animation.TransitionLibrary"/></strong> or in a library provided by a third party; however, if you need custom behavior, you can create your own transitions by implementing the <strong><see cref="SharpDX.Animation.Interpolator"/></strong> interface.</p><p>Before Windows Animation can use your custom interpolator, you must wrap it in an object that implements  <strong><see cref="SharpDX.Animation.Transition"/></strong> by calling the <strong><see cref="SharpDX.Animation.TransitionFactory.CreateTransition"/></strong> method and passing in the custom  interpolator.  After the interpolator is wrapped, client applications interact with your interpolator using the <strong><see cref="SharpDX.Animation.Transition"/></strong> interface.</p><p>Custom interpolators can be reused across applications, but it is recommended that they be exposed using factory interfaces that return <strong><see cref="SharpDX.Animation.Transition"/></strong> interfaces.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator']/*"/>	
    /// <msdn-id>dd371665</msdn-id>	
    /// <unmanaged>IUIAnimationInterpolator</unmanaged>	
    /// <unmanaged-short>IUIAnimationInterpolator</unmanaged-short>	
    [Guid("7815CBBA-DDF7-478c-A46C-7B6C738B7978")]
    public partial class Interpolator : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.Interpolator"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Interpolator(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.Interpolator"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.Interpolator(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.Interpolator(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets or sets the duration of a transition.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Windows Animation always calls the <strong>SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>GetDuration</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>GetDuration</strong> reflect the updated state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator::GetDuration']/*"/>	
        /// <msdn-id>dd371674</msdn-id>	
        /// <unmanaged>GetDuration / SetDuration</unmanaged>	
        /// <unmanaged-short>GetDuration</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator::GetDuration([Out] double* duration)</unmanaged>
        public double Duration {
                get { double __output__; GetDuration(out __output__); return __output__; }
                set { SetDuration(value); }
        }
        
        /// <summary>	
        /// <p>Gets the final value at the end of the transition.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Windows Animation always calls the <strong>SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>GetFinalValue</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>GetFinalValue</strong> reflect the updated state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator::GetFinalValue']/*"/>	
        /// <msdn-id>dd371676</msdn-id>	
        /// <unmanaged>GetFinalValue</unmanaged>	
        /// <unmanaged-short>GetFinalValue</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator::GetFinalValue([Out] double* value)</unmanaged>
        public double FinalValue {
                get { double __output__; GetFinalValue(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Sets the initial value and velocity at the start of the transition.</p>	
        /// </summary>	
        /// <param name="initialValue"><dd> <p>The initial value.</p> </dd></param>	
        /// <param name="initialVelocity"><dd> <p>The initial velocity.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.  See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Windows Animation always calls <strong>SetInitialValueAndVelocity</strong> before calling the other methods of  <strong><see cref="SharpDX.Animation.Interpolator"/></strong> at different offsets. However, it can be called multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to these methods reflect the updated state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator::SetInitialValueAndVelocity']/*"/>	
        /// <msdn-id>dd371682</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator::SetInitialValueAndVelocity([In] double initialValue,[In] double initialVelocity)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator::SetInitialValueAndVelocity</unmanaged-short>	
        public void SetInitialValueAndVelocity(double initialValue, double initialVelocity) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, initialValue, initialVelocity,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the duration of the transition.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p>The duration of the transition.</p> </dd></param>	
        /// <returns><p> If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Windows Animation calls this method only after calling the <strong>GetDependencies</strong> method, and only if that call returns <strong><see cref="SharpDX.Animation.Dependencies.Duration"/></strong> as one of its <em>durationDependencies</em> flags.</p><p>Typically, an interpolator with a duration dependency will have a duration parameter in its associated creation method of <strong><see cref="SharpDX.Animation.TransitionFactory"/></strong>.  The interpolator should store its duration when first initialized and overwrite it when <strong>SetDuration</strong> is called.</p><p>Windows Animation always calls the <strong>SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>SetDuration</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> and <strong>SetDuration</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>SetDuration</strong> reflect the updated state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator::SetDuration']/*"/>	
        /// <msdn-id>dd371679</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator::SetDuration([In] double duration)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator::SetDuration</unmanaged-short>	
        internal void SetDuration(double duration) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the duration of a transition.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p>The duration of the transition.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Windows Animation always calls the <strong>SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>GetDuration</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>GetDuration</strong> reflect the updated state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator::GetDuration']/*"/>	
        /// <msdn-id>dd371674</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator::GetDuration([Out] double* duration)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator::GetDuration</unmanaged-short>	
        internal void GetDuration(out double duration) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* duration_ = &duration)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the final value at the end of the transition.</p>	
        /// </summary>	
        /// <param name="value"><dd> <p>The final value.</p> </dd></param>	
        /// <returns><p> If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.  See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Windows Animation always calls the <strong>SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>GetFinalValue</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>GetFinalValue</strong> reflect the updated state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator::GetFinalValue']/*"/>	
        /// <msdn-id>dd371676</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator::GetFinalValue([Out] double* value)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator::GetFinalValue</unmanaged-short>	
        internal void GetFinalValue(out double value) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* value_ = &value)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, value_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Interpolates the value of an animation variable at the specified offset.</p>	
        /// </summary>	
        /// <param name="offset"><dd> <p> The offset from the start of the transition.</p> <p>This parameter is always greater than or equal to zero and less than the duration of the transition. This method is not called if the duration of the transition is zero.</p> </dd></param>	
        /// <returns><dd> <p>The interpolated value.</p> </dd></returns>	
        /// <remarks>	
        /// <p>Windows Animation always calls the <strong>SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>InterpolateValue</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>InterpolateValue</strong> reflect the updated state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator::InterpolateValue']/*"/>	
        /// <msdn-id>dd756725</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator::InterpolateValue([In] double offset,[Out] double* value)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator::InterpolateValue</unmanaged-short>	
        public double InterpolateValue(double offset) {
            unsafe {
                double value;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, offset, &value,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
                return value;
            }
        }
        
        /// <summary>	
        /// <p> Interpolates the velocity, or rate of change, at the specified offset.</p>	
        /// </summary>	
        /// <param name="offset"><dd> <p>The offset from the start of the transition.</p> <p>The offset is always greater than or equal to zero and less than or equal to the duration of the transition. This method is not called if the duration of the transition is zero.</p> </dd></param>	
        /// <returns><dd> <p> The interpolated velocity.</p> </dd></returns>	
        /// <remarks>	
        /// <p>Windows Animation always calls the <strong>SetInitialValueAndVelocity</strong> method to set the initial value and velocity before calling <strong>InterpolateVelocity</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>InterpolateVelocity</strong> reflect the updated state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator::InterpolateVelocity']/*"/>	
        /// <msdn-id>dd756726</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator::InterpolateVelocity([In] double offset,[Out] double* velocity)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator::InterpolateVelocity</unmanaged-short>	
        public double InterpolateVelocity(double offset) {
            unsafe {
                double velocity;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, offset, &velocity,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
                return velocity;
            }
        }
        
        /// <summary>	
        /// <p> Gets the aspects of the interpolator that depend on the initial value or velocity passed to <strong>SetInitialValueAndVelocity</strong>, or that depend on the duration passed to <strong>SetDuration</strong>.</p>	
        /// </summary>	
        /// <param name="initialValueDependencies">No documentation.</param>	
        /// <param name="initialVelocityDependencies">No documentation.</param>	
        /// <param name="durationDependencies">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method is called to identify which aspects of the custom interpolator are affected by certain inputs: value, velocity, and duration. For each of these inputs, the interpolator returns either of the following:</p><ul> <li>The bitwise-OR of any members of <strong><see cref="SharpDX.Animation.Dependencies"/></strong> that apply.</li> <li><strong><see cref="SharpDX.Animation.Dependencies.None"/></strong> if nothing depends on the input.</li> </ul><p>For example, consider an interpolator (1) that accepts a final value as a parameter, (2) that always comes to a gradual stop at that final value, and (3) whose duration is determined by the difference between the final and initial values.  The interpolator should return <strong><see cref="SharpDX.Animation.Dependencies.IntermediateValues"/></strong>|<strong>UI_ANIMATION_DURATION</strong> for <em>initialValueDependencies</em>.  It should not return <strong><see cref="SharpDX.Animation.Dependencies.FinalValue"/></strong> because this is set when the interpolator is created and is not affected by the initial value. Likewise it should not return <strong><see cref="SharpDX.Animation.Dependencies.FinalVelocity"/></strong> because the slope of the curve is defined to always be zero when it reaches the final value.</p><p>It is important that an interpolator return correct set of flags. If a flag is not present for an output, Windows Animation assumes that the corresponding parameter does not affect that aspect of the interpolator's results.  For example, if the custom interpolator does not include <strong><see cref="SharpDX.Animation.Dependencies.FinalValue"/></strong> for <em>initialVelocityDependencies</em>, Windows Animation may call <strong>SetInitialValueAndVelocity</strong> with an arbitrary velocity parameter, then call <strong>GetFinalValue</strong> to determine the final value.  The interpolator's implementation of <strong>GetFinalValue</strong> must return the same result no matter what velocity parameter has been passed to <strong>SetInitialValueAndVelocity</strong> because the interpolator has claimed that the transition's final value does not depend on the initial velocity.</p><p><strong>Note</strong>??If the flags returned for <em>durationDependencies</em> do not include <strong><see cref="SharpDX.Animation.Dependencies.Duration"/></strong>, <strong>SetDuration</strong> will never be called on the interpolator.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator::GetDependencies']/*"/>	
        /// <msdn-id>dd371672</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator::GetDependencies([Out] UI_ANIMATION_DEPENDENCIES* initialValueDependencies,[Out] UI_ANIMATION_DEPENDENCIES* initialVelocityDependencies,[Out] UI_ANIMATION_DEPENDENCIES* durationDependencies)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator::GetDependencies</unmanaged-short>	
        public void GetDependencies(out SharpDX.Animation.Dependencies initialValueDependencies, out SharpDX.Animation.Dependencies initialVelocityDependencies, out SharpDX.Animation.Dependencies durationDependencies) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* initialValueDependencies_ = &initialValueDependencies)
                    fixed (void* initialVelocityDependencies_ = &initialVelocityDependencies)
                        fixed (void* durationDependencies_ = &durationDependencies)
                            __result__= 
            				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, initialValueDependencies_, initialVelocityDependencies_, durationDependencies_,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Extends the <strong><see cref="SharpDX.Animation.Interpolator"/></strong> interface that defines methods for creating a custom interpolator.   <strong><see cref="SharpDX.Animation.Interpolator2"/></strong> supports interpolation in a given dimension. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Client applications can use the transitions provided in  the <strong><see cref="SharpDX.Animation.TransitionLibrary"/></strong> or<strong><see cref="SharpDX.Animation.TransitionLibrary2"/></strong> interfaces, or in a library provided by a third party; however, custom transitions can be created by implementing the <strong><see cref="SharpDX.Animation.Interpolator"/></strong> or  <strong><see cref="SharpDX.Animation.Interpolator2"/></strong> interfaces.</p><p>Before Windows Animation can use your custom interpolator, you must wrap it in an object that implements the  <strong><see cref="SharpDX.Animation.Transition"/></strong> interface (by calling <strong><see cref="SharpDX.Animation.TransitionFactory.CreateTransition"/></strong>) or the <strong><see cref="SharpDX.Animation.Transition2"/></strong> interface (by calling  <strong><see cref="SharpDX.Animation.TransitionFactory2.CreateTransition"/></strong>)  and passing in the custom  interpolator.  After the interpolator wrapper has been created, client applications interact with your interpolator using the <strong><see cref="SharpDX.Animation.Transition"/></strong> or <strong><see cref="SharpDX.Animation.Transition2"/></strong> interfaces.</p><p>Custom interpolators can be reused across applications, but it is recommended that they be exposed using factory interfaces that return an  <strong><see cref="SharpDX.Animation.Transition"/></strong> interface or an <strong><see cref="SharpDX.Animation.Transition2"/></strong> interface.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator2']/*"/>	
    /// <msdn-id>hh437121</msdn-id>	
    /// <unmanaged>IUIAnimationInterpolator2</unmanaged>	
    /// <unmanaged-short>IUIAnimationInterpolator2</unmanaged-short>	
    [Guid("EA76AFF8-EA22-4a23-A0EF-A6A966703518")]
    public partial class Interpolator2 : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.Interpolator2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Interpolator2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.Interpolator2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.Interpolator2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.Interpolator2(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the number of dimensions that require interpolation.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator2::GetDimension']/*"/>	
        /// <msdn-id>hh437125</msdn-id>	
        /// <unmanaged>GetDimension</unmanaged>	
        /// <unmanaged-short>GetDimension</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::GetDimension([Out] unsigned int* dimension)</unmanaged>
        public int Dimension {
                get { int __output__; GetDimension(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets or sets the duration of a transition for the given dimension.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Windows Animation always calls the <strong><see cref="SharpDX.Animation.Interpolator2.SetInitialValueAndVelocity"/></strong> method to set the initial value and velocity before calling <strong>GetDuration</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>GetDuration</strong> reflect the updated state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator2::GetDuration']/*"/>	
        /// <msdn-id>hh437126</msdn-id>	
        /// <unmanaged>GetDuration / SetDuration</unmanaged>	
        /// <unmanaged-short>GetDuration</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::GetDuration([Out] double* duration)</unmanaged>
        public double Duration {
                get { double __output__; GetDuration(out __output__); return __output__; }
                set { SetDuration(value); }
        }
        
        /// <summary>	
        /// <p>Gets the number of dimensions that require interpolation.</p>	
        /// </summary>	
        /// <param name="dimension"><dd> <p>The number of dimensions.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator2::GetDimension']/*"/>	
        /// <msdn-id>hh437125</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::GetDimension([Out] unsigned int* dimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator2::GetDimension</unmanaged-short>	
        internal void GetDimension(out int dimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dimension_ = &dimension)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, dimension_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the initial value and velocity of the transition for the given dimension.</p>	
        /// </summary>	
        /// <param name="initialValue"><dd> <p>The initial value.</p> </dd></param>	
        /// <param name="initialVelocity"><dd> <p>The initial velocity.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The dimension in which to set the initial value or velocity of the transition.</p> </dd></param>	
        /// <returns><p>Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Windows Animation always calls <strong>SetInitialValueAndVelocity</strong> before calling the other methods of  <strong><see cref="SharpDX.Animation.Interpolator2"/></strong> at different offsets. However, <strong>SetInitialValueAndVelocity</strong> can be called multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to these methods reflect the updated state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator2::SetInitialValueAndVelocity']/*"/>	
        /// <msdn-id>hh437132</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::SetInitialValueAndVelocity([In, Buffer] double* initialValue,[In, Buffer] double* initialVelocity,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator2::SetInitialValueAndVelocity</unmanaged-short>	
        public void SetInitialValueAndVelocity(double[] initialValue, double[] initialVelocity, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* initialValue_ = initialValue)
                    fixed (void* initialVelocity_ = initialVelocity)
                        __result__= 
        				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, initialValue_, initialVelocity_, cDimension,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the duration of the transition in the given dimension.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p>The duration of the transition.</p> </dd></param>	
        /// <returns><p>Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Windows Animation calls this method only after calling the <strong><see cref="SharpDX.Animation.Interpolator2.GetDependencies"/></strong> method, and only if that call returns <strong><see cref="SharpDX.Animation.Dependencies.Duration"/></strong> as one of its <em>durationDependencies</em> flags.</p><p>Typically, an interpolator with a duration dependency has a duration parameter in the <strong><see cref="SharpDX.Animation.TransitionFactory"/></strong> or <strong><see cref="SharpDX.Animation.TransitionFactory2"/></strong> creation method  that is associated with that interpolator.  The interpolator should store its duration when first initialized and overwrite the duration when <strong>SetDuration</strong> is called.</p><p>Windows Animation always calls the <strong><see cref="SharpDX.Animation.Interpolator2.SetInitialValueAndVelocity"/></strong> method to set the initial value and velocity before calling <strong>SetDuration</strong>, so a custom interpolator doesn't need to check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> and <strong>SetDuration</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>SetDuration</strong> reflect the updated state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator2::SetDuration']/*"/>	
        /// <msdn-id>hh437131</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::SetDuration([In] double duration)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator2::SetDuration</unmanaged-short>	
        internal void SetDuration(double duration) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the duration of a transition for the given dimension.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p>The duration of the transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Windows Animation always calls the <strong><see cref="SharpDX.Animation.Interpolator2.SetInitialValueAndVelocity"/></strong> method to set the initial value and velocity before calling <strong>GetDuration</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>GetDuration</strong> reflect the updated state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator2::GetDuration']/*"/>	
        /// <msdn-id>hh437126</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::GetDuration([Out] double* duration)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator2::GetDuration</unmanaged-short>	
        internal void GetDuration(out double duration) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* duration_ = &duration)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the final value at the end of the transition for the given dimension.</p>	
        /// </summary>	
        /// <param name="value"><dd> <p>The final value.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The dimension from which to retrieve the final value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Windows Animation always calls the <strong><see cref="SharpDX.Animation.Interpolator2.SetInitialValueAndVelocity"/></strong> method to set the initial value and velocity before calling <strong>GetFinalValue</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>GetFinalValue</strong> reflect the updated state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator2::GetFinalValue']/*"/>	
        /// <msdn-id>hh437127</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::GetFinalValue([Out, Buffer] double* value,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator2::GetFinalValue</unmanaged-short>	
        public void GetFinalValue(double[] value, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* value_ = value)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, value_, cDimension,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Interpolates the value of an animation variable at the specified offset and for the given dimension.</p>	
        /// </summary>	
        /// <param name="offset"><dd> <p>The offset from the start of the transition.</p> <p>This parameter is always greater than or equal to zero and less than the duration of the transition. This method is not called if the duration of the transition is zero.</p> </dd></param>	
        /// <param name="value"><dd> <p>The interpolated value.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The dimension in which to interpolate the value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Windows Animation always calls the <strong><see cref="SharpDX.Animation.Interpolator2.SetInitialValueAndVelocity"/></strong> method to set the initial value and velocity before calling <strong>InterpolateValue</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>InterpolateValue</strong> reflect the updated state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator2::InterpolateValue']/*"/>	
        /// <msdn-id>hh437129</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::InterpolateValue([In] double offset,[Out, Buffer] double* value,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator2::InterpolateValue</unmanaged-short>	
        public void InterpolateValue(double offset, double[] value, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* value_ = value)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, offset, value_, cDimension,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Interpolates the velocity, or rate of change, at the specified offset for the given dimension.</p>	
        /// </summary>	
        /// <param name="offset"><dd> <p>The offset from the start of the transition. </p> <p>The offset is always greater than or equal to zero and less than or equal to the duration of the transition. This method is not called if the duration of the transition is zero.</p> </dd></param>	
        /// <param name="velocity"><dd> <p>The interpolated velocity.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The dimension in which to interpolate the velocity.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Windows Animation always calls the <strong><see cref="SharpDX.Animation.Interpolator2.SetInitialValueAndVelocity"/></strong> method to set the initial value and velocity before calling <strong>InterpolateVelocity</strong>, so a custom interpolator need not check whether the initial value and velocity have been set.</p><p>Windows Animation can call <strong>SetInitialValueAndVelocity</strong> multiple times with different parameters. Interpolators can cache internal state to improve performance, but they must update this cached state each time <strong>SetInitialValueAndVelocity</strong> is called and ensure that the results of subsequent calls to <strong>InterpolateVelocity</strong> reflect the updated state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator2::InterpolateVelocity']/*"/>	
        /// <msdn-id>hh437130</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::InterpolateVelocity([In] double offset,[Out, Buffer] double* velocity,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator2::InterpolateVelocity</unmanaged-short>	
        public void InterpolateVelocity(double offset, double[] velocity, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* velocity_ = velocity)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, offset, velocity_, cDimension,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Generates a primitive interpolation of the specified animation curve.</p>	
        /// </summary>	
        /// <param name="interpolation"><dd> <p>The object that defines the custom animation curve information.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The dimension in which to apply the new segment.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator2::GetPrimitiveInterpolation']/*"/>	
        /// <msdn-id>hh437128</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::GetPrimitiveInterpolation([In] IUIAnimationPrimitiveInterpolation* interpolation,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator2::GetPrimitiveInterpolation</unmanaged-short>	
        public void GetPrimitiveInterpolation(SharpDX.Animation.PrimitiveInterpolation interpolation, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((interpolation == null)?IntPtr.Zero:interpolation.NativePointer), cDimension,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>For the given dimension, <strong>GetDependencies</strong> retrieves the aspects of the interpolator that depend on the initial value or velocity that is passed to the <strong><see cref="SharpDX.Animation.Interpolator2.SetInitialValueAndVelocity"/></strong> method or the duration that is passed to the <strong><see cref="SharpDX.Animation.Interpolator2.SetDuration"/></strong> method.</p>	
        /// </summary>	
        /// <param name="initialValueDependencies">No documentation.</param>	
        /// <param name="initialVelocityDependencies">No documentation.</param>	
        /// <param name="durationDependencies">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method is called to identify which aspects of the custom interpolator are affected by certain inputs: value, velocity, and duration. For each of these inputs, the interpolator returns either of the following:</p><ul> <li>The bitwise-OR of any members of <strong><see cref="SharpDX.Animation.Dependencies"/></strong> that apply.</li> <li><strong><see cref="SharpDX.Animation.Dependencies.None"/></strong> if nothing depends on the input.</li> </ul><p>For example, consider an interpolator that:</p><ul> <li>Accepts a final value as a parameter.</li> <li>Always comes to a gradual stop at that final value.</li> <li>Has a duration determined by the difference between the final value and the initial value.</li> </ul><p>In this case the interpolator should return <strong><see cref="SharpDX.Animation.Dependencies.IntermediateValues"/></strong>|<strong>UI_ANIMATION_DURATION</strong> for the <em>initialValueDependencies</em> parameter.  It should not return <strong><see cref="SharpDX.Animation.Dependencies.FinalValue"/></strong>, because this value is set when the interpolator is created and is not affected by the initial value. Likewise, the interpolator should not return <strong><see cref="SharpDX.Animation.Dependencies.FinalVelocity"/></strong>, because the slope of the curve is defined to always be zero when it reaches the final value.</p><p>It is important that an interpolator return a correct set of flags. If a flag is not present for an output, Windows Animation assumes that the corresponding parameter does not affect that aspect of the interpolator's results.  For example, if the custom interpolator does not include <strong><see cref="SharpDX.Animation.Dependencies.FinalValue"/></strong> for <em>initialVelocityDependencies</em>, Windows Animation may call <strong>SetInitialValueAndVelocity</strong> with an arbitrary velocity parameter, and then call <strong>GetFinalValue</strong> to determine the final value.  The interpolator's implementation of <strong>GetFinalValue</strong> must return the same result no matter which velocity parameter has been passed to <strong>SetInitialValueAndVelocity</strong>, because the interpolator has claimed that the transition's final value does not depend on the initial velocity.</p><p><strong>Note</strong>??If the flags returned for <em>durationDependencies</em> do not include <strong><see cref="SharpDX.Animation.Dependencies.Duration"/></strong>, <strong>SetDuration</strong> will never be called on the interpolator.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationInterpolator2::GetDependencies']/*"/>	
        /// <msdn-id>hh437123</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationInterpolator2::GetDependencies([Out] UI_ANIMATION_DEPENDENCIES* initialValueDependencies,[Out] UI_ANIMATION_DEPENDENCIES* initialVelocityDependencies,[Out] UI_ANIMATION_DEPENDENCIES* durationDependencies)</unmanaged>	
        /// <unmanaged-short>IUIAnimationInterpolator2::GetDependencies</unmanaged-short>	
        public void GetDependencies(out SharpDX.Animation.Dependencies initialValueDependencies, out SharpDX.Animation.Dependencies initialVelocityDependencies, out SharpDX.Animation.Dependencies durationDependencies) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* initialValueDependencies_ = &initialValueDependencies)
                    fixed (void* initialVelocityDependencies_ = &initialVelocityDependencies)
                        fixed (void* durationDependencies_ = &durationDependencies)
                            __result__= 
            				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, initialValueDependencies_, initialVelocityDependencies_, durationDependencies_,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Defines a method for handling storyboard loop iteration events.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationLoopIterationChangeHandler2']/*"/>	
    /// <msdn-id>hh437133</msdn-id>	
    /// <unmanaged>IUIAnimationLoopIterationChangeHandler2</unmanaged>	
    /// <unmanaged-short>IUIAnimationLoopIterationChangeHandler2</unmanaged-short>	
    [Guid("2D3B15A4-4762-47AB-A030-B23221DF3AE0")]
    internal partial interface LoopIterationChangeHandler2 : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p>Handles loop iteration change events, which occur when a loop within a storyboard begins a new iteration.</p>	
        /// </summary>	
        /// <param name="storyboard"><dd> <p>The storyboard to which the loop belongs.</p> </dd></param>	
        /// <param name="id"><dd> <p>The loop ID.</p> </dd></param>	
        /// <param name="newIterationCount"><dd> <p>The iteration count for the latest <strong><see cref="SharpDX.Animation.Manager2.Update"/></strong>.</p> </dd></param>	
        /// <param name="oldIterationCount"><dd> <p>The iteration count for the previous <strong><see cref="SharpDX.Animation.Manager2.Update"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationLoopIterationChangeHandler2::OnLoopIterationChanged']/*"/>	
        /// <msdn-id>hh437134</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationLoopIterationChangeHandler2::OnLoopIterationChanged([In] IUIAnimationStoryboard2* storyboard,[In] UINT_PTR id,[In] unsigned int newIterationCount,[In] unsigned int oldIterationCount)</unmanaged>	
        /// <unmanaged-short>IUIAnimationLoopIterationChangeHandler2::OnLoopIterationChanged</unmanaged-short>	
        /* public void OnLoopIterationChanged(SharpDX.Animation.Storyboard2 storyboard, System.IntPtr id, int newIterationCount, int oldIterationCount) */
    }
    /// <summary>	
    /// <p> Defines the animation manager, which provides a central interface for creating and managing animations.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong><see cref="SharpDX.Animation.Manager"/></strong> defines a central control object for animations. A single instance of <strong><see cref="SharpDX.Animation.Manager"/></strong> is typically used to compose, schedule,  and manage all animations for a client application.</p><p> <strong><see cref="SharpDX.Animation.Variable"/></strong>, <strong><see cref="SharpDX.Animation.Transition"/></strong>, and  <strong><see cref="SharpDX.Animation.Storyboard"/></strong> are the primary components for building animations. Use <strong><see cref="SharpDX.Animation.Manager"/></strong> to create and manage these components.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager']/*"/>	
    /// <msdn-id>dd371687</msdn-id>	
    /// <unmanaged>IUIAnimationManager</unmanaged>	
    /// <unmanaged-short>IUIAnimationManager</unmanaged-short>	
    [Guid("9169896C-AC8D-4e7d-94E5-67FA4DC2F2E8")]
    public partial class Manager : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.Manager"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Manager(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.Manager"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.Manager(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.Manager(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Gets the status of the animation manager.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::GetStatus']/*"/>	
        /// <msdn-id>dd371712</msdn-id>	
        /// <unmanaged>GetStatus</unmanaged>	
        /// <unmanaged-short>GetStatus</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationManager::GetStatus([Out] UI_ANIMATION_MANAGER_STATUS* status)</unmanaged>
        public SharpDX.Animation.ManagerStatus Status {
                get { SharpDX.Animation.ManagerStatus __output__; GetStatus(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Sets the animation mode.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method is used to enable or disable animation globally. While animation is disabled, all storyboards finish immediately when they are scheduled. The default mode is <strong><see cref="SharpDX.Animation.Mode.SystemDefault"/></strong>, which lets Windows decide when to enable or disable animation in the application.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::SetAnimationMode']/*"/>	
        /// <msdn-id>dd371732</msdn-id>	
        /// <unmanaged>SetAnimationMode</unmanaged>	
        /// <unmanaged-short>SetAnimationMode</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationManager::SetAnimationMode([In] UI_ANIMATION_MODE mode)</unmanaged>
        public SharpDX.Animation.Mode AnimationMode {
                set { SetAnimationMode(value); }
        }
        
        /// <summary>	
        /// <p> Sets the default acceptable animation delay. This is the length of time that may pass before storyboards begin.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>For a storyboard to be successfully scheduled, it must begin before the longest acceptable delay has elapsed. This delay is determined in the following order: the delay value set by calling <strong><see cref="SharpDX.Animation.Storyboard.SetLongestAcceptableDelay"/></strong> for this specific storyboard, the delay value set by calling this method, or 0.0 if neither method has been called.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::SetDefaultLongestAcceptableDelay']/*"/>	
        /// <msdn-id>dd371746</msdn-id>	
        /// <unmanaged>SetDefaultLongestAcceptableDelay</unmanaged>	
        /// <unmanaged-short>SetDefaultLongestAcceptableDelay</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationManager::SetDefaultLongestAcceptableDelay([In] double delay)</unmanaged>
        public double DefaultLongestAcceptableDelay {
                set { SetDefaultLongestAcceptableDelay(value); }
        }
        
        /// <summary>	
        /// <p> Creates a new animation variable.</p>	
        /// </summary>	
        /// <param name="initialValue"><dd> <p> The initial value for the new animation variable.</p> </dd></param>	
        /// <param name="variable"><dd> <p> The new animation variable.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The initial value of an animation variable is specified when the variable is created. After an animation variable is created, its value cannot be changed directly; it must be updated through the animation manager.</p><p>An animation variable is typically created to represent each visual characteristic that is to be animated. For example, an application might create two animation variables for the X and Y coordinates of an object that can move freely within a window.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::CreateAnimationVariable']/*"/>	
        /// <msdn-id>dd371699</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::CreateAnimationVariable([In] double initialValue,[Out, Fast] IUIAnimationVariable** variable)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::CreateAnimationVariable</unmanaged-short>	
        internal void CreateAnimationVariable(double initialValue, SharpDX.Animation.Variable variable) {
            unsafe {
                IntPtr variable_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, initialValue, &variable_,((void**)(*(void**)_nativePointer))[3]);		
                ((SharpDX.Animation.Variable)variable).NativePointer = variable_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates and schedules a single-transition storyboard.</p>	
        /// </summary>	
        /// <param name="variable"><dd> <p> The animation variable.</p> </dd></param>	
        /// <param name="transition"><dd> <p> A transition to be applied to the animation variable.</p> </dd></param>	
        /// <param name="timeNow"><dd> <p> The current system time.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method schedules a new storyboard by creating the storyboard, applying the specified transition to the specified variable, and then scheduling the storyboard.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::ScheduleTransition']/*"/>	
        /// <msdn-id>dd371728</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::ScheduleTransition([In] IUIAnimationVariable* variable,[In] IUIAnimationTransition* transition,[In] double timeNow)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::ScheduleTransition</unmanaged-short>	
        public void ScheduleTransition(SharpDX.Animation.Variable variable, SharpDX.Animation.Transition transition, double timeNow) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((variable == null)?IntPtr.Zero:variable.NativePointer), (void*)((transition == null)?IntPtr.Zero:transition.NativePointer), timeNow,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a new storyboard.</p>	
        /// </summary>	
        /// <param name="storyboard"><dd> <p> The new storyboard.</p> </dd></param>	
        /// <returns><p> If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Storyboards can specify complex coordinated updates to many animation variables. These updates happen in sequence or in parallel, and they are guaranteed to remain synchronized within the storyboard. A storyboard is created, populated with transitions on animation variables, and then scheduled. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::CreateStoryboard']/*"/>	
        /// <msdn-id>dd371703</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::CreateStoryboard([Out, Fast] IUIAnimationStoryboard** storyboard)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::CreateStoryboard</unmanaged-short>	
        internal void CreateStoryboard(SharpDX.Animation.Storyboard storyboard) {
            unsafe {
                IntPtr storyboard_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, &storyboard_,((void**)(*(void**)_nativePointer))[5]);		
                ((SharpDX.Animation.Storyboard)storyboard).NativePointer = storyboard_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Finishes all active storyboards within the specified time interval.</p>	
        /// </summary>	
        /// <param name="completionDeadline"><dd> <p> The maximum time interval during which all storyboards must be finished.</p> </dd></param>	
        /// <returns><p> If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> Calling <strong>FinishAllStoryboards</strong> ensures that all active storyboards finish within the specified completion deadline. If a storyboard is scheduled to play past the deadline, it is compressed. A storyboard is considered active if its status is <strong><see cref="SharpDX.Animation.StoryboardStatus.Playing"/></strong> or <strong><see cref="SharpDX.Animation.StoryboardStatus.Scheduled"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::FinishAllStoryboards']/*"/>	
        /// <msdn-id>dd371707</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::FinishAllStoryboards([In] double completionDeadline)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::FinishAllStoryboards</unmanaged-short>	
        public void FinishAllStoryboards(double completionDeadline) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, completionDeadline,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Abandons all active storyboards.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method is equivalent to calling the <strong><see cref="SharpDX.Animation.Storyboard.Abandon"/></strong> method for each active storyboard. A storyboard is considered active if its status is <strong><see cref="SharpDX.Animation.StoryboardStatus.Playing"/></strong> or <strong><see cref="SharpDX.Animation.StoryboardStatus.Scheduled"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::AbandonAllStoryboards']/*"/>	
        /// <msdn-id>dd371697</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::AbandonAllStoryboards()</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::AbandonAllStoryboards</unmanaged-short>	
        public void AbandonAllStoryboards() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Updates the values of all animation variables.</p>	
        /// </summary>	
        /// <param name="timeNow"><dd> <p> The current system time. This parameter must be greater than or equal to 0.0.</p> </dd></param>	
        /// <returns><dd> <p>The result of the update. This parameter can be omitted from calls to this method.</p> </dd></returns>	
        /// <remarks>	
        /// <p>Calling this method advances the animation manager to <em>timeNow</em>, changing statuses of storyboards as necessary and updating any animation variables to appropriate interpolated values. If the animation manager is paused, no storyboards or variables are updated. If the animation  mode is <strong><see cref="SharpDX.Animation.Mode.Disabled"/></strong>, all scheduled storyboards finish playing immediately. If the values of any variables change during this call, the value of <em>updateResult</em> is <strong><see cref="SharpDX.Animation.UpdateResult.VariablesChanged"/></strong>; otherwise, it is <strong><see cref="SharpDX.Animation.UpdateResult.NoChange"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::Update']/*"/>	
        /// <msdn-id>dd371755</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::Update([In] double timeNow,[Out, Optional] UI_ANIMATION_UPDATE_RESULT* updateResult)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::Update</unmanaged-short>	
        public SharpDX.Animation.UpdateResult Update(double timeNow) {
            unsafe {
                SharpDX.Animation.UpdateResult updateResult;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, timeNow, &updateResult,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
                return updateResult;
            }
        }
        
        /// <summary>	
        /// <p> Gets the animation variable with the specified tag.</p>	
        /// </summary>	
        /// <param name="@object"><dd> <p> The object portion of the tag. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="id"><dd> <p> The identifier portion of the tag.</p> </dd></param>	
        /// <returns><dd> <p> The animation variable that matches the specified tag, or <strong><c>null</c></strong> if no match is found.</p> </dd></returns>	
        /// <remarks>	
        /// <p> A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>). An application can use tags to identify animation variables and storyboards. <strong><c>null</c></strong> is a valid object component of a tag; therefore, the <em>object</em> parameter can be <strong><c>null</c></strong>.</p><p>Tags are not necessarily unique; this method returns <strong>UI_E_AMBIGUOUS_MATCH</strong> if more than one animation variable exists with the specified tag.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::GetVariableFromTag']/*"/>	
        /// <msdn-id>dd371717</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::GetVariableFromTag([In, Optional] void* object,[In] unsigned int id,[Out] IUIAnimationVariable** variable)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::GetVariableFromTag</unmanaged-short>	
        internal SharpDX.Animation.Variable GetVariableFromTag(System.IntPtr @object, int id) {
            unsafe {
                SharpDX.Animation.Variable variable;
                IntPtr variable_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)@object, id, &variable_,((void**)(*(void**)_nativePointer))[9]);		
                variable= (variable_ == IntPtr.Zero)?null:new SharpDX.Animation.Variable(variable_);	
                __result__.CheckError();
                return variable;
            }
        }
        
        /// <summary>	
        /// <p> Gets the storyboard with the specified tag.</p>	
        /// </summary>	
        /// <param name="@object"><dd> <p> The object portion of the tag. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="id"><dd> <p> The identifier portion of the tag.</p> </dd></param>	
        /// <returns><dd> <p> The storyboard that matches the specified tag, or <strong><c>null</c></strong> if no match is found.</p> </dd></returns>	
        /// <remarks>	
        /// <p>A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>). An application can use tags to identify animation variables and storyboards. <strong><c>null</c></strong> is a valid object component of a tag; therefore, the <em>object</em> parameter can be <strong><c>null</c></strong>.</p><p>Tags are not necessarily unique; this method returns UI_E_AMBIGUOUS_MATCH if more than one storyboard exists with the specified tag.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::GetStoryboardFromTag']/*"/>	
        /// <msdn-id>dd371714</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::GetStoryboardFromTag([In, Optional] void* object,[In] unsigned int id,[Out] IUIAnimationStoryboard** storyboard)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::GetStoryboardFromTag</unmanaged-short>	
        internal SharpDX.Animation.Storyboard GetStoryboardFromTag(System.IntPtr @object, int id) {
            unsafe {
                SharpDX.Animation.Storyboard storyboard;
                IntPtr storyboard_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)@object, id, &storyboard_,((void**)(*(void**)_nativePointer))[10]);		
                storyboard= (storyboard_ == IntPtr.Zero)?null:new SharpDX.Animation.Storyboard(storyboard_);	
                __result__.CheckError();
                return storyboard;
            }
        }
        
        /// <summary>	
        /// <p> Gets the status of the animation manager.</p>	
        /// </summary>	
        /// <param name="status"><dd> <p> The status.</p> </dd></param>	
        /// <returns><p> If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::GetStatus']/*"/>	
        /// <msdn-id>dd371712</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::GetStatus([Out] UI_ANIMATION_MANAGER_STATUS* status)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::GetStatus</unmanaged-short>	
        internal void GetStatus(out SharpDX.Animation.ManagerStatus status) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* status_ = &status)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, status_,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the animation mode.</p>	
        /// </summary>	
        /// <param name="mode"><dd> <p> The animation mode.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method is used to enable or disable animation globally. While animation is disabled, all storyboards finish immediately when they are scheduled. The default mode is <strong><see cref="SharpDX.Animation.Mode.SystemDefault"/></strong>, which lets Windows decide when to enable or disable animation in the application.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::SetAnimationMode']/*"/>	
        /// <msdn-id>dd371732</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::SetAnimationMode([In] UI_ANIMATION_MODE mode)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::SetAnimationMode</unmanaged-short>	
        internal void SetAnimationMode(SharpDX.Animation.Mode mode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, unchecked((int)mode),((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Pauses all animations.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> When an animation manager is paused, its status is set to <strong><see cref="SharpDX.Animation.ManagerStatus.Idle"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::Pause']/*"/>	
        /// <msdn-id>dd371722</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::Pause()</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::Pause</unmanaged-short>	
        public void Pause() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Resumes all animations.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> When an animation manager is resumed, and at least one animation is currently scheduled or playing, its status is set to <strong><see cref="SharpDX.Animation.ManagerStatus.Busy"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::Resume']/*"/>	
        /// <msdn-id>dd371726</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::Resume()</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::Resume</unmanaged-short>	
        public void Resume() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Specifies a handler for animation manager status updates.</p>	
        /// </summary>	
        /// <param name="handler"><dd> <p>The event handler to be called when the status of the animation manager changes.   The specified object must implement the <strong><see cref="SharpDX.Animation.ManagerEventHandler"/></strong> interface or be <strong><c>null</c></strong>. See Remarks section for more information.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::SetManagerEventHandler']/*"/>	
        /// <msdn-id>dd371749</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::SetManagerEventHandler([In, Optional] IUIAnimationManagerEventHandler* handler)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::SetManagerEventHandler</unmanaged-short>	
        internal void SetManagerEventHandler_(System.IntPtr handler) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)handler,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the priority comparison handler to be called to determine whether a scheduled storyboard can be canceled.</p>	
        /// </summary>	
        /// <param name="comparison"><dd> <p> The priority comparison handler for cancelation.   The specified object must implement the <strong><see cref="SharpDX.Animation.PriorityComparison"/></strong> interface or be <strong><c>null</c></strong>. See Remarks.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by canceling storyboards.</p><p>A scheduled storyboard can be canceled only if it has not started playing and the priority comparison object registered with this method returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Canceled storyboards are completely removed from the schedule.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any priority comparison handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::SetCancelPriorityComparison']/*"/>	
        /// <msdn-id>dd371734</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::SetCancelPriorityComparison([In, Optional] IUIAnimationPriorityComparison* comparison)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::SetCancelPriorityComparison</unmanaged-short>	
        internal void SetCancelPriorityComparison_(System.IntPtr comparison) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)comparison,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the priority comparison handler to be called to determine whether a scheduled storyboard can be trimmed.</p>	
        /// </summary>	
        /// <param name="comparison"><dd> <p>The priority comparison handler for trimming.   The specified object must implement the <strong><see cref="SharpDX.Animation.PriorityComparison"/></strong> interface or be <strong><c>null</c></strong>. See Remarks.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes. </p></returns>	
        /// <remarks>	
        /// <p> Setting a priority comparison handler with this method enables the application to indicate when  scheduling conflicts can be resolved by trimming the scheduled storyboard.</p><p>A scheduled storyboard can be trimmed only if the priority comparison object registered with this method returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If the new storyboard trims the scheduled storyboard,  the scheduled storyboard can no longer affect a variable once the new storyboard begins to animate that variable.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::SetTrimPriorityComparison']/*"/>	
        /// <msdn-id>dd371750</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::SetTrimPriorityComparison([In, Optional] IUIAnimationPriorityComparison* comparison)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::SetTrimPriorityComparison</unmanaged-short>	
        internal void SetTrimPriorityComparison_(System.IntPtr comparison) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)comparison,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the priority comparison handler to be called to determine whether a scheduled storyboard can be compressed.</p>	
        /// </summary>	
        /// <param name="comparison"><dd> <p> The priority comparison handler for compression.   The specified object must implement the <strong><see cref="SharpDX.Animation.PriorityComparison"/></strong> interface or be <strong><c>null</c></strong>. See Remarks. </p> </dd></param>	
        /// <returns><p> If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when the scheduling conflicts can be resolved by compressing  the scheduled storyboard and any other storyboards animating the same variables.</p><p>A storyboard can be compressed only if the priority comparison object registered with this method returns <strong><see cref="SharpDX.Result.Ok"/></strong> for all the other scheduled storyboards that will be affected by compression. When the storyboards are compressed, time is temporarily accelerated for affected storyboards, so they play faster.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::SetCompressPriorityComparison']/*"/>	
        /// <msdn-id>dd371737</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::SetCompressPriorityComparison([In, Optional] IUIAnimationPriorityComparison* comparison)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::SetCompressPriorityComparison</unmanaged-short>	
        internal void SetCompressPriorityComparison_(System.IntPtr comparison) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)comparison,((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the priority comparison handler to be called to determine whether a scheduled storyboard can be concluded.</p>	
        /// </summary>	
        /// <param name="comparison"><dd> <p> The priority comparison handler for conclusion. The specified object must implement the <strong><see cref="SharpDX.Animation.PriorityComparison"/></strong> interface or be <strong><c>null</c></strong>. See Remarks.</p> </dd></param>	
        /// <returns><p> If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by concluding the scheduled storyboard.</p><p>A scheduled storyboard can be concluded only if it contains a loop with a repetition count of <strong><strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong></strong> and the priority comparison object registered with this method returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If the storyboard is concluded, the current repetition of the loop completes, and the reminder of the storyboard then plays. </p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::SetConcludePriorityComparison']/*"/>	
        /// <msdn-id>dd371742</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::SetConcludePriorityComparison([In, Optional] IUIAnimationPriorityComparison* comparison)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::SetConcludePriorityComparison</unmanaged-short>	
        internal void SetConcludePriorityComparison_(System.IntPtr comparison) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)comparison,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the default acceptable animation delay. This is the length of time that may pass before storyboards begin.</p>	
        /// </summary>	
        /// <param name="delay"><dd> <p> The default delay. This parameter can be a positive value, or <strong>UI_ANIMATION_SECONDS_EVENTUALLY</strong> (-1) to indicate that any finite delay is acceptable.</p> </dd></param>	
        /// <returns><p> If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.             See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>For a storyboard to be successfully scheduled, it must begin before the longest acceptable delay has elapsed. This delay is determined in the following order: the delay value set by calling <strong><see cref="SharpDX.Animation.Storyboard.SetLongestAcceptableDelay"/></strong> for this specific storyboard, the delay value set by calling this method, or 0.0 if neither method has been called.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::SetDefaultLongestAcceptableDelay']/*"/>	
        /// <msdn-id>dd371746</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::SetDefaultLongestAcceptableDelay([In] double delay)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::SetDefaultLongestAcceptableDelay</unmanaged-short>	
        internal void SetDefaultLongestAcceptableDelay(double delay) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, delay,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Shuts down the animation manager and all its associated objects.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method directs the animation manager, and all the objects it created, to  release all their references to other objects. After <strong><see cref="SharpDX.Animation.Manager.Shutdown"/></strong> has been called, no other methods may be called on the animation manager or any objects that it created. An application can call this method to clean up if there is any possibility that the application has introduced a reference cycle that includes some animation objects.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager::Shutdown']/*"/>	
        /// <msdn-id>dd371753</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager::Shutdown()</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager::Shutdown</unmanaged-short>	
        public void Shutdown() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Defines an <strong>animation manager</strong>, which provides a central interface for creating and managing animations in multiple dimensions.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2']/*"/>	
    /// <msdn-id>hh437135</msdn-id>	
    /// <unmanaged>IUIAnimationManager2</unmanaged>	
    /// <unmanaged-short>IUIAnimationManager2</unmanaged-short>	
    [Guid("D8B6F7D4-4109-4d3f-ACEE-879926968CB1")]
    public partial class Manager2 : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.Manager2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Manager2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.Manager2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.Manager2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.Manager2(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Gets the status of the animation manager.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::GetStatus']/*"/>	
        /// <msdn-id>hh437147</msdn-id>	
        /// <unmanaged>GetStatus</unmanaged>	
        /// <unmanaged-short>GetStatus</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationManager2::GetStatus([Out] UI_ANIMATION_MANAGER_STATUS* status)</unmanaged>
        public SharpDX.Animation.ManagerStatus Status {
                get { SharpDX.Animation.ManagerStatus __output__; GetStatus(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Sets the animation mode.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Use this method to enable or disable animation globally. While animation is disabled, all storyboards finish immediately when they are scheduled. The default mode is <strong><see cref="SharpDX.Animation.Mode.SystemDefault"/></strong>, which lets Windows decide when to enable or disable animation in the application.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::SetAnimationMode']/*"/>	
        /// <msdn-id>hh437159</msdn-id>	
        /// <unmanaged>SetAnimationMode</unmanaged>	
        /// <unmanaged-short>SetAnimationMode</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationManager2::SetAnimationMode([In] UI_ANIMATION_MODE mode)</unmanaged>
        public SharpDX.Animation.Mode AnimationMode {
                set { SetAnimationMode(value); }
        }
        
        /// <summary>	
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be canceled.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by canceling storyboards.</p><p>A scheduled storyboard can be canceled only if it hasn't started playing and the priority comparison object registered with this method returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Canceled storyboards are completely removed from the schedule.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any priority comparison handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager2.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::SetCancelPriorityComparison']/*"/>	
        /// <msdn-id>hh437161</msdn-id>	
        /// <unmanaged>SetCancelPriorityComparison</unmanaged>	
        /// <unmanaged-short>SetCancelPriorityComparison</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationManager2::SetCancelPriorityComparison([In, Optional] IUIAnimationPriorityComparison2* comparison)</unmanaged>
        public SharpDX.Animation.PriorityComparison2 CancelPriorityComparison {
                set { SetCancelPriorityComparison(value); }
        }
        
        /// <summary>	
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be trimmed.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> Setting a priority comparison handler with this method enables the application to indicate when  scheduling conflicts can be resolved by trimming the scheduled storyboard.</p><p>A scheduled storyboard can be trimmed only if the priority comparison object registered with this method returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If the new storyboard trims the scheduled storyboard,  the scheduled storyboard can no longer affect a variable after the new storyboard begins to animate that variable.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager2.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::SetTrimPriorityComparison']/*"/>	
        /// <msdn-id>hh437169</msdn-id>	
        /// <unmanaged>SetTrimPriorityComparison</unmanaged>	
        /// <unmanaged-short>SetTrimPriorityComparison</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationManager2::SetTrimPriorityComparison([In, Optional] IUIAnimationPriorityComparison2* comparison)</unmanaged>
        public SharpDX.Animation.PriorityComparison2 TrimPriorityComparison {
                set { SetTrimPriorityComparison(value); }
        }
        
        /// <summary>	
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be compressed.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by compressing  the scheduled storyboard and any other storyboards animating the same variables.</p><p>A storyboard can be compressed only if the priority comparison object registered with this method returns <strong><see cref="SharpDX.Result.Ok"/></strong> for all the other scheduled storyboards that will be affected by compression. When the storyboards are compressed, time is temporarily accelerated for affected storyboards, so they play faster.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager2.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::SetCompressPriorityComparison']/*"/>	
        /// <msdn-id>hh437163</msdn-id>	
        /// <unmanaged>SetCompressPriorityComparison</unmanaged>	
        /// <unmanaged-short>SetCompressPriorityComparison</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationManager2::SetCompressPriorityComparison([In, Optional] IUIAnimationPriorityComparison2* comparison)</unmanaged>
        public SharpDX.Animation.PriorityComparison2 CompressPriorityComparison {
                set { SetCompressPriorityComparison(value); }
        }
        
        /// <summary>	
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be concluded.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by concluding the scheduled storyboard.</p><p>A scheduled storyboard can be concluded only if it contains a loop with a repetition count of <strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong> and the priority comparison object registered with this method returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If the storyboard is concluded, the current repetition of the loop completes, and the rest of the storyboard then plays. </p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager2.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::SetConcludePriorityComparison']/*"/>	
        /// <msdn-id>hh437165</msdn-id>	
        /// <unmanaged>SetConcludePriorityComparison</unmanaged>	
        /// <unmanaged-short>SetConcludePriorityComparison</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationManager2::SetConcludePriorityComparison([In, Optional] IUIAnimationPriorityComparison2* comparison)</unmanaged>
        public SharpDX.Animation.PriorityComparison2 ConcludePriorityComparison {
                set { SetConcludePriorityComparison(value); }
        }
        
        /// <summary>	
        /// <p> Sets the default acceptable animation delay. This is the length of time that may pass before storyboards begin.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>For Windows Animation to schedule a storyboard successfully, the storyboard must begin before the longest acceptable delay has elapsed. Windows Animation determines this delay in the following order: the delay value set by calling <strong><see cref="SharpDX.Animation.Storyboard.SetLongestAcceptableDelay"/></strong> for this specific storyboard, the delay value set by calling this method, or 0.0 if neither method has been called.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::SetDefaultLongestAcceptableDelay']/*"/>	
        /// <msdn-id>hh437167</msdn-id>	
        /// <unmanaged>SetDefaultLongestAcceptableDelay</unmanaged>	
        /// <unmanaged-short>SetDefaultLongestAcceptableDelay</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationManager2::SetDefaultLongestAcceptableDelay([In] double delay)</unmanaged>
        public double DefaultLongestAcceptableDelay {
                set { SetDefaultLongestAcceptableDelay(value); }
        }
        
        /// <summary>	
        /// <p>Creates a new animation variable for each specified dimension.</p>	
        /// </summary>	
        /// <param name="initialValue"><dd> <p>A vector (of size <em>cDimension</em>) of  initial values for the animation variable.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The number of dimensions that require animated values. This parameter specifies the number of values listed in <em>initialValue</em>.</p> </dd></param>	
        /// <param name="variable"><dd> <p> The new animation variable.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The initial value of an animation variable is specified when the variable is created. After an animation variable is created, its value cannot be changed directly; it must be updated through the animation manager.</p><p>An animation variable is typically created to represent each visual characteristic that is to be animated. For example, an application might create three animation variables for the X, Y, and Z coordinates of an object  that can move freely within a a three-dimensional space.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::CreateAnimationVectorVariable']/*"/>	
        /// <msdn-id>hh437139</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::CreateAnimationVectorVariable([In, Buffer] const double* initialValue,[In] unsigned int cDimension,[Out] IUIAnimationVariable2** variable)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::CreateAnimationVectorVariable</unmanaged-short>	
        public void CreateAnimationVectorVariable(double[] initialValue, int cDimension, out SharpDX.Animation.Variable2 variable) {
            unsafe {
                IntPtr variable_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* initialValue_ = initialValue)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, initialValue_, cDimension, &variable_,((void**)(*(void**)_nativePointer))[3]);		
                variable= (variable_ == IntPtr.Zero)?null:new SharpDX.Animation.Variable2(variable_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new animation variable.</p>	
        /// </summary>	
        /// <param name="initialValue"><dd> <p> The initial value for the animation variable.</p> </dd></param>	
        /// <param name="variable"><dd> <p> The new animation variable.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The initial value of an animation variable is specified when the variable is created. After an animation variable is created, its value cannot be changed directly; it must be updated through the animation manager.</p><p>An animation variable is typically created to represent each visual characteristic that is to be animated. For example, an application might create two animation variables for the X and Y coordinates of an object that can move freely within a window.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::CreateAnimationVariable']/*"/>	
        /// <msdn-id>hh437137</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::CreateAnimationVariable([In] double initialValue,[Out] IUIAnimationVariable2** variable)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::CreateAnimationVariable</unmanaged-short>	
        public void CreateAnimationVariable(double initialValue, out SharpDX.Animation.Variable2 variable) {
            unsafe {
                IntPtr variable_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, initialValue, &variable_,((void**)(*(void**)_nativePointer))[4]);		
                variable= (variable_ == IntPtr.Zero)?null:new SharpDX.Animation.Variable2(variable_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates and schedules a single-transition storyboard.</p>	
        /// </summary>	
        /// <param name="variable"><dd> <p> The animation variable.</p> </dd></param>	
        /// <param name="transition"><dd> <p> A transition to be applied to the animation variable.</p> </dd></param>	
        /// <param name="timeNow"><dd> <p> The current system time.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method schedules a new storyboard by creating the storyboard, applying the specified transition to the specified variable, and then scheduling the storyboard.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::ScheduleTransition']/*"/>	
        /// <msdn-id>hh437157</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::ScheduleTransition([In] IUIAnimationVariable2* variable,[In] IUIAnimationTransition2* transition,[In] double timeNow)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::ScheduleTransition</unmanaged-short>	
        public void ScheduleTransition(SharpDX.Animation.Variable2 variable, SharpDX.Animation.Transition2 transition, double timeNow) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((variable == null)?IntPtr.Zero:variable.NativePointer), (void*)((transition == null)?IntPtr.Zero:transition.NativePointer), timeNow,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new storyboard.</p>	
        /// </summary>	
        /// <param name="storyboard"><dd> <p>The new storyboard.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::CreateStoryboard']/*"/>	
        /// <msdn-id>hh437141</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::CreateStoryboard([Out] IUIAnimationStoryboard2** storyboard)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::CreateStoryboard</unmanaged-short>	
        public void CreateStoryboard(out SharpDX.Animation.Storyboard2 storyboard) {
            unsafe {
                IntPtr storyboard_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, &storyboard_,((void**)(*(void**)_nativePointer))[6]);		
                storyboard= (storyboard_ == IntPtr.Zero)?null:new SharpDX.Animation.Storyboard2(storyboard_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Finishes all active storyboards within the specified time interval.</p>	
        /// </summary>	
        /// <param name="completionDeadline"><dd> <p> The maximum time interval during which all storyboards must be finished.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> Calling the <strong>FinishAllStoryboards</strong> method ensures that all active storyboards finish within the specified completion deadline. If a storyboard is scheduled to play past the deadline, it is compressed.</p><p>A storyboard is considered active if a call to the <strong><see cref="SharpDX.Animation.Storyboard.GetStatus"/></strong> method returns <strong><see cref="SharpDX.Animation.StoryboardStatus.Playing"/></strong> or <strong><see cref="SharpDX.Animation.StoryboardStatus.Scheduled"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::FinishAllStoryboards']/*"/>	
        /// <msdn-id>hh437145</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::FinishAllStoryboards([In] double completionDeadline)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::FinishAllStoryboards</unmanaged-short>	
        public void FinishAllStoryboards(double completionDeadline) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, completionDeadline,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Abandons all active storyboards.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method is equivalent to calling the <strong><see cref="SharpDX.Animation.Storyboard.Abandon"/></strong> method for each active storyboard. </p><p>A storyboard is considered active if a call to the <strong><see cref="SharpDX.Animation.Storyboard.GetStatus"/></strong> method returns <strong><see cref="SharpDX.Animation.StoryboardStatus.Playing"/></strong> or <strong><see cref="SharpDX.Animation.StoryboardStatus.Scheduled"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::AbandonAllStoryboards']/*"/>	
        /// <msdn-id>hh437136</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::AbandonAllStoryboards()</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::AbandonAllStoryboards</unmanaged-short>	
        public void AbandonAllStoryboards() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Updates the values of all animation variables.</p>	
        /// </summary>	
        /// <param name="timeNow"><dd> <p> The current system time. This parameter must be greater than or equal to 0.0.</p> </dd></param>	
        /// <param name="updateResult"><dd> <p>The result of the update. You can omit this parameter from calls to this method.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method advances the animation manager to <em>timeNow</em>, changes the status of all storyboards as necessary, and updates any animation variables to appropriate interpolated values. If the animation manager is paused, no storyboards or variables are updated. If the animation  mode is <strong><see cref="SharpDX.Animation.Mode.Disabled"/></strong>, all scheduled storyboards finish playing immediately. If the values of any variables change during this call, the value of <em>updateResult</em> is <strong><see cref="SharpDX.Animation.UpdateResult.VariablesChanged"/></strong>; otherwise, it is <strong><see cref="SharpDX.Animation.UpdateResult.NoChange"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::Update']/*"/>	
        /// <msdn-id>hh437171</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::Update([In] double timeNow,[Out, Optional] UI_ANIMATION_UPDATE_RESULT* updateResult)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::Update</unmanaged-short>	
        public void Update(double timeNow, out SharpDX.Animation.UpdateResult updateResult) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* updateResult_ = &updateResult)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, timeNow, updateResult_,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the animation variable with the specified tag.</p>	
        /// </summary>	
        /// <param name="@object"><dd> <p> The object portion of the tag. This parameter can be <c>null</c>.</p> </dd></param>	
        /// <param name="id"><dd> <p> The identifier portion of the tag.</p> </dd></param>	
        /// <param name="variable"><dd> <p> The animation variable that matches the specified tag, or <strong><c>null</c></strong> if no match is found.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>). An application can use tags to identify animation variables and storyboards. <c>null</c> is a valid object component of a tag; therefore, the <em>object</em> parameter can be <c>null</c>.</p><p>Tags are not necessarily unique; this method returns <strong>UI_E_AMBIGUOUS_MATCH</strong> if more than one animation variable exists with the specified tag.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::GetVariableFromTag']/*"/>	
        /// <msdn-id>hh437151</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::GetVariableFromTag([In, Optional] IUnknown* object,[In] unsigned int id,[Out] IUIAnimationVariable2** variable)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::GetVariableFromTag</unmanaged-short>	
        public void GetVariableFromTag(SharpDX.ComObject @object, int id, out SharpDX.Animation.Variable2 variable) {
            unsafe {
                IntPtr variable_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((@object == null)?IntPtr.Zero:@object.NativePointer), id, &variable_,((void**)(*(void**)_nativePointer))[10]);		
                variable= (variable_ == IntPtr.Zero)?null:new SharpDX.Animation.Variable2(variable_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the storyboard with the specified tag.</p>	
        /// </summary>	
        /// <param name="@object"><dd> <p> The object portion of the tag. This parameter can be <c>null</c>.</p> </dd></param>	
        /// <param name="id"><dd> <p> The identifier portion of the tag.</p> </dd></param>	
        /// <param name="storyboard"><dd> <p> The storyboard that matches the specified tag, or <strong><c>null</c></strong> if no match is found.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>). An application can use tags to identify animation variables and storyboards. <c>null</c> is a valid object component of a tag; therefore, the <em>object</em> parameter can be <c>null</c>.</p><p>Tags are not necessarily unique; this method returns UI_E_AMBIGUOUS_MATCH if more than one storyboard exists with the specified tag.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::GetStoryboardFromTag']/*"/>	
        /// <msdn-id>hh437149</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::GetStoryboardFromTag([In, Optional] IUnknown* object,[In] unsigned int id,[Out] IUIAnimationStoryboard2** storyboard)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::GetStoryboardFromTag</unmanaged-short>	
        public void GetStoryboardFromTag(SharpDX.ComObject @object, int id, out SharpDX.Animation.Storyboard2 storyboard) {
            unsafe {
                IntPtr storyboard_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((@object == null)?IntPtr.Zero:@object.NativePointer), id, &storyboard_,((void**)(*(void**)_nativePointer))[11]);		
                storyboard= (storyboard_ == IntPtr.Zero)?null:new SharpDX.Animation.Storyboard2(storyboard_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves an estimate of  the time interval before the next animation event.</p>	
        /// </summary>	
        /// <param name="seconds"><dd> <p>The estimated time, in seconds.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::EstimateNextEventTime']/*"/>	
        /// <msdn-id>hh437143</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::EstimateNextEventTime([Out] double* seconds)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::EstimateNextEventTime</unmanaged-short>	
        public void EstimateNextEventTime(out double seconds) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* seconds_ = &seconds)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, seconds_,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the status of the animation manager.</p>	
        /// </summary>	
        /// <param name="status"><dd> <p> The status of the animation manager.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::GetStatus']/*"/>	
        /// <msdn-id>hh437147</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::GetStatus([Out] UI_ANIMATION_MANAGER_STATUS* status)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::GetStatus</unmanaged-short>	
        internal void GetStatus(out SharpDX.Animation.ManagerStatus status) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* status_ = &status)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, status_,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the animation mode.</p>	
        /// </summary>	
        /// <param name="mode"><dd> <p> The animation mode.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Use this method to enable or disable animation globally. While animation is disabled, all storyboards finish immediately when they are scheduled. The default mode is <strong><see cref="SharpDX.Animation.Mode.SystemDefault"/></strong>, which lets Windows decide when to enable or disable animation in the application.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::SetAnimationMode']/*"/>	
        /// <msdn-id>hh437159</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::SetAnimationMode([In] UI_ANIMATION_MODE mode)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::SetAnimationMode</unmanaged-short>	
        internal void SetAnimationMode(SharpDX.Animation.Mode mode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, unchecked((int)mode),((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Pauses all animations.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> When an animation manager is paused, its status is set to <strong><see cref="SharpDX.Animation.ManagerStatus.Idle"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::Pause']/*"/>	
        /// <msdn-id>hh437153</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::Pause()</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::Pause</unmanaged-short>	
        public void Pause() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Resumes all animations.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> When an animation manager is resumed, and at least one animation is currently scheduled or playing, its status is set to <strong><see cref="SharpDX.Animation.ManagerStatus.Busy"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::Resume']/*"/>	
        /// <msdn-id>hh437155</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::Resume()</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::Resume</unmanaged-short>	
        public void Resume() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Specifies a handler for animation manager status updates.</p>	
        /// </summary>	
        /// <param name="handler"><dd> <p>The event handler to be called when the status of the animation manager changes.   The specified object must implement the <strong><see cref="SharpDX.Animation.ManagerEventHandler"/></strong> interface or be <strong><c>null</c></strong>. See Remarks for more info.</p> </dd></param>	
        /// <param name="fRegisterForNextAnimationEvent"><dd> <p>If <strong>TRUE</strong>, specifies that <strong><see cref="SharpDX.Animation.Manager2.EstimateNextEventTime"/></strong> will incorporate <em>handler</em> into its estimate of the time interval until the next animation event. No default value.</p> </dd></param>	
        /// <returns><p>Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager2.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::SetManagerEventHandler']/*"/>	
        /// <msdn-id>hh437168</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::SetManagerEventHandler([In, Optional] IUIAnimationManagerEventHandler2* handler,[In] BOOL fRegisterForNextAnimationEvent)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::SetManagerEventHandler</unmanaged-short>	
        internal void SetManagerEventHandler_(System.IntPtr handler, SharpDX.Mathematics.Interop.RawBool fRegisterForNextAnimationEvent) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint22(_nativePointer, (void*)handler, fRegisterForNextAnimationEvent,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be canceled.</p>	
        /// </summary>	
        /// <param name="comparison"><dd> <p> The priority comparison handler for cancelation.   The specified object must implement the <strong><see cref="SharpDX.Animation.PriorityComparison2"/></strong> interface or be <strong><c>null</c></strong>. See Remarks for more info.</p> </dd></param>	
        /// <returns><p>Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by canceling storyboards.</p><p>A scheduled storyboard can be canceled only if it hasn't started playing and the priority comparison object registered with this method returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Canceled storyboards are completely removed from the schedule.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any priority comparison handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager2.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::SetCancelPriorityComparison']/*"/>	
        /// <msdn-id>hh437161</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::SetCancelPriorityComparison([In, Optional] IUIAnimationPriorityComparison2* comparison)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::SetCancelPriorityComparison</unmanaged-short>	
        internal void SetCancelPriorityComparison(SharpDX.Animation.PriorityComparison2 comparison) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((comparison == null)?IntPtr.Zero:comparison.NativePointer),((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be trimmed.</p>	
        /// </summary>	
        /// <param name="comparison"><dd> <p>The priority comparison handler for trimming.   The specified object must implement the <strong><see cref="SharpDX.Animation.PriorityComparison"/></strong> interface or be <strong><c>null</c></strong>. See Remarks for more info.</p> </dd></param>	
        /// <returns><p>Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> Setting a priority comparison handler with this method enables the application to indicate when  scheduling conflicts can be resolved by trimming the scheduled storyboard.</p><p>A scheduled storyboard can be trimmed only if the priority comparison object registered with this method returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If the new storyboard trims the scheduled storyboard,  the scheduled storyboard can no longer affect a variable after the new storyboard begins to animate that variable.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager2.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::SetTrimPriorityComparison']/*"/>	
        /// <msdn-id>hh437169</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::SetTrimPriorityComparison([In, Optional] IUIAnimationPriorityComparison2* comparison)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::SetTrimPriorityComparison</unmanaged-short>	
        internal void SetTrimPriorityComparison(SharpDX.Animation.PriorityComparison2 comparison) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((comparison == null)?IntPtr.Zero:comparison.NativePointer),((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be compressed.</p>	
        /// </summary>	
        /// <param name="comparison"><dd> <p> The priority comparison handler for compression.   The specified object must implement the <strong><see cref="SharpDX.Animation.PriorityComparison2"/></strong> interface or be <strong><c>null</c></strong>. See Remarks for more info. </p> </dd></param>	
        /// <returns><p>Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by compressing  the scheduled storyboard and any other storyboards animating the same variables.</p><p>A storyboard can be compressed only if the priority comparison object registered with this method returns <strong><see cref="SharpDX.Result.Ok"/></strong> for all the other scheduled storyboards that will be affected by compression. When the storyboards are compressed, time is temporarily accelerated for affected storyboards, so they play faster.</p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager2.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::SetCompressPriorityComparison']/*"/>	
        /// <msdn-id>hh437163</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::SetCompressPriorityComparison([In, Optional] IUIAnimationPriorityComparison2* comparison)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::SetCompressPriorityComparison</unmanaged-short>	
        internal void SetCompressPriorityComparison(SharpDX.Animation.PriorityComparison2 comparison) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((comparison == null)?IntPtr.Zero:comparison.NativePointer),((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the priority comparison handler that determines whether  a scheduled storyboard can be concluded.</p>	
        /// </summary>	
        /// <param name="comparison"><dd> <p> The priority comparison handler for conclusion. The specified object must implement the <strong><see cref="SharpDX.Animation.PriorityComparison2"/></strong> interface or be <strong><c>null</c></strong>. See Remarks for more info.</p> </dd></param>	
        /// <returns><p>Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Setting a priority comparison handler with this method enables the application to indicate when scheduling conflicts can be resolved by concluding the scheduled storyboard.</p><p>A scheduled storyboard can be concluded only if it contains a loop with a repetition count of <strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong> and the priority comparison object registered with this method returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If the storyboard is concluded, the current repetition of the loop completes, and the rest of the storyboard then plays. </p><p>Passing <strong><c>null</c></strong> for the <em>comparison</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager2.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::SetConcludePriorityComparison']/*"/>	
        /// <msdn-id>hh437165</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::SetConcludePriorityComparison([In, Optional] IUIAnimationPriorityComparison2* comparison)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::SetConcludePriorityComparison</unmanaged-short>	
        internal void SetConcludePriorityComparison(SharpDX.Animation.PriorityComparison2 comparison) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((comparison == null)?IntPtr.Zero:comparison.NativePointer),((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the default acceptable animation delay. This is the length of time that may pass before storyboards begin.</p>	
        /// </summary>	
        /// <param name="delay"><dd> <p> The default delay. This parameter can be a positive value, or <strong>UI_ANIMATION_SECONDS_EVENTUALLY</strong> (-1) to indicate that any finite delay is acceptable.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>For Windows Animation to schedule a storyboard successfully, the storyboard must begin before the longest acceptable delay has elapsed. Windows Animation determines this delay in the following order: the delay value set by calling <strong><see cref="SharpDX.Animation.Storyboard.SetLongestAcceptableDelay"/></strong> for this specific storyboard, the delay value set by calling this method, or 0.0 if neither method has been called.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::SetDefaultLongestAcceptableDelay']/*"/>	
        /// <msdn-id>hh437167</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::SetDefaultLongestAcceptableDelay([In] double delay)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::SetDefaultLongestAcceptableDelay</unmanaged-short>	
        internal void SetDefaultLongestAcceptableDelay(double delay) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, delay,((void**)(*(void**)_nativePointer))[22]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Shuts down the animation manager and all its associated objects.</p>	
        /// </summary>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method directs the animation manager, and all the objects it created, to  release all their references to other objects. After <strong><see cref="SharpDX.Animation.Manager2.Shutdown"/></strong> has been called, no other methods may be called on the animation manager or on any objects that it created. An application can call this method to clean up if there is any possibility that the application has introduced a reference cycle that includes some animation objects.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManager2::Shutdown']/*"/>	
        /// <msdn-id>hh437170</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManager2::Shutdown()</unmanaged>	
        /// <unmanaged-short>IUIAnimationManager2::Shutdown</unmanaged-short>	
        public void Shutdown() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[23]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Defines a method for handling status updates to an animation manager.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManagerEventHandler']/*"/>	
    /// <msdn-id>dd371690</msdn-id>	
    /// <unmanaged>IUIAnimationManagerEventHandler</unmanaged>	
    /// <unmanaged-short>IUIAnimationManagerEventHandler</unmanaged-short>	
    [Guid("783321ED-78A3-4366-B574-6AF607A64788")]
    internal partial interface ManagerEventHandler : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p> Handles status changes to an animation manager.</p>	
        /// </summary>	
        /// <param name="newStatus"><dd> <p> The new status.</p> </dd></param>	
        /// <param name="previousStatus"><dd> <p> The previous status.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A call made in this callback method to any other animation method results in the call failing and returning <strong>UI_E_ILLEGAL_REENTRANCY</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManagerEventHandler::OnManagerStatusChanged']/*"/>	
        /// <msdn-id>dd371693</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManagerEventHandler::OnManagerStatusChanged([In] UI_ANIMATION_MANAGER_STATUS newStatus,[In] UI_ANIMATION_MANAGER_STATUS previousStatus)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManagerEventHandler::OnManagerStatusChanged</unmanaged-short>	
        /* public void OnManagerStatusChanged(SharpDX.Animation.ManagerStatus newStatus, SharpDX.Animation.ManagerStatus previousStatus) */
    }
    /// <summary>	
    /// <p> Defines a method for handling updates to an <strong>animation manager</strong>.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManagerEventHandler2']/*"/>	
    /// <msdn-id>hh437172</msdn-id>	
    /// <unmanaged>IUIAnimationManagerEventHandler2</unmanaged>	
    /// <unmanaged-short>IUIAnimationManagerEventHandler2</unmanaged-short>	
    [Guid("F6E022BA-BFF3-42EC-9033-E073F33E83C3")]
    internal partial interface ManagerEventHandler2 : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p> Handles status changes to an <strong>animation manager</strong>.</p>	
        /// </summary>	
        /// <param name="newStatus">No documentation.</param>	
        /// <param name="previousStatus">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Calls made to other Windows Animation methods from <strong>IUIAnimationManager2::OnManagerStatusChanged</strong> fail and return <strong>UI_E_ILLEGAL_REENTRANCY</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationManagerEventHandler2::OnManagerStatusChanged']/*"/>	
        /// <msdn-id>hh437173</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationManagerEventHandler2::OnManagerStatusChanged([In] UI_ANIMATION_MANAGER_STATUS newStatus,[In] UI_ANIMATION_MANAGER_STATUS previousStatus)</unmanaged>	
        /// <unmanaged-short>IUIAnimationManagerEventHandler2::OnManagerStatusChanged</unmanaged-short>	
        /* public void OnManagerStatusChanged(SharpDX.Animation.ManagerStatus newStatus, SharpDX.Animation.ManagerStatus previousStatus) */
    }
    /// <summary>	
    /// <p>Defines a method that allows a custom interpolator to provide transition information, in the form of a cubic polynomial curve, to the animation manager.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationPrimitiveInterpolation']/*"/>	
    /// <msdn-id>hh437174</msdn-id>	
    /// <unmanaged>IUIAnimationPrimitiveInterpolation</unmanaged>	
    /// <unmanaged-short>IUIAnimationPrimitiveInterpolation</unmanaged-short>	
    [Guid("BAB20D63-4361-45DA-A24F-AB8508846B5B")]
    public partial class PrimitiveInterpolation : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.PrimitiveInterpolation"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PrimitiveInterpolation(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.PrimitiveInterpolation"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.PrimitiveInterpolation(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.PrimitiveInterpolation(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Adds a cubic polynomial segment that describes the shape of a transition curve to the animation function. </p>	
        /// </summary>	
        /// <param name="dimension"><dd> <p>The dimension in which to apply the new segment.</p> </dd></param>	
        /// <param name="beginOffset"><dd> <p>The begin offset for the segment, where 0 corresponds to the start of the transition.</p> </dd></param>	
        /// <param name="constantCoefficient"><dd> <p>The cubic polynomial constant coefficient.</p> </dd></param>	
        /// <param name="linearCoefficient"><dd> <p>The cubic polynomial linear coefficient.</p> </dd></param>	
        /// <param name="quadraticCoefficient"><dd> <p>The cubic polynomial quadratic coefficient.</p> </dd></param>	
        /// <param name="cubicCoefficient"><dd> <p>The cubic polynomial cubic coefficient.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method will fail with an error code of UI_E_INVALID_PRIMITIVE if the start time is either less than 0	
        /// or less than the start time of  a previous segment.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationPrimitiveInterpolation::AddCubic']/*"/>	
        /// <msdn-id>hh437175</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationPrimitiveInterpolation::AddCubic([In] unsigned int dimension,[In] double beginOffset,[In] float constantCoefficient,[In] float linearCoefficient,[In] float quadraticCoefficient,[In] float cubicCoefficient)</unmanaged>	
        /// <unmanaged-short>IUIAnimationPrimitiveInterpolation::AddCubic</unmanaged-short>	
        public void AddCubic(int dimension, double beginOffset, float constantCoefficient, float linearCoefficient, float quadraticCoefficient, float cubicCoefficient) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, dimension, beginOffset, constantCoefficient, linearCoefficient, quadraticCoefficient, cubicCoefficient,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds a sinusoidal segment that describes the shape of a transition curve to the animation function. </p>	
        /// </summary>	
        /// <param name="dimension"><dd> <p>The dimension in which to apply the new segment.</p> </dd></param>	
        /// <param name="beginOffset"><dd> <p>The begin offset for the segment, where 0 corresponds to the start of the transition.</p> </dd></param>	
        /// <param name="bias"><dd> <p>The bias constant in the sinusoidal function.</p> </dd></param>	
        /// <param name="amplitude"><dd> <p>The amplitude constant in the sinusoidal function.</p> </dd></param>	
        /// <param name="frequency"><dd> <p>The frequency constant in the sinusoidal function.</p> </dd></param>	
        /// <param name="phase"><dd> <p>The phase constant in the sinusoidal function.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Defined by the function Y(t) = bias + amplitude*sin(360*frequency*t + phase), where 'sin' is the sin of an angle specified in degrees (for example, sin(n + 360) == sin(n) for any real number 'n').</p><p>This method will fail with an error code of UI_E_INVALID_PRIMITIVE if the start time is either less than 0	
        /// or less than the start time of  a previous segment.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationPrimitiveInterpolation::AddSinusoidal']/*"/>	
        /// <msdn-id>jj643353</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationPrimitiveInterpolation::AddSinusoidal([In] unsigned int dimension,[In] double beginOffset,[In] float bias,[In] float amplitude,[In] float frequency,[In] float phase)</unmanaged>	
        /// <unmanaged-short>IUIAnimationPrimitiveInterpolation::AddSinusoidal</unmanaged-short>	
        public void AddSinusoidal(int dimension, double beginOffset, float bias, float amplitude, float frequency, float phase) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, dimension, beginOffset, bias, amplitude, frequency, phase,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Defines a method for priority comparison that the animation manager uses to resolve scheduling conflicts.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A single animation variable can be included in multiple storyboards,  but multiple storyboards cannot animate the same variable at the same time. If a newly scheduled storyboard attempts to animate one or more variables that are currently scheduled for animation by  different storyboards, a scheduling conflict occurs. To determine which storyboard has priority, the animation manager can call <strong>HasPriority</strong> on one or more  priority comparison handlers provided by the application.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationPriorityComparison']/*"/>	
    /// <msdn-id>dd371757</msdn-id>	
    /// <unmanaged>IUIAnimationPriorityComparison</unmanaged>	
    /// <unmanaged-short>IUIAnimationPriorityComparison</unmanaged-short>	
    [Guid("83FA9B74-5F86-4618-BC6A-A2FAC19B3F44")]
    internal partial interface PriorityComparison : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p> Determines whether a new storyboard has priority over a scheduled storyboard.</p>	
        /// </summary>	
        /// <param name="scheduledStoryboard"><dd> <p> The currently scheduled storyboard.</p> </dd></param>	
        /// <param name="newStoryboard"><dd> <p> The new storyboard that is interrupting the scheduled storyboard specified in <em>scheduledStoryboard</em>.</p> </dd></param>	
        /// <param name="priorityEffect"><dd> <p> The potential effect on <em>newStoryboard</em> if <em>scheduledStoryboard</em> has a higher priority.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p><em>newStoryboard</em> has priority.</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p><em>scheduledStoryboard</em> has priority.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> A single animation variable can be included in multiple storyboards,  but multiple storyboards cannot animate the same variable at the same time. If a new storyboard attempts to animate one or more variables that are currently scheduled for animation by a different storyboard, a scheduling conflict occurs. To determine which storyboard has priority, the animation manager can call <strong>HasPriority</strong> on one or more  priority comparison handlers provided by the application.</p><p>Registering priority comparison objects is optional.  By default, all storyboards can be trimmed, concluded or compressed to prevent failure, but none can be canceled, and by default no storyboards will be canceled or trimmed to prevent a delay.</p><p>By default, a call made in a callback method to any other animation method results in the call failing and returning <strong>UI_E_ILLEGAL_REENTRANCY</strong>. However, there are exceptions to this default. The following methods can be successfully called from <strong>HasPriority</strong>:</p><ul> <li> <strong><see cref="SharpDX.Animation.Manager.GetStoryboardFromTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager.GetVariableFromTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.GetTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetTag"/></strong> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationPriorityComparison::HasPriority']/*"/>	
        /// <msdn-id>dd371759</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationPriorityComparison::HasPriority([In] IUIAnimationStoryboard* scheduledStoryboard,[In] IUIAnimationStoryboard* newStoryboard,[In] UI_ANIMATION_PRIORITY_EFFECT priorityEffect)</unmanaged>	
        /// <unmanaged-short>IUIAnimationPriorityComparison::HasPriority</unmanaged-short>	
        /* public void HasPriority(SharpDX.Animation.Storyboard scheduledStoryboard, SharpDX.Animation.Storyboard newStoryboard, SharpDX.Animation.PriorityEffect priorityEffect) */
    }
    /// <summary>	
    /// <p>Defines a method that resolves scheduling conflicts through priority comparison.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A single animation variable can be included in multiple storyboards,  but multiple storyboards cannot animate the same variable at the same time. If a newly scheduled storyboard attempts to animate one or more variables that are currently scheduled for animation by  different storyboards, a scheduling conflict occurs. To determine which storyboard has priority, the animation manager can call the <strong>HasPriority</strong> method on one or more  priority comparison handlers provided by the application.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationPriorityComparison2']/*"/>	
    /// <msdn-id>hh437176</msdn-id>	
    /// <unmanaged>IUIAnimationPriorityComparison2</unmanaged>	
    /// <unmanaged-short>IUIAnimationPriorityComparison2</unmanaged-short>	
    [Guid("5B6D7A37-4621-467C-8B05-70131DE62DDB")]
    public partial class PriorityComparison2 : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.PriorityComparison2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PriorityComparison2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.PriorityComparison2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.PriorityComparison2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.PriorityComparison2(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Determines the relative priority between a scheduled storyboard and a new storyboard.</p>	
        /// </summary>	
        /// <param name="scheduledStoryboard"><dd> <p> The currently scheduled storyboard.</p> </dd></param>	
        /// <param name="newStoryboard"><dd> <p> The new storyboard that is interrupting the scheduled storyboard specified by <em>scheduledStoryboard</em>.</p> </dd></param>	
        /// <param name="priorityEffect"><dd> <p> The potential effect on <em>newStoryboard</em> if <em>scheduledStoryboard</em> has a higher priority.</p> </dd></param>	
        /// <returns><p>Returns the following if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p><em>newStoryboard</em> has priority.</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p><em>scheduledStoryboard</em> has priority.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> A single animation variable can be included in multiple storyboards,  but multiple storyboards cannot animate the same variable at the same time. If a new storyboard attempts to animate one or more variables that are currently scheduled for animation by a different storyboard, a scheduling conflict occurs. To determine which storyboard has priority, the animation manager can call the <strong>HasPriority</strong> method on one or more  priority comparison handlers provided by the application.</p><p>Registering priority comparison objects is optional.  By default, all storyboards can be trimmed, concluded, or compressed to prevent failure, but none can be canceled, and by default no storyboards will be canceled or trimmed to prevent a delay.</p><p>By default, a call made in a callback method to any other animation method results in the call failing and returning <strong>UI_E_ILLEGAL_REENTRANCY</strong>. However, there are exceptions to this default. The following methods can be successfully called from <strong>HasPriority</strong>:</p><ul> <li> <strong><see cref="SharpDX.Animation.Manager2.GetStoryboardFromTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager2.GetVariableFromTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.GetTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetTag"/></strong> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationPriorityComparison2::HasPriority']/*"/>	
        /// <msdn-id>hh437177</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationPriorityComparison2::HasPriority([In] IUIAnimationStoryboard2* scheduledStoryboard,[In] IUIAnimationStoryboard2* newStoryboard,[In] UI_ANIMATION_PRIORITY_EFFECT priorityEffect)</unmanaged>	
        /// <unmanaged-short>IUIAnimationPriorityComparison2::HasPriority</unmanaged-short>	
        public void HasPriority(SharpDX.Animation.Storyboard2 scheduledStoryboard, SharpDX.Animation.Storyboard2 newStoryboard, SharpDX.Animation.PriorityEffect priorityEffect) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((scheduledStoryboard == null)?IntPtr.Zero:scheduledStoryboard.NativePointer), (void*)((newStoryboard == null)?IntPtr.Zero:newStoryboard.NativePointer), unchecked((int)priorityEffect),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Defines a storyboard, which contains a group of transitions that are synchronized relative to one another.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong><see cref="SharpDX.Animation.Storyboard"/></strong> is a primary component for building animations, along with  <strong><see cref="SharpDX.Animation.Variable"/></strong> and  <strong><see cref="SharpDX.Animation.Transition"/></strong>. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard']/*"/>	
    /// <msdn-id>dd371761</msdn-id>	
    /// <unmanaged>IUIAnimationStoryboard</unmanaged>	
    /// <unmanaged-short>IUIAnimationStoryboard</unmanaged-short>	
    [Guid("A8FF128F-9BF9-4af1-9E67-E5E410DEFB84")]
    public partial class Storyboard : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.Storyboard"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Storyboard(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.Storyboard"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.Storyboard(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.Storyboard(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Sets the longest acceptable delay before the scheduled storyboard begins.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>For a storyboard to be successfully scheduled, it must begin before the longest acceptable delay has elapsed. This delay is determined in the following order: the delay value set by calling this method, the delay value set by calling the <strong><see cref="SharpDX.Animation.Manager.SetDefaultLongestAcceptableDelay"/></strong> method, or 0.0 if neither of these methods has been called.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::SetLongestAcceptableDelay']/*"/>	
        /// <msdn-id>dd371824</msdn-id>	
        /// <unmanaged>SetLongestAcceptableDelay</unmanaged>	
        /// <unmanaged-short>SetLongestAcceptableDelay</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::SetLongestAcceptableDelay([In] double delay)</unmanaged>
        public double LongestAcceptableDelay {
                set { SetLongestAcceptableDelay(value); }
        }
        
        /// <summary>	
        /// <p> Gets the status of the storyboard.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Unless this method is called from a handler for <strong>OnStoryboardStatusChanged</strong> events, the only values it returns are <strong><see cref="SharpDX.Animation.StoryboardStatus.Building"/></strong>, <strong><see cref="SharpDX.Animation.StoryboardStatus.Scheduled"/></strong>,	
        /// <strong><see cref="SharpDX.Animation.StoryboardStatus.Playing"/></strong>, and <strong><see cref="SharpDX.Animation.StoryboardStatus.Ready"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::GetStatus']/*"/>	
        /// <msdn-id>dd371808</msdn-id>	
        /// <unmanaged>GetStatus</unmanaged>	
        /// <unmanaged-short>GetStatus</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::GetStatus([Out] UI_ANIMATION_STORYBOARD_STATUS* status)</unmanaged>
        public SharpDX.Animation.StoryboardStatus Status {
                get { SharpDX.Animation.StoryboardStatus __output__; GetStatus(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Gets the time that has elapsed since the storyboard started playing.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::GetElapsedTime']/*"/>	
        /// <msdn-id>dd371807</msdn-id>	
        /// <unmanaged>GetElapsedTime</unmanaged>	
        /// <unmanaged-short>GetElapsedTime</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::GetElapsedTime([Out] double* elapsedTime)</unmanaged>
        public double ElapsedTime {
                get { double __output__; GetElapsedTime(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Adds a transition to the storyboard.</p>	
        /// </summary>	
        /// <param name="variable"><dd> <p> The animation variable for which the transition is to be added.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The transition to be added.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ALREADY_USED</strong></dt> </dl> </td><td> <p>This transition has already been added to a storyboard.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The <strong>AddTransition</strong> method applies the specified transition to the specified variable in the storyboard. If this is the first transition applied to this variable in this storyboard, the transition begins at the start of the storyboard. Otherwise, the transition is appended to the transition that was most recently added to the variable.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::AddTransition']/*"/>	
        /// <msdn-id>dd371789</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::AddTransition([In] IUIAnimationVariable* variable,[In] IUIAnimationTransition* transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::AddTransition</unmanaged-short>	
        public void AddTransition(SharpDX.Animation.Variable variable, SharpDX.Animation.Transition transition) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((variable == null)?IntPtr.Zero:variable.NativePointer), (void*)((transition == null)?IntPtr.Zero:transition.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Adds a keyframe at the specified offset from an existing keyframe.</p>	
        /// </summary>	
        /// <param name="existingKeyframe"><dd> <p> The existing keyframe. To add a keyframe at an offset from the start of the storyboard, use the special keyframe <strong>UI_ANIMATION_KEYFRAME_STORYBOARD_START</strong>.</p> </dd></param>	
        /// <param name="offset"><dd> <p> The offset from the existing keyframe at which a new keyframe is to be added.</p> </dd></param>	
        /// <returns><dd> <p> The keyframe to be added.</p> </dd></returns>	
        /// <remarks>	
        /// <p>A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::AddKeyframeAtOffset']/*"/>	
        /// <msdn-id>dd371784</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::AddKeyframeAtOffset([In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* existingKeyframe,[In] double offset,[Out] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003** keyframe)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::AddKeyframeAtOffset</unmanaged-short>	
        public SharpDX.Animation.KeyFrame AddKeyframeAtOffset(SharpDX.Animation.KeyFrame existingKeyframe, double offset) {
            unsafe {
                SharpDX.Animation.KeyFrame keyframe;
                keyframe = new SharpDX.Animation.KeyFrame();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, &existingKeyframe, offset, &keyframe,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
                return keyframe;
            }
        }
        
        /// <summary>	
        /// <p> Adds a keyframe at the end of the specified transition.</p>	
        /// </summary>	
        /// <param name="transition"><dd> <p> The transition after which a keyframe is to be added.</p> </dd></param>	
        /// <returns><dd> <p> The keyframe to be added.</p> </dd></returns>	
        /// <remarks>	
        /// <p> A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::AddKeyframeAfterTransition']/*"/>	
        /// <msdn-id>dd371783</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::AddKeyframeAfterTransition([In] IUIAnimationTransition* transition,[Out] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003** keyframe)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::AddKeyframeAfterTransition</unmanaged-short>	
        public SharpDX.Animation.KeyFrame AddKeyframeAfterTransition(SharpDX.Animation.Transition transition) {
            unsafe {
                SharpDX.Animation.KeyFrame keyframe;
                keyframe = new SharpDX.Animation.KeyFrame();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((transition == null)?IntPtr.Zero:transition.NativePointer), &keyframe,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
                return keyframe;
            }
        }
        
        /// <summary>	
        /// <p> Adds a transition that starts at the specified keyframe.</p>	
        /// </summary>	
        /// <param name="variable"><dd> <p> The animation variable for which a transition is to be added.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The transition to be added.</p> </dd></param>	
        /// <param name="startKeyframe"><dd> <p> The keyframe that specifies the beginning of the new transition.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ALREADY_USED</strong></dt> </dl> </td><td> <p>This transition has already been added to a storyboard or has been added to a storyboard that has finished playing and been released.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ECLIPSED</strong></dt> </dl> </td><td> <p>The transition might eclipse the beginning of another transition in the storyboard.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Transitions must be added in the order in which they will be played. A transition may begin playing before the preceding transition in the storyboard has finished, in which case the initial value and velocity seen by the new transition is determined by the state of the preceding one. A transition should not begin before the start of the preceding transition.</p><p>A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::AddTransitionAtKeyframe']/*"/>	
        /// <msdn-id>dd371795</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::AddTransitionAtKeyframe([In] IUIAnimationVariable* variable,[In] IUIAnimationTransition* transition,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* startKeyframe)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::AddTransitionAtKeyframe</unmanaged-short>	
        public void AddTransitionAtKeyframe(SharpDX.Animation.Variable variable, SharpDX.Animation.Transition transition, SharpDX.Animation.KeyFrame startKeyframe) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((variable == null)?IntPtr.Zero:variable.NativePointer), (void*)((transition == null)?IntPtr.Zero:transition.NativePointer), &startKeyframe,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Adds a transition between two keyframes.</p>	
        /// </summary>	
        /// <param name="variable"><dd> <p> The animation variable for which the transition is to be added.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The transition to be added.</p> </dd></param>	
        /// <param name="startKeyframe"><dd> <p> A keyframe that specifies the beginning of the new transition.</p> </dd></param>	
        /// <param name="endKeyframe"><dd> <p> A keyframe that specifies the end of the new transition. It must not be possible for <em>endKeyframe</em> to appear earlier in the storyboard than <em>startKeyframe</em>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ALREADY_USED</strong></dt> </dl> </td><td> <p>This transition has already been added to a storyboard or has been added to a storyboard that has finished playing and been released.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ECLIPSED</strong></dt> </dl> </td><td> <p>The transition might eclipse the beginning of another transition in the storyboard.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_START_KEYFRAME_AFTER_END</strong></dt> </dl> </td><td> <p>The start keyframe might occur after the end keyframe.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method applies the specified transition to the specified variable in the storyboard, with the transition starting and ending at the specified keyframes.  If the transition was created with a duration parameter specified, that duration is overwritten with the duration of time between the start and end keyframes. Otherwise, Windows Animation speeds up or slows down the transition as necessary.</p><p> A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p><p>Transitions must be added in the order in which they will be played. A transition may begin playing before the preceding transition in the storyboard has finished, in which case the initial value and velocity seen by the new transition will be determined by the state of the preceding one. It must not be possible for a transition to begin before the start of the preceding transition.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::AddTransitionBetweenKeyframes']/*"/>	
        /// <msdn-id>dd371798</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::AddTransitionBetweenKeyframes([In] IUIAnimationVariable* variable,[In] IUIAnimationTransition* transition,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* startKeyframe,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* endKeyframe)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::AddTransitionBetweenKeyframes</unmanaged-short>	
        public void AddTransitionBetweenKeyframes(SharpDX.Animation.Variable variable, SharpDX.Animation.Transition transition, SharpDX.Animation.KeyFrame startKeyframe, SharpDX.Animation.KeyFrame endKeyframe) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((variable == null)?IntPtr.Zero:variable.NativePointer), (void*)((transition == null)?IntPtr.Zero:transition.NativePointer), &startKeyframe, &endKeyframe,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a loop between two specified keyframes.</p>	
        /// </summary>	
        /// <param name="startKeyframe"><dd> <p> The keyframe at which the loop is to begin.</p> </dd></param>	
        /// <param name="endKeyframe"><dd> <p> The keyframe at which the loop is to end. It must not be posssible for <em>endKeyframe</em> to occur earlier in the storyboard than <em>startKeyframe</em>.</p> </dd></param>	
        /// <param name="repetitionCount"><dd> <p> The number of times the loop is to be repeated; this parameter must be 0 or a positive number. Use <strong><strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong></strong> (-1) to repeat the loop indefinitely until the storyboard is trimmed or concluded.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_START_KEYFRAME_AFTER_END</strong></dt> </dl> </td><td> <p>The start keyframe might occur after the end keyframe.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_END_KEYFRAME_NOT_DETERMINED</strong></dt> </dl> </td><td> <p>It might not be possible to determine the end keyframe time when the start keyframe is reached.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_LOOPS_OVERLAP</strong></dt> </dl> </td><td> <p>Two repeated portions of a storyboard might overlap.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method directs a storyboard to play the interval between the given keyframes repeatedly before playing the remainder of the storyboard. If a finite repetition count is specified, the loop always plays that number of times. If <strong><strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong></strong> (-1) is specified, the loop repeats until the storyboard is concluded, in which case the current iteration of the loop completes and the remainder of the storyboard plays. A storyboard that loops indefinitely also ends if it is truncated.</p><p>Nested and overlapping loops are not supported.</p><p>A keyframe represents a moment in time within a storyboard and can be used to specify the start or end times of transitions.  Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::RepeatBetweenKeyframes']/*"/>	
        /// <msdn-id>dd371816</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::RepeatBetweenKeyframes([In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* startKeyframe,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* endKeyframe,[In] int repetitionCount)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::RepeatBetweenKeyframes</unmanaged-short>	
        public void RepeatBetweenKeyframes(SharpDX.Animation.KeyFrame startKeyframe, SharpDX.Animation.KeyFrame endKeyframe, int repetitionCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, &startKeyframe, &endKeyframe, repetitionCount,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Directs the storyboard to hold the specified animation variable at its final value until the storyboard ends.</p>	
        /// </summary>	
        /// <param name="variable"><dd> <p> The animation variable.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> When a storyboard is playing, it has exclusive access to any variables it animates unless the storyboard is trimmed by a higher priority storyboard. Typically, this exclusive access is released  when the last transition in the storyboard for that variable finishes playing. Applications can call this method to maintain exclusive access to the animation variable and hold the variable, at the final value of the last transition, until the end of the storyboard.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::HoldVariable']/*"/>	
        /// <msdn-id>dd371812</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::HoldVariable([In] IUIAnimationVariable* variable)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::HoldVariable</unmanaged-short>	
        public void HoldVariable(SharpDX.Animation.Variable variable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((variable == null)?IntPtr.Zero:variable.NativePointer),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the longest acceptable delay before the scheduled storyboard begins.</p>	
        /// </summary>	
        /// <param name="delay"><dd> <p> The longest acceptable delay. This parameter can be a positive value, or <strong>UI_ANIMATION_SECONDS_EVENTUALLY</strong> (-1) to indicate that any finite delay is acceptable.</p> </dd></param>	
        /// <returns><p> If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.             </p></returns>	
        /// <remarks>	
        /// <p>For a storyboard to be successfully scheduled, it must begin before the longest acceptable delay has elapsed. This delay is determined in the following order: the delay value set by calling this method, the delay value set by calling the <strong><see cref="SharpDX.Animation.Manager.SetDefaultLongestAcceptableDelay"/></strong> method, or 0.0 if neither of these methods has been called.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::SetLongestAcceptableDelay']/*"/>	
        /// <msdn-id>dd371824</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::SetLongestAcceptableDelay([In] double delay)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::SetLongestAcceptableDelay</unmanaged-short>	
        internal void SetLongestAcceptableDelay(double delay) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, delay,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Directs the storyboard to schedule itself for play.</p>	
        /// </summary>	
        /// <param name="timeNow"><dd> <p> The current time.</p> </dd></param>	
        /// <returns><dd> <p>The result of the scheduling request. This parameter can be omitted from calls to this method.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This method directs a storyboard to attempt to add itself to the schedule of playing storyboards. The rules are as follows:</p><ul> <li> <p>If there are no playing storyboards animating any of the same animation variables, the attempt succeeds and the storyboard starts playing immediately.</p> </li> <li> <p>If the storyboard has priority to cancel, trim, conclude, or compress conflicting storyboards, the attempt to schedule succeeds and the storyboard begins playing as soon as possible.</p> </li> <li> <p>If the storyboard does not have priority, the attempt fails and the <em>schedulingResult</em> parameter is set to <strong><see cref="SharpDX.Animation.SchedulingResult.InsufficientPriority"/></strong>.</p> </li> </ul><p>If this method is called from a handler for <strong>OnStoryboardStatusChanged</strong> events, the <em>schedulingResult</em> parameter is set to <strong><see cref="SharpDX.Animation.SchedulingResult.Deferred"/></strong>.  The only way to determine whether the storyboard is successfully scheduled is to set a storyboard event handler and check whether the storyboard's status ever becomes <strong><see cref="SharpDX.Animation.StoryboardStatus.InsufficientPriority"/></strong>.</p><p>It is possible reuse a storyboard by calling <strong>Schedule</strong> again after its status has reached <strong><see cref="SharpDX.Animation.StoryboardStatus.Ready"/></strong>.  An attempt to schedule a storyboard when it is in any state other than <strong><see cref="SharpDX.Animation.StoryboardStatus.Building"/></strong> or <strong><see cref="SharpDX.Animation.StoryboardStatus.Ready"/></strong> fails, and  <em>schedulingResult</em> is set to <strong><see cref="SharpDX.Animation.SchedulingResult.AlreadyScheduled"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::Schedule']/*"/>	
        /// <msdn-id>dd371820</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::Schedule([In] double timeNow,[Out, Optional] UI_ANIMATION_SCHEDULING_RESULT* schedulingResult)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::Schedule</unmanaged-short>	
        public SharpDX.Animation.SchedulingResult Schedule(double timeNow) {
            unsafe {
                SharpDX.Animation.SchedulingResult schedulingResult;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, timeNow, &schedulingResult,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
                return schedulingResult;
            }
        }
        
        /// <summary>	
        /// <p>Completes the current iteration of a keyframe loop that is in progress (where the loop is set to <strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong>), terminates the loop, and continues with the storyboard. </p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method specifies that any subsequent  keyframe loops that have a repetition count of <strong><strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong></strong> (-1) will be skipped while the remainder of the storyboard is played.  </p><p>An iteration of a keyframe loop that is in progress will be completed before the remainder of the storyboard plays.</p><p>If this method is called  at the end  of a keyframe loop iteration, the loop is terminated and the loop value is set to the starting loop value.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::Conclude']/*"/>	
        /// <msdn-id>dd371801</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::Conclude()</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::Conclude</unmanaged-short>	
        public void Conclude() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Finishes the storyboard within the specified time, compressing the storyboard if necessary.</p>	
        /// </summary>	
        /// <param name="completionDeadline"><dd> <p> The maximum amount of time that the storyboard can use to finish playing.</p> </dd></param>	
        /// <returns><p> If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method has no effect on storyboard events. Events continue to be raised as expected while the storyboard plays.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::Finish']/*"/>	
        /// <msdn-id>dd371804</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::Finish([In] double completionDeadline)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::Finish</unmanaged-short>	
        public void Finish(double completionDeadline) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, completionDeadline,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Terminates the storyboard, releases all related animation variables, and removes the storyboard from the schedule.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> This method can be called before or after the storyboard starts playing.</p><p>This method does not trigger any storyboard events.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::Abandon']/*"/>	
        /// <msdn-id>dd371779</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::Abandon()</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::Abandon</unmanaged-short>	
        public void Abandon() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the tag for the storyboard.</p>	
        /// </summary>	
        /// <param name="@object"><dd> <p> The object portion of the tag.         This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="id"><dd> <p> The identifier portion of the tag.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_STORYBOARD_ACTIVE</strong></dt> </dl> </td><td> <p>The storyboard is currently in the schedule.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>); it can be used by an application to identify a storyboard.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::SetTag']/*"/>	
        /// <msdn-id>dd371829</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::SetTag([In, Optional] void* object,[In] unsigned int id)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::SetTag</unmanaged-short>	
        internal void SetTag(System.IntPtr @object, int id) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)@object, id,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the tag for a storyboard.</p>	
        /// </summary>	
        /// <param name="@object"><dd> <p> The object portion of the tag.</p> </dd></param>	
        /// <param name="id"><dd> <p> The identifier portion of the tag.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_VALUE_NOT_SET</strong></dt> </dl> </td><td> <p>The storyboard's tag was not set.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>); it can be used by an application to identify a storyboard.</p><p>The parameters are optional so that the method can return both portions of the tag, or just the identifier or object portion.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::GetTag']/*"/>	
        /// <msdn-id>dd371809</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::GetTag([Out, Optional] void** object,[Out, Optional] unsigned int* id)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::GetTag</unmanaged-short>	
        internal void GetTag(out System.IntPtr @object, out int id) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* @object_ = &@object)
                    fixed (void* id_ = &id)
                        __result__= 
        				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, @object_, id_,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the status of the storyboard.</p>	
        /// </summary>	
        /// <param name="status"><dd> <p> The storyboard status.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Unless this method is called from a handler for <strong>OnStoryboardStatusChanged</strong> events, the only values it returns are <strong><see cref="SharpDX.Animation.StoryboardStatus.Building"/></strong>, <strong><see cref="SharpDX.Animation.StoryboardStatus.Scheduled"/></strong>,	
        /// <strong><see cref="SharpDX.Animation.StoryboardStatus.Playing"/></strong>, and <strong><see cref="SharpDX.Animation.StoryboardStatus.Ready"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::GetStatus']/*"/>	
        /// <msdn-id>dd371808</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::GetStatus([Out] UI_ANIMATION_STORYBOARD_STATUS* status)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::GetStatus</unmanaged-short>	
        internal void GetStatus(out SharpDX.Animation.StoryboardStatus status) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* status_ = &status)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, status_,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the time that has elapsed since the storyboard started playing.</p>	
        /// </summary>	
        /// <param name="elapsedTime"><dd> <p> The elapsed time.</p> </dd></param>	
        /// <returns><p> If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.             See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_STORYBOARD_NOT_PLAYING</strong></dt> </dl> </td><td> <p>The storyboard is not playing.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::GetElapsedTime']/*"/>	
        /// <msdn-id>dd371807</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::GetElapsedTime([Out] double* elapsedTime)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::GetElapsedTime</unmanaged-short>	
        internal void GetElapsedTime(out double elapsedTime) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* elapsedTime_ = &elapsedTime)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, elapsedTime_,((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Specifies a handler for storyboard events.</p>	
        /// </summary>	
        /// <param name="handler"><dd> <p> The handler to be called whenever storyboard status and update events occur. The specified object must implement the <strong><see cref="SharpDX.Animation.StoryboardEventHandler"/></strong> interface or be <strong><c>null</c></strong>. See Remarks.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard::SetStoryboardEventHandler']/*"/>	
        /// <msdn-id>dd371827</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard::SetStoryboardEventHandler([In, Optional] IUIAnimationStoryboardEventHandler* handler)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard::SetStoryboardEventHandler</unmanaged-short>	
        internal void SetStoryboardEventHandler_(System.IntPtr handler) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)handler,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Defines a storyboard, which contains a group of transitions that are synchronized relative to one another.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong><see cref="SharpDX.Animation.Storyboard2"/></strong> is the primary component for building animations, along with  <strong><see cref="SharpDX.Animation.Variable2"/></strong> and  <strong><see cref="SharpDX.Animation.Transition2"/></strong>. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2']/*"/>	
    /// <msdn-id>hh437178</msdn-id>	
    /// <unmanaged>IUIAnimationStoryboard2</unmanaged>	
    /// <unmanaged-short>IUIAnimationStoryboard2</unmanaged-short>	
    [Guid("AE289CD2-12D4-4945-9419-9E41BE034DF2")]
    public partial class Storyboard2 : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.Storyboard2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Storyboard2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.Storyboard2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.Storyboard2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.Storyboard2(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Sets the longest acceptable delay before the scheduled storyboard begins.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>For Windows Animation to schedule a storyboard successfully, the storyboard must begin before the longest acceptable delay has elapsed. Windows Animation determines this delay in the following order: the delay value set by calling this method, the delay value set by calling the <strong><see cref="SharpDX.Animation.Manager2.SetDefaultLongestAcceptableDelay"/></strong> method, or 0.0 if neither of these methods has been called.</p><p> Use <strong><see cref="SharpDX.Animation.Storyboard2.SetSkipDuration"/></strong> to start a storyboard animation at a specified offset instead of delaying the start of a storyboard.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::SetLongestAcceptableDelay']/*"/>	
        /// <msdn-id>hh448595</msdn-id>	
        /// <unmanaged>SetLongestAcceptableDelay</unmanaged>	
        /// <unmanaged-short>SetLongestAcceptableDelay</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::SetLongestAcceptableDelay([In] double delay)</unmanaged>
        public double LongestAcceptableDelay {
                set { SetLongestAcceptableDelay(value); }
        }
        
        /// <summary>	
        /// <p>Specifies an offset from the beginning of a storyboard at which to start animating.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Calls to <strong>SetSkipDuration</strong> fail if the storyboard has been scheduled.</p><p><strong>SetSkipDuration</strong> does not delay the start of a scheduled storyboard. See <strong><see cref="SharpDX.Animation.Storyboard2.SetLongestAcceptableDelay"/></strong> for more info on how to set a delay for a scheduled storyboard.</p><p>This diagram shows a skip duration, or offset, for a storyboard. </p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::SetSkipDuration']/*"/>	
        /// <msdn-id>hh448596</msdn-id>	
        /// <unmanaged>SetSkipDuration</unmanaged>	
        /// <unmanaged-short>SetSkipDuration</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::SetSkipDuration([In] double secondsDuration)</unmanaged>
        public double SkipDuration {
                set { SetSkipDuration(value); }
        }
        
        /// <summary>	
        /// <p> Gets the status of the storyboard.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Unless this method is called from a handler for <strong>OnStoryboardStatusChanged</strong> events, the only values it returns are <strong><see cref="SharpDX.Animation.StoryboardStatus.Building"/></strong>, <strong><see cref="SharpDX.Animation.StoryboardStatus.Scheduled"/></strong>,	
        /// <strong><see cref="SharpDX.Animation.StoryboardStatus.Playing"/></strong>, and <strong><see cref="SharpDX.Animation.StoryboardStatus.Ready"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::GetStatus']/*"/>	
        /// <msdn-id>hh437188</msdn-id>	
        /// <unmanaged>GetStatus</unmanaged>	
        /// <unmanaged-short>GetStatus</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::GetStatus([Out] UI_ANIMATION_STORYBOARD_STATUS* status)</unmanaged>
        public SharpDX.Animation.StoryboardStatus Status {
                get { SharpDX.Animation.StoryboardStatus __output__; GetStatus(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Gets the time that has elapsed since the storyboard started playing.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::GetElapsedTime']/*"/>	
        /// <msdn-id>hh437187</msdn-id>	
        /// <unmanaged>GetElapsedTime</unmanaged>	
        /// <unmanaged-short>GetElapsedTime</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::GetElapsedTime([Out] double* elapsedTime)</unmanaged>
        public double ElapsedTime {
                get { double __output__; GetElapsedTime(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Adds a transition to the storyboard.</p>	
        /// </summary>	
        /// <param name="variable"><dd> <p> The animation variable for which the transition is to be added.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The transition to be added.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ALREADY_USED</strong></dt> </dl> </td><td> <p>This transition has already been added to a storyboard.</p> </td></tr> </table><p>?</p><p>See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The <strong>AddTransition</strong> method applies the specified transition to the specified variable in the storyboard. If this is the first transition applied to this variable in this storyboard, the transition begins at the start of the storyboard. Otherwise, the transition is appended to the transition that was most recently added to the variable.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::AddTransition']/*"/>	
        /// <msdn-id>hh437182</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::AddTransition([In] IUIAnimationVariable2* variable,[In] IUIAnimationTransition2* transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::AddTransition</unmanaged-short>	
        public void AddTransition(SharpDX.Animation.Variable2 variable, SharpDX.Animation.Transition2 transition) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((variable == null)?IntPtr.Zero:variable.NativePointer), (void*)((transition == null)?IntPtr.Zero:transition.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Adds a keyframe at the specified offset from an existing keyframe.</p>	
        /// </summary>	
        /// <param name="existingKeyframe"><dd> <p> The existing keyframe. To add a keyframe at an offset from the start of the storyboard, use the special keyframe <strong>UI_ANIMATION_KEYFRAME_STORYBOARD_START</strong>.</p> </dd></param>	
        /// <param name="offset"><dd> <p> The offset from the existing keyframe at which a new keyframe is to be added.</p> </dd></param>	
        /// <param name="keyframe"><dd> <p> The keyframe to be added.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::AddKeyframeAtOffset']/*"/>	
        /// <msdn-id>hh437181</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::AddKeyframeAtOffset([In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* existingKeyframe,[In] double offset,[Out] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003** keyframe)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::AddKeyframeAtOffset</unmanaged-short>	
        public void AddKeyframeAtOffset(SharpDX.Animation.KeyFrame existingKeyframe, double offset, out SharpDX.Animation.KeyFrame keyframe) {
            unsafe {
                keyframe = new SharpDX.Animation.KeyFrame();
                SharpDX.Result __result__;
                fixed (void* keyframe_ = &keyframe)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, &existingKeyframe, offset, keyframe_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Adds a keyframe at the end of the specified transition.</p>	
        /// </summary>	
        /// <param name="transition"><dd> <p> The transition after which a keyframe is to be added.</p> </dd></param>	
        /// <param name="keyframe"><dd> <p> The keyframe to be added.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_NOT_IN_STORYBOARD</strong></dt> </dl> </td><td> <p>The transition has not been added to the storyboard.</p> </td></tr> </table><p>?</p><p>See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::AddKeyframeAfterTransition']/*"/>	
        /// <msdn-id>hh437180</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::AddKeyframeAfterTransition([In] IUIAnimationTransition2* transition,[Out] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003** keyframe)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::AddKeyframeAfterTransition</unmanaged-short>	
        public void AddKeyframeAfterTransition(SharpDX.Animation.Transition2 transition, out SharpDX.Animation.KeyFrame keyframe) {
            unsafe {
                keyframe = new SharpDX.Animation.KeyFrame();
                SharpDX.Result __result__;
                fixed (void* keyframe_ = &keyframe)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((transition == null)?IntPtr.Zero:transition.NativePointer), keyframe_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Adds a transition that starts at the specified keyframe.</p>	
        /// </summary>	
        /// <param name="variable"><dd> <p> The animation variable for which a transition is to be added.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The transition to be added.</p> </dd></param>	
        /// <param name="startKeyframe"><dd> <p> The keyframe that specifies the beginning of the new transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ALREADY_USED</strong></dt> </dl> </td><td> <p>This transition has already been added to a storyboard or has been added to a storyboard that has finished playing and been released.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ECLIPSED</strong></dt> </dl> </td><td> <p>The transition might eclipse the beginning of another transition in the storyboard.</p> </td></tr> </table><p>?</p><p>See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Transitions must be added in the order in which they will be played. A transition may begin playing before the preceding transition in the storyboard has finished, in which case the initial value and velocity seen by the new transition is determined by the state of the preceding one. A transition should not begin before the start of the preceding transition.</p><p>A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::AddTransitionAtKeyframe']/*"/>	
        /// <msdn-id>hh437183</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::AddTransitionAtKeyframe([In] IUIAnimationVariable2* variable,[In] IUIAnimationTransition2* transition,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* startKeyframe)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::AddTransitionAtKeyframe</unmanaged-short>	
        public void AddTransitionAtKeyframe(SharpDX.Animation.Variable2 variable, SharpDX.Animation.Transition2 transition, SharpDX.Animation.KeyFrame startKeyframe) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((variable == null)?IntPtr.Zero:variable.NativePointer), (void*)((transition == null)?IntPtr.Zero:transition.NativePointer), &startKeyframe,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Adds a transition between two keyframes.</p>	
        /// </summary>	
        /// <param name="variable"><dd> <p> The animation variable for which the transition is to be added.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The transition to be added.</p> </dd></param>	
        /// <param name="startKeyframe"><dd> <p> A keyframe that specifies the beginning of the new transition.</p> </dd></param>	
        /// <param name="endKeyframe"><dd> <p> A keyframe that specifies the end of the new transition. It must not be possible for <em>endKeyframe</em> to appear earlier in the storyboard than <em>startKeyframe</em>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ALREADY_USED</strong></dt> </dl> </td><td> <p>This transition has already been added to a storyboard or has been added to a storyboard that has finished playing and been released.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_TRANSITION_ECLIPSED</strong></dt> </dl> </td><td> <p>The transition might eclipse the beginning of another transition in the storyboard.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_START_KEYFRAME_AFTER_END</strong></dt> </dl> </td><td> <p>The start keyframe might occur after the end keyframe.</p> </td></tr> </table><p>?</p><p>See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method applies the specified transition to the specified variable in the storyboard, with the transition starting and ending at the specified keyframes.  If the transition was created with a duration parameter specified, that duration is overwritten with the duration of time between the start and end keyframes. Otherwise, Windows Animation speeds up or slows down the transition as necessary.</p><p> A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions. Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p><p>Transitions must be added in the order in which they will be played. A transition may begin playing before the preceding transition in the storyboard has finished, in which case the initial value and velocity seen by the new transition will be determined by the state of the preceding one. It must not be possible for a transition to begin before the start of the preceding transition.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::AddTransitionBetweenKeyframes']/*"/>	
        /// <msdn-id>hh437184</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::AddTransitionBetweenKeyframes([In] IUIAnimationVariable2* variable,[In] IUIAnimationTransition2* transition,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* startKeyframe,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* endKeyframe)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::AddTransitionBetweenKeyframes</unmanaged-short>	
        public void AddTransitionBetweenKeyframes(SharpDX.Animation.Variable2 variable, SharpDX.Animation.Transition2 transition, SharpDX.Animation.KeyFrame startKeyframe, SharpDX.Animation.KeyFrame endKeyframe) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((variable == null)?IntPtr.Zero:variable.NativePointer), (void*)((transition == null)?IntPtr.Zero:transition.NativePointer), &startKeyframe, &endKeyframe,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a loop between two keyframes.</p>	
        /// </summary>	
        /// <param name="startKeyframe"><dd> <p>The keyframe at which the loop is to begin.</p> </dd></param>	
        /// <param name="endKeyframe"><dd> <p>The keyframe at which the loop is to end. <em>endKeyframe</em> must not occur earlier in the storyboard than <em>startKeyframe</em>.</p> </dd></param>	
        /// <param name="cRepetition"><dd> <p>The number of times the loop is to be repeated; the last iteration of a loop can terminate fractionally between keyframes. A value of  zero indicates that the specified portion of a storyboard will not be played.  A value of <strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong> (-1) indicates that the loop will repeat indefinitely until the storyboard is trimmed or concluded.</p> </dd></param>	
        /// <param name="repeatMode"><dd> <p>The pattern for the loop iteration. </p> <p>A value of <strong><see cref="SharpDX.Animation.RepeatMode.RepeatModeAlternate"/></strong> (1) specifies that the  start of the loop must alternate between keyframes (k1-&gt;k2, k2-&gt;k1, k1-&gt;k2, and so on).</p> <p>A value of <strong><see cref="SharpDX.Animation.RepeatMode.RepeatModeNormal"/></strong> (0) specifies that the start of the  loop must begin with the first keyframe (k1-&gt;k2, k1-&gt;k2, k1-&gt;k2, and so on).</p> <p><strong>Note</strong>??If <em>repeatMode</em> has a value of <strong><see cref="SharpDX.Animation.RepeatMode.RepeatModeAlternate"/></strong> (1) and <em>cRepetition</em> has a value of <strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong> (-1), the loop terminates on the end keyframe.</p> </dd></param>	
        /// <param name="iterationChangeHandlerRef"><dd> <p>The handler for each loop iteration event. The default value is 0.</p> </dd></param>	
        /// <param name="id"><dd> <p>The loop ID to pass to <em>pIterationChangeHandler</em>. The default value is 0.</p> </dd></param>	
        /// <param name="fRegisterForNextAnimationEvent"><dd> <p>If true, specifies that <em>pIterationChangeHandler</em> will be incorporated into the estimate of the time interval until the next animation event that is returned by the <strong><see cref="SharpDX.Animation.Manager2.EstimateNextEventTime"/></strong> method. The default value is 0, or false.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method directs a storyboard to play the interval between the given keyframes repeatedly before playing the remainder of the storyboard. If a finite repetition count is specified, the loop always plays that number of times. If <strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong> (-1) is specified, the loop repeats until the storyboard is concluded, in which case the current iteration of the loop completes and the remainder of the storyboard plays. A storyboard that loops indefinitely also ends if it is truncated.</p><p>Nested and overlapping loops are not supported.</p><p>A keyframe represents a moment in time within a storyboard and can be used to specify the start or end times of transitions.  Because keyframes can be added at the ends of transitions, their offsets from the start of the storyboard may not be known until the storyboard is playing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::RepeatBetweenKeyframes']/*"/>	
        /// <msdn-id>hh448593</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::RepeatBetweenKeyframes([In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* startKeyframe,[In] __MIDL___MIDL_itf_UIAnimation_0000_0002_0003* endKeyframe,[In] double cRepetition,[In] UI_ANIMATION_REPEAT_MODE repeatMode,[In, Optional] IUIAnimationLoopIterationChangeHandler2* pIterationChangeHandler,[In] UINT_PTR id,[In] BOOL fRegisterForNextAnimationEvent)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::RepeatBetweenKeyframes</unmanaged-short>	
        internal void RepeatBetweenKeyframes_(SharpDX.Animation.KeyFrame startKeyframe, SharpDX.Animation.KeyFrame endKeyframe, double cRepetition, SharpDX.Animation.RepeatMode repeatMode, System.IntPtr iterationChangeHandlerRef, System.IntPtr id, SharpDX.Mathematics.Interop.RawBool fRegisterForNextAnimationEvent) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint27(_nativePointer, &startKeyframe, &endKeyframe, cRepetition, unchecked((int)repeatMode), (void*)iterationChangeHandlerRef, (void*)id, fRegisterForNextAnimationEvent,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Directs the storyboard to hold the specified animation variable at its final value until the storyboard ends.</p>	
        /// </summary>	
        /// <param name="variable"><dd> <p> The animation variable.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> When a storyboard is playing, it has exclusive access to any variables it animates unless the storyboard is trimmed by a higher-priority storyboard. Typically, this exclusive access is released  when the last transition in the storyboard for that variable finishes playing. Applications can call this method to maintain exclusive access to the animation variable and hold the variable, at the final value of the last transition, until the end of the storyboard.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::HoldVariable']/*"/>	
        /// <msdn-id>hh448592</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::HoldVariable([In] IUIAnimationVariable2* variable)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::HoldVariable</unmanaged-short>	
        public void HoldVariable(SharpDX.Animation.Variable2 variable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((variable == null)?IntPtr.Zero:variable.NativePointer),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the longest acceptable delay before the scheduled storyboard begins.</p>	
        /// </summary>	
        /// <param name="delay"><dd> <p> The longest acceptable delay. This parameter can be a positive value, or <strong>UI_ANIMATION_SECONDS_EVENTUALLY</strong> (-1) to indicate that any finite delay is acceptable.</p> </dd></param>	
        /// <returns><p>Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>For Windows Animation to schedule a storyboard successfully, the storyboard must begin before the longest acceptable delay has elapsed. Windows Animation determines this delay in the following order: the delay value set by calling this method, the delay value set by calling the <strong><see cref="SharpDX.Animation.Manager2.SetDefaultLongestAcceptableDelay"/></strong> method, or 0.0 if neither of these methods has been called.</p><p> Use <strong><see cref="SharpDX.Animation.Storyboard2.SetSkipDuration"/></strong> to start a storyboard animation at a specified offset instead of delaying the start of a storyboard.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::SetLongestAcceptableDelay']/*"/>	
        /// <msdn-id>hh448595</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::SetLongestAcceptableDelay([In] double delay)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::SetLongestAcceptableDelay</unmanaged-short>	
        internal void SetLongestAcceptableDelay(double delay) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, delay,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies an offset from the beginning of a storyboard at which to start animating.</p>	
        /// </summary>	
        /// <param name="secondsDuration"><dd> <p>The offset, or amount of time, to skip at the beginning of the storyboard.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Calls to <strong>SetSkipDuration</strong> fail if the storyboard has been scheduled.</p><p><strong>SetSkipDuration</strong> does not delay the start of a scheduled storyboard. See <strong><see cref="SharpDX.Animation.Storyboard2.SetLongestAcceptableDelay"/></strong> for more info on how to set a delay for a scheduled storyboard.</p><p>This diagram shows a skip duration, or offset, for a storyboard. </p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::SetSkipDuration']/*"/>	
        /// <msdn-id>hh448596</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::SetSkipDuration([In] double secondsDuration)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::SetSkipDuration</unmanaged-short>	
        internal void SetSkipDuration(double secondsDuration) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, secondsDuration,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Directs the storyboard to schedule itself for play.</p>	
        /// </summary>	
        /// <param name="timeNow"><dd> <p> The current time.</p> </dd></param>	
        /// <param name="schedulingResult"><dd> <p>The result of the scheduling request. You can omit this parameter from calls to this method.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method directs a storyboard to try to add itself to the schedule of playing storyboards, using these rules:</p><ul> <li> <p>If there are no playing storyboards animating any of the same animation variables, the attempt succeeds and the storyboard starts playing immediately.</p> </li> <li> <p>If the storyboard has priority to cancel, trim, conclude, or compress conflicting storyboards, the attempt to schedule succeeds and the storyboard starts playing as soon as possible.</p> </li> <li> <p>If the storyboard does not have priority, the attempt fails and the <em>schedulingResult</em> parameter is set to <strong><see cref="SharpDX.Animation.SchedulingResult.InsufficientPriority"/></strong>.</p> </li> </ul><p>If this method is called from a handler for <strong>OnStoryboardStatusChanged</strong> events, the <em>schedulingResult</em> parameter is set to <strong><see cref="SharpDX.Animation.SchedulingResult.Deferred"/></strong>.  The only way to determine whether the storyboard is successfully scheduled is to set a storyboard event handler and check whether the storyboard's status ever becomes <strong><see cref="SharpDX.Animation.SchedulingResult.InsufficientPriority"/></strong>.</p><p>It is possible to reuse a storyboard by calling <strong>Schedule</strong> again after its status has reached <strong><see cref="SharpDX.Animation.StoryboardStatus.Ready"/></strong>.  An attempt to schedule a storyboard when it is in any state other than <strong><see cref="SharpDX.Animation.StoryboardStatus.Building"/></strong> or <strong><see cref="SharpDX.Animation.StoryboardStatus.Ready"/></strong> fails, and  <em>schedulingResult</em> is set to <strong><see cref="SharpDX.Animation.SchedulingResult.AlreadyScheduled"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::Schedule']/*"/>	
        /// <msdn-id>hh448594</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::Schedule([In] double timeNow,[Out, Optional] UI_ANIMATION_SCHEDULING_RESULT* schedulingResult)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::Schedule</unmanaged-short>	
        public void Schedule(double timeNow, out SharpDX.Animation.SchedulingResult schedulingResult) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* schedulingResult_ = &schedulingResult)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, timeNow, schedulingResult_,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Completes the current iteration of a keyframe loop that is in progress (where the loop is set to <strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong>), terminates the loop, and continues with the storyboard. </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method specifies that any subsequent  keyframe loops that have a repetition count of <strong><strong>UI_ANIMATION_REPEAT_INDEFINITELY</strong></strong> (-1) will be skipped while the remainder of the storyboard is played.  </p><p>An iteration of a keyframe loop that is in progress will be completed before the remainder of the storyboard plays.</p><p>If this method is called at the end of an alternating keyframe loop iteration, the loop is terminated with the  loop value set to the ending loop value.</p><p> If this method is called at the end of a non-alternating keyframe loop iteration, where  "loop wrapping" results in the loop value being set to the starting value of the next iteration, the loop is executed once more in order for the loop value to be set to the ending loop value.</p><p>For alternating keyframe loops, each iteration has a starting value that is equivalent to the ending value of the preceding loop. In this case, "loop wrapping" is not an issue.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::Conclude']/*"/>	
        /// <msdn-id>hh437185</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::Conclude()</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::Conclude</unmanaged-short>	
        public void Conclude() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Finishes the storyboard within the specified time, compressing the storyboard if necessary.</p>	
        /// </summary>	
        /// <param name="completionDeadline"><dd> <p> The maximum amount of time that the storyboard can use to finish playing.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method has no effect on storyboard events. Events continue to be raised as expected while the storyboard plays.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::Finish']/*"/>	
        /// <msdn-id>hh437186</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::Finish([In] double completionDeadline)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::Finish</unmanaged-short>	
        public void Finish(double completionDeadline) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, completionDeadline,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Terminates the storyboard, releases all related animation variables, and removes the storyboard from the schedule.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> This method can be called before or after the storyboard starts playing.</p><p>This method does not trigger any storyboard events.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::Abandon']/*"/>	
        /// <msdn-id>hh437179</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::Abandon()</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::Abandon</unmanaged-short>	
        public void Abandon() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the tag for the storyboard.</p>	
        /// </summary>	
        /// <param name="@object"><dd> <p> The object portion of the tag.         This parameter can be <c>null</c>.</p> </dd></param>	
        /// <param name="id"><dd> <p> The identifier portion of the tag.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>). It can be used by an application to identify a storyboard.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::SetTag']/*"/>	
        /// <msdn-id>hh448598</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::SetTag([In, Optional] IUnknown* object,[In] unsigned int id)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::SetTag</unmanaged-short>	
        public void SetTag(SharpDX.ComObject @object, int id) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((@object == null)?IntPtr.Zero:@object.NativePointer), id,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the tag for a storyboard.</p>	
        /// </summary>	
        /// <param name="@object"><dd> <p> The object portion of the tag.</p> </dd></param>	
        /// <param name="id"><dd> <p> The identifier portion of the tag.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_VALUE_NOT_SET</strong></dt> </dl> </td><td> <p>The storyboard tag was not set.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>); it can be used by an application to identify a storyboard.</p><p>This method can return the identifier, the object, or both portions of the tag.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::GetTag']/*"/>	
        /// <msdn-id>hh437189</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::GetTag([Out, Optional] IUnknown** object,[Out, Optional] unsigned int* id)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::GetTag</unmanaged-short>	
        public void GetTag(out SharpDX.ComObject @object, out int id) {
            unsafe {
                IntPtr @object_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* id_ = &id)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, &@object_, id_,((void**)(*(void**)_nativePointer))[17]);		
                @object= (@object_ == IntPtr.Zero)?null:new SharpDX.ComObject(@object_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the status of the storyboard.</p>	
        /// </summary>	
        /// <param name="status"><dd> <p> The storyboard status.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Unless this method is called from a handler for <strong>OnStoryboardStatusChanged</strong> events, the only values it returns are <strong><see cref="SharpDX.Animation.StoryboardStatus.Building"/></strong>, <strong><see cref="SharpDX.Animation.StoryboardStatus.Scheduled"/></strong>,	
        /// <strong><see cref="SharpDX.Animation.StoryboardStatus.Playing"/></strong>, and <strong><see cref="SharpDX.Animation.StoryboardStatus.Ready"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::GetStatus']/*"/>	
        /// <msdn-id>hh437188</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::GetStatus([Out] UI_ANIMATION_STORYBOARD_STATUS* status)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::GetStatus</unmanaged-short>	
        internal void GetStatus(out SharpDX.Animation.StoryboardStatus status) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* status_ = &status)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, status_,((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the time that has elapsed since the storyboard started playing.</p>	
        /// </summary>	
        /// <param name="elapsedTime"><dd> <p> The elapsed time.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_STORYBOARD_NOT_PLAYING</strong></dt> </dl> </td><td> <p>The storyboard is not playing.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::GetElapsedTime']/*"/>	
        /// <msdn-id>hh437187</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::GetElapsedTime([Out] double* elapsedTime)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::GetElapsedTime</unmanaged-short>	
        internal void GetElapsedTime(out double elapsedTime) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* elapsedTime_ = &elapsedTime)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, elapsedTime_,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Specifies a handler for storyboard events.</p>	
        /// </summary>	
        /// <param name="handler"><dd> <p> The handler that Windows Animation should call whenever storyboard status and update events occur. The specified object must implement the <strong><see cref="SharpDX.Animation.StoryboardEventHandler2"/></strong> interface or be <strong><c>null</c></strong>. See Remarks for more info.</p> </dd></param>	
        /// <param name="fRegisterStatusChangeForNextAnimationEvent"><dd> <p>If <strong>TRUE</strong>, registers the <strong>OnStoryboardStatusChanged</strong> event and includes those events in <strong><see cref="SharpDX.Animation.Manager2.EstimateNextEventTime"/></strong>, which estimates the time interval until the next animation event. No default value.</p> </dd></param>	
        /// <param name="fRegisterUpdateForNextAnimationEvent"><dd> <p>If <strong>TRUE</strong>, registers the <strong>OnStoryboardUpdated</strong> event and includes those events in <strong><see cref="SharpDX.Animation.Manager2.EstimateNextEventTime"/></strong>, which estimates the time interval until the next animation event. No default value.</p> </dd></param>	
        /// <returns><p>Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager2.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboard2::SetStoryboardEventHandler']/*"/>	
        /// <msdn-id>hh448597</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboard2::SetStoryboardEventHandler([In, Optional] IUIAnimationStoryboardEventHandler2* handler,[In] BOOL fRegisterStatusChangeForNextAnimationEvent,[In] BOOL fRegisterUpdateForNextAnimationEvent)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboard2::SetStoryboardEventHandler</unmanaged-short>	
        internal void SetStoryboardEventHandler_(System.IntPtr handler, SharpDX.Mathematics.Interop.RawBool fRegisterStatusChangeForNextAnimationEvent, SharpDX.Mathematics.Interop.RawBool fRegisterUpdateForNextAnimationEvent) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint28(_nativePointer, (void*)handler, fRegisterStatusChangeForNextAnimationEvent, fRegisterUpdateForNextAnimationEvent,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Defines methods for handling status and update events for a storyboard.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboardEventHandler']/*"/>	
    /// <msdn-id>dd371764</msdn-id>	
    /// <unmanaged>IUIAnimationStoryboardEventHandler</unmanaged>	
    /// <unmanaged-short>IUIAnimationStoryboardEventHandler</unmanaged-short>	
    [Guid("3D5C9008-EC7C-4364-9F8A-9AF3C58CBAE6")]
    internal partial interface StoryboardEventHandler : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p> Handles events that occur when a storyboard's status changes.</p>	
        /// </summary>	
        /// <param name="storyboard"><dd> <p> The storyboard whose status has changed.</p> </dd></param>	
        /// <param name="newStatus"><dd> <p> The new status.</p> </dd></param>	
        /// <param name="previousStatus"><dd> <p> The previous status.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>By default, a call made in a callback method to any other animation method results in the call failing and returning <strong>UI_E_ILLEGAL_REENTRANCY</strong>. However, there are exceptions to this default. The following methods can be successfully called from <strong>OnStoryboardStatusChanged</strong>:</p><ul> <li> <strong><see cref="SharpDX.Animation.Manager.CreateAnimationVariable"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager.CreateStoryboard"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager.GetStoryboardFromTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager.GetVariableFromTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.Abandon"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.AddKeyframeAtOffset"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.AddKeyframeAfterTransition"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.AddTransition"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.AddTransitionAtKeyframe"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.AddTransitionBetweenKeyframes"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.Conclude"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.Finish"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.GetTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.HoldVariable"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.RepeatBetweenKeyframes"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.SetLongestAcceptableDelay"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.SetStoryboardEventHandler_"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.SetTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.Schedule"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Transition.GetDuration"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Transition.IsDurationKnown_"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Transition.SetInitialValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Transition.SetInitialVelocity"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetCurrentStoryboard"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetFinalIntegerValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetFinalValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetIntegerValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetPreviousIntegerValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetPreviousValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.SetTag"/></strong> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboardEventHandler::OnStoryboardStatusChanged']/*"/>	
        /// <msdn-id>dd371770</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboardEventHandler::OnStoryboardStatusChanged([In] IUIAnimationStoryboard* storyboard,[In] UI_ANIMATION_STORYBOARD_STATUS newStatus,[In] UI_ANIMATION_STORYBOARD_STATUS previousStatus)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboardEventHandler::OnStoryboardStatusChanged</unmanaged-short>	
        /* public void OnStoryboardStatusChanged(SharpDX.Animation.Storyboard storyboard, SharpDX.Animation.StoryboardStatus newStatus, SharpDX.Animation.StoryboardStatus previousStatus) */
        
        /// <summary>	
        /// <p> Handles events that occur when a storyboard is updated.</p>	
        /// </summary>	
        /// <param name="storyboard"><dd> <p> The storyboard that has been updated.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method is called when the value of at least one of the variables that a storyboard is animating has changed since the last call to the <strong><see cref="SharpDX.Animation.Manager.Update"/></strong> method.</p><p>By default, a call made in a callback method to any other animation method results in the call failing and returning <strong>UI_E_ILLEGAL_REENTRANCY</strong>. However, there are exceptions to this default. The following methods can be successfully called from <strong>OnStoryboardUpdated</strong>:</p><ul> <li> <strong><see cref="SharpDX.Animation.Manager.GetStoryboardFromTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager.GetVariableFromTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.GetTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetCurrentStoryboard"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetFinalIntegerValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetFinalValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetIntegerValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetPreviousIntegerValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetPreviousValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetValue"/></strong> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboardEventHandler::OnStoryboardUpdated']/*"/>	
        /// <msdn-id>dd371775</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboardEventHandler::OnStoryboardUpdated([In] IUIAnimationStoryboard* storyboard)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboardEventHandler::OnStoryboardUpdated</unmanaged-short>	
        /* public void OnStoryboardUpdated(SharpDX.Animation.Storyboard storyboard) */
    }
    /// <summary>	
    /// <p>Defines methods for handling storyboard events. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboardEventHandler2']/*"/>	
    /// <msdn-id>hh448599</msdn-id>	
    /// <unmanaged>IUIAnimationStoryboardEventHandler2</unmanaged>	
    /// <unmanaged-short>IUIAnimationStoryboardEventHandler2</unmanaged-short>	
    [Guid("BAC5F55A-BA7C-414C-B599-FBF850F553C6")]
    internal partial interface StoryboardEventHandler2 : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p> Handles storyboard status change events.</p>	
        /// </summary>	
        /// <param name="storyboard"><dd> <p> The storyboard for which the status has changed.</p> </dd></param>	
        /// <param name="newStatus"><dd> <p> The new status.</p> </dd></param>	
        /// <param name="previousStatus"><dd> <p> The previous status.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>By default, a call made in a callback method to any other animation method results in the call failing and returning <strong>UI_E_ILLEGAL_REENTRANCY</strong>. However, there are exceptions to this default. The following methods can be successfully called from <strong>OnStoryboardStatusChanged</strong>:</p><ul> <li> <strong><see cref="SharpDX.Animation.Manager2.CreateAnimationVariable"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager2.CreateStoryboard"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager2.GetStoryboardFromTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager2.GetVariableFromTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.Abandon"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.AddKeyframeAtOffset"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.AddKeyframeAfterTransition"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.AddTransition"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.AddTransitionAtKeyframe"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.AddTransitionBetweenKeyframes"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.Conclude"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.Finish"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.GetTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.HoldVariable"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.RepeatBetweenKeyframes_"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.SetLongestAcceptableDelay"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.SetStoryboardEventHandler_"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.SetTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.Schedule"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Transition2.GetDuration"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Transition2.IsDurationKnown_"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Transition2.SetInitialValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Transition2.SetInitialVelocity"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetCurrentStoryboard"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetFinalIntegerValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetFinalValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetIntegerValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetPreviousIntegerValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetPreviousValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.SetTag"/></strong> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboardEventHandler2::OnStoryboardStatusChanged']/*"/>	
        /// <msdn-id>hh448600</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboardEventHandler2::OnStoryboardStatusChanged([In] IUIAnimationStoryboard2* storyboard,[In] UI_ANIMATION_STORYBOARD_STATUS newStatus,[In] UI_ANIMATION_STORYBOARD_STATUS previousStatus)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboardEventHandler2::OnStoryboardStatusChanged</unmanaged-short>	
        /* public void OnStoryboardStatusChanged(SharpDX.Animation.Storyboard2 storyboard, SharpDX.Animation.StoryboardStatus newStatus, SharpDX.Animation.StoryboardStatus previousStatus) */
        
        /// <summary>	
        /// <p>Handles storyboard update events.</p>	
        /// </summary>	
        /// <param name="storyboard"><dd> <p> The storyboard that has been updated.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method is called when the value of at least one of the variables that a storyboard is animating has changed since the last call to the <strong><see cref="SharpDX.Animation.Manager2.Update"/></strong> method.</p><p>By default, a call made in a callback method to any other animation method results in the call failing and returning <strong>UI_E_ILLEGAL_REENTRANCY</strong>. However, there are exceptions to this default. The following methods can be successfully called from <strong>OnStoryboardUpdated</strong>:</p><ul> <li> <strong><see cref="SharpDX.Animation.Manager2.GetStoryboardFromTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager2.GetVariableFromTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.GetTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetCurrentStoryboard"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetFinalIntegerValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetFinalValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetIntegerValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetPreviousIntegerValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetPreviousValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetValue"/></strong> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationStoryboardEventHandler2::OnStoryboardUpdated']/*"/>	
        /// <msdn-id>hh448601</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationStoryboardEventHandler2::OnStoryboardUpdated([In] IUIAnimationStoryboard2* storyboard)</unmanaged>	
        /// <unmanaged-short>IUIAnimationStoryboardEventHandler2::OnStoryboardUpdated</unmanaged-short>	
        /* public void OnStoryboardUpdated(SharpDX.Animation.Storyboard2 storyboard) */
    }
    /// <summary>	
    /// <p> Defines an animation timer, which provides services for managing animation timing.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A timer helps to manage animation rendering by automatically indicating the passage of a small unit of time, called a tick. In turn, ticks can trigger animation rendering or other animation events. Each animation timer provides timing for a single animation manager.</p><p>The timing system is designed to provide the necessary timing services needed to support animations and does not require applications to play an explicit role in generating the ticks. The animation timer can be set up to automatically update the animation manager for each tick without application-side handling.</p><p>An application may not need to use a timer with Windows Animation, depending on the graphics platform it is using. For example, an application drawing with Direct2D or Direct3D can synchronize to monitor's refresh rate, yielding very smooth animation. However, such applications may still find the <strong><see cref="SharpDX.Animation.Timer"/></strong> interface useful for its <strong>GetTime</strong> method, which returns an accurate system time in <strong>UI_ANIMATION_SECONDS</strong>, the units used throughout the Windows Animation API.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimer']/*"/>	
    /// <msdn-id>dd371831</msdn-id>	
    /// <unmanaged>IUIAnimationTimer</unmanaged>	
    /// <unmanaged-short>IUIAnimationTimer</unmanaged-short>	
    [Guid("6B0EFAD1-A053-41d6-9085-33A689144665")]
    public partial class Timer : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.Timer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Timer(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.Timer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.Timer(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.Timer(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Gets the current time.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> This method can be used in both the application-driven and timer-driven  configurations to retrieve the system time in <strong>UI_ANIMATION_SECONDS</strong>, the units used throughout the Windows Animation API.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimer::GetTime']/*"/>	
        /// <msdn-id>dd371869</msdn-id>	
        /// <unmanaged>GetTime</unmanaged>	
        /// <unmanaged-short>GetTime</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationTimer::GetTime([Out] double* seconds)</unmanaged>
        public double Time {
                get { double __output__; GetTime(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Sets the frame rate below which the timer notifies the application that rendering is too slow.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> If the rendering frame rate for an animation falls below the specified frame rate, an  <strong><see cref="SharpDX.Animation.TimerEventHandler.OnRenderingTooSlow"/></strong> event is raised.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimer::SetFrameRateThreshold']/*"/>	
        /// <msdn-id>dd756727</msdn-id>	
        /// <unmanaged>SetFrameRateThreshold</unmanaged>	
        /// <unmanaged-short>SetFrameRateThreshold</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationTimer::SetFrameRateThreshold([In] unsigned int framesPerSecond)</unmanaged>
        public int FrameRateThreshold {
                set { SetFrameRateThreshold(value); }
        }
        
        /// <summary>	
        /// <p> Specifies a timer update handler.</p>	
        /// </summary>	
        /// <param name="updateHandler"><dd> <p> A timer update handler, or <strong><c>null</c></strong> (see Remarks).  The specified object must implement the <strong><see cref="SharpDX.Animation.TimerUpdateHandler"/></strong> interface.</p> </dd></param>	
        /// <param name="idleBehavior"><dd> <p> A member of  <strong><see cref="SharpDX.Animation.IdleBehavior"/></strong> that specifies the behavior of the timer when it is idle.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. If the update handler is already connected to a timer, this method returns <strong>UI_E_TIMER_CLIENT_ALREADY_CONNECTED</strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> The timer update handler receives time updates (ticks) from the timer. The timer indicates an update by calling  the <strong><see cref="SharpDX.Animation.TimerUpdateHandler.OnUpdate"/></strong> method on the specified handler.</p><p>Passing <strong><c>null</c></strong> for the <em>updateHandler</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimer::SetTimerUpdateHandler']/*"/>	
        /// <msdn-id>dd371884</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTimer::SetTimerUpdateHandler([In, Optional] IUIAnimationTimerUpdateHandler* updateHandler,[In] UI_ANIMATION_IDLE_BEHAVIOR idleBehavior)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTimer::SetTimerUpdateHandler</unmanaged-short>	
        internal void SetTimerUpdateHandler_(System.IntPtr updateHandler, SharpDX.Animation.IdleBehavior idleBehavior) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)updateHandler, unchecked((int)idleBehavior),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Specifies a timer event handler.</p>	
        /// </summary>	
        /// <param name="handler"><dd> <p> A timer event handler.  The specified object must implement the <strong><see cref="SharpDX.Animation.TimerEventHandler"/></strong> interface or be <strong><c>null</c></strong>. See Remarks.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> Timing events include the <strong>OnPreUpdate</strong>, <strong>OnPostUpdate</strong>, and <strong>OnRenderingTooSlow</strong> methods of the <strong><see cref="SharpDX.Animation.TimerEventHandler"/></strong> interface.</p><p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimer::SetTimerEventHandler']/*"/>	
        /// <msdn-id>dd371881</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTimer::SetTimerEventHandler([In, Optional] IUIAnimationTimerEventHandler* handler)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTimer::SetTimerEventHandler</unmanaged-short>	
        internal void SetTimerEventHandler_(System.IntPtr handler) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)handler,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Enables the animation timer.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimer::Enable']/*"/>	
        /// <msdn-id>dd371866</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTimer::Enable()</unmanaged>	
        /// <unmanaged-short>IUIAnimationTimer::Enable</unmanaged-short>	
        public void Enable() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Disables the animation timer.</p>	
        /// </summary>	
        /// <returns><p> If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimer::Disable']/*"/>	
        /// <msdn-id>dd371863</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTimer::Disable()</unmanaged>	
        /// <unmanaged-short>IUIAnimationTimer::Disable</unmanaged-short>	
        public void Disable() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Determines whether the timer is currently enabled.</p>	
        /// </summary>	
        /// <returns><p> Returns <see cref="SharpDX.Result.Ok"/> if the animation timer is enabled, S_FALSE if the animation timer is disabled, or an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimer::IsEnabled']/*"/>	
        /// <msdn-id>dd371873</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTimer::IsEnabled()</unmanaged>	
        /// <unmanaged-short>IUIAnimationTimer::IsEnabled</unmanaged-short>	
        internal SharpDX.Result IsEnabled_() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[7]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Gets the current time.</p>	
        /// </summary>	
        /// <param name="seconds"><dd> <p> The current time, in <strong>UI_ANIMATION_SECONDS</strong>.</p> </dd></param>	
        /// <returns><p> If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See Windows Animation Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> This method can be used in both the application-driven and timer-driven  configurations to retrieve the system time in <strong>UI_ANIMATION_SECONDS</strong>, the units used throughout the Windows Animation API.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimer::GetTime']/*"/>	
        /// <msdn-id>dd371869</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTimer::GetTime([Out] double* seconds)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTimer::GetTime</unmanaged-short>	
        internal void GetTime(out double seconds) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* seconds_ = &seconds)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, seconds_,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the frame rate below which the timer notifies the application that rendering is too slow.</p>	
        /// </summary>	
        /// <param name="framesPerSecond"><dd> <p> The minimum desirable frame rate, in frames per second.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> If the rendering frame rate for an animation falls below the specified frame rate, an  <strong><see cref="SharpDX.Animation.TimerEventHandler.OnRenderingTooSlow"/></strong> event is raised.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimer::SetFrameRateThreshold']/*"/>	
        /// <msdn-id>dd756727</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTimer::SetFrameRateThreshold([In] unsigned int framesPerSecond)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTimer::SetFrameRateThreshold</unmanaged-short>	
        internal void SetFrameRateThreshold(int framesPerSecond) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, framesPerSecond,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Defines a method for handling events related to changes in timer client status.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimerClientEventHandler']/*"/>	
    /// <msdn-id>dd371834</msdn-id>	
    /// <unmanaged>IUIAnimationTimerClientEventHandler</unmanaged>	
    /// <unmanaged-short>IUIAnimationTimerClientEventHandler</unmanaged-short>	
    [Guid("BEDB4DB6-94FA-4bfb-A47F-EF2D9E408C25")]
    internal partial interface TimerClientEventHandler : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p> Handles events that occur when the status of the timer's  client changes.</p>	
        /// </summary>	
        /// <param name="newStatus"><dd> <p>The new status of the timer's client.</p> </dd></param>	
        /// <param name="previousStatus"><dd> <p> The previous status of the timer's client.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimerClientEventHandler::OnTimerClientStatusChanged']/*"/>	
        /// <msdn-id>dd371837</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTimerClientEventHandler::OnTimerClientStatusChanged([In] UI_ANIMATION_TIMER_CLIENT_STATUS newStatus,[In] UI_ANIMATION_TIMER_CLIENT_STATUS previousStatus)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTimerClientEventHandler::OnTimerClientStatusChanged</unmanaged-short>	
        /* public void OnTimerClientStatusChanged(SharpDX.Animation.TimerClientStatus newStatus, SharpDX.Animation.TimerClientStatus previousStatus) */
    }
    /// <summary>	
    /// <p> Defines methods for handling timing events.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> Use  <strong> SetTimerEventHandler</strong> to specify the timing events handler for an instance of <strong><see cref="SharpDX.Animation.Timer"/></strong>.  </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimerEventHandler']/*"/>	
    /// <msdn-id>dd371841</msdn-id>	
    /// <unmanaged>IUIAnimationTimerEventHandler</unmanaged>	
    /// <unmanaged-short>IUIAnimationTimerEventHandler</unmanaged-short>	
    [Guid("274A7DEA-D771-4095-ABBD-8DF7ABD23CE3")]
    internal partial interface TimerEventHandler : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p> Handles events that occur before an animation update begins.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>UIAnimation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>For each tick, a timer calls the following sequence of methods:</p><ul> <li><strong><see cref="SharpDX.Animation.TimerEventHandler.OnPreUpdate"/></strong></li> <li> <strong><see cref="SharpDX.Animation.TimerUpdateHandler.OnUpdate"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.TimerEventHandler.OnPostUpdate"/></strong> </li> </ul><p><strong>OnPreUpdate</strong> and <strong>OnPostUpdate</strong> are called on the <strong><see cref="SharpDX.Animation.TimerEventHandler"/></strong> registered with the <strong><see cref="SharpDX.Animation.Timer.SetTimerEventHandler_"/></strong> method. <strong>OnUpdate</strong> is called on the <strong><see cref="SharpDX.Animation.TimerUpdateHandler"/></strong> registered with the <strong><see cref="SharpDX.Animation.Timer.SetTimerUpdateHandler_"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimerEventHandler::OnPreUpdate']/*"/>	
        /// <msdn-id>dd371847</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTimerEventHandler::OnPreUpdate()</unmanaged>	
        /// <unmanaged-short>IUIAnimationTimerEventHandler::OnPreUpdate</unmanaged-short>	
        /* public void OnPreUpdate() */
        
        /// <summary>	
        /// <p> Handles events that occur after an animation update is finished.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>UIAnimation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The <strong>UIAnimationTimer</strong> object calls this method only when calls to <strong><see cref="SharpDX.Animation.TimerUpdateHandler.OnUpdate"/></strong> return a result of <strong><see cref="SharpDX.Animation.UpdateResult.VariablesChanged"/></strong>.</p><p>For each tick, a timer calls the following sequence of methods:</p><ul> <li> <strong><see cref="SharpDX.Animation.TimerEventHandler.OnPreUpdate"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.TimerUpdateHandler.OnUpdate"/></strong> </li> <li><strong><see cref="SharpDX.Animation.TimerEventHandler.OnPostUpdate"/></strong></li> </ul><p> <strong>OnPreUpdate</strong> and <strong>OnPostUpdate</strong> are called on the <strong><see cref="SharpDX.Animation.TimerEventHandler"/></strong> registered with <strong><see cref="SharpDX.Animation.Timer.SetTimerEventHandler_"/></strong>. <strong>OnUpdate</strong> is called on the <strong><see cref="SharpDX.Animation.TimerUpdateHandler"/></strong> registered with <strong><see cref="SharpDX.Animation.Timer.SetTimerUpdateHandler_"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimerEventHandler::OnPostUpdate']/*"/>	
        /// <msdn-id>dd371844</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTimerEventHandler::OnPostUpdate()</unmanaged>	
        /// <unmanaged-short>IUIAnimationTimerEventHandler::OnPostUpdate</unmanaged-short>	
        /* public void OnPostUpdate() */
        
        /// <summary>	
        /// <p> Handles events that occur when the rendering frame rate  for an animation falls below a minimum desirable frame rate. </p>	
        /// </summary>	
        /// <param name="framesPerSecond"><dd> <p> The current frame rate, in frames per second.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>UIAnimation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> The minimum desirable frame rate is specified using the <strong><see cref="SharpDX.Animation.Timer.SetFrameRateThreshold"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimerEventHandler::OnRenderingTooSlow']/*"/>	
        /// <msdn-id>dd371849</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTimerEventHandler::OnRenderingTooSlow([In] unsigned int framesPerSecond)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTimerEventHandler::OnRenderingTooSlow</unmanaged-short>	
        /* public void OnRenderingTooSlow(int framesPerSecond) */
    }
    /// <summary>	
    /// <p> Defines methods for handling timing update events.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong>UIAnimationManager</strong> object implements this interface, so a client application can query the <strong>UIAnimationManager</strong> object for this interface and then pass the interface to <strong><see cref="SharpDX.Animation.Timer.SetTimerUpdateHandler_"/></strong>.  It is not necessary to disconnect the <strong>UIAnimationManager</strong> and <strong>UIAnimationTimer</strong> objects; releasing them both is sufficient to clean up.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimerUpdateHandler']/*"/>	
    /// <msdn-id>dd371853</msdn-id>	
    /// <unmanaged>IUIAnimationTimerUpdateHandler</unmanaged>	
    /// <unmanaged-short>IUIAnimationTimerUpdateHandler</unmanaged-short>	
    [Guid("195509B7-5D5E-4e3e-B278-EE3759B367AD")]
    internal partial interface TimerUpdateHandler : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p> Handles update events from the timer.</p>	
        /// </summary>	
        /// <param name="timeNow"><dd> <p> The current timer time, in seconds.</p> </dd></param>	
        /// <param name="result"><dd> <p> Receives a member of the <strong><see cref="SharpDX.Animation.UpdateResult"/></strong> enumeration, indicating whether any animation variables changed as a result of the update.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method is used by the <strong>UIAnimationTimer</strong> object to update the state of the <strong>UIAnimationManager</strong> object. The <strong>UIAnimationTimer</strong> object calls <strong>UIAnimationTimerEventHandler::OnPostUpdate</strong> only when calls to this method return a result of <strong><see cref="SharpDX.Animation.UpdateResult.VariablesChanged"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimerUpdateHandler::OnUpdate']/*"/>	
        /// <msdn-id>dd371857</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTimerUpdateHandler::OnUpdate([In] double timeNow,[Out] UI_ANIMATION_UPDATE_RESULT* result)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTimerUpdateHandler::OnUpdate</unmanaged-short>	
        /* public void OnUpdate(double timeNow, out SharpDX.Animation.UpdateResult result) */
        
        /// <summary>	
        /// <p> Specifies a handler for timer client status change events.</p>	
        /// </summary>	
        /// <param name="handler"><dd> <p> A handler for timer client events.  The specified object must implement <strong><see cref="SharpDX.Animation.TimerUpdateHandler"/></strong>. </p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>If the update handler is already connected to the timer, this method returns <strong>UI_E_TIMER_CLIENT_ALREADY_CONNECTED.</strong></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimerUpdateHandler::SetTimerClientEventHandler']/*"/>	
        /// <msdn-id>dd371860</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTimerUpdateHandler::SetTimerClientEventHandler([In] IUIAnimationTimerClientEventHandler* handler)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTimerUpdateHandler::SetTimerClientEventHandler</unmanaged-short>	
        /* internal void SetTimerClientEventHandler_(System.IntPtr handler) */
        
        /// <summary>	
        /// <p> Clears the handler for timer client status change events.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTimerUpdateHandler::ClearTimerClientEventHandler']/*"/>	
        /// <msdn-id>dd371856</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTimerUpdateHandler::ClearTimerClientEventHandler()</unmanaged>	
        /// <unmanaged-short>IUIAnimationTimerUpdateHandler::ClearTimerClientEventHandler</unmanaged-short>	
        /* public void ClearTimerClientEventHandler() */
    }
    /// <summary>	
    /// <p> Defines a transition, which determines how an animation variable changes over time.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong><see cref="SharpDX.Animation.Transition"/></strong> is one of the primary interfaces used to add animation to an application, along with  the <strong><see cref="SharpDX.Animation.Variable"/></strong> and  <strong><see cref="SharpDX.Animation.Storyboard"/></strong> interfaces.</p><p> <strong>UIAnimationTransitionLibrary</strong> implements a library of standard transitions.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition']/*"/>	
    /// <msdn-id>dd371887</msdn-id>	
    /// <unmanaged>IUIAnimationTransition</unmanaged>	
    /// <unmanaged-short>IUIAnimationTransition</unmanaged-short>	
    [Guid("DC6CE252-F731-41cf-B610-614B6CA049AD")]
    public partial class Transition : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.Transition"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Transition(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.Transition"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.Transition(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.Transition(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Sets the initial value for the transition.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method should not be called after the transition has been added to a storyboard.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition::SetInitialValue']/*"/>	
        /// <msdn-id>dd371960</msdn-id>	
        /// <unmanaged>SetInitialValue</unmanaged>	
        /// <unmanaged-short>SetInitialValue</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationTransition::SetInitialValue([In] double value)</unmanaged>
        public double InitialValue {
                set { SetInitialValue(value); }
        }
        
        /// <summary>	
        /// <p> Sets the initial velocity for the transition.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method should not be called after the transition has been added to a storyboard.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition::SetInitialVelocity']/*"/>	
        /// <msdn-id>dd371964</msdn-id>	
        /// <unmanaged>SetInitialVelocity</unmanaged>	
        /// <unmanaged-short>SetInitialVelocity</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationTransition::SetInitialVelocity([In] double velocity)</unmanaged>
        public double InitialVelocity {
                set { SetInitialVelocity(value); }
        }
        
        /// <summary>	
        /// <p> Gets the duration of the transition.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>An application should typically call the <strong><see cref="SharpDX.Animation.Transition.IsDurationKnown_"/></strong> method before calling this method. This method should not be called when the storyboard to which the transition has been added is scheduled or playing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition::GetDuration']/*"/>	
        /// <msdn-id>dd371951</msdn-id>	
        /// <unmanaged>GetDuration</unmanaged>	
        /// <unmanaged-short>GetDuration</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationTransition::GetDuration([Out] double* duration)</unmanaged>
        public double Duration {
                get { double __output__; GetDuration(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Sets the initial value for the transition.</p>	
        /// </summary>	
        /// <param name="value"><dd> <p>The initial value for the transition.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method should not be called after the transition has been added to a storyboard.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition::SetInitialValue']/*"/>	
        /// <msdn-id>dd371960</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransition::SetInitialValue([In] double value)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransition::SetInitialValue</unmanaged-short>	
        internal void SetInitialValue(double value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, value,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the initial velocity for the transition.</p>	
        /// </summary>	
        /// <param name="velocity"><dd> <p>The initial velocity for the transition.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method should not be called after the transition has been added to a storyboard.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition::SetInitialVelocity']/*"/>	
        /// <msdn-id>dd371964</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransition::SetInitialVelocity([In] double velocity)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransition::SetInitialVelocity</unmanaged-short>	
        internal void SetInitialVelocity(double velocity) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, velocity,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Determines whether a transition's duration is currently known.</p>	
        /// </summary>	
        /// <returns><p> Returns <see cref="SharpDX.Result.Ok"/> if the duration is known, S_FALSE if the duration is not known, or an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_STORYBOARD_ACTIVE</strong></dt> </dl> </td><td> <p>The storyboard for this transition is currently in schedule.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method should not be called when the storyboard to which the transition has been added is scheduled or playing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition::IsDurationKnown']/*"/>	
        /// <msdn-id>dd371957</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransition::IsDurationKnown()</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransition::IsDurationKnown</unmanaged-short>	
        internal SharpDX.Result IsDurationKnown_() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Gets the duration of the transition.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p>The duration of the transition, in seconds.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_VALUE_NOT_DETERMINED</strong></dt> </dl> </td><td> <p>The requested value for the duration cannot be determined.</p> </td></tr> <tr><td> <dl> <dt><strong>UI_E_STORYBOARD_ACTIVE</strong></dt> </dl> </td><td> <p>The storyboard for this transition is currently in the schedule.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>An application should typically call the <strong><see cref="SharpDX.Animation.Transition.IsDurationKnown_"/></strong> method before calling this method. This method should not be called when the storyboard to which the transition has been added is scheduled or playing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition::GetDuration']/*"/>	
        /// <msdn-id>dd371951</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransition::GetDuration([Out] double* duration)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransition::GetDuration</unmanaged-short>	
        internal void GetDuration(out double duration) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* duration_ = &duration)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Extends the <strong><see cref="SharpDX.Animation.Transition"/></strong> interface that defines a transition. An  <strong><see cref="SharpDX.Animation.Transition2"/></strong> transition determines how an animation variable  changes over time in a given dimension.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition2']/*"/>	
    /// <msdn-id>hh448602</msdn-id>	
    /// <unmanaged>IUIAnimationTransition2</unmanaged>	
    /// <unmanaged-short>IUIAnimationTransition2</unmanaged-short>	
    [Guid("62FF9123-A85A-4e9b-A218-435A93E268FD")]
    public partial class Transition2 : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.Transition2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Transition2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.Transition2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.Transition2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.Transition2(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the number of dimensions in which the animation variable has a transition specified.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition2::GetDimension']/*"/>	
        /// <msdn-id>hh448603</msdn-id>	
        /// <unmanaged>GetDimension</unmanaged>	
        /// <unmanaged-short>GetDimension</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationTransition2::GetDimension([Out] unsigned int* dimension)</unmanaged>
        public int Dimension {
                get { int __output__; GetDimension(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Sets the initial value of the transition.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Do not call this method after the transition has been added to a storyboard.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition2::SetInitialValue']/*"/>	
        /// <msdn-id>hh448606</msdn-id>	
        /// <unmanaged>SetInitialValue</unmanaged>	
        /// <unmanaged-short>SetInitialValue</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationTransition2::SetInitialValue([In] double value)</unmanaged>
        public double InitialValue {
                set { SetInitialValue(value); }
        }
        
        /// <summary>	
        /// <p>Sets the initial velocity of the transition.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition2::SetInitialVelocity']/*"/>	
        /// <msdn-id>hh448609</msdn-id>	
        /// <unmanaged>SetInitialVelocity</unmanaged>	
        /// <unmanaged-short>SetInitialVelocity</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationTransition2::SetInitialVelocity([In] double velocity)</unmanaged>
        public double InitialVelocity {
                set { SetInitialVelocity(value); }
        }
        
        /// <summary>	
        /// <p>Determines whether the duration of a transition is known.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method should not be called when the storyboard to which the transition has been added is scheduled or playing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition2::IsDurationKnown']/*"/>	
        /// <msdn-id>hh448605</msdn-id>	
        /// <unmanaged>IsDurationKnown</unmanaged>	
        /// <unmanaged-short>IsDurationKnown</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationTransition2::IsDurationKnown()</unmanaged>
        public SharpDX.Result IsDurationKnown {
                get { return IsDurationKnown_(); }
        }
        
        /// <summary>	
        /// <p> Gets the duration of the transition.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>An application should typically call the <strong>IsDurationKnown</strong> method before calling this method. </p><p>This method should not be called when the storyboard to which the transition has been added is scheduled or playing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition2::GetDuration']/*"/>	
        /// <msdn-id>hh448604</msdn-id>	
        /// <unmanaged>GetDuration</unmanaged>	
        /// <unmanaged-short>GetDuration</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationTransition2::GetDuration([Out] double* duration)</unmanaged>
        public double Duration {
                get { double __output__; GetDuration(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the number of dimensions in which the animation variable has a transition specified.</p>	
        /// </summary>	
        /// <param name="dimension"><dd> <p>The number of dimensions.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition2::GetDimension']/*"/>	
        /// <msdn-id>hh448603</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransition2::GetDimension([Out] unsigned int* dimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransition2::GetDimension</unmanaged-short>	
        internal void GetDimension(out int dimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dimension_ = &dimension)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, dimension_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the initial value of the transition.</p>	
        /// </summary>	
        /// <param name="value"><dd> <p>The initial value for the transition.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Do not call this method after the transition has been added to a storyboard.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition2::SetInitialValue']/*"/>	
        /// <msdn-id>hh448606</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransition2::SetInitialValue([In] double value)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransition2::SetInitialValue</unmanaged-short>	
        internal void SetInitialValue(double value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, value,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the initial value of the transition for each specified dimension in the animation variable.</p>	
        /// </summary>	
        /// <param name="value"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the initial values for the transition.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The number of dimensions that require transition values. This parameter specifies the number of values listed in <em>value</em>.</p> </dd></param>	
        /// <returns><p>Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The animation manager should not call this method after the transition has been added to a storyboard.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition2::SetInitialVectorValue']/*"/>	
        /// <msdn-id>hh448607</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransition2::SetInitialVectorValue([In, Buffer] const double* value,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransition2::SetInitialVectorValue</unmanaged-short>	
        public void SetInitialVectorValue(double[] value, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* value_ = value)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, value_, cDimension,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the initial velocity of the transition.</p>	
        /// </summary>	
        /// <param name="velocity"><dd> <p>The initial velocity for the transition.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition2::SetInitialVelocity']/*"/>	
        /// <msdn-id>hh448609</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransition2::SetInitialVelocity([In] double velocity)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransition2::SetInitialVelocity</unmanaged-short>	
        internal void SetInitialVelocity(double velocity) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, velocity,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the initial velocity of the transition for each specified dimension in the animation variable.</p>	
        /// </summary>	
        /// <param name="velocity"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the initial velocities for the transition.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The number of dimensions that require transition velocities. This parameter specifies the number of values listed in <em>velocity</em>.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition2::SetInitialVectorVelocity']/*"/>	
        /// <msdn-id>hh448608</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransition2::SetInitialVectorVelocity([In, Buffer] const double* velocity,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransition2::SetInitialVectorVelocity</unmanaged-short>	
        public void SetInitialVectorVelocity(double[] velocity, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* velocity_ = velocity)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, velocity_, cDimension,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Determines whether the duration of a transition is known.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method should not be called when the storyboard to which the transition has been added is scheduled or playing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition2::IsDurationKnown']/*"/>	
        /// <msdn-id>hh448605</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransition2::IsDurationKnown()</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransition2::IsDurationKnown</unmanaged-short>	
        internal SharpDX.Result IsDurationKnown_() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Gets the duration of the transition.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p>The duration of the transition, in seconds.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>An application should typically call the <strong>IsDurationKnown</strong> method before calling this method. </p><p>This method should not be called when the storyboard to which the transition has been added is scheduled or playing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransition2::GetDuration']/*"/>	
        /// <msdn-id>hh448604</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransition2::GetDuration([Out] double* duration)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransition2::GetDuration</unmanaged-short>	
        internal void GetDuration(out double duration) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* duration_ = &duration)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration_,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Defines a method for creating transitions from custom interpolators.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> When an application requires animation effects that are not available in the transition library, developers can implement custom transitions that it can use. A custom transition is created by first implementing the interpolator function for the transition, and then by using a factory object to generate transitions from the interpolator. An interpolator must implement the <strong><see cref="SharpDX.Animation.Interpolator"/></strong> interface; an implementation of the transition factory object is provided by <strong>UIAnimationTransitionFactory</strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionFactory']/*"/>	
    /// <msdn-id>dd371891</msdn-id>	
    /// <unmanaged>IUIAnimationTransitionFactory</unmanaged>	
    /// <unmanaged-short>IUIAnimationTransitionFactory</unmanaged-short>	
    [Guid("FCD91E03-3E3B-45ad-BBB1-6DFC8153743D")]
    public partial class TransitionFactory : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.TransitionFactory"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TransitionFactory(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.TransitionFactory"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.TransitionFactory(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.TransitionFactory(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Creates a transition from a custom interpolator.</p>	
        /// </summary>	
        /// <param name="interpolator"><dd> <p> The interpolator from which a transition is to be created.   The specified object must implement the <strong><see cref="SharpDX.Animation.Interpolator"/></strong> interface.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new transition.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionFactory::CreateTransition']/*"/>	
        /// <msdn-id>dd371894</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionFactory::CreateTransition([In] IUIAnimationInterpolator* interpolator,[Out, Fast] IUIAnimationTransition** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionFactory::CreateTransition</unmanaged-short>	
        internal void CreateTransition(SharpDX.Animation.Interpolator interpolator, SharpDX.Animation.Transition transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((interpolator == null)?IntPtr.Zero:interpolator.NativePointer), &transition_,((void**)(*(void**)_nativePointer))[3]);		
                ((SharpDX.Animation.Transition)transition).NativePointer = transition_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Defines a method for creating transitions from custom interpolators.</p><p><strong><see cref="SharpDX.Animation.TransitionFactory2"/></strong> supports the creation of transitions in a specified dimension.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> When an application requires animation effects that are not available in the transition library, developers can implement custom transitions that the application can use. A custom transition is created by first implementing the interpolator function for the transition, and then by using a factory object to generate transitions from the interpolator. An interpolator must implement either the <strong><see cref="SharpDX.Animation.Interpolator"/></strong> interface or the <strong><see cref="SharpDX.Animation.Interpolator2"/></strong> interface; an implementation of the transition factory object is provided by <strong>UIAnimationTransitionFactory</strong> or by <strong>UIAnimationTransitionFactory2</strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionFactory2']/*"/>	
    /// <msdn-id>hh448610</msdn-id>	
    /// <unmanaged>IUIAnimationTransitionFactory2</unmanaged>	
    /// <unmanaged-short>IUIAnimationTransitionFactory2</unmanaged-short>	
    [Guid("937D4916-C1A6-42d5-88D8-30344D6EFE31")]
    public partial class TransitionFactory2 : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.TransitionFactory2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TransitionFactory2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.TransitionFactory2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.TransitionFactory2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.TransitionFactory2(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Creates a transition from a custom interpolator for a given dimension.</p>	
        /// </summary>	
        /// <param name="interpolator"><dd> <p> The interpolator from which a transition is to be created.   The specified object must implement the <strong><see cref="SharpDX.Animation.Interpolator2"/></strong> interface.</p> </dd></param>	
        /// <param name="transition"><dd> <p>The new transition.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.  See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionFactory2::CreateTransition']/*"/>	
        /// <msdn-id>hh448611</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionFactory2::CreateTransition([In] IUIAnimationInterpolator2* interpolator,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionFactory2::CreateTransition</unmanaged-short>	
        public void CreateTransition(SharpDX.Animation.Interpolator2 interpolator, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((interpolator == null)?IntPtr.Zero:interpolator.NativePointer), &transition_,((void**)(*(void**)_nativePointer))[3]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Defines a library of standard transitions. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Windows Animation includes a library of common transitions that developers can apply to variables through a storyboard. The parameters for specifying a transition depend on the type of transition. For some transitions, the duration of the transition is an explicit parameter; for others, the duration is determined by other parameters, such as speed or acceleration when the transition begins. A transition's initial value or velocity can be overridden if a discontinuous jump is desired, and duration can be queried after the transition is added to a storyboard.</p><p>If an application requires an effect that cannot be specified using the transition library, developers can implement custom transitions. A custom transition is created by first implementing the interpolator function for the transition, and then by using a factory object to generate transitions from interpolators. An interpolator must implement the <strong><see cref="SharpDX.Animation.Interpolator"/></strong> interface; an implementation of the transition factory object is provided by <strong>UIAnimationTransitionFactory</strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary']/*"/>	
    /// <msdn-id>dd371897</msdn-id>	
    /// <unmanaged>IUIAnimationTransitionLibrary</unmanaged>	
    /// <unmanaged-short>IUIAnimationTransitionLibrary</unmanaged-short>	
    [Guid("CA5A14B1-D24F-48b8-8FE4-C78169BA954E")]
    public partial class TransitionLibrary : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.TransitionLibrary"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TransitionLibrary(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.TransitionLibrary"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.TransitionLibrary(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.TransitionLibrary(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Creates an instantaneous transition.</p>	
        /// </summary>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <returns><dd> <p> The new instantaneous transition.</p> </dd></returns>	
        /// <remarks>	
        /// <p>During an instantaneous transition, the value of the animation variable changes instantly from its current value to a specified final value. The duration of this transition is always zero.</p><p>The figure below shows the effect on an animation variable over time during an instantaneous transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary::CreateInstantaneousTransition']/*"/>	
        /// <msdn-id>dd371914</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateInstantaneousTransition([In] double finalValue,[Out] IUIAnimationTransition** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateInstantaneousTransition</unmanaged-short>	
        public SharpDX.Animation.Transition Instantaneous(double finalValue) {
            unsafe {
                SharpDX.Animation.Transition transition;
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, finalValue, &transition_,((void**)(*(void**)_nativePointer))[3]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition(transition_);	
                __result__.CheckError();
                return transition;
            }
        }
        
        /// <summary>	
        /// <p> Creates a constant transition.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p> The duration of the transition.</p> </dd></param>	
        /// <returns><dd> <p> The new constant transition.</p> </dd></returns>	
        /// <remarks>	
        /// <p>During a constant transition, the value of an animation variable remains at the initial value over the duration of the transition.</p><p>The figure below shows the effect on an animation variable over time during a constant-duration transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary::CreateConstantTransition']/*"/>	
        /// <msdn-id>dd371903</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateConstantTransition([In] double duration,[Out] IUIAnimationTransition** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateConstantTransition</unmanaged-short>	
        public SharpDX.Animation.Transition Constant(double duration) {
            unsafe {
                SharpDX.Animation.Transition transition;
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, &transition_,((void**)(*(void**)_nativePointer))[4]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition(transition_);	
                __result__.CheckError();
                return transition;
            }
        }
        
        /// <summary>	
        /// <p> Creates a discrete transition.</p>	
        /// </summary>	
        /// <param name="delay"><dd> <p>The amount of time by which to delay the instantaneous switch to the final value.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="hold"><dd> <p>The amount of time by which to hold the variable at its final value.</p> </dd></param>	
        /// <returns><dd> <p> The new discrete transition.</p> </dd></returns>	
        /// <remarks>	
        /// <p>During a discrete transition, the animation variable remains at the initial value for a specified delay time, then switches instantaneously to a specified final value and remains at that value for a given hold time.</p><p>The figure below shows the effect on an animation variable over time during a discrete transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary::CreateDiscreteTransition']/*"/>	
        /// <msdn-id>dd371911</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateDiscreteTransition([In] double delay,[In] double finalValue,[In] double hold,[Out] IUIAnimationTransition** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateDiscreteTransition</unmanaged-short>	
        public SharpDX.Animation.Transition Discrete(double delay, double finalValue, double hold) {
            unsafe {
                SharpDX.Animation.Transition transition;
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, delay, finalValue, hold, &transition_,((void**)(*(void**)_nativePointer))[5]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition(transition_);	
                __result__.CheckError();
                return transition;
            }
        }
        
        /// <summary>	
        /// <p> Creates a linear transition.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p> The duration of the transition.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <returns><dd> <p> The new linear transition.</p> </dd></returns>	
        /// <remarks>	
        /// <p>During a linear transition, the value of the animation variable transitions linearly from its initial value to a  specified final value.</p><p>The figure below shows the effect on an animation variable over time during a linear transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary::CreateLinearTransition']/*"/>	
        /// <msdn-id>dd371920</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateLinearTransition([In] double duration,[In] double finalValue,[Out] IUIAnimationTransition** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateLinearTransition</unmanaged-short>	
        public SharpDX.Animation.Transition Linear(double duration, double finalValue) {
            unsafe {
                SharpDX.Animation.Transition transition;
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, finalValue, &transition_,((void**)(*(void**)_nativePointer))[6]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition(transition_);	
                __result__.CheckError();
                return transition;
            }
        }
        
        /// <summary>	
        /// <p> Creates a linear-speed transition.</p>	
        /// </summary>	
        /// <param name="speed"><dd> <p>The absolute value of the velocity.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <returns><dd> <p> The new linear-speed transition.</p> </dd></returns>	
        /// <remarks>	
        /// <p>During a linear-speed transition, the value of the animation variable changes at a specified rate. The duration of the transition is determined by  the difference between the initial value and the specified final value.</p><p>The figure below shows the effect on an animation variable over time during a linear-speed transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary::CreateLinearTransitionFromSpeed']/*"/>	
        /// <msdn-id>dd371925</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateLinearTransitionFromSpeed([In] double speed,[In] double finalValue,[Out] IUIAnimationTransition** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateLinearTransitionFromSpeed</unmanaged-short>	
        public SharpDX.Animation.Transition LinearFromSpeed(double speed, double finalValue) {
            unsafe {
                SharpDX.Animation.Transition transition;
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, speed, finalValue, &transition_,((void**)(*(void**)_nativePointer))[7]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition(transition_);	
                __result__.CheckError();
                return transition;
            }
        }
        
        /// <summary>	
        /// <p> Creates a sinusoidal-velocity transition, with an amplitude determined by the initial velocity.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p>The duration of the transition.</p> </dd></param>	
        /// <param name="period"><dd> <p>The period of oscillation of the sinusoidal wave in seconds.</p> </dd></param>	
        /// <returns><dd> <p> The new sinusoidal-velocity transition.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The value of the animation variable oscillates around the initial value over the entire duration of a sinusoidal-range transition. The amplitude of the oscillation is determined by the velocity when the transition begins.</p><p>The figure below shows the effect on an animation variable over time during a sinusoidal-velocity transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary::CreateSinusoidalTransitionFromVelocity']/*"/>	
        /// <msdn-id>dd371945</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateSinusoidalTransitionFromVelocity([In] double duration,[In] double period,[Out] IUIAnimationTransition** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateSinusoidalTransitionFromVelocity</unmanaged-short>	
        public SharpDX.Animation.Transition SinusoidalFromVelocity(double duration, double period) {
            unsafe {
                SharpDX.Animation.Transition transition;
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, period, &transition_,((void**)(*(void**)_nativePointer))[8]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition(transition_);	
                __result__.CheckError();
                return transition;
            }
        }
        
        /// <summary>	
        /// <p> Creates a sinusoidal-range  transition, with a specified range of oscillation.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p>The duration of the transition.</p> </dd></param>	
        /// <param name="minimumValue"><dd> <p>The value of the animation variable at a trough of the sinusoidal wave.</p> </dd></param>	
        /// <param name="maximumValue"><dd> <p>The value of the animation variable at a peak of the sinusoidal wave.</p> </dd></param>	
        /// <param name="period"><dd> <p>The period of oscillation of the sinusoidal wave, in seconds.</p> </dd></param>	
        /// <param name="slope"><dd> <p>The slope at the start of the transition.</p> </dd></param>	
        /// <returns><dd> <p> The new sinusoidal-range transition.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The value of the animation variable fluctuates between the specified minimum and maximum values over the entire duration of a  sinusodial-range transition. The <em>slope</em> parameter is used to disambiguate between the two possible sine waves specified by the other parameters.</p><p>The figure below shows the effect on an animation variable over time during a sinusoidal-range transition. Passing in the <strong><see cref="SharpDX.Animation.Slope.Increasing"/></strong> enumeration value yields a wave like the solid curve shown in the figure, whereas the <strong><see cref="SharpDX.Animation.Slope.Decreasing"/></strong> value yields a wave like the dashed curve.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary::CreateSinusoidalTransitionFromRange']/*"/>	
        /// <msdn-id>dd371942</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateSinusoidalTransitionFromRange([In] double duration,[In] double minimumValue,[In] double maximumValue,[In] double period,[In] UI_ANIMATION_SLOPE slope,[Out] IUIAnimationTransition** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateSinusoidalTransitionFromRange</unmanaged-short>	
        public SharpDX.Animation.Transition SinusoidalFromRange(double duration, double minimumValue, double maximumValue, double period, SharpDX.Animation.Slope slope) {
            unsafe {
                SharpDX.Animation.Transition transition;
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, minimumValue, maximumValue, period, unchecked((int)slope), &transition_,((void**)(*(void**)_nativePointer))[9]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition(transition_);	
                __result__.CheckError();
                return transition;
            }
        }
        
        /// <summary>	
        /// <p> Creates an accelerate-decelerate transition.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p> The duration of the transition.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="accelerationRatio"><dd> <p> The ratio of the time spent accelerating to the duration.</p> </dd></param>	
        /// <param name="decelerationRatio"><dd> <p> The ratio of the time spent decelerating to the duration.</p> </dd></param>	
        /// <returns><dd> <p> The new accelerate-decelerate transition.</p> </dd></returns>	
        /// <remarks>	
        /// <p>During an accelerate-decelerate transition, the animation variable speeds up and then slows down over the duration of the transition, ending at a specified value. You can control how quickly the variable accelerates and decelerates independently, by specifying different acceleration and deceleration ratios.</p><p>When the initial velocity is zero, the acceleration ratio is the fraction of the duration that the variable will spend accelerating; likewise with the deceleration ratio. If the initial velocity is nonzero, it is the fraction of the time between the velocity reaching zero and the end of transition. The acceleration ratio and the deceleration ratio should sum to a maximum of 1.0. </p><p>The figures below show the effect on animation variables with different initial velocities during accelerate-decelerate transitions.</p><p><strong>Note</strong>??d' in the above figure on the right shows the time between the velocity reaching zero and the end of the transition.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary::CreateAccelerateDecelerateTransition']/*"/>	
        /// <msdn-id>dd371900</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateAccelerateDecelerateTransition([In] double duration,[In] double finalValue,[In] double accelerationRatio,[In] double decelerationRatio,[Out] IUIAnimationTransition** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateAccelerateDecelerateTransition</unmanaged-short>	
        public SharpDX.Animation.Transition AccelerateDecelerate(double duration, double finalValue, double accelerationRatio, double decelerationRatio) {
            unsafe {
                SharpDX.Animation.Transition transition;
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, finalValue, accelerationRatio, decelerationRatio, &transition_,((void**)(*(void**)_nativePointer))[10]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition(transition_);	
                __result__.CheckError();
                return transition;
            }
        }
        
        /// <summary>	
        /// <p> Creates a reversal transition.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p>The duration of the transition.</p> </dd></param>	
        /// <returns><dd> <p> The new reversal transition.</p> </dd></returns>	
        /// <remarks>	
        /// <p> A reversal transition smoothly changes direction over the specified duration. The final value will be the same as the initial value and the final velocity will be the negative of the initial velocity. The figure below shows such a reversal transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary::CreateReversalTransition']/*"/>	
        /// <msdn-id>dd371938</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateReversalTransition([In] double duration,[Out] IUIAnimationTransition** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateReversalTransition</unmanaged-short>	
        public SharpDX.Animation.Transition Reversal(double duration) {
            unsafe {
                SharpDX.Animation.Transition transition;
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, &transition_,((void**)(*(void**)_nativePointer))[11]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition(transition_);	
                __result__.CheckError();
                return transition;
            }
        }
        
        /// <summary>	
        /// <p> Creates a cubic transition.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p> The duration of the transition.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="finalVelocity"><dd> <p> The velocity of the variable at the end of the transition.</p> </dd></param>	
        /// <returns><dd> <p> The new cubic transition.</p> </dd></returns>	
        /// <remarks>	
        /// <p>During a cubic transition, the value of the animation variable changes from its initial value to a specified final value over the duration of the transition, ending at a specified velocity.</p><p>The figure below shows the effect on an animation variable over time during a cubic transition.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary::CreateCubicTransition']/*"/>	
        /// <msdn-id>dd756728</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateCubicTransition([In] double duration,[In] double finalValue,[In] double finalVelocity,[Out] IUIAnimationTransition** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateCubicTransition</unmanaged-short>	
        public SharpDX.Animation.Transition Cubic(double duration, double finalValue, double finalVelocity) {
            unsafe {
                SharpDX.Animation.Transition transition;
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, finalValue, finalVelocity, &transition_,((void**)(*(void**)_nativePointer))[12]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition(transition_);	
                __result__.CheckError();
                return transition;
            }
        }
        
        /// <summary>	
        /// <p> Creates a smooth-stop transition.</p>	
        /// </summary>	
        /// <param name="maximumDuration"><dd> <p> The maximum duration of the transition.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <returns><dd> <p> The new smooth-stop transition.</p> </dd></returns>	
        /// <remarks>	
        /// <p>A smooth-stop transition slows down as it approaches the specified final value, and reaches it with a velocity of zero. The duration of the transition is determined by the initial velocity, the difference between the initial and final values, and the specified maximum duration. If there is no solution consisting of a single parabolic arc, this method creates a cubic transition.</p><p>The figure below shows the effect on an animation variable over time during a smooth-stop transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary::CreateSmoothStopTransition']/*"/>	
        /// <msdn-id>dd756729</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateSmoothStopTransition([In] double maximumDuration,[In] double finalValue,[Out] IUIAnimationTransition** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateSmoothStopTransition</unmanaged-short>	
        public SharpDX.Animation.Transition SmoothStop(double maximumDuration, double finalValue) {
            unsafe {
                SharpDX.Animation.Transition transition;
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, maximumDuration, finalValue, &transition_,((void**)(*(void**)_nativePointer))[13]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition(transition_);	
                __result__.CheckError();
                return transition;
            }
        }
        
        /// <summary>	
        /// <p> Creates a parabolic-acceleration transition.</p>	
        /// </summary>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="finalVelocity"><dd> <p>The velocity at the end of the transition.</p> </dd></param>	
        /// <param name="acceleration"><dd> <p> The acceleration during the transition.</p> </dd></param>	
        /// <returns><dd> <p> The new parabolic-acceleration transition.</p> </dd></returns>	
        /// <remarks>	
        /// <p> During a parabolic-acceleration transition, the value of the animation variable changes from the  initial value to the final value ending at the specified velocity.  You can control how quickly the variable reaches the final value by specifying the rate of acceleration.</p><p>The figure below shows the effect on an animation variable over time during a parabolic-acceleration transition.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary::CreateParabolicTransitionFromAcceleration']/*"/>	
        /// <msdn-id>dd371934</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary::CreateParabolicTransitionFromAcceleration([In] double finalValue,[In] double finalVelocity,[In] double acceleration,[Out] IUIAnimationTransition** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary::CreateParabolicTransitionFromAcceleration</unmanaged-short>	
        public SharpDX.Animation.Transition ParabolicFromAcceleration(double finalValue, double finalVelocity, double acceleration) {
            unsafe {
                SharpDX.Animation.Transition transition;
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, finalValue, finalVelocity, acceleration, &transition_,((void**)(*(void**)_nativePointer))[14]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition(transition_);	
                __result__.CheckError();
                return transition;
            }
        }
    }
    /// <summary>	
    /// <p> Creates a cubic B?zier linear scalar transition.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>During a cubic B?zier linear transition, the value of the animation variable changes from its initial value to the <em>finalValue</em> over the <em>duration</em> of the transition. The ordered pairs, (x1, y1) and (x2, y2), act as control points that provide directional information to transform the linear path of the transition into a smooth parametric curve.</p><p>The following figure shows the change in value over time for an animation variable during a cubic B?zier linear transition.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2']/*"/>	
    /// <msdn-id>hh448615</msdn-id>	
    /// <unmanaged>IUIAnimationTransitionLibrary2</unmanaged>	
    /// <unmanaged-short>IUIAnimationTransitionLibrary2</unmanaged-short>	
    [Guid("03CFAE53-9580-4ee3-B363-2ECE51B4AF6A")]
    public partial class TransitionLibrary2 : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.TransitionLibrary2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TransitionLibrary2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.TransitionLibrary2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.TransitionLibrary2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.TransitionLibrary2(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Creates an instantaneous scalar transition.</p>	
        /// </summary>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new instantaneous transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>During an instantaneous transition, the value of the animation variable changes instantly from its current value to a specified final value. The duration of this transition is always zero.</p><p>The following figure shows the change in value over time of an animation variable during an instantaneous transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateInstantaneousTransition']/*"/>	
        /// <msdn-id>hh448621</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateInstantaneousTransition([In] double finalValue,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateInstantaneousTransition</unmanaged-short>	
        public void CreateInstantaneousTransition(double finalValue, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, finalValue, &transition_,((void**)(*(void**)_nativePointer))[3]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates an instantaneous vector transition for each specified dimension.</p>	
        /// </summary>	
        /// <param name="finalValue"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the values of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The number of dimensions to apply the transition. This parameter specifies the number of values listed in <em>finalValue</em>.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new instantaneous transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>During an instantaneous transition, the value of the animation variable changes instantly from its current value to a specified final value. The duration of this transition is always zero.</p><p>The following figure shows the change in value over time of an animation variable during an instantaneous transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateInstantaneousVectorTransition']/*"/>	
        /// <msdn-id>hh448622</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateInstantaneousVectorTransition([In, Buffer] const double* finalValue,[In] unsigned int cDimension,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateInstantaneousVectorTransition</unmanaged-short>	
        public void CreateInstantaneousVectorTransition(double[] finalValue, int cDimension, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* finalValue_ = finalValue)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, finalValue_, cDimension, &transition_,((void**)(*(void**)_nativePointer))[4]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a constant scalar transition.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p> The duration of the transition.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new constant transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>During a constant transition, the value of an animation variable remains at the initial value over the duration of the transition.</p><p>The following figure shows the change in value for an animation variable over time during a constant-duration transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateConstantTransition']/*"/>	
        /// <msdn-id>hh448614</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateConstantTransition([In] double duration,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateConstantTransition</unmanaged-short>	
        public void CreateConstantTransition(double duration, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, &transition_,((void**)(*(void**)_nativePointer))[5]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a discrete scalar transition.</p>	
        /// </summary>	
        /// <param name="delay"><dd> <p>The amount of time by which to delay the instantaneous switch to the final value.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="hold"><dd> <p>The amount of time by which to hold the variable at its final value.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new discrete transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>During a discrete transition, the animation variable remains at the initial value for a specified delay time, then switches instantaneously to a specified final value and remains at that value for a given hold time.</p><p>The following figure shows the change in value over time of an animation variable during a discrete transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateDiscreteTransition']/*"/>	
        /// <msdn-id>hh448619</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateDiscreteTransition([In] double delay,[In] double finalValue,[In] double hold,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateDiscreteTransition</unmanaged-short>	
        public void CreateDiscreteTransition(double delay, double finalValue, double hold, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, delay, finalValue, hold, &transition_,((void**)(*(void**)_nativePointer))[6]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a discrete vector transition for each specified dimension.</p>	
        /// </summary>	
        /// <param name="delay"><dd> <p>The amount of time by which to delay the instantaneous switch to the final value.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the final values of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The number of dimensions to apply the transition. This parameter specifies the number of values listed in <em>finalValue</em>.</p> </dd></param>	
        /// <param name="hold"><dd> <p>The amount of time by which to hold the variable at its final value.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new discrete transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>During a discrete transition, the animation variable remains at the initial value for a specified delay time, then switches instantaneously to a specified final value and remains at that value for a given hold time.</p><p>The following figure shows the change in value over time of an animation variable during a discrete transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateDiscreteVectorTransition']/*"/>	
        /// <msdn-id>hh448620</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateDiscreteVectorTransition([In] double delay,[In, Buffer] const double* finalValue,[In] unsigned int cDimension,[In] double hold,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateDiscreteVectorTransition</unmanaged-short>	
        public void CreateDiscreteVectorTransition(double delay, double[] finalValue, int cDimension, double hold, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* finalValue_ = finalValue)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, delay, finalValue_, cDimension, hold, &transition_,((void**)(*(void**)_nativePointer))[7]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a linear scalar transition.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p> The duration of the transition.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new linear transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>During a linear transition, the value of the animation variable transitions linearly from its initial value to a  specified final value.</p><p>The following figure shows the change in value over time of an animation variable during a linear transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateLinearTransition']/*"/>	
        /// <msdn-id>hh448623</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateLinearTransition([In] double duration,[In] double finalValue,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateLinearTransition</unmanaged-short>	
        public void CreateLinearTransition(double duration, double finalValue, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, finalValue, &transition_,((void**)(*(void**)_nativePointer))[8]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a linear vector transition in the specified dimension.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p> The duration of the transition.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the final values of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The number of dimensions to apply the transition. This parameter specifies the number of values listed in <em>finalValue</em>.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new linear transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>During a linear transition, the value of the animation variable transitions linearly from its initial value to a  specified final value.</p><p>The following figure shows the change in value over time of an animation variable during a linear transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateLinearVectorTransition']/*"/>	
        /// <msdn-id>hh448625</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateLinearVectorTransition([In] double duration,[In, Buffer] const double* finalValue,[In] unsigned int cDimension,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateLinearVectorTransition</unmanaged-short>	
        public void CreateLinearVectorTransition(double duration, double[] finalValue, int cDimension, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* finalValue_ = finalValue)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, finalValue_, cDimension, &transition_,((void**)(*(void**)_nativePointer))[9]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a linear-speed scalar transition.</p>	
        /// </summary>	
        /// <param name="speed"><dd> <p>The absolute value of the velocity in units/second.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new linear-speed transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>During a linear-speed transition, the value of the animation variable changes at a specified rate. The duration of the transition is determined by  the difference between the initial value and the specified final value.</p><p>The following figure shows the change in value over time of an animation variable during a linear-speed transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateLinearTransitionFromSpeed']/*"/>	
        /// <msdn-id>hh448624</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateLinearTransitionFromSpeed([In] double speed,[In] double finalValue,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateLinearTransitionFromSpeed</unmanaged-short>	
        public void CreateLinearTransitionFromSpeed(double speed, double finalValue, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, speed, finalValue, &transition_,((void**)(*(void**)_nativePointer))[10]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a linear-speed vector transition in the specified dimension.</p>	
        /// </summary>	
        /// <param name="speed"><dd> <p>The absolute value of the velocity in units/second.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the final values of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The number of dimensions to apply the transition. This parameter specifies the number of values listed in <em>finalValue</em>.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new linear-speed transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>During a linear-speed transition, the value of the animation variable changes at a specified rate. The duration of the transition is determined by  the difference between the initial value and the specified final value.</p><p>The following figure shows the change in value over time of an animation variable during a linear-speed transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateLinearVectorTransitionFromSpeed']/*"/>	
        /// <msdn-id>hh448626</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateLinearVectorTransitionFromSpeed([In] double speed,[In, Buffer] const double* finalValue,[In] unsigned int cDimension,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateLinearVectorTransitionFromSpeed</unmanaged-short>	
        public void CreateLinearVectorTransitionFromSpeed(double speed, double[] finalValue, int cDimension, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* finalValue_ = finalValue)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, speed, finalValue_, cDimension, &transition_,((void**)(*(void**)_nativePointer))[11]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a sinusoidal scalar transition where amplitude is determined by initial velocity.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p> The duration of the transition.</p> </dd></param>	
        /// <param name="period"><dd> <p>The period of oscillation of the sinusoidal wave.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new sinusoidal-velocity transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The value of the animation variable oscillates around the initial value over the entire duration of a sinusoidal-range transition. The amplitude of the oscillation is determined by the velocity when the transition begins.</p><p>The following figure shows the change in value over time of an animation variable during a sinusoidal-velocity transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateSinusoidalTransitionFromVelocity']/*"/>	
        /// <msdn-id>hh448630</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateSinusoidalTransitionFromVelocity([In] double duration,[In] double period,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateSinusoidalTransitionFromVelocity</unmanaged-short>	
        public void CreateSinusoidalTransitionFromVelocity(double duration, double period, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, period, &transition_,((void**)(*(void**)_nativePointer))[12]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a sinusoidal-range scalar  transition with a specified range of oscillation.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p>The duration of the transition.</p> </dd></param>	
        /// <param name="minimumValue"><dd> <p>The value of the animation variable at a trough of the sinusoidal wave.</p> </dd></param>	
        /// <param name="maximumValue"><dd> <p>The value of the animation variable at a peak of the sinusoidal wave.</p> </dd></param>	
        /// <param name="period"><dd> <p>The period of oscillation of the sinusoidal wave.</p> </dd></param>	
        /// <param name="slope"><dd> <p>The slope at the start of the transition.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new sinusoidal-range transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The value of the animation variable fluctuates between the specified minimum and maximum values over the entire duration of a  sinusodial-range transition. The <em>slope</em> parameter is used to disambiguate between the two possible sine waves specified by the other parameters.</p><p>The following figure shows the change in value over time of an animation variable during a sinusoidal-range transition. Passing in the <strong><see cref="SharpDX.Animation.Slope.Increasing"/></strong> enumeration value yields a wave like the solid curve shown in the figure, whereas the <strong><see cref="SharpDX.Animation.Slope.Decreasing"/></strong> value yields a wave like the dashed curve.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateSinusoidalTransitionFromRange']/*"/>	
        /// <msdn-id>hh448629</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateSinusoidalTransitionFromRange([In] double duration,[In] double minimumValue,[In] double maximumValue,[In] double period,[In] UI_ANIMATION_SLOPE slope,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateSinusoidalTransitionFromRange</unmanaged-short>	
        public void CreateSinusoidalTransitionFromRange(double duration, double minimumValue, double maximumValue, double period, SharpDX.Animation.Slope slope, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, minimumValue, maximumValue, period, unchecked((int)slope), &transition_,((void**)(*(void**)_nativePointer))[13]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates an accelerate-decelerate scalar transition.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p>The duration of the transition.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="accelerationRatio"><dd> <p> The ratio of <em>duration</em> time spent accelerating (0 to 1).</p> </dd></param>	
        /// <param name="decelerationRatio"><dd> <p> The ratio of <em>duration</em> time spent decelerating (0 to 1).</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new accelerate-decelerate transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>During an accelerate-decelerate transition, the animation variable speeds up and then slows down over the duration of the transition, ending at a specified value. You can control how quickly the variable accelerates and decelerates independently, by specifying different acceleration and deceleration ratios.</p><p>When the initial velocity is zero, the acceleration ratio is the fraction of the duration that the variable will spend accelerating; likewise for the deceleration ratio. If the value of initial velocity is nonzero, the value is the fraction of the time between the velocity reaching zero and the end of transition. The acceleration ratio and the deceleration ratio should sum to a maximum of 1.0. </p><p>The following figures show the change in value for animation variables with different initial velocities during accelerate-decelerate transitions.</p><p><strong>Note</strong>??d' in the figure on the right shows the time between the velocity reaching zero and the end of the transition.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateAccelerateDecelerateTransition']/*"/>	
        /// <msdn-id>hh448613</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateAccelerateDecelerateTransition([In] double duration,[In] double finalValue,[In] double accelerationRatio,[In] double decelerationRatio,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateAccelerateDecelerateTransition</unmanaged-short>	
        public void CreateAccelerateDecelerateTransition(double duration, double finalValue, double accelerationRatio, double decelerationRatio, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, finalValue, accelerationRatio, decelerationRatio, &transition_,((void**)(*(void**)_nativePointer))[14]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a reversal scalar transition.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p>The duration of the transition.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new reversal transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> A reversal transition smoothly changes direction over the specified duration. The final value will be the same as the initial value and the final velocity will be the negative of the initial velocity. The folllowing figure shows such a reversal transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateReversalTransition']/*"/>	
        /// <msdn-id>hh448628</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateReversalTransition([In] double duration,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateReversalTransition</unmanaged-short>	
        public void CreateReversalTransition(double duration, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, &transition_,((void**)(*(void**)_nativePointer))[15]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a cubic scalar transition.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p> The duration of the transition.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="finalVelocity"><dd> <p> The velocity of the variable at the end of the transition.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new cubic transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>During a cubic transition, the value of the animation variable changes from its initial value to the <em>finalValue</em> over the <em>duration</em> of the transition, ending at the <em>finalVelocity</em>.</p><p>The following figure shows the effect on an animation variable over time during a cubic transition.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateCubicTransition']/*"/>	
        /// <msdn-id>hh448617</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateCubicTransition([In] double duration,[In] double finalValue,[In] double finalVelocity,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateCubicTransition</unmanaged-short>	
        public void CreateCubicTransition(double duration, double finalValue, double finalVelocity, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, finalValue, finalVelocity, &transition_,((void**)(*(void**)_nativePointer))[16]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a cubic vector transition for each specified dimension.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p> The duration of the transition.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the final values of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="finalVelocity"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the final velocities (in units per second) of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The number of dimensions to apply the transition. This parameter specifies the number of values listed in <em>finalValue</em> and <em>finalVelocity</em>.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new cubic transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>During a cubic transition, the value of the animation variable changes from its initial value to the <em>finalValue</em> over the <em>duration</em> of the transition, ending at the <em>finalVelocity</em>.</p><p>The following figure shows the effect on an animation variable over time during a cubic transition.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateCubicVectorTransition']/*"/>	
        /// <msdn-id>hh448618</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateCubicVectorTransition([In] double duration,[In, Buffer] const double* finalValue,[In, Buffer] const double* finalVelocity,[In] unsigned int cDimension,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateCubicVectorTransition</unmanaged-short>	
        public void CreateCubicVectorTransition(double duration, double[] finalValue, double[] finalVelocity, int cDimension, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* finalValue_ = finalValue)
                    fixed (void* finalVelocity_ = finalVelocity)
                        __result__= 
        				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, finalValue_, finalVelocity_, cDimension, &transition_,((void**)(*(void**)_nativePointer))[17]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a smooth-stop scalar transition.</p>	
        /// </summary>	
        /// <param name="maximumDuration"><dd> <p> The maximum duration of the transition.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new smooth-stop transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A smooth-stop transition slows down as it approaches the specified final value, and reaches the final value with a velocity of zero. The duration of the transition is determined by the initial velocity, the difference between the initial and final values, and the specified maximum duration. If there is no solution consisting of a single parabolic arc, this method creates a cubic transition.</p><p>The following figure shows the change in value over time of an animation variable during a smooth-stop transition.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateSmoothStopTransition']/*"/>	
        /// <msdn-id>hh448631</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateSmoothStopTransition([In] double maximumDuration,[In] double finalValue,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateSmoothStopTransition</unmanaged-short>	
        public void CreateSmoothStopTransition(double maximumDuration, double finalValue, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, maximumDuration, finalValue, &transition_,((void**)(*(void**)_nativePointer))[18]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a parabolic-acceleration scalar transition.</p>	
        /// </summary>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="finalVelocity"><dd> <p>The velocity, in units/second, at the end of the transition.</p> </dd></param>	
        /// <param name="acceleration"><dd> <p> The acceleration, in units/second2, during the transition.</p> </dd></param>	
        /// <param name="transition"><dd> <p> The new parabolic-acceleration transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> During a parabolic-acceleration transition, the value of the animation variable changes from the  initial value to the final value, ending at the specified velocity.  You can control how quickly the variable reaches the final value by specifying the rate of acceleration.</p><p>The following figure shows the change in value over time of an animation variable during a parabolic-acceleration transition.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateParabolicTransitionFromAcceleration']/*"/>	
        /// <msdn-id>hh448627</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateParabolicTransitionFromAcceleration([In] double finalValue,[In] double finalVelocity,[In] double acceleration,[Out] IUIAnimationTransition2** transition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateParabolicTransitionFromAcceleration</unmanaged-short>	
        public void CreateParabolicTransitionFromAcceleration(double finalValue, double finalVelocity, double acceleration, out SharpDX.Animation.Transition2 transition) {
            unsafe {
                IntPtr transition_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, finalValue, finalVelocity, acceleration, &transition_,((void**)(*(void**)_nativePointer))[19]);		
                transition= (transition_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transition_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a cubic B?zier linear scalar transition.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p> The duration of the transition.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p> The value of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="x1"><dd> <p>The x-coordinate of the first control point.</p> </dd></param>	
        /// <param name="y1"><dd> <p>The y-coordinate of the first control point.</p> </dd></param>	
        /// <param name="x2"><dd> <p>The x-coordinate of the second control point.</p> </dd></param>	
        /// <param name="y2"><dd> <p>The y-coordinate of the second control point.</p> </dd></param>	
        /// <param name="transitionOut"><dd> <p>The new cubic B?zier linear transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>During a cubic B?zier linear transition, the value of the animation variable changes from its initial value to the <em>finalValue</em> over the <em>duration</em> of the transition. The ordered pairs, (x1, y1) and (x2, y2), act as control points that provide directional information to transform the linear path of the transition into a smooth parametric curve.</p><p>The following figure shows the change in value over time for an animation variable during a cubic B?zier linear transition.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateCubicBezierLinearTransition']/*"/>	
        /// <msdn-id>hh448615</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateCubicBezierLinearTransition([In] double duration,[In] double finalValue,[In] double x1,[In] double y1,[In] double x2,[In] double y2,[Out] IUIAnimationTransition2** ppTransition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateCubicBezierLinearTransition</unmanaged-short>	
        public void CreateCubicBezierLinearTransition(double duration, double finalValue, double x1, double y1, double x2, double y2, out SharpDX.Animation.Transition2 transitionOut) {
            unsafe {
                IntPtr transitionOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, finalValue, x1, y1, x2, y2, &transitionOut_,((void**)(*(void**)_nativePointer))[20]);		
                transitionOut= (transitionOut_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transitionOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates a cubic B?zier linear vector transition for each specified dimension.</p>	
        /// </summary>	
        /// <param name="duration"><dd> <p> The duration of the transition.</p> </dd></param>	
        /// <param name="finalValue"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the final values of the animation variable at the end of the transition.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The number of dimensions to apply the transition. This parameter specifies the number of values listed in <em>finalValue</em>.</p> </dd></param>	
        /// <param name="x1"><dd> <p>The x-coordinate of the first control point.</p> </dd></param>	
        /// <param name="y1"><dd> <p>The y-coordinate of the first control point.</p> </dd></param>	
        /// <param name="x2"><dd> <p>The x-coordinate of the second control point.</p> </dd></param>	
        /// <param name="y2"><dd> <p>The y-coordinate of the second control point.</p> </dd></param>	
        /// <param name="transitionOut"><dd> <p>The new cubic B?zier linear transition.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>During a cubic B?zier linear transition, the value of the animation variable changes from its initial value to the <em>finalValue</em> over the <em>duration</em> of the transition. The ordered pairs, (x1, y1) and (x2, y2), act as control points that provide directional information to transform the linear path of the transition into a smooth parametric curve.</p><p>The following figure shows the change in value over time of an animation variable during a cubic B?zier linear transition.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationTransitionLibrary2::CreateCubicBezierLinearVectorTransition']/*"/>	
        /// <msdn-id>hh448616</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationTransitionLibrary2::CreateCubicBezierLinearVectorTransition([In] double duration,[In, Buffer] const double* finalValue,[In] unsigned int cDimension,[In] double x1,[In] double y1,[In] double x2,[In] double y2,[Out] IUIAnimationTransition2** ppTransition)</unmanaged>	
        /// <unmanaged-short>IUIAnimationTransitionLibrary2::CreateCubicBezierLinearVectorTransition</unmanaged-short>	
        public void CreateCubicBezierLinearVectorTransition(double duration, double[] finalValue, int cDimension, double x1, double y1, double x2, double y2, out SharpDX.Animation.Transition2 transitionOut) {
            unsafe {
                IntPtr transitionOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* finalValue_ = finalValue)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, duration, finalValue_, cDimension, x1, y1, x2, y2, &transitionOut_,((void**)(*(void**)_nativePointer))[21]);		
                transitionOut= (transitionOut_ == IntPtr.Zero)?null:new SharpDX.Animation.Transition2(transitionOut_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Defines an animation variable, which represents a visual element that can be animated.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> Along with  <strong><see cref="SharpDX.Animation.Transition"/></strong> and  <strong><see cref="SharpDX.Animation.Storyboard"/></strong>, <strong><see cref="SharpDX.Animation.Variable"/></strong> is a primary component for building animations. To create and manage animation variables, use <strong><see cref="SharpDX.Animation.Manager"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable']/*"/>	
    /// <msdn-id>dd316797</msdn-id>	
    /// <unmanaged>IUIAnimationVariable</unmanaged>	
    /// <unmanaged-short>IUIAnimationVariable</unmanaged-short>	
    [Guid("8CEEB155-2849-4ce5-9448-91FF70E1E4D9")]
    public partial class Variable : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.Variable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Variable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.Variable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.Variable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.Variable(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Gets the current value of the animation variable.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The results can be affected by the lower and upper bounds determined by <strong><see cref="SharpDX.Animation.Variable.SetLowerBound"/></strong> and <strong><see cref="SharpDX.Animation.Variable.SetUpperBound"/></strong>, respectively.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::GetValue']/*"/>	
        /// <msdn-id>dd317002</msdn-id>	
        /// <unmanaged>GetValue</unmanaged>	
        /// <unmanaged-short>GetValue</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable::GetValue([Out] double* value)</unmanaged>
        public double Value {
                get { double __output__; GetValue(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Gets the final value of the animation variable.   This is the value after all currently scheduled animations have completed.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The result can be affected by the lower and upper bounds determined by <strong><see cref="SharpDX.Animation.Variable.SetLowerBound"/></strong> and <strong><see cref="SharpDX.Animation.Variable.SetUpperBound"/></strong>, respectively.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::GetFinalValue']/*"/>	
        /// <msdn-id>dd316990</msdn-id>	
        /// <unmanaged>GetFinalValue</unmanaged>	
        /// <unmanaged-short>GetFinalValue</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable::GetFinalValue([Out] double* finalValue)</unmanaged>
        public double FinalValue {
                get { double __output__; GetFinalValue(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Gets the previous value of the animation variable. This is the value of the animation variable before the most recent update.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The results can be affected by the lower and upper bounds determined by <strong><see cref="SharpDX.Animation.Variable.SetLowerBound"/></strong> and <strong><see cref="SharpDX.Animation.Variable.SetUpperBound"/></strong>, respectively.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::GetPreviousValue']/*"/>	
        /// <msdn-id>dd316996</msdn-id>	
        /// <unmanaged>GetPreviousValue</unmanaged>	
        /// <unmanaged-short>GetPreviousValue</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable::GetPreviousValue([Out] double* previousValue)</unmanaged>
        public double PreviousValue {
                get { double __output__; GetPreviousValue(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Gets the current value of the animation variable as an integer.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>To specify the rounding mode to be used when converting the value, use the <strong><see cref="SharpDX.Animation.Variable.SetRoundingMode"/></strong> method.</p><p>The result can also be affected by the lower and upper bounds determined by <strong><see cref="SharpDX.Animation.Variable.SetLowerBound"/></strong> and <strong><see cref="SharpDX.Animation.Variable.SetUpperBound"/></strong>, respectively.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::GetIntegerValue']/*"/>	
        /// <msdn-id>dd316991</msdn-id>	
        /// <unmanaged>GetIntegerValue</unmanaged>	
        /// <unmanaged-short>GetIntegerValue</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable::GetIntegerValue([Out] int* value)</unmanaged>
        public int IntegerValue {
                get { int __output__; GetIntegerValue(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Gets the final value of the animation variable as an integer.       This is the value after all currently scheduled animations have completed.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>To specify the rounding mode to be used when converting the value, use the <strong><see cref="SharpDX.Animation.Variable.SetRoundingMode"/></strong> method.</p><p>The result can also be affected by the lower and upper bounds determined by <strong><see cref="SharpDX.Animation.Variable.SetLowerBound"/></strong> and <strong><see cref="SharpDX.Animation.Variable.SetUpperBound"/></strong>, respectively.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::GetFinalIntegerValue']/*"/>	
        /// <msdn-id>dd316836</msdn-id>	
        /// <unmanaged>GetFinalIntegerValue</unmanaged>	
        /// <unmanaged-short>GetFinalIntegerValue</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable::GetFinalIntegerValue([Out] int* finalValue)</unmanaged>
        public int FinalIntegerValue {
                get { int __output__; GetFinalIntegerValue(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Gets the previous value of the animation variable as an integer.       This is the value of the animation variable before the most recent update.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>To specify the rounding mode to be used when converting the value, use the <strong><see cref="SharpDX.Animation.Variable.SetRoundingMode"/></strong> method.</p><p>The result can also be affected by the lower and upper bounds determined by <strong><see cref="SharpDX.Animation.Variable.SetLowerBound"/></strong> and <strong><see cref="SharpDX.Animation.Variable.SetUpperBound"/></strong>, respectively.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::GetPreviousIntegerValue']/*"/>	
        /// <msdn-id>dd316994</msdn-id>	
        /// <unmanaged>GetPreviousIntegerValue</unmanaged>	
        /// <unmanaged-short>GetPreviousIntegerValue</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable::GetPreviousIntegerValue([Out] int* previousValue)</unmanaged>
        public int PreviousIntegerValue {
                get { int __output__; GetPreviousIntegerValue(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Gets the storyboard that is currently animating the animation variable.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::GetCurrentStoryboard']/*"/>	
        /// <msdn-id>dd316831</msdn-id>	
        /// <unmanaged>GetCurrentStoryboard</unmanaged>	
        /// <unmanaged-short>GetCurrentStoryboard</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable::GetCurrentStoryboard([Out] IUIAnimationStoryboard** storyboard)</unmanaged>
        public SharpDX.Animation.Storyboard CurrentStoryboard {
                get { SharpDX.Animation.Storyboard __output__; GetCurrentStoryboard(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Sets the lower bound (floor) for the animation variable. The value of the animation variable should not fall below the specified value.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::SetLowerBound']/*"/>	
        /// <msdn-id>dd317005</msdn-id>	
        /// <unmanaged>SetLowerBound</unmanaged>	
        /// <unmanaged-short>SetLowerBound</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable::SetLowerBound([In] double bound)</unmanaged>
        public double LowerBound {
                set { SetLowerBound(value); }
        }
        
        /// <summary>	
        /// <p> Sets an upper bound (ceiling) for the animation variable. The value of the animation variable should not rise above the specified value.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::SetUpperBound']/*"/>	
        /// <msdn-id>dd317010</msdn-id>	
        /// <unmanaged>SetUpperBound</unmanaged>	
        /// <unmanaged-short>SetUpperBound</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable::SetUpperBound([In] double bound)</unmanaged>
        public double UpperBound {
                set { SetUpperBound(value); }
        }
        
        /// <summary>	
        /// <p> Specifies the rounding mode for the animation variable.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> An animation variable's rounding mode determines how a floating-point value is converted to an integer. The default mode for each variable is <strong><see cref="SharpDX.Animation.RoundingMode.RoundingNearest"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::SetRoundingMode']/*"/>	
        /// <msdn-id>dd317006</msdn-id>	
        /// <unmanaged>SetRoundingMode</unmanaged>	
        /// <unmanaged-short>SetRoundingMode</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable::SetRoundingMode([In] UI_ANIMATION_ROUNDING_MODE mode)</unmanaged>
        public SharpDX.Animation.RoundingMode RoundingMode {
                set { SetRoundingMode(value); }
        }
        
        /// <summary>	
        /// <p> Gets the current value of the animation variable.</p>	
        /// </summary>	
        /// <param name="value"><dd> <p> The current value of the animation variable.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The results can be affected by the lower and upper bounds determined by <strong><see cref="SharpDX.Animation.Variable.SetLowerBound"/></strong> and <strong><see cref="SharpDX.Animation.Variable.SetUpperBound"/></strong>, respectively.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::GetValue']/*"/>	
        /// <msdn-id>dd317002</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable::GetValue([Out] double* value)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable::GetValue</unmanaged-short>	
        internal void GetValue(out double value) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* value_ = &value)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, value_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the final value of the animation variable.   This is the value after all currently scheduled animations have completed.</p>	
        /// </summary>	
        /// <param name="finalValue"><dd> <p> The final value of the animation variable.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_VALUE_NOT_DETERMINED</strong></dt> </dl> </td><td> <p>The final value of the animation variable cannot be determined at this time.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The result can be affected by the lower and upper bounds determined by <strong><see cref="SharpDX.Animation.Variable.SetLowerBound"/></strong> and <strong><see cref="SharpDX.Animation.Variable.SetUpperBound"/></strong>, respectively.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::GetFinalValue']/*"/>	
        /// <msdn-id>dd316990</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable::GetFinalValue([Out] double* finalValue)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable::GetFinalValue</unmanaged-short>	
        internal void GetFinalValue(out double finalValue) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* finalValue_ = &finalValue)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, finalValue_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the previous value of the animation variable. This is the value of the animation variable before the most recent update.</p>	
        /// </summary>	
        /// <param name="reviousValueRef"><dd> <p> The previous value of the animation variable.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The results can be affected by the lower and upper bounds determined by <strong><see cref="SharpDX.Animation.Variable.SetLowerBound"/></strong> and <strong><see cref="SharpDX.Animation.Variable.SetUpperBound"/></strong>, respectively.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::GetPreviousValue']/*"/>	
        /// <msdn-id>dd316996</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable::GetPreviousValue([Out] double* previousValue)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable::GetPreviousValue</unmanaged-short>	
        internal void GetPreviousValue(out double reviousValueRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* reviousValueRef_ = &reviousValueRef)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, reviousValueRef_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the current value of the animation variable as an integer.</p>	
        /// </summary>	
        /// <param name="value"><dd> <p> The current value of the animation variable, converted to an <strong>INT32</strong> value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>To specify the rounding mode to be used when converting the value, use the <strong><see cref="SharpDX.Animation.Variable.SetRoundingMode"/></strong> method.</p><p>The result can also be affected by the lower and upper bounds determined by <strong><see cref="SharpDX.Animation.Variable.SetLowerBound"/></strong> and <strong><see cref="SharpDX.Animation.Variable.SetUpperBound"/></strong>, respectively.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::GetIntegerValue']/*"/>	
        /// <msdn-id>dd316991</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable::GetIntegerValue([Out] int* value)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable::GetIntegerValue</unmanaged-short>	
        internal void GetIntegerValue(out int value) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* value_ = &value)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, value_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the final value of the animation variable as an integer.       This is the value after all currently scheduled animations have completed.</p>	
        /// </summary>	
        /// <param name="finalValue"><dd> <p> The final value of the animation variable, converted to an <strong>INT32</strong> value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_VALUE_NOT_DETERMINED</strong></dt> </dl> </td><td> <p>The final value of the animation variable cannot be determined at this time.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>To specify the rounding mode to be used when converting the value, use the <strong><see cref="SharpDX.Animation.Variable.SetRoundingMode"/></strong> method.</p><p>The result can also be affected by the lower and upper bounds determined by <strong><see cref="SharpDX.Animation.Variable.SetLowerBound"/></strong> and <strong><see cref="SharpDX.Animation.Variable.SetUpperBound"/></strong>, respectively.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::GetFinalIntegerValue']/*"/>	
        /// <msdn-id>dd316836</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable::GetFinalIntegerValue([Out] int* finalValue)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable::GetFinalIntegerValue</unmanaged-short>	
        internal void GetFinalIntegerValue(out int finalValue) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* finalValue_ = &finalValue)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, finalValue_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the previous value of the animation variable as an integer.       This is the value of the animation variable before the most recent update.</p>	
        /// </summary>	
        /// <param name="reviousValueRef"><dd> <p> The previous value of the animation variable, converted to an <strong>INT32</strong> value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>To specify the rounding mode to be used when converting the value, use the <strong><see cref="SharpDX.Animation.Variable.SetRoundingMode"/></strong> method.</p><p>The result can also be affected by the lower and upper bounds determined by <strong><see cref="SharpDX.Animation.Variable.SetLowerBound"/></strong> and <strong><see cref="SharpDX.Animation.Variable.SetUpperBound"/></strong>, respectively.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::GetPreviousIntegerValue']/*"/>	
        /// <msdn-id>dd316994</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable::GetPreviousIntegerValue([Out] int* previousValue)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable::GetPreviousIntegerValue</unmanaged-short>	
        internal void GetPreviousIntegerValue(out int reviousValueRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* reviousValueRef_ = &reviousValueRef)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, reviousValueRef_,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the storyboard that is currently animating the animation variable.</p>	
        /// </summary>	
        /// <param name="storyboard"><dd> <p>The current storyboard, or <strong><c>null</c></strong> if no storyboard is currently animating the animation variable.</p> </dd></param>	
        /// <returns><p> If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>UIAnimation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::GetCurrentStoryboard']/*"/>	
        /// <msdn-id>dd316831</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable::GetCurrentStoryboard([Out] IUIAnimationStoryboard** storyboard)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable::GetCurrentStoryboard</unmanaged-short>	
        internal void GetCurrentStoryboard(out SharpDX.Animation.Storyboard storyboard) {
            unsafe {
                IntPtr storyboard_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, &storyboard_,((void**)(*(void**)_nativePointer))[9]);		
                storyboard= (storyboard_ == IntPtr.Zero)?null:new SharpDX.Animation.Storyboard(storyboard_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the lower bound (floor) for the animation variable. The value of the animation variable should not fall below the specified value.</p>	
        /// </summary>	
        /// <param name="bound"><dd> <p> The lower bound for the animation variable.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::SetLowerBound']/*"/>	
        /// <msdn-id>dd317005</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable::SetLowerBound([In] double bound)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable::SetLowerBound</unmanaged-short>	
        internal void SetLowerBound(double bound) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, bound,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets an upper bound (ceiling) for the animation variable. The value of the animation variable should not rise above the specified value.</p>	
        /// </summary>	
        /// <param name="bound"><dd> <p> The upper bound for the animation variable.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::SetUpperBound']/*"/>	
        /// <msdn-id>dd317010</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable::SetUpperBound([In] double bound)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable::SetUpperBound</unmanaged-short>	
        internal void SetUpperBound(double bound) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, bound,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Specifies the rounding mode for the animation variable.</p>	
        /// </summary>	
        /// <param name="mode"><dd> <p> The rounding mode for the animation variable.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> An animation variable's rounding mode determines how a floating-point value is converted to an integer. The default mode for each variable is <strong><see cref="SharpDX.Animation.RoundingMode.RoundingNearest"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::SetRoundingMode']/*"/>	
        /// <msdn-id>dd317006</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable::SetRoundingMode([In] UI_ANIMATION_ROUNDING_MODE mode)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable::SetRoundingMode</unmanaged-short>	
        internal void SetRoundingMode(SharpDX.Animation.RoundingMode mode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, unchecked((int)mode),((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the tag for an animation variable.</p>	
        /// </summary>	
        /// <param name="@object"><dd> <p> The object portion of the tag. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="id"><dd> <p> The identifier portion  of the tag.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>); it can be used by an application to identify an animation variable.           Because <strong><c>null</c></strong> is a valid object component of a tag, the <em>object</em> parameter can be <strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::SetTag']/*"/>	
        /// <msdn-id>dd317008</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable::SetTag([In, Optional] void* object,[In] unsigned int id)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable::SetTag</unmanaged-short>	
        internal void SetTag(System.IntPtr @object, int id) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)@object, id,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the tag for an animation variable.</p>	
        /// </summary>	
        /// <param name="@object"><dd> <p> The object portion of the tag.</p> </dd></param>	
        /// <param name="id"><dd> <p> The identifier portion of the tag.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>UI_E_VALUE_NOT_SET</strong></dt> </dl> </td><td> <p>The animation variable's tag was not set.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>); it can be used by an application to identify an animation variable.</p><p>The parameters are optional so that the method can return both portions of the tag, or just the identifier or object portion.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::GetTag']/*"/>	
        /// <msdn-id>dd316998</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable::GetTag([Out, Optional] void** object,[Out, Optional] unsigned int* id)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable::GetTag</unmanaged-short>	
        internal void GetTag(out System.IntPtr @object, out int id) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* @object_ = &@object)
                    fixed (void* id_ = &id)
                        __result__= 
        				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, @object_, id_,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Specifies a variable change handler. This handler is notified of changes to the value of the animation variable.</p>	
        /// </summary>	
        /// <param name="handler"><dd> <p> A variable change handler.   The specified object must implement the <strong><see cref="SharpDX.Animation.VariableChangeHandler"/></strong> interface or be <strong><c>null</c></strong>. See Remarks.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::SetVariableChangeHandler']/*"/>	
        /// <msdn-id>dd317011</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable::SetVariableChangeHandler([In, Optional] IUIAnimationVariableChangeHandler* handler)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable::SetVariableChangeHandler</unmanaged-short>	
        internal void SetVariableChangeHandler_(System.IntPtr handler) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)handler,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Specifies an integer variable change handler. This handler is notified of changes to the integer value of the animation variable.</p>	
        /// </summary>	
        /// <param name="handler"><dd> <p> An integer variable change handler.   The specified object must implement the <strong><see cref="SharpDX.Animation.VariableIntegerChangeHandler"/></strong> interface or be <c>null</c>. See Remarks.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Winodws Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Passing <c>null</c> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager.Shutdown"/></strong> method.</p><p> <strong><see cref="SharpDX.Animation.VariableIntegerChangeHandler.OnIntegerValueChanged"/></strong> is called only if the rounded value has changed since the last update.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable::SetVariableIntegerChangeHandler']/*"/>	
        /// <msdn-id>dd317013</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable::SetVariableIntegerChangeHandler([In, Optional] IUIAnimationVariableIntegerChangeHandler* handler)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable::SetVariableIntegerChangeHandler</unmanaged-short>	
        internal void SetVariableIntegerChangeHandler_(System.IntPtr handler) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)handler,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Defines an animation variable, which represents a visual element that can be animated in multiple dimensions.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2']/*"/>	
    /// <msdn-id>hh448632</msdn-id>	
    /// <unmanaged>IUIAnimationVariable2</unmanaged>	
    /// <unmanaged-short>IUIAnimationVariable2</unmanaged-short>	
    [Guid("4914B304-96AB-44d9-9E77-D5109B7E7466")]
    public partial class Variable2 : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Animation.Variable2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Variable2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Animation.Variable2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Animation.Variable2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Animation.Variable2(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the number of dimensions that the animation variable is to be animated in.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetDimension']/*"/>	
        /// <msdn-id>hh448635</msdn-id>	
        /// <unmanaged>GetDimension</unmanaged>	
        /// <unmanaged-short>GetDimension</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetDimension([Out] unsigned int* dimension)</unmanaged>
        public int Dimension {
                get { int __output__; GetDimension(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the value of the animation variable.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetValue']/*"/>	
        /// <msdn-id>hh448647</msdn-id>	
        /// <unmanaged>GetValue</unmanaged>	
        /// <unmanaged-short>GetValue</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetValue([Out] double* value)</unmanaged>
        public double Value {
                get { double __output__; GetValue(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the final value of the animation variable. This is the value after all currently scheduled animations have completed.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetFinalValue']/*"/>	
        /// <msdn-id>hh448638</msdn-id>	
        /// <unmanaged>GetFinalValue</unmanaged>	
        /// <unmanaged-short>GetFinalValue</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetFinalValue([Out] double* finalValue)</unmanaged>
        public double FinalValue {
                get { double __output__; GetFinalValue(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the previous value of the animation variable. This is the value of the animation variable before the most recent update.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetPreviousValue']/*"/>	
        /// <msdn-id>hh448644</msdn-id>	
        /// <unmanaged>GetPreviousValue</unmanaged>	
        /// <unmanaged-short>GetPreviousValue</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetPreviousValue([Out] double* previousValue)</unmanaged>
        public double PreviousValue {
                get { double __output__; GetPreviousValue(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the integer value of the animation variable.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetIntegerValue']/*"/>	
        /// <msdn-id>hh448640</msdn-id>	
        /// <unmanaged>GetIntegerValue</unmanaged>	
        /// <unmanaged-short>GetIntegerValue</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetIntegerValue([Out] int* value)</unmanaged>
        public int IntegerValue {
                get { int __output__; GetIntegerValue(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the final integer value of the animation variable. This is the value after all currently scheduled animations have completed.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetFinalIntegerValue']/*"/>	
        /// <msdn-id>hh448636</msdn-id>	
        /// <unmanaged>GetFinalIntegerValue</unmanaged>	
        /// <unmanaged-short>GetFinalIntegerValue</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetFinalIntegerValue([Out] int* finalValue)</unmanaged>
        public int FinalIntegerValue {
                get { int __output__; GetFinalIntegerValue(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the previous integer value of the animation variable in the specified dimension. This is the value of the animation variable before the most recent update.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetPreviousIntegerValue']/*"/>	
        /// <msdn-id>hh448642</msdn-id>	
        /// <unmanaged>GetPreviousIntegerValue</unmanaged>	
        /// <unmanaged-short>GetPreviousIntegerValue</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetPreviousIntegerValue([Out] int* previousValue)</unmanaged>
        public int PreviousIntegerValue {
                get { int __output__; GetPreviousIntegerValue(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the active storyboard for the animation variable.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetCurrentStoryboard']/*"/>	
        /// <msdn-id>hh448633</msdn-id>	
        /// <unmanaged>GetCurrentStoryboard</unmanaged>	
        /// <unmanaged-short>GetCurrentStoryboard</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetCurrentStoryboard([Out] IUIAnimationStoryboard2** storyboard)</unmanaged>
        public SharpDX.Animation.Storyboard2 CurrentStoryboard {
                get { SharpDX.Animation.Storyboard2 __output__; GetCurrentStoryboard(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Sets the lower bound (floor) for the value of the animation variable. The value of the animation variable should not fall below the specified value.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::SetLowerBound']/*"/>	
        /// <msdn-id>hh448650</msdn-id>	
        /// <unmanaged>SetLowerBound</unmanaged>	
        /// <unmanaged-short>SetLowerBound</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetLowerBound([In] double bound)</unmanaged>
        public double LowerBound {
                set { SetLowerBound(value); }
        }
        
        /// <summary>	
        /// <p>Sets the upper bound (ceiling) for the value of the animation variable. The value of the animation variable should not rise above the specified value.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::SetUpperBound']/*"/>	
        /// <msdn-id>hh448654</msdn-id>	
        /// <unmanaged>SetUpperBound</unmanaged>	
        /// <unmanaged-short>SetUpperBound</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetUpperBound([In] double bound)</unmanaged>
        public double UpperBound {
                set { SetUpperBound(value); }
        }
        
        /// <summary>	
        /// <p>Sets the rounding mode of the animation variable.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> An animation variable's rounding mode determines how a floating-point value is converted to an integer. The default mode for each variable is <strong><see cref="SharpDX.Animation.RoundingMode.RoundingNearest"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::SetRoundingMode']/*"/>	
        /// <msdn-id>hh448652</msdn-id>	
        /// <unmanaged>SetRoundingMode</unmanaged>	
        /// <unmanaged-short>SetRoundingMode</unmanaged-short>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetRoundingMode([In] UI_ANIMATION_ROUNDING_MODE mode)</unmanaged>
        public SharpDX.Animation.RoundingMode RoundingMode {
                set { SetRoundingMode(value); }
        }
        
        /// <summary>	
        /// <p>Gets the number of dimensions that the animation variable is to be animated in.</p>	
        /// </summary>	
        /// <param name="dimension"><dd> <p>The number of dimensions.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetDimension']/*"/>	
        /// <msdn-id>hh448635</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetDimension([Out] unsigned int* dimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetDimension</unmanaged-short>	
        internal void GetDimension(out int dimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dimension_ = &dimension)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, dimension_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the value of the animation variable.</p>	
        /// </summary>	
        /// <param name="value"><dd> <p>The value of the animation variable.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetValue']/*"/>	
        /// <msdn-id>hh448647</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetValue([Out] double* value)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetValue</unmanaged-short>	
        internal void GetValue(out double value) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* value_ = &value)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, value_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="value">No documentation.</param>	
        /// <param name="cDimension">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetVectorValue']/*"/>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetVectorValue([Out, Buffer] double* value,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetVectorValue</unmanaged-short>	
        public void GetVectorValue(double[] value, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* value_ = value)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, value_, cDimension,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the animation curve of the animation variable.</p>	
        /// </summary>	
        /// <param name="animation"><dd> <p>The object that generates a sequence of animation curve primitives.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The application implements the <strong><see cref="SharpDX.DirectComposition.Animation"/></strong> object that is referenced by the <em>animation</em> parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetCurve']/*"/>	
        /// <msdn-id>hh448634</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetCurve([In] IUnknown* animation)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetCurve</unmanaged-short>	
        public void GetCurve(SharpDX.ComObject animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the animation curve of the animation variable for the specified dimension.</p>	
        /// </summary>	
        /// <param name="animation"><dd> <p>The object that generates a sequence of animation curve primitives.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The number of animation curves.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The application implements the <strong><see cref="SharpDX.DirectComposition.Animation"/></strong> object that is referenced by the <em>animation</em> parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetVectorCurve']/*"/>	
        /// <msdn-id>hh448648</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetVectorCurve([In, Buffer] IUnknown** animation,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetVectorCurve</unmanaged-short>	
        public void GetVectorCurve(SharpDX.ComObject[] animation, int cDimension) {
            unsafe {
                IntPtr* animation_ = (IntPtr*)0;
                if ( animation != null ) {
                    IntPtr* animation__ = stackalloc IntPtr[animation.Length];
                    animation_ = animation__;
                    for (int i = 0; i < animation.Length; i++)                        
                        animation_[i] =  (animation[i] == null)? IntPtr.Zero : animation[i].NativePointer;
                }
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, animation_, cDimension,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the animation curve of the animation variable for the specified dimension.</p>	
        /// </summary>	
        /// <param name="animation"><dd> <p>The object that generates a sequence of animation curve primitives.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The number of animation curves.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The application implements the <strong><see cref="SharpDX.DirectComposition.Animation"/></strong> object that is referenced by the <em>animation</em> parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetVectorCurve']/*"/>	
        /// <msdn-id>hh448648</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetVectorCurve([In, Buffer] IUnknown** animation,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetVectorCurve</unmanaged-short>	
        public void GetVectorCurve(SharpDX.ComArray<SharpDX.ComObject> animation, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer), cDimension,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the animation curve of the animation variable for the specified dimension.</p>	
        /// </summary>	
        /// <param name="animation"><dd> <p>The object that generates a sequence of animation curve primitives.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The number of animation curves.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The application implements the <strong><see cref="SharpDX.DirectComposition.Animation"/></strong> object that is referenced by the <em>animation</em> parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetVectorCurve']/*"/>	
        /// <msdn-id>hh448648</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetVectorCurve([In, Buffer] IUnknown** animation,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetVectorCurve</unmanaged-short>	
        private void GetVectorCurve(System.IntPtr animation, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)animation, cDimension,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the final value of the animation variable. This is the value after all currently scheduled animations have completed.</p>	
        /// </summary>	
        /// <param name="finalValue"><dd> <p>The final value of the animation variable.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetFinalValue']/*"/>	
        /// <msdn-id>hh448638</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetFinalValue([Out] double* finalValue)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetFinalValue</unmanaged-short>	
        internal void GetFinalValue(out double finalValue) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* finalValue_ = &finalValue)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, finalValue_,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the final value of the animation variable for the specified dimension. This is the value after all currently scheduled animations have completed.</p>	
        /// </summary>	
        /// <param name="finalValue"><dd> <p>The final value of the animation variable.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The dimension from which to get the value of the animation variable.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetFinalVectorValue']/*"/>	
        /// <msdn-id>hh448639</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetFinalVectorValue([Out, Buffer] double* finalValue,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetFinalVectorValue</unmanaged-short>	
        public void GetFinalVectorValue(double[] finalValue, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* finalValue_ = finalValue)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, finalValue_, cDimension,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the previous value of the animation variable. This is the value of the animation variable before the most recent update.</p>	
        /// </summary>	
        /// <param name="reviousValueRef"><dd> <p>The previous value of the animation variable.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetPreviousValue']/*"/>	
        /// <msdn-id>hh448644</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetPreviousValue([Out] double* previousValue)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetPreviousValue</unmanaged-short>	
        internal void GetPreviousValue(out double reviousValueRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* reviousValueRef_ = &reviousValueRef)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, reviousValueRef_,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the previous value of the animation variable for the specified dimension. This is the value of the animation variable before the most recent update.</p>	
        /// </summary>	
        /// <param name="reviousValueRef"><dd> <p>The previous value of the animation variable.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The dimension from which to get the value of the animation variable.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetPreviousVectorValue']/*"/>	
        /// <msdn-id>hh448645</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetPreviousVectorValue([Out, Buffer] double* previousValue,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetPreviousVectorValue</unmanaged-short>	
        public void GetPreviousVectorValue(double[] reviousValueRef, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* reviousValueRef_ = reviousValueRef)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, reviousValueRef_, cDimension,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the integer value of the animation variable.</p>	
        /// </summary>	
        /// <param name="value"><dd> <p>The value of the animation variable as an integer.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetIntegerValue']/*"/>	
        /// <msdn-id>hh448640</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetIntegerValue([Out] int* value)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetIntegerValue</unmanaged-short>	
        internal void GetIntegerValue(out int value) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* value_ = &value)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, value_,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the integer value of the animation variable for the specified dimension.</p>	
        /// </summary>	
        /// <param name="value"><dd> <p>The value of the animation variable as an integer.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The dimension from which to get the value of the animation variable.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetIntegerVectorValue']/*"/>	
        /// <msdn-id>hh448641</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetIntegerVectorValue([Out, Buffer] int* value,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetIntegerVectorValue</unmanaged-short>	
        public void GetIntegerVectorValue(int[] value, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* value_ = value)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, value_, cDimension,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the final integer value of the animation variable. This is the value after all currently scheduled animations have completed.</p>	
        /// </summary>	
        /// <param name="finalValue"><dd> <p>The final value of the animation variable as an integer.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetFinalIntegerValue']/*"/>	
        /// <msdn-id>hh448636</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetFinalIntegerValue([Out] int* finalValue)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetFinalIntegerValue</unmanaged-short>	
        internal void GetFinalIntegerValue(out int finalValue) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* finalValue_ = &finalValue)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, finalValue_,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the final integer value of the animation variable for the specified dimension. This is the value after all currently scheduled animations have completed.</p>	
        /// </summary>	
        /// <param name="finalValue"><dd> <p>The final value of the animation variable as an integer.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The dimension from which to get the value of the animation variable.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetFinalIntegerVectorValue']/*"/>	
        /// <msdn-id>hh448637</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetFinalIntegerVectorValue([Out, Buffer] int* finalValue,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetFinalIntegerVectorValue</unmanaged-short>	
        public void GetFinalIntegerVectorValue(int[] finalValue, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* finalValue_ = finalValue)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, finalValue_, cDimension,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the previous integer value of the animation variable in the specified dimension. This is the value of the animation variable before the most recent update.</p>	
        /// </summary>	
        /// <param name="reviousValueRef"><dd> <p>The previous value of the animation variable as an integer.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetPreviousIntegerValue']/*"/>	
        /// <msdn-id>hh448642</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetPreviousIntegerValue([Out] int* previousValue)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetPreviousIntegerValue</unmanaged-short>	
        internal void GetPreviousIntegerValue(out int reviousValueRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* reviousValueRef_ = &reviousValueRef)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, reviousValueRef_,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the previous integer value of the animation variable for the specified dimension. This is the value of the animation variable before the most recent update.</p>	
        /// </summary>	
        /// <param name="reviousValueRef"><dd> <p>The previous value of the animation variable as an integer.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The dimension from which to get the value of the animation variable.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetPreviousIntegerVectorValue']/*"/>	
        /// <msdn-id>hh448643</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetPreviousIntegerVectorValue([Out, Buffer] int* previousValue,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetPreviousIntegerVectorValue</unmanaged-short>	
        public void GetPreviousIntegerVectorValue(int[] reviousValueRef, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* reviousValueRef_ = reviousValueRef)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, reviousValueRef_, cDimension,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the active storyboard for the animation variable.</p>	
        /// </summary>	
        /// <param name="storyboard"><dd> <p>The active storyboard, or <c>null</c> if the animation variable is not being animated.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetCurrentStoryboard']/*"/>	
        /// <msdn-id>hh448633</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetCurrentStoryboard([Out] IUIAnimationStoryboard2** storyboard)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetCurrentStoryboard</unmanaged-short>	
        internal void GetCurrentStoryboard(out SharpDX.Animation.Storyboard2 storyboard) {
            unsafe {
                IntPtr storyboard_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, &storyboard_,((void**)(*(void**)_nativePointer))[18]);		
                storyboard= (storyboard_ == IntPtr.Zero)?null:new SharpDX.Animation.Storyboard2(storyboard_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the lower bound (floor) for the value of the animation variable. The value of the animation variable should not fall below the specified value.</p>	
        /// </summary>	
        /// <param name="bound"><dd> <p>The lower bound for the value of the animation variable.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::SetLowerBound']/*"/>	
        /// <msdn-id>hh448650</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetLowerBound([In] double bound)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::SetLowerBound</unmanaged-short>	
        internal void SetLowerBound(double bound) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, bound,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the lower bound (floor) value of each specified dimension for the animation variable. The value of each animation variable should not fall below its lower bound.</p>	
        /// </summary>	
        /// <param name="bound"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the lower bound values of each dimension.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The number of dimensions that require lower bound values. This parameter specifies the number of values listed in <em>bound</em>.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::SetLowerBoundVector']/*"/>	
        /// <msdn-id>hh448651</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetLowerBoundVector([In, Buffer] const double* bound,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::SetLowerBoundVector</unmanaged-short>	
        public void SetLowerBoundVector(double[] bound, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* bound_ = bound)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, bound_, cDimension,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the upper bound (ceiling) for the value of the animation variable. The value of the animation variable should not rise above the specified value.</p>	
        /// </summary>	
        /// <param name="bound"><dd> <p>The upper bound for the value of the animation variable.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::SetUpperBound']/*"/>	
        /// <msdn-id>hh448654</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetUpperBound([In] double bound)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::SetUpperBound</unmanaged-short>	
        internal void SetUpperBound(double bound) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, bound,((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the upper bound (ceiling) value of each specified dimension for the animation variable. The value of each animation variable should not rise above its upper bound.</p>	
        /// </summary>	
        /// <param name="bound"><dd> <p>A vector (of size <em>cDimension</em>) that contains  the upper bound values of each dimension.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The number of dimensions that require upper bound values. This parameter specifies the number of values listed in <em>bound</em>.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::SetUpperBoundVector']/*"/>	
        /// <msdn-id>hh448655</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetUpperBoundVector([In, Buffer] const double* bound,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::SetUpperBoundVector</unmanaged-short>	
        public void SetUpperBoundVector(double[] bound, int cDimension) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* bound_ = bound)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, bound_, cDimension,((void**)(*(void**)_nativePointer))[22]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the rounding mode of the animation variable.</p>	
        /// </summary>	
        /// <param name="mode"><dd> <p>The rounding mode.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> An animation variable's rounding mode determines how a floating-point value is converted to an integer. The default mode for each variable is <strong><see cref="SharpDX.Animation.RoundingMode.RoundingNearest"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::SetRoundingMode']/*"/>	
        /// <msdn-id>hh448652</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetRoundingMode([In] UI_ANIMATION_ROUNDING_MODE mode)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::SetRoundingMode</unmanaged-short>	
        internal void SetRoundingMode(SharpDX.Animation.RoundingMode mode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, unchecked((int)mode),((void**)(*(void**)_nativePointer))[23]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the tag of the animation variable. </p>	
        /// </summary>	
        /// <param name="@object"><dd> <p>The object portion of the tag. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="id"><dd> <p>The identifier portion of the tag. </p> </dd></param>	
        /// <returns><p>Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>), and it can be used by an application to identify an animation variable.           Because <strong><c>null</c></strong> is a valid object component of a tag, the <em>object</em> parameter can be <strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::SetTag']/*"/>	
        /// <msdn-id>hh448653</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetTag([In, Optional] IUnknown* object,[In] unsigned int id)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::SetTag</unmanaged-short>	
        public void SetTag(SharpDX.ComObject @object, int id) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)((@object == null)?IntPtr.Zero:@object.NativePointer), id,((void**)(*(void**)_nativePointer))[24]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets the tag of the animation variable.</p>	
        /// </summary>	
        /// <param name="@object"><dd> <p> The object portion of the tag.</p> </dd></param>	
        /// <param name="id"><dd> <p> The identifier portion of the tag.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A tag is a pairing of an integer identifier (<em>id</em>) with a COM object (<em>object</em>); it can be used by an application to identify an animation variable.</p><p>The parameters are optional, so that the method can return both portions of the tag, or just the identifier or object portion.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::GetTag']/*"/>	
        /// <msdn-id>hh448646</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::GetTag([Out, Optional] IUnknown** object,[Out, Optional] unsigned int* id)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::GetTag</unmanaged-short>	
        public void GetTag(out SharpDX.ComObject @object, out int id) {
            unsafe {
                IntPtr @object_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* id_ = &id)
                    __result__= 
    				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, &@object_, id_,((void**)(*(void**)_nativePointer))[25]);		
                @object= (@object_ == IntPtr.Zero)?null:new SharpDX.ComObject(@object_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies a handler for changes to the value of the animation variable. </p>	
        /// </summary>	
        /// <param name="handler"><dd> <p>The handler for changes to the value of the animation variable. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="fRegisterForNextAnimationEvent"><dd> <p>If <strong>TRUE</strong>, specifies that the <strong>EstimateNextEventTime</strong> method will incorporate <em>handler</em> into its estimate of the time interval until the next animation event. No default value.</p> </dd></param>	
        /// <returns><p>Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong><see cref="SharpDX.Animation.Manager2.Shutdown"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::SetVariableChangeHandler']/*"/>	
        /// <msdn-id>hh448656</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetVariableChangeHandler([In, Optional] IUIAnimationVariableChangeHandler2* handler,[In] BOOL fRegisterForNextAnimationEvent)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::SetVariableChangeHandler</unmanaged-short>	
        internal void SetVariableChangeHandler_(System.IntPtr handler, SharpDX.Mathematics.Interop.RawBool fRegisterForNextAnimationEvent) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint22(_nativePointer, (void*)handler, fRegisterForNextAnimationEvent,((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies a handler for changes to the integer value of the animation variable. </p>	
        /// </summary>	
        /// <param name="handler"><dd> <p>A reference to the handler for changes to the integer value of the animation variable. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="fRegisterForNextAnimationEvent"><dd> <p>If <strong>TRUE</strong>, specifies that the <strong>EstimateNextEventTime</strong> method will incorporate <em>handler</em> into its estimate of the time interval until the next animation event. No default value.</p> </dd></param>	
        /// <returns><p>Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Passing <strong><c>null</c></strong> for the <em>handler</em> parameter causes Windows Animation to release its reference to any handler object that you passed in earlier. This technique can be essential for breaking reference cycles without having to call the <strong>Shutdown</strong> method.</p><p> <strong><see cref="SharpDX.Animation.VariableIntegerChangeHandler2.OnIntegerValueChanged"/></strong> is called only if the rounded value has changed since the last update.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::SetVariableIntegerChangeHandler']/*"/>	
        /// <msdn-id>hh448658</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetVariableIntegerChangeHandler([In, Optional] IUIAnimationVariableIntegerChangeHandler2* handler,[In] BOOL fRegisterForNextAnimationEvent)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::SetVariableIntegerChangeHandler</unmanaged-short>	
        internal void SetVariableIntegerChangeHandler_(System.IntPtr handler, SharpDX.Mathematics.Interop.RawBool fRegisterForNextAnimationEvent) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint22(_nativePointer, (void*)handler, fRegisterForNextAnimationEvent,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies a handler for changes to the animation curve of the animation variable. </p>	
        /// </summary>	
        /// <param name="handler"><dd> <p>A reference to the handler for changes to the animation curve of the animation variable. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariable2::SetVariableCurveChangeHandler']/*"/>	
        /// <msdn-id>hh448657</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariable2::SetVariableCurveChangeHandler([In, Optional] IUIAnimationVariableCurveChangeHandler2* handler)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariable2::SetVariableCurveChangeHandler</unmanaged-short>	
        internal void SetVariableCurveChangeHandler_(System.IntPtr handler) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Animation.LocalInterop.Calliint(_nativePointer, (void*)handler,((void**)(*(void**)_nativePointer))[28]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Defines a method for handling events related to animation variable updates.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> <strong> OnValueChanged</strong> receives animation variable value updates as  <strong>DOUBLE</strong> values. To receive value updates as <strong>INT32</strong> values, use <strong><see cref="SharpDX.Animation.VariableIntegerChangeHandler.OnIntegerValueChanged"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariableChangeHandler']/*"/>	
    /// <msdn-id>dd316806</msdn-id>	
    /// <unmanaged>IUIAnimationVariableChangeHandler</unmanaged>	
    /// <unmanaged-short>IUIAnimationVariableChangeHandler</unmanaged-short>	
    [Guid("6358B7BA-87D2-42d5-BF71-82E919DD5862")]
    internal partial interface VariableChangeHandler : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p> Handles events that occur when the value of an animation variable changes.</p><p>This method receives updates as <strong>DOUBLE</strong> values.   To receive updates as <strong>INT32</strong> values, use the <strong> <see cref="SharpDX.Animation.VariableIntegerChangeHandler.OnIntegerValueChanged"/></strong> method.</p>	
        /// </summary>	
        /// <param name="storyboard">No documentation.</param>	
        /// <param name="variable">No documentation.</param>	
        /// <param name="newValue">No documentation.</param>	
        /// <param name="previousValue">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>By default, a call made in a callback method to any other animation method results in the call failing and returning <strong>UI_E_ILLEGAL_REENTRANCY</strong>. However, there are exceptions to this default. The following methods can be successfully called from <strong>OnValueChanged</strong>:</p><ul> <li> <strong><see cref="SharpDX.Animation.Variable.GetValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetFinalValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetPreviousValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetIntegerValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetFinalIntegerValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetPreviousIntegerValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetCurrentStoryboard"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager.GetVariableFromTag"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager.GetStoryboardFromTag"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.GetTag"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetTag"/>	
        /// </strong> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariableChangeHandler::OnValueChanged']/*"/>	
        /// <msdn-id>dd756730</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariableChangeHandler::OnValueChanged([In] IUIAnimationStoryboard* storyboard,[In] IUIAnimationVariable* variable,[In] double newValue,[In] double previousValue)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariableChangeHandler::OnValueChanged</unmanaged-short>	
        /* public void OnValueChanged(SharpDX.Animation.Storyboard storyboard, SharpDX.Animation.Variable variable, double newValue, double previousValue) */
    }
    /// <summary>	
    /// <p>Defines a method for handling animation variable update events. <strong><see cref="SharpDX.Animation.VariableChangeHandler2"/></strong> handles events that occur in a specified dimension.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> The <strong> OnValueChanged</strong> method receives animation variable value updates as  <strong>DOUBLE</strong> values. To receive value updates as <strong>INT32</strong> values, use the <strong><see cref="SharpDX.Animation.VariableIntegerChangeHandler2.OnIntegerValueChanged"/></strong> method.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariableChangeHandler2']/*"/>	
    /// <msdn-id>hh448659</msdn-id>	
    /// <unmanaged>IUIAnimationVariableChangeHandler2</unmanaged>	
    /// <unmanaged-short>IUIAnimationVariableChangeHandler2</unmanaged-short>	
    [Guid("63ACC8D2-6EAE-4bb0-B879-586DD8CFBE42")]
    internal partial interface VariableChangeHandler2 : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p> Handles events that occur when the value of an animation variable changes in the specified dimension.</p>	
        /// </summary>	
        /// <param name="storyboard"><dd> <p>The storyboard that is animating the animation variable specified by the <em>variable</em> parameter.</p> </dd></param>	
        /// <param name="variable"><dd> <p>The animation variable that has been updated.</p> </dd></param>	
        /// <param name="newValue"><dd> <p>The new value of the animation variable.</p> </dd></param>	
        /// <param name="reviousValueRef"><dd> <p>The previous value of the animation variable.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The dimension in which the value of the animation variable changed.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method receives updates as <strong>DOUBLE</strong> values.   To receive updates as <strong>INT32</strong> values, use the <strong> <see cref="SharpDX.Animation.VariableIntegerChangeHandler2.OnIntegerValueChanged"/></strong> method.</p><p>By default, a call made in a callback method to any other animation method results in the call failing and returning <strong>UI_E_ILLEGAL_REENTRANCY</strong>. However, there are exceptions to this default. The following methods can be successfully called from <strong><see cref="SharpDX.Animation.VariableChangeHandler2.OnValueChanged"/></strong>:</p><ul> <li> <strong><see cref="SharpDX.Animation.Variable2.GetValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetFinalValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetPreviousValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetIntegerValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetFinalIntegerValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetPreviousIntegerValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetCurrentStoryboard"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable2.GetTag"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager2.GetVariableFromTag"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager2.GetStoryboardFromTag"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard2.GetTag"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetFinalValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetPreviousValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetIntegerValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetFinalIntegerValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetPreviousIntegerValue"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetCurrentStoryboard"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetTag"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager.GetVariableFromTag"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager.GetStoryboardFromTag"/>	
        /// </strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.GetTag"/>	
        /// </strong> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariableChangeHandler2::OnValueChanged']/*"/>	
        /// <msdn-id>hh448660</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariableChangeHandler2::OnValueChanged([In] IUIAnimationStoryboard2* storyboard,[In] IUIAnimationVariable2* variable,[In, Buffer] double* newValue,[In, Buffer] double* previousValue,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariableChangeHandler2::OnValueChanged</unmanaged-short>	
        /* public void OnValueChanged(SharpDX.Animation.Storyboard2 storyboard, SharpDX.Animation.Variable2 variable, double[] newValue, double[] reviousValueRef, int cDimension) */
    }
    /// <summary>	
    /// <p>Defines a method for handling animation curve update events. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariableCurveChangeHandler2']/*"/>	
    /// <msdn-id>hh448661</msdn-id>	
    /// <unmanaged>IUIAnimationVariableCurveChangeHandler2</unmanaged>	
    /// <unmanaged-short>IUIAnimationVariableCurveChangeHandler2</unmanaged-short>	
    [Guid("72895E91-0145-4C21-9192-5AAB40EDDF80")]
    internal partial interface VariableCurveChangeHandler2 : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p> Handles events that occur when the animation curve of an animation variable changes.</p>	
        /// </summary>	
        /// <param name="variable"><dd> <p>The animation variable for which the animation curve has been updated.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariableCurveChangeHandler2::OnCurveChanged']/*"/>	
        /// <msdn-id>hh448662</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariableCurveChangeHandler2::OnCurveChanged([In] IUIAnimationVariable2* variable)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariableCurveChangeHandler2::OnCurveChanged</unmanaged-short>	
        /* public void OnCurveChanged(SharpDX.Animation.Variable2 variable) */
    }
    /// <summary>	
    /// <p> Defines a method for handling animation variable update events.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> <strong> OnIntegerValueChanged</strong> receives animation variable value updates as <strong>INT32</strong> values. To receive value updates as <strong>DOUBLE</strong> values, use the <strong><see cref="SharpDX.Animation.VariableChangeHandler.OnValueChanged"/></strong> method.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariableIntegerChangeHandler']/*"/>	
    /// <msdn-id>dd316819</msdn-id>	
    /// <unmanaged>IUIAnimationVariableIntegerChangeHandler</unmanaged>	
    /// <unmanaged-short>IUIAnimationVariableIntegerChangeHandler</unmanaged-short>	
    [Guid("BB3E1550-356E-44b0-99DA-85AC6017865E")]
    internal partial interface VariableIntegerChangeHandler : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p> Handles events that occur when the value of an animation variable changes.</p><p>This method receives updates as <strong>INT32</strong> values. To receive updates as <strong>DOUBLE</strong> values, use the <strong><see cref="SharpDX.Animation.VariableChangeHandler.OnValueChanged"/></strong> method.</p>	
        /// </summary>	
        /// <param name="storyboard">No documentation.</param>	
        /// <param name="variable">No documentation.</param>	
        /// <param name="newValue">No documentation.</param>	
        /// <param name="previousValue">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The rounding mode for an animation variable is specified using the <strong><see cref="SharpDX.Animation.Variable.SetRoundingMode"/></strong> method.</p><p><strong>OnIntegerValueChanged</strong> events might occur less frequently than <strong>OnValueChanged</strong> events because values such as 2.2, 2.3, 2.4 would all be rounded to the same integer.</p><p>By default, a call made in a callback method to any other animation method results in the call failing and returning <strong>UI_E_ILLEGAL_REENTRANCY</strong>. However, there are exceptions to this default. The following methods can be successfully called from <strong>OnIntegerValueChanged</strong>:</p><ul> <li> <strong><see cref="SharpDX.Animation.Variable.GetCurrentStoryboard"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetFinalIntegerValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetFinalValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetIntegerValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetPreviousIntegerValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetPreviousValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetValue"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager.GetStoryboardFromTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Manager.GetVariableFromTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Storyboard.GetTag"/></strong> </li> <li> <strong><see cref="SharpDX.Animation.Variable.GetTag"/></strong> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariableIntegerChangeHandler::OnIntegerValueChanged']/*"/>	
        /// <msdn-id>dd756731</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariableIntegerChangeHandler::OnIntegerValueChanged([In] IUIAnimationStoryboard* storyboard,[In] IUIAnimationVariable* variable,[In] int newValue,[In] int previousValue)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariableIntegerChangeHandler::OnIntegerValueChanged</unmanaged-short>	
        /* public void OnIntegerValueChanged(SharpDX.Animation.Storyboard storyboard, SharpDX.Animation.Variable variable, int newValue, int previousValue) */
    }
    /// <summary>	
    /// <p>Defines a method for handling animation variable update events. <strong><see cref="SharpDX.Animation.VariableIntegerChangeHandler2"/></strong> handles events that occur in a specified dimension.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariableIntegerChangeHandler2']/*"/>	
    /// <msdn-id>hh448663</msdn-id>	
    /// <unmanaged>IUIAnimationVariableIntegerChangeHandler2</unmanaged>	
    /// <unmanaged-short>IUIAnimationVariableIntegerChangeHandler2</unmanaged-short>	
    [Guid("829B6CF1-4F3A-4412-AE09-B243EB4C6B58")]
    internal partial interface VariableIntegerChangeHandler2 : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p> Handles events that occur when the integer value of an animation variable changes in the specified dimension.</p>	
        /// </summary>	
        /// <param name="storyboard"><dd> <p>The storyboard that is animating the animation variable specified by the <em>variable</em> parameter.</p> </dd></param>	
        /// <param name="variable"><dd> <p>The animation variable that has been updated.</p> </dd></param>	
        /// <param name="newValue"><dd> <p>The new integer value of the animation variable.</p> <p><strong>Note</strong>??The rounding mode for an animation variable is specified using the <strong>SetRoundingMode</strong> method.</p> </dd></param>	
        /// <param name="reviousValueRef"><dd> <p>The previous integer value of the animation variable.</p> <p><strong>Note</strong>??The rounding mode for an animation variable is specified using the <strong>SetRoundingMode</strong> method.</p> </dd></param>	
        /// <param name="cDimension"><dd> <p>The dimension in which the integer value of the animation variable changed.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an  <strong><see cref="SharpDX.Result"/></strong> error code. See <strong>Windows Animation Error Codes</strong> for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method receives updates as <strong>INT32</strong> values.   To receive updates as <strong>DOUBLE</strong> values, use the <strong>OnValueChanged</strong> method.</p><p><strong>OnIntegerValueChanged</strong> events might occur less frequently than <strong>OnValueChanged</strong> events because values such as 2.2, 2.3, and 2.4 would all be rounded to the same integer.</p><p>By default, a call made in a callback method to any other animation method results in the call failing and returning <strong>UI_E_ILLEGAL_REENTRANCY</strong>. However, there are exceptions to this default. The following methods can be successfully called from <strong>OnIntegerValueChanged</strong>:</p><ul> <li> <strong>GetValue</strong> </li> <li> <strong>GetFinalValue</strong> </li> <li> <strong>GetPreviousValue</strong> </li> <li> <strong>GetIntegerValue</strong> </li> <li> <strong>GetFinalIntegerValue</strong> </li> <li> <strong>GetPreviousIntegerValue</strong> </li> <li> <strong>GetCurrentStoryboard</strong> </li> <li> <strong>GetVariableFromTag</strong> </li> <li> <strong>GetStoryboardFromTag</strong> </li> <li> <strong>GetTag</strong> </li> <li> <strong>GetTag</strong> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IUIAnimationVariableIntegerChangeHandler2::OnIntegerValueChanged']/*"/>	
        /// <msdn-id>hh448664</msdn-id>	
        /// <unmanaged>HRESULT IUIAnimationVariableIntegerChangeHandler2::OnIntegerValueChanged([In] IUIAnimationStoryboard2* storyboard,[In] IUIAnimationVariable2* variable,[In, Buffer] int* newValue,[In, Buffer] int* previousValue,[In] unsigned int cDimension)</unmanaged>	
        /// <unmanaged-short>IUIAnimationVariableIntegerChangeHandler2::OnIntegerValueChanged</unmanaged-short>	
        /* public void OnIntegerValueChanged(SharpDX.Animation.Storyboard2 storyboard, SharpDX.Animation.Variable2 variable, int[] newValue, int[] reviousValueRef, int cDimension) */
    }
}
