// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.XAudio2 namespace.
//     This code was generated by a tool.
//     Date : 6/25/2016 10:38:12 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.XAudio2 {

// Disable warning : XML comment is not placed on a valid language element
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
    /// <summary>	
    /// <p>The <see cref="SharpDX.XAudio2.EngineCallback"/> interface contains methods that notify the client when certain events happen in the <strong><see cref="SharpDX.XAudio2.XAudio2"/></strong> engine.</p><p>This interface should be implemented by the XAudio2 client. XAudio2 calls these methods via an interface reference provided by the client, using the <strong>XAudio2Create</strong> method. Methods in this interface return <strong>void</strong>, rather than an <see cref="SharpDX.Result"/>. 	
    /// </p><p>See XAudio2 Callbacks for restrictions on callback implementation.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2EngineCallback']/*"/>	
    /// <msdn-id>microsoft.directx_sdk.ixaudio2enginecallback.ixaudio2enginecallback</msdn-id>	
    /// <unmanaged>IXAudio2EngineCallback</unmanaged>	
    /// <unmanaged-short>IXAudio2EngineCallback</unmanaged-short>	
    internal partial interface EngineCallback : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p>Called by XAudio2 just before an audio processing pass begins.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2EngineCallback::OnProcessingPassStart']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2enginecallback.ixaudio2enginecallback.onprocessingpassstart</msdn-id>	
        /// <unmanaged>void IXAudio2EngineCallback::OnProcessingPassStart()</unmanaged>	
        /// <unmanaged-short>IXAudio2EngineCallback::OnProcessingPassStart</unmanaged-short>	
        /* public void OnProcessingPassStart() */
        
        /// <summary>	
        /// <p>Called by XAudio2 just after an audio processing pass ends.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>For information about the <strong><see cref="SharpDX.XAudio2.EngineCallback"/></strong> interface methods, see the XAudio2 Callbacks section.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2EngineCallback::OnProcessingPassEnd']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2enginecallback.ixaudio2enginecallback.onprocessingpassend</msdn-id>	
        /// <unmanaged>void IXAudio2EngineCallback::OnProcessingPassEnd()</unmanaged>	
        /// <unmanaged-short>IXAudio2EngineCallback::OnProcessingPassEnd</unmanaged-short>	
        /* public void OnProcessingPassEnd() */
        
        /// <summary>	
        /// <p>Called if a critical system error occurs that requires XAudio2 to be closed down and restarted.</p><p> </p><p><strong>Note</strong>??A critical error can happen when the underlying WASAPI rendering object is no longer available, such as when a headset or speaker are unplugged, a USB audio device is removed, and so on. The entire audio graph must be destroyed, audio device re-enumerated, and a new audio graph created since the various channel counts and formats could have changed.</p>	
        /// </summary>	
        /// <param name="error"><dd> <p>Error code returned by XAudio2.</p> </dd></param>	
        /// <remarks>	
        /// <p>Once a critical error has occurred, audio processing stops and all further calls to XAudio2 fail. The only way to recover in this situation is to release the XAudio2 instance and create a new one. </p><p>For information about the <strong><see cref="SharpDX.XAudio2.EngineCallback"/></strong> interface methods, see the XAudio2 Callbacks section.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2EngineCallback::OnCriticalError']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2enginecallback.ixaudio2enginecallback.oncriticalerror</msdn-id>	
        /// <unmanaged>void IXAudio2EngineCallback::OnCriticalError([In] HRESULT Error)</unmanaged>	
        /// <unmanaged-short>IXAudio2EngineCallback::OnCriticalError</unmanaged-short>	
        /* public void OnCriticalError(SharpDX.Result error) */
    }
    /// <summary>	
    /// <p>A mastering voice is used to represent the audio output device.</p><p>Data buffers cannot be submitted directly to mastering voices, but data submitted to other types of voices must be directed to a mastering voice to be heard. 	
    /// </p><p><strong><see cref="SharpDX.XAudio2.MasteringVoice"/></strong> inherits directly from <strong><see cref="SharpDX.XAudio2.Voice"/></strong>, but does not implement methods specific to mastering voices. The interface type exists solely because some of the base class methods are implemented differently for mastering voices. Having a separate type for these voices helps client code to distinguish the different voice types and to benefit from C++ type safety.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2MasteringVoice']/*"/>	
    /// <msdn-id>microsoft.directx_sdk.ixaudio2masteringvoice.ixaudio2masteringvoice</msdn-id>	
    /// <unmanaged>IXAudio2MasteringVoice</unmanaged>	
    /// <unmanaged-short>IXAudio2MasteringVoice</unmanaged-short>	
    public partial class MasteringVoice : SharpDX.XAudio2.Voice {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.XAudio2.MasteringVoice"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MasteringVoice(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.XAudio2.MasteringVoice"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.XAudio2.MasteringVoice(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.XAudio2.MasteringVoice(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Returns the channel mask for this voice.</p>	
        /// </summary>	
        /// <param name="channelmaskRef"><dd> <p> Returns the channel mask for this voice. This corresponds to the <strong>dwChannelMask</strong> member of the  <strong><see cref="SharpDX.Multimedia.WaveFormatExtensible"/></strong> structure. </p> </dd></param>	
        /// <returns><p>This method does not return a value.</p></returns>	
        /// <remarks>	
        /// <p>The <em>pChannelMask</em> argument is a bit-mask of the various channels in the speaker geometry reported by the audio system. This information is needed for the <strong>X3DAudioInitialize</strong> <em>SpeakerChannelMask</em> parameter. </p><p>The X3DAUDIO.H header declares a number of <strong>SPEAKER_</strong> positional defines to decode these channels masks. </p><p>Examples include: </p><pre><see cref="SharpDX.Multimedia.Speakers.Stereo"/> // <see cref="SharpDX.Multimedia.Speakers.FrontLeft"/> (0x1) | <see cref="SharpDX.Multimedia.Speakers.FrontRight"/> (0x2)  <see cref="SharpDX.Multimedia.Speakers.FivePointOne"/> // <see cref="SharpDX.Multimedia.Speakers.FrontLeft"/> (0x1) | <see cref="SharpDX.Multimedia.Speakers.FrontRight"/> (0x2) // | <see cref="SharpDX.Multimedia.Speakers.FrontCenter"/> (0x4) // | <see cref="SharpDX.Multimedia.Speakers.LowFrequency"/> (0x8) // | <see cref="SharpDX.Multimedia.Speakers.BackLeft"/> (0x10) | <see cref="SharpDX.Multimedia.Speakers.BackRight"/> (0x20)</pre><p><strong>Note</strong>??For the DirectX SDK versions of XAUDIO, the channel mask for the output device was obtained via the <strong>IXAudio2::GetDeviceDetails</strong> method, which doesn't exist in Windows?8 and later.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2MasteringVoice::GetChannelMask']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2masteringvoice.ixaudio2masteringvoice.getchannelmask</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2MasteringVoice::GetChannelMask([Out] unsigned int* pChannelmask)</unmanaged>	
        /// <unmanaged-short>IXAudio2MasteringVoice::GetChannelMask</unmanaged-short>	
        public void GetChannelMask(out int channelmaskRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* channelmaskRef_ = &channelmaskRef)
                    __result__= 
    				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, channelmaskRef_,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Use a source voice to submit audio data to the XAudio2 processing pipeline.You must send voice data to a mastering voice to be heard, either directly or through intermediate submix voices. 	
    /// </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2SourceVoice']/*"/>	
    /// <msdn-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice</msdn-id>	
    /// <unmanaged>IXAudio2SourceVoice</unmanaged>	
    /// <unmanaged-short>IXAudio2SourceVoice</unmanaged-short>	
    public partial class SourceVoice : SharpDX.XAudio2.Voice {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.XAudio2.SourceVoice"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SourceVoice(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.XAudio2.SourceVoice"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.XAudio2.SourceVoice(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.XAudio2.SourceVoice(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Returns the frequency adjustment ratio of the voice.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p><strong>GetFrequencyRatio</strong> always returns the voice's actual current frequency ratio. However, this may not match the ratio set by the most recent <strong><see cref="SharpDX.XAudio2.SourceVoice.SetFrequencyRatio"/></strong> call: the actual ratio is only changed the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.SourceVoice.SetFrequencyRatio"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.SourceVoice.SetFrequencyRatio"/></strong> was called with a deferred operation ID). </p><p>For information on frequency ratios, see <strong><see cref="SharpDX.XAudio2.SourceVoice.SetFrequencyRatio"/></strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2SourceVoice::GetFrequencyRatio']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.getfrequencyratio</msdn-id>	
        /// <unmanaged>GetFrequencyRatio</unmanaged>	
        /// <unmanaged-short>GetFrequencyRatio</unmanaged-short>	
        /// <unmanaged>void IXAudio2SourceVoice::GetFrequencyRatio([Out] float* pRatio)</unmanaged>
        public float FrequencyRatio {
                get { float __output__; GetFrequencyRatio(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Reconfigures the voice to consume source data at a different sample rate than the rate specified when the voice was created.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The <strong>SetSourceSampleRate</strong> method supports reuse of XAudio2 voices by allowing a voice to play sounds with a variety of sample rates. To use <strong>SetSourceSampleRate</strong> the voice must have been created without the <see cref="SharpDX.XAudio2.VoiceFlags.NoPitch"/> or <see cref="SharpDX.XAudio2.VoiceFlags.NoSampleRateConversion"/> flags and must not have any buffers currently queued. </p><p>The typical use of <strong>SetSourceSampleRate</strong> is to support voice pooling. For example to support voice pooling an application would precreate all the voices it expects to use. Whenever a new sound will be played the application chooses an inactive voice or ,if all voices are busy, picks the least important voice and calls <strong>SetSourceSampleRate</strong> on the voice with the new sound's sample rate. After <strong>SetSourceSampleRate</strong> has been called on the voice, the application can immediately start submitting and playing buffers with the new sample rate. This allows the application to avoid the overhead of creating and destroying voices frequently during gameplay.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2SourceVoice::SetSourceSampleRate']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.setsourcesamplerate</msdn-id>	
        /// <unmanaged>SetSourceSampleRate</unmanaged>	
        /// <unmanaged-short>SetSourceSampleRate</unmanaged-short>	
        /// <unmanaged>HRESULT IXAudio2SourceVoice::SetSourceSampleRate([In] unsigned int NewSourceSampleRate)</unmanaged>
        public int SourceSampleRate {
                set { SetSourceSampleRate(value); }
        }
        
        /// <summary>	
        /// <p>Starts consumption and processing of audio by the voice. Delivers the result to any connected submix or mastering voices, or to the output device.</p>	
        /// </summary>	
        /// <param name="flags"><dd> <p>Flags that control how the voice is started. Must be 0.</p> </dd></param>	
        /// <param name="operationSet"><dd> <p> Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>	
        /// <remarks>	
        /// <p>If the XAudio2 engine is stopped, the voice stops running. However, it remains in the started state, so that it starts running again as soon as the engine starts. </p><p>When first created, source voices are in the stopped state. Submix and mastering voices are in the started state. </p><p>After <strong>Start</strong> is called it has no further effect if called again before <strong><see cref="SharpDX.XAudio2.SourceVoice.Stop"/></strong> is called. In addition multiple calls to <strong>Start</strong> without matching calls to <strong><see cref="SharpDX.XAudio2.SourceVoice.Stop"/></strong> will result in warning messages in debug builds.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2SourceVoice::Start']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.start</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2SourceVoice::Start([In] unsigned int Flags,[In] unsigned int OperationSet)</unmanaged>	
        /// <unmanaged-short>IXAudio2SourceVoice::Start</unmanaged-short>	
        internal void Start(int flags, int operationSet = 0) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, flags, operationSet,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Stops consumption of audio by the current voice.</p>	
        /// </summary>	
        /// <param name="flags"><dd> <p> Flags that control how the voice is stopped. Can be 0 or the following: </p> <table> <tr><th>Value</th><th>Description</th></tr> <tr><td><see cref="SharpDX.XAudio2.PlayFlags.Tails"/></td><td>Continue emitting effect output after the voice is stopped.?</td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>	
        /// <remarks>	
        /// <p>All source buffers that are queued on the voice and the current cursor position are preserved. This allows the voice to continue from where it left off, when it is restarted. The <strong><see cref="SharpDX.XAudio2.SourceVoice.FlushSourceBuffers"/></strong> method can be used to flush queued source buffers. </p><p>By default, any pending output from voice effects?for example, reverb tails?is not played. Instead, the voice is immediately rendered silent. The <see cref="SharpDX.XAudio2.PlayFlags.Tails"/> flag can be used to continue emitting effect output after the voice stops running. </p><p>A voice stopped with the <see cref="SharpDX.XAudio2.PlayFlags.Tails"/> flag stops consuming source buffers, but continues to process its effects and send audio to its destination voices. A voice in this state can later be stopped completely by calling <strong>Stop</strong> again with the Flags argument set to 0. This enables stopping a voice with <see cref="SharpDX.XAudio2.PlayFlags.Tails"/>, waiting sufficient time for any audio being produced by its effects to finish, and then fully stopping the voice by calling <strong>Stop</strong> again without <see cref="SharpDX.XAudio2.PlayFlags.Tails"/>. This technique allows voices with effects to be stopped gracefully while ensuring idle voices will not continue to be processed after they have finished producing audio. </p><p><strong>Stop</strong> is always asynchronous, even if called within a callback. </p><p><strong>Note</strong>??XAudio2 never calls any voice callbacks for a voice if the voice is stopped (even if it was stopped with <see cref="SharpDX.XAudio2.PlayFlags.Tails"/>).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2SourceVoice::Stop']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.stop</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2SourceVoice::Stop([In] XAUDIO2_PLAY_FLAGS Flags,[In] unsigned int OperationSet)</unmanaged>	
        /// <unmanaged-short>IXAudio2SourceVoice::Stop</unmanaged-short>	
        public void Stop(SharpDX.XAudio2.PlayFlags flags, int operationSet = 0) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, unchecked((int)flags), operationSet,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds a new audio buffer to the voice queue.</p>	
        /// </summary>	
        /// <param name="bufferRef"><dd> <p> Pointer to an <strong><see cref="SharpDX.XAudio2.AudioBuffer"/></strong> structure to queue. </p> </dd></param>	
        /// <param name="bufferWMARef"><dd> <p>Pointer to an additional <strong><see cref="SharpDX.XAudio2.BufferWma"/></strong> structure used when submitting WMA data. </p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>	
        /// <remarks>	
        /// <p>The voice processes and plays back the buffers in its queue in the order that they were submitted. </p><p>The <strong><see cref="SharpDX.XAudio2.AudioBuffer"/></strong> structure includes details about the audio buffer's location and size, the part of the buffer that should actually be played, the loop region (if any) and loop count, the context reference to be used in any callbacks relating to this buffer, and an optional <see cref="SharpDX.XAudio2.BufferFlags.EndOfStream"/> flag that indicates that it is the last buffer of a contiguous sound. </p><p>If the voice is started and has no buffers queued, the new buffer will start playing immediately. If the voice is stopped, the buffer is added to the voice's queue and will be played when the voice starts. </p><p>If only part of the given buffer should be played, the <strong>PlayBegin</strong> and <strong>PlayLength</strong> fields in the <strong><see cref="SharpDX.XAudio2.AudioBuffer"/></strong> can be used to specify the region to be played. A <strong>PlayLength</strong> value of 0 means to play the entire buffer (and in this case <strong>PlayBegin</strong> must be 0 as well). </p><p>If all or part of the buffer should be played in a continuous loop, the <strong>LoopBegin</strong>, <strong>LoopLength</strong> and <strong>LoopCount</strong> fields in <strong><see cref="SharpDX.XAudio2.AudioBuffer"/></strong> can be used to specify the characteristics of the loop region. A <strong>LoopBegin</strong> value of <see cref="SharpDX.XAudio2.XAudio2.NoLoopRegion"/> means that no looping should be performed, and in this case <strong>LoopLength</strong> and <strong>LoopCount</strong> must be given as 0. If a loop region is specified, it must be non-empty (<strong>LoopLength</strong> &gt; 0), and the loop count must be between 1 and <see cref="SharpDX.XAudio2.XAudio2.MaximumLoopCount"/> inclusive (or <see cref="SharpDX.XAudio2.AudioBuffer.LoopInfinite"/> to specify an endless loop which will only end when <strong><see cref="SharpDX.XAudio2.SourceVoice.ExitLoop"/></strong> is called). A loop count of <em>N</em> means to skip backwards N times, i.e. to play the loop region <em>N</em>+1 times. </p><p>If an explicit play region is specified, it must begin and end within the given audio buffer (or, in the compressed case, within the set of samples that the buffer will decode to). In addition, the loop region cannot end past the end of the play region. </p><table> <tr><th>Xbox 360</th></tr> <tr><td>For certain audio formats, there may be additional restrictions on the valid endpoints of any play or loop regions; e.g. for XMA buffers, the regions can only begin or end at 128-sample boundaries in the decoded audio.	
        /// </td></tr> </table><p>?</p><p>The <em>pBuffer</em> reference can be reused or freed immediately after calling this method, but the actual audio data referenced by <em>pBuffer</em> must remain valid until the buffer has been fully consumed by XAudio2 (which is indicated by the <strong><see cref="SharpDX.XAudio2.VoiceCallback.OnBufferEnd"/></strong> callback). </p><p>Up to <see cref="SharpDX.XAudio2.XAudio2.MaximumQueuedBuffers"/> buffers can be queued on a voice at any one time. </p><p><strong>SubmitSourceBuffer</strong> takes effect immediately when called from an XAudio2 callback with an OperationSet of <see cref="SharpDX.XAudio2.XAudio2.CommitNow"/>.	
        /// </p><table> <tr><th>Xbox 360</th></tr> <tr><td>This method can be called from an Xbox system thread (most other XAudio2 methods cannot). However, a maximum of two source buffers can be submitted from a system thread at a time.</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2SourceVoice::SubmitSourceBuffer']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.submitsourcebuffer</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2SourceVoice::SubmitSourceBuffer([In] const XAUDIO2_BUFFER* pBuffer,[In] const void* pBufferWMA)</unmanaged>	
        /// <unmanaged-short>IXAudio2SourceVoice::SubmitSourceBuffer</unmanaged-short>	
        internal void SubmitSourceBuffer(SharpDX.XAudio2.AudioBuffer bufferRef, System.IntPtr bufferWMARef) {
            unsafe {
                var bufferRef_ = new SharpDX.XAudio2.AudioBuffer.__Native();
                bufferRef.__MarshalTo(ref bufferRef_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, &bufferRef_, (void*)bufferWMARef,((void**)(*(void**)_nativePointer))[21]);		
                bufferRef.__MarshalFree(ref bufferRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes all pending audio buffers from the voice queue.</p>	
        /// </summary>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise.</p></returns>	
        /// <remarks>	
        /// <p>If the voice is started, the buffer that is currently playing is not removed from the queue. </p><p><strong>FlushSourceBuffers</strong> can be called regardless of whether the voice is currently started or stopped. </p><p>For every buffer removed, an <strong>OnBufferEnd</strong> callback will be made, but none of the other per-buffer callbacks (<strong>OnBufferStart</strong>, <strong>OnStreamEnd</strong> or <strong>OnLoopEnd</strong>) will be made. </p><p><strong>FlushSourceBuffers</strong> does not change a the voice's running state, so if the voice was playing a buffer prior to the call, it will continue to do so, and will deliver all the callbacks for the buffer normally. This means that the <strong>OnBufferEnd</strong> callback for this buffer will take place after the <strong>OnBufferEnd</strong> callbacks for the buffers that were removed. Thus, an XAudio2 client that calls <strong>FlushSourceBuffers</strong> cannot expect to receive <strong>OnBufferEnd</strong> callbacks in the order in which the buffers were submitted. </p><p>No warnings for starvation of the buffer queue will be emitted when the currently playing buffer completes; it is assumed that the client has intentionally removed the buffers that followed it. However, there may be an audio pop if this buffer does not end at a zero crossing. If the application must ensure that the flush operation takes place while a specific buffer is playing?perhaps because the buffer ends with a zero crossing?it must call <strong>FlushSourceBuffers</strong> from a callback, so that it executes synchronously. </p><p>Calling <strong>FlushSourceBuffers</strong> after a voice is stopped and then submitting new data to the voice resets all of the voice's internal counters. </p><p>A voice's state is not considered reset after calling <strong>FlushSourceBuffers</strong> until the <strong>OnBufferEnd</strong> callback occurs (if a buffer was previously submitted) or <strong><see cref="SharpDX.XAudio2.SourceVoice.GetState"/></strong> returns with <strong><see cref="SharpDX.XAudio2.VoiceState"/></strong>. <strong>BuffersQueued</strong> == 0. For example, if you stop a voice and call <strong>FlushSourceBuffers</strong>, it's still not legal to immediately call <strong><see cref="SharpDX.XAudio2.SourceVoice.SetSourceSampleRate"/></strong> (which requires the voice to not have any buffers currently queued), until either of the previously mentioned conditions are met.  </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2SourceVoice::FlushSourceBuffers']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.flushsourcebuffers</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2SourceVoice::FlushSourceBuffers()</unmanaged>	
        /// <unmanaged-short>IXAudio2SourceVoice::FlushSourceBuffers</unmanaged-short>	
        public void FlushSourceBuffers() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[22]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Notifies an XAudio2 voice that no more buffers are coming after the last one that is currently in its queue.</p>	
        /// </summary>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise.</p></returns>	
        /// <remarks>	
        /// <p><strong>Discontinuity</strong> suppresses the warnings that normally occur in the debug build of XAudio2 when a voice runs out of audio buffers to play. It is preferable to mark the final buffer of a stream by tagging it with the <see cref="SharpDX.XAudio2.BufferFlags.EndOfStream"/> flag, but in some cases the client may not know that a buffer is the end of a stream until after the buffer has been submitted. </p><p>Because calling <strong>Discontinuity</strong> is equivalent to applying the <see cref="SharpDX.XAudio2.BufferFlags.EndOfStream"/> flag retroactively to the last buffer submitted, an <strong>OnStreamEnd</strong> callback will be made when this buffer completes.	
        /// </p><p><strong>Note</strong>??XAudio2 may consume its entire buffer queue and emit a warning before the <strong>Discontinuity</strong> call takes effect, so <strong>Discontinuity</strong> is not guaranteed to suppress the warnings.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2SourceVoice::Discontinuity']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.discontinuity</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2SourceVoice::Discontinuity()</unmanaged>	
        /// <unmanaged-short>IXAudio2SourceVoice::Discontinuity</unmanaged-short>	
        public void Discontinuity() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[23]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Stops looping the voice when it reaches the end of the current loop region. </p>	
        /// </summary>	
        /// <param name="operationSet"><dd> <p> Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>	
        /// <remarks>	
        /// <p>If the cursor for the voice is not in a loop region, <strong>ExitLoop</strong> does nothing. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2SourceVoice::ExitLoop']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.exitloop</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2SourceVoice::ExitLoop([In] unsigned int OperationSet)</unmanaged>	
        /// <unmanaged-short>IXAudio2SourceVoice::ExitLoop</unmanaged-short>	
        public void ExitLoop(int operationSet = 0) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, operationSet,((void**)(*(void**)_nativePointer))[24]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Returns the voice's current cursor position data.</p>	
        /// </summary>	
        /// <param name="flags"><dd> <p>Flags controlling which voice state data should be returned. Valid values are 0 or <strong><see cref="SharpDX.XAudio2.VoiceFlags.Nosamplesplayed"/></strong>. The default value is 0. If you specify <strong><see cref="SharpDX.XAudio2.VoiceFlags.Nosamplesplayed"/></strong>, <strong>GetState</strong> returns only the buffer state, not the sampler state. <strong>GetState</strong> takes roughly one-third as much time to complete when you specify <strong><see cref="SharpDX.XAudio2.VoiceFlags.Nosamplesplayed"/></strong>.</p> </dd></param>	
        /// <remarks>	
        /// <p>If a client needs to get the correlated positions of several voices (for example, to know exactly which sample of a given voice is playing when a given sample of another voice is playing), it must make <strong>GetState</strong> calls in an XAudio2 engine callback. This ensures that none of the voices advance while the calls are being made. See the XAudio2 Callbacks overview for information about using XAudio2 callbacks. </p><p>Note that the DirectX SDK versions of XAUDIO2 do not take the Flags parameter for <strong>GetState</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2SourceVoice::GetState']/*"/>	
        /// <msdn-id>hh405047</msdn-id>	
        /// <unmanaged>void IXAudio2SourceVoice::GetState([Out] XAUDIO2_VOICE_STATE* pVoiceState,[In] unsigned int Flags)</unmanaged>	
        /// <unmanaged-short>IXAudio2SourceVoice::GetState</unmanaged-short>	
        internal SharpDX.XAudio2.VoiceState GetState(int flags) {
            unsafe {
                SharpDX.XAudio2.VoiceState voiceStateRef;
                voiceStateRef = new SharpDX.XAudio2.VoiceState();
                SharpDX.XAudio2.LocalInterop.Callivoid(_nativePointer, &voiceStateRef, flags,((void**)(*(void**)_nativePointer))[25]);		
                return voiceStateRef;
            }
        }
        
        /// <summary>	
        /// <p>Sets the frequency adjustment ratio of the voice.</p>	
        /// </summary>	
        /// <param name="ratio"><dd> <p>Frequency adjustment ratio. This value must be between <see cref="SharpDX.XAudio2.XAudio2.MinimumFrequencyRatio"/> and the <em>MaxFrequencyRatio</em> parameter specified when the voice was created (see <strong><see cref="SharpDX.XAudio2.XAudio2.CreateSourceVoice_"/></strong>). <see cref="SharpDX.XAudio2.XAudio2.MinimumFrequencyRatio"/> currently is 0.0005, which allows pitch to be lowered by up to 11 octaves.</p> </dd></param>	
        /// <param name="operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information. </p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes. </p></returns>	
        /// <remarks>	
        /// <p>Frequency adjustment is expressed as <em>source frequency</em> / <em>target frequency</em>. Changing the frequency ratio changes the rate audio is played on the voice. A ratio greater than 1.0 will cause the audio to play faster and a ratio less than 1.0 will cause the audio to play slower. Additionally, the frequency ratio affects the pitch of audio on the voice. As an example, a value of 1.0 has no effect on the audio, whereas a value of 2.0 raises pitch by one octave and 0.5 lowers it by one octave. </p><p>If <strong>SetFrequencyRatio</strong> is called specifying a Ratio value outside the valid range, the method will set the frequency ratio to the nearest valid value. A warning also will be generated for debug builds. </p><p><strong>Note</strong>??<strong><see cref="SharpDX.XAudio2.SourceVoice.GetFrequencyRatio"/></strong> always returns the voice's actual current frequency ratio. However, this may not match the ratio set by the most recent <strong><see cref="SharpDX.XAudio2.SourceVoice.SetFrequencyRatio"/></strong> call: the actual ratio is only changed the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.SourceVoice.SetFrequencyRatio"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.SourceVoice.SetFrequencyRatio"/></strong> was called with a deferred operation ID).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2SourceVoice::SetFrequencyRatio']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.setfrequencyratio</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2SourceVoice::SetFrequencyRatio([In] float Ratio,[In] unsigned int OperationSet)</unmanaged>	
        /// <unmanaged-short>IXAudio2SourceVoice::SetFrequencyRatio</unmanaged-short>	
        public void SetFrequencyRatio(float ratio, int operationSet = 0) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, ratio, operationSet,((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Returns the frequency adjustment ratio of the voice.</p>	
        /// </summary>	
        /// <param name="ratioRef"><dd> <p>Returns the current frequency adjustment ratio if successful.</p> </dd></param>	
        /// <remarks>	
        /// <p><strong>GetFrequencyRatio</strong> always returns the voice's actual current frequency ratio. However, this may not match the ratio set by the most recent <strong><see cref="SharpDX.XAudio2.SourceVoice.SetFrequencyRatio"/></strong> call: the actual ratio is only changed the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.SourceVoice.SetFrequencyRatio"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.SourceVoice.SetFrequencyRatio"/></strong> was called with a deferred operation ID). </p><p>For information on frequency ratios, see <strong><see cref="SharpDX.XAudio2.SourceVoice.SetFrequencyRatio"/></strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2SourceVoice::GetFrequencyRatio']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.getfrequencyratio</msdn-id>	
        /// <unmanaged>void IXAudio2SourceVoice::GetFrequencyRatio([Out] float* pRatio)</unmanaged>	
        /// <unmanaged-short>IXAudio2SourceVoice::GetFrequencyRatio</unmanaged-short>	
        internal void GetFrequencyRatio(out float ratioRef) {
            unsafe {
                fixed (void* ratioRef_ = &ratioRef)
                    SharpDX.XAudio2.LocalInterop.Callivoid(_nativePointer, ratioRef_,((void**)(*(void**)_nativePointer))[27]);		
            }
        }
        
        /// <summary>	
        /// <p>Reconfigures the voice to consume source data at a different sample rate than the rate specified when the voice was created.</p>	
        /// </summary>	
        /// <param name="newSourceSampleRate"><dd> <p>The new sample rate the voice should process submitted data at. Valid sample rates are 1kHz to 200kHz. </p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes. </p></returns>	
        /// <remarks>	
        /// <p>The <strong>SetSourceSampleRate</strong> method supports reuse of XAudio2 voices by allowing a voice to play sounds with a variety of sample rates. To use <strong>SetSourceSampleRate</strong> the voice must have been created without the <see cref="SharpDX.XAudio2.VoiceFlags.NoPitch"/> or <see cref="SharpDX.XAudio2.VoiceFlags.NoSampleRateConversion"/> flags and must not have any buffers currently queued. </p><p>The typical use of <strong>SetSourceSampleRate</strong> is to support voice pooling. For example to support voice pooling an application would precreate all the voices it expects to use. Whenever a new sound will be played the application chooses an inactive voice or ,if all voices are busy, picks the least important voice and calls <strong>SetSourceSampleRate</strong> on the voice with the new sound's sample rate. After <strong>SetSourceSampleRate</strong> has been called on the voice, the application can immediately start submitting and playing buffers with the new sample rate. This allows the application to avoid the overhead of creating and destroying voices frequently during gameplay.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2SourceVoice::SetSourceSampleRate']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2sourcevoice.ixaudio2sourcevoice.setsourcesamplerate</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2SourceVoice::SetSourceSampleRate([In] unsigned int NewSourceSampleRate)</unmanaged>	
        /// <unmanaged-short>IXAudio2SourceVoice::SetSourceSampleRate</unmanaged-short>	
        internal void SetSourceSampleRate(int newSourceSampleRate) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, newSourceSampleRate,((void**)(*(void**)_nativePointer))[28]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A submix voice is used primarily for performance improvements and effects processing. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Data buffers cannot be submitted directly to submix voices and will not be audible unless submitted to a mastering voice. A submix voice can be used to ensure that a particular set of voice data is converted to the same format and/or to have a particular effect chain processed on the collective result. 	
    /// </p><p><see cref="SharpDX.XAudio2.SubmixVoice"/> inherits directly from <strong><see cref="SharpDX.XAudio2.Voice"/></strong>, but does not implement methods specific to submix voices. The interface type exists solely because some of the base class methods are implemented differently for submix voices. Having a separate type for these voices helps client code to distinguish the different voice types and to benefit from C++ type safety.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2SubmixVoice']/*"/>	
    /// <msdn-id>microsoft.directx_sdk.ixaudio2submixvoice.ixaudio2submixvoice</msdn-id>	
    /// <unmanaged>IXAudio2SubmixVoice</unmanaged>	
    /// <unmanaged-short>IXAudio2SubmixVoice</unmanaged-short>	
    public partial class SubmixVoice : SharpDX.XAudio2.Voice {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.XAudio2.SubmixVoice"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SubmixVoice(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.XAudio2.SubmixVoice"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.XAudio2.SubmixVoice(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.XAudio2.SubmixVoice(nativePointer);
		}
        
    }
    /// <summary>	
    /// <p>Sets the filter parameters on one of this voice's sends.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong>SetOutputFilterParameters</strong> will fail if the send was not created with the <see cref="SharpDX.XAudio2.VoiceSendFlags.UseFilter"/> flag. This method is usable only on sends belonging to source and submix voices and has no effect on a mastering voice's sends.	
    /// </p><p><strong>Note</strong>??<strong><see cref="SharpDX.XAudio2.Voice.GetOutputFilterParameters"/></strong> always returns this send?s actual current filter parameters. However, these may not match the parameters set by the most recent <strong><see cref="SharpDX.XAudio2.Voice.SetOutputFilterParameters"/></strong> call: the actual parameters are only changed the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.SetOutputFilterParameters"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.Voice.SetOutputFilterParameters"/></strong> was called with a deferred operation ID).</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice']/*"/>	
    /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setoutputfilterparameters</msdn-id>	
    /// <unmanaged>IXAudio2Voice</unmanaged>	
    /// <unmanaged-short>IXAudio2Voice</unmanaged-short>	
    public partial class Voice : SharpDX.CppObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.XAudio2.Voice"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Voice(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.XAudio2.Voice"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.XAudio2.Voice(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.XAudio2.Voice(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Designates a new set of submix or mastering voices to receive the output of the voice.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method is only valid for source and submix voices. Mastering voices can not send audio to another voice. </p><p>After calling <strong>SetOutputVoices</strong> a voice's current send levels will be replaced by a default send matrix. The <strong><see cref="SharpDX.XAudio2.Voice.SetOutputMatrix"/></strong> method must be called to set a custom matrix for the new sendlist. </p><p>It is invalid to call <strong>SetOutputVoices</strong> from within a callback (that is, <strong><see cref="SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong>). If <strong>SetOutputVoices</strong> is called within a callback, it returns <see cref="SharpDX.XAudio2.ResultCode.InvalidCall"/>.</p><p><strong>Note</strong>??Calling <strong>SetOutputVoices</strong> invalidates any send matrices previously set with <strong><see cref="SharpDX.XAudio2.Voice.SetOutputMatrix"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::SetOutputVoices']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setoutputvoices</msdn-id>	
        /// <unmanaged>SetOutputVoices</unmanaged>	
        /// <unmanaged-short>SetOutputVoices</unmanaged-short>	
        /// <unmanaged>HRESULT IXAudio2Voice::SetOutputVoices([In, Optional] const XAUDIO2_VOICE_SENDS* pSendList)</unmanaged>
        internal SharpDX.XAudio2.VoiceSendDescriptors OutputVoices {
                set { SetOutputVoices(value); }
        }
        
        /// <summary>	
        /// <p>Gets the voice's filter parameters.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p><strong>GetFilterParameters</strong> will fail if the voice was not created with the <see cref="SharpDX.XAudio2.VoiceFlags.UseFilter"/> flag. </p><p><strong>GetFilterParameters</strong> always returns this voice's actual current filter parameters. However, these may not match the parameters set by the most recent <strong><see cref="SharpDX.XAudio2.Voice.SetFilterParameters"/></strong> call: the actual parameters are only changed the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.SetFilterParameters"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.Voice.SetFilterParameters"/></strong> was called with a deferred operation ID). </p><p><strong>Note</strong>??<strong>GetFilterParameters</strong> is usable only on source and submix voices and has no effect on mastering voices.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::GetFilterParameters']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.getfilterparameters</msdn-id>	
        /// <unmanaged>GetFilterParameters</unmanaged>	
        /// <unmanaged-short>GetFilterParameters</unmanaged-short>	
        /// <unmanaged>void IXAudio2Voice::GetFilterParameters([Out] XAUDIO2_FILTER_PARAMETERS* pParameters)</unmanaged>
        public SharpDX.XAudio2.FilterParameters FilterParameters {
                get { SharpDX.XAudio2.FilterParameters __output__; GetFilterParameters(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the current overall volume level of the voice.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Volume levels are expressed as floating-point amplitude multipliers between -224 to 224, with a maximum gain of 144.5 dB. A volume level of 1 means there is no attenuation or gain and 0 means silence. Negative levels can be used to invert the audio's phase. See XAudio2 Volume and Pitch Control for additional information on volume control. </p><p><strong>Note</strong>??<strong>GetVolume</strong> always returns the volume most recently set by <strong><see cref="SharpDX.XAudio2.Voice.SetVolume"/></strong>. However, it may not actually be in effect yet: it only takes effect the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.SetVolume"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.Voice.SetVolume"/></strong> was called with a deferred operation ID).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::GetVolume']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.getvolume</msdn-id>	
        /// <unmanaged>GetVolume</unmanaged>	
        /// <unmanaged-short>GetVolume</unmanaged-short>	
        /// <unmanaged>void IXAudio2Voice::GetVolume([Out] float* pVolume)</unmanaged>
        public float Volume {
                get { float __output__; GetVolume(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Returns information about the creation flags, input channels, and sample rate of a voice.</p>	
        /// </summary>	
        /// <param name="voiceDetailsRef"><dd> <p> <strong><see cref="SharpDX.XAudio2.VoiceDetails"/></strong> structure containing information about the voice.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::GetVoiceDetails']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.getvoicedetails</msdn-id>	
        /// <unmanaged>void IXAudio2Voice::GetVoiceDetails([Out] XAUDIO2_VOICE_DETAILS* pVoiceDetails)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::GetVoiceDetails</unmanaged-short>	
        public void GetVoiceDetails(out SharpDX.XAudio2.VoiceDetails voiceDetailsRef) {
            unsafe {
                voiceDetailsRef = new SharpDX.XAudio2.VoiceDetails();
                fixed (void* voiceDetailsRef_ = &voiceDetailsRef)
                    SharpDX.XAudio2.LocalInterop.Callivoid(_nativePointer, voiceDetailsRef_,((void**)(*(void**)_nativePointer))[0]);		
            }
        }
        
        /// <summary>	
        /// <p>Designates a new set of submix or mastering voices to receive the output of the voice.</p>	
        /// </summary>	
        /// <param name="sendListRef"><dd> <p>Array of <strong><see cref="SharpDX.XAudio2.VoiceSendDescriptors"/></strong> structure references to destination voices. If <em>pSendList</em> is <c>null</c>, the voice will send its output to the current mastering voice. To set the voice to not send its output anywhere set the <strong>OutputCount</strong> member of <strong><see cref="SharpDX.XAudio2.VoiceSendDescriptors"/></strong> to 0. All of the voices in a send list must have the same input sample rate, see XAudio2 Sample Rate Conversions for additional information.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes. </p></returns>	
        /// <remarks>	
        /// <p>This method is only valid for source and submix voices. Mastering voices can not send audio to another voice. </p><p>After calling <strong>SetOutputVoices</strong> a voice's current send levels will be replaced by a default send matrix. The <strong><see cref="SharpDX.XAudio2.Voice.SetOutputMatrix"/></strong> method must be called to set a custom matrix for the new sendlist. </p><p>It is invalid to call <strong>SetOutputVoices</strong> from within a callback (that is, <strong><see cref="SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong>). If <strong>SetOutputVoices</strong> is called within a callback, it returns <see cref="SharpDX.XAudio2.ResultCode.InvalidCall"/>.</p><p><strong>Note</strong>??Calling <strong>SetOutputVoices</strong> invalidates any send matrices previously set with <strong><see cref="SharpDX.XAudio2.Voice.SetOutputMatrix"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::SetOutputVoices']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setoutputvoices</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2Voice::SetOutputVoices([In, Optional] const XAUDIO2_VOICE_SENDS* pSendList)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::SetOutputVoices</unmanaged-short>	
        internal void SetOutputVoices(SharpDX.XAudio2.VoiceSendDescriptors? sendListRef) {
            unsafe {
                SharpDX.XAudio2.VoiceSendDescriptors sendListRef_;
                if (sendListRef.HasValue)
                    sendListRef_ = sendListRef.Value;				
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, (sendListRef.HasValue)?&sendListRef_:(void*)IntPtr.Zero,((void**)(*(void**)_nativePointer))[1]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Replaces the effect chain of the voice.</p>	
        /// </summary>	
        /// <param name="effectChainRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.XAudio2.EffectChain"/></strong> structure that describes the new effect chain to use. If <c>null</c> is passed, the current effect chain is removed.</p> <p><strong>Note</strong>??If <em>pEffectChain</em> is non-<c>null</c>, the <strong><see cref="SharpDX.XAudio2.EffectChain"/></strong> structure that it points to must specify at least one effect.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise, an error code.  </p><p>See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>	
        /// <remarks>	
        /// <p>The number of output channels allowed for a voice's effect chain is locked at creation of the voice. If you create the voice with an effect chain, any new effect chain passed to <strong>SetEffectChain</strong> must have the same number of input and output channels as the original effect chain. If you create the voice without an effect chain, the number of output channels allowed for the effect chain will default to the number of input channels for the voice. If any part of effect chain creation fails, none of it is applied. </p><p>After you attach an effect to an XAudio2 voice, XAudio2 takes control of the effect, and the client should not make any further calls to it. The simplest way to ensure this is to release all references to the effect. </p><p>It is invalid to call <strong>SetEffectChain</strong> from within a callback (that is, <strong><see cref="SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong>). If you call <strong>SetEffectChain</strong> within a callback, it returns <see cref="SharpDX.XAudio2.ResultCode.InvalidCall"/>. </p><p>The <strong><see cref="SharpDX.XAudio2.EffectChain"/></strong> that is passed in as the pEffectChain argument and any <strong><see cref="SharpDX.XAudio2.EffectDescriptor"/></strong> information contained within it are no longer needed after <strong>SetEffectChain</strong> successfully completes, and may be deleted immediately after <strong>SetEffectChain</strong> is called.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::SetEffectChain']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.seteffectchain</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2Voice::SetEffectChain([In, Optional] const XAUDIO2_EFFECT_CHAIN* pEffectChain)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::SetEffectChain</unmanaged-short>	
        internal void SetEffectChain(SharpDX.XAudio2.EffectChain? effectChainRef) {
            unsafe {
                SharpDX.XAudio2.EffectChain effectChainRef_;
                if (effectChainRef.HasValue)
                    effectChainRef_ = effectChainRef.Value;				
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, (effectChainRef.HasValue)?&effectChainRef_:(void*)IntPtr.Zero,((void**)(*(void**)_nativePointer))[2]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Enables the effect at a given position in the effect chain of the voice.</p>	
        /// </summary>	
        /// <param name="effectIndex"><dd> <p>Zero-based index of an effect in the effect chain of the voice.</p> </dd></param>	
        /// <param name="operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information. </p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise, an error code. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes. </p></returns>	
        /// <remarks>	
        /// <p>Be careful when you enable an effect while the voice that hosts it is running. Such an action can result in a problem if the effect significantly changes the audio's pitch or volume. </p><p>The effects in a given XAudio2 voice's effect chain must consume and produce audio at that voice's processing sample rate. The only aspect of the audio format they can change is the channel count. For example a reverb effect can convert mono data to 5.1. The client can use the <strong><see cref="SharpDX.XAudio2.EffectDescriptor"/></strong> structure's <strong>OutputChannels</strong> field to specify the number of channels it wants each effect to produce. Each effect in an effect chain must produce a number of channels that the next effect can consume. Any calls to <strong><see cref="SharpDX.XAudio2.Voice.EnableEffect"/></strong> or <strong><see cref="SharpDX.XAudio2.Voice.DisableEffect"/></strong> that would make the effect chain stop fulfilling these requirements will fail. </p><p><strong>EnableEffect</strong> takes effect immediately when you call it from an XAudio2 callback with an <em>OperationSet</em> of <strong><see cref="SharpDX.XAudio2.XAudio2.CommitNow"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::EnableEffect']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.enableeffect</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2Voice::EnableEffect([In] unsigned int EffectIndex,[In] unsigned int OperationSet)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::EnableEffect</unmanaged-short>	
        public void EnableEffect(int effectIndex, int operationSet = 0) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, effectIndex, operationSet,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Disables the effect at a given position in the effect chain of the voice.</p>	
        /// </summary>	
        /// <param name="effectIndex"><dd> <p>Zero-based index of an effect in the effect chain of the voice.</p> </dd></param>	
        /// <param name="operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information. </p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise, an error code. See <strong>XAudio2 Error Codes</strong> for descriptions of valid error codes.</p></returns>	
        /// <remarks>	
        /// <p>The effects in a given XAudio2 voice's effect chain must consume and produce audio at that voice's processing sample rate. The only aspect of the audio format they can change is the channel count. For example a reverb effect can convert mono data to 5.1. The client can use the <strong><see cref="SharpDX.XAudio2.EffectDescriptor"/></strong> structure's <strong>OutputChannels</strong> field to specify the number of channels it wants each effect to produce. Each effect in an effect chain must produce a number of channels that the next effect can consume. Any calls to <strong><see cref="SharpDX.XAudio2.Voice.EnableEffect"/></strong> or <strong><see cref="SharpDX.XAudio2.Voice.DisableEffect"/></strong> that would make the effect chain stop fulfilling these requirements will fail. </p><p>Disabling an effect immediately removes it from the processing graph. Any pending audio in the effect?such as a reverb tail?is not played. Be careful disabling an effect while the voice that hosts it is running. This can result in an audible artifact if the effect significantly changes the audio's pitch or volume. </p><p><strong>DisableEffect</strong> takes effect immediately when called from an XAudio2 callback with an <em>OperationSet</em> of <strong><see cref="SharpDX.XAudio2.XAudio2.CommitNow"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::DisableEffect']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.disableeffect</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2Voice::DisableEffect([In] unsigned int EffectIndex,[In] unsigned int OperationSet)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::DisableEffect</unmanaged-short>	
        public void DisableEffect(int effectIndex, int operationSet = 0) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, effectIndex, operationSet,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Returns the running state of the effect at a specified position in the effect chain of the voice.</p>	
        /// </summary>	
        /// <param name="effectIndex"><dd> <p>Zero-based index of an effect in the effect chain of the voice.</p> </dd></param>	
        /// <remarks>	
        /// <p><strong>GetEffectState</strong> always returns the effect's actual current state. However, this may not be the state set by the most recent <strong><see cref="SharpDX.XAudio2.Voice.EnableEffect"/></strong> or <strong><see cref="SharpDX.XAudio2.Voice.DisableEffect"/></strong> call: the actual state is only changed the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.EnableEffect"/></strong> or <strong><see cref="SharpDX.XAudio2.Voice.DisableEffect"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if EnableEffect/DisableEffect was called with a deferred operation ID).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::GetEffectState']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.geteffectstate</msdn-id>	
        /// <unmanaged>void IXAudio2Voice::GetEffectState([In] unsigned int EffectIndex,[Out] BOOL* pEnabled)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::GetEffectState</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool IsEffectEnabled(int effectIndex) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool enabledRef;
                enabledRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.XAudio2.LocalInterop.Callivoid(_nativePointer, effectIndex, &enabledRef,((void**)(*(void**)_nativePointer))[5]);		
                return enabledRef;
            }
        }
        
        /// <summary>	
        /// <p>Sets parameters for a given effect in the voice's effect chain.</p>	
        /// </summary>	
        /// <param name="effectIndex"><dd> <p>Zero-based index of an effect within the voice's effect chain.</p> </dd></param>	
        /// <param name="parametersRef"><dd> <p> Returns the current values of the effect-specific parameters.</p> </dd></param>	
        /// <param name="parametersByteSize"><dd> <p> Size of the <strong>pParameters</strong> array in bytes.</p> </dd></param>	
        /// <param name="operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise, an error code. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes. </p><p>Fails with E_NOTIMPL if the effect does not support a generic parameter control interface.</p></returns>	
        /// <remarks>	
        /// <p>The specific effect being used determines the valid size and format of the <em>pParameters</em> buffer. The call will fail if <em>pParameters</em> is invalid or if <em>ParametersByteSize</em> is not exactly the size that the effect expects. The client must take care to direct the <strong>SetEffectParameters</strong> call to the right effect. If this call is directed to a different effect that happens to accept the same parameter block size, the parameters will be interpreted differently. This may lead to unexpected results. </p><p>The memory pointed to by <em>pParameters</em> must <em>not</em> be freed immediately, because XAudio2 will need to refer to it later when the parameters actually are applied to the effect. This happens during the next audio processing pass if the <em>OperationSet</em> argument is <strong><see cref="SharpDX.XAudio2.XAudio2.CommitNow"/></strong>. Otherwise, the parameters are applied to the effect later, during the first processing pass after the <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> function is called with the same <em>OperationSet</em> argument. </p><p><strong>SetEffectParameters</strong> takes effect immediately when called from an XAudio2 callback with an <em>OperationSet</em> of <strong><see cref="SharpDX.XAudio2.XAudio2.CommitNow"/></strong>.	
        /// </p><p><strong>Note</strong>??<strong><see cref="SharpDX.XAudio2.Voice.GetEffectParameters"/></strong> always returns the effect's actual current parameters. However, these may not match the parameters set by the most recent call to <strong><see cref="SharpDX.XAudio2.Voice.SetEffectParameters"/></strong>. The actual parameters are only changed the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.SetEffectParameters"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.Voice.SetEffectParameters"/></strong> was called with a deferred operation ID).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::SetEffectParameters']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.seteffectparameters</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2Voice::SetEffectParameters([In] unsigned int EffectIndex,[In, Buffer] const void* pParameters,[In] unsigned int ParametersByteSize,[In] unsigned int OperationSet)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::SetEffectParameters</unmanaged-short>	
        internal void SetEffectParameters(int effectIndex, System.IntPtr parametersRef, int parametersByteSize, int operationSet = 0) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, effectIndex, (void*)parametersRef, parametersByteSize, operationSet,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Returns the current effect-specific parameters of a given effect in the voice's effect chain.</p>	
        /// </summary>	
        /// <param name="effectIndex"><dd> <p>Zero-based index of an effect within the voice's effect chain.</p> </dd></param>	
        /// <param name="parametersRef"><dd> <p>Returns the current values of the effect-specific parameters.</p> </dd></param>	
        /// <param name="parametersByteSize"><dd> <p>Size, in bytes, of the pParameters array.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes. </p><p>Fails with E_NOTIMPL if the effect does not support a generic parameter control interface.</p></returns>	
        /// <remarks>	
        /// <p><strong>GetEffectParameters</strong> always returns the effect's actual current parameters. However, these may not match the parameters set by the most recent call to <strong><see cref="SharpDX.XAudio2.Voice.SetEffectParameters"/></strong>: the actual parameters are only changed the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.SetEffectParameters"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.Voice.SetEffectParameters"/></strong> was called with a deferred operation ID). </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::GetEffectParameters']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.geteffectparameters</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2Voice::GetEffectParameters([In] unsigned int EffectIndex,[Out, Buffer] void* pParameters,[In] unsigned int ParametersByteSize)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::GetEffectParameters</unmanaged-short>	
        internal void GetEffectParameters(int effectIndex, System.IntPtr parametersRef, int parametersByteSize) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, effectIndex, (void*)parametersRef, parametersByteSize,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the voice's filter parameters.</p>	
        /// </summary>	
        /// <param name="parametersRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.XAudio2.FilterParameters"/></strong> structure containing the filter information. </p> </dd></param>	
        /// <param name="operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes. </p></returns>	
        /// <remarks>	
        /// <p><strong>SetFilterParameters</strong> will fail if the voice was not created with the <see cref="SharpDX.XAudio2.VoiceFlags.UseFilter"/> flag. </p><p>This method is usable only on source and submix voices and has no effect on mastering voices.</p><p><strong>Note</strong>??<strong><see cref="SharpDX.XAudio2.Voice.GetFilterParameters"/></strong> always returns this voice's actual current filter parameters. However, these may not match the parameters set by the most recent <strong><see cref="SharpDX.XAudio2.Voice.SetFilterParameters"/></strong> call: the actual parameters are only changed the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.SetFilterParameters"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.Voice.SetFilterParameters"/></strong> was called with a deferred operation ID).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::SetFilterParameters']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setfilterparameters</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2Voice::SetFilterParameters([In] const XAUDIO2_FILTER_PARAMETERS* pParameters,[In] unsigned int OperationSet)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::SetFilterParameters</unmanaged-short>	
        public void SetFilterParameters(SharpDX.XAudio2.FilterParameters parametersRef, int operationSet = 0) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, &parametersRef, operationSet,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the voice's filter parameters.</p>	
        /// </summary>	
        /// <param name="parametersRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.XAudio2.FilterParameters"/></strong> structure containing the filter information. </p> </dd></param>	
        /// <remarks>	
        /// <p><strong>GetFilterParameters</strong> will fail if the voice was not created with the <see cref="SharpDX.XAudio2.VoiceFlags.UseFilter"/> flag. </p><p><strong>GetFilterParameters</strong> always returns this voice's actual current filter parameters. However, these may not match the parameters set by the most recent <strong><see cref="SharpDX.XAudio2.Voice.SetFilterParameters"/></strong> call: the actual parameters are only changed the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.SetFilterParameters"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.Voice.SetFilterParameters"/></strong> was called with a deferred operation ID). </p><p><strong>Note</strong>??<strong>GetFilterParameters</strong> is usable only on source and submix voices and has no effect on mastering voices.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::GetFilterParameters']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.getfilterparameters</msdn-id>	
        /// <unmanaged>void IXAudio2Voice::GetFilterParameters([Out] XAUDIO2_FILTER_PARAMETERS* pParameters)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::GetFilterParameters</unmanaged-short>	
        internal void GetFilterParameters(out SharpDX.XAudio2.FilterParameters parametersRef) {
            unsafe {
                parametersRef = new SharpDX.XAudio2.FilterParameters();
                fixed (void* parametersRef_ = &parametersRef)
                    SharpDX.XAudio2.LocalInterop.Callivoid(_nativePointer, parametersRef_,((void**)(*(void**)_nativePointer))[9]);		
            }
        }
        
        /// <summary>	
        /// <p>Sets the filter parameters on one of this voice's sends.</p>	
        /// </summary>	
        /// <param name="destinationVoiceRef"><dd> <p> <strong><see cref="SharpDX.XAudio2.Voice"/></strong> reference to the destination voice of the send whose filter parameters will be set.</p> </dd></param>	
        /// <param name="parametersRef"><dd> <p> Pointer to an <strong><see cref="SharpDX.XAudio2.FilterParameters"/></strong> structure containing the filter information.</p> </dd></param>	
        /// <param name="operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes. </p></returns>	
        /// <remarks>	
        /// <p><strong>SetOutputFilterParameters</strong> will fail if the send was not created with the <see cref="SharpDX.XAudio2.VoiceSendFlags.UseFilter"/> flag. This method is usable only on sends belonging to source and submix voices and has no effect on a mastering voice's sends.	
        /// </p><p><strong>Note</strong>??<strong><see cref="SharpDX.XAudio2.Voice.GetOutputFilterParameters"/></strong> always returns this send?s actual current filter parameters. However, these may not match the parameters set by the most recent <strong><see cref="SharpDX.XAudio2.Voice.SetOutputFilterParameters"/></strong> call: the actual parameters are only changed the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.SetOutputFilterParameters"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.Voice.SetOutputFilterParameters"/></strong> was called with a deferred operation ID).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::SetOutputFilterParameters']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setoutputfilterparameters</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2Voice::SetOutputFilterParameters([In, Optional] IXAudio2Voice* pDestinationVoice,[In] const XAUDIO2_FILTER_PARAMETERS* pParameters,[In] unsigned int OperationSet)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::SetOutputFilterParameters</unmanaged-short>	
        public void SetOutputFilterParameters(SharpDX.XAudio2.Voice destinationVoiceRef, SharpDX.XAudio2.FilterParameters parametersRef, int operationSet = 0) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, (void*)((destinationVoiceRef == null)?IntPtr.Zero:destinationVoiceRef.NativePointer), &parametersRef, operationSet,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Returns the filter parameters from one of this voice's sends.</p>	
        /// </summary>	
        /// <param name="destinationVoiceRef"><dd> <p> <strong><see cref="SharpDX.XAudio2.Voice"/></strong> reference to the destination voice of the send whose filter parameters will be read.</p> </dd></param>	
        /// <param name="parametersRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.XAudio2.FilterParameters"/></strong> structure containing the filter information.</p> </dd></param>	
        /// <remarks>	
        /// <p><strong>GetOutputFilterParameters</strong> will fail if the send was not created with the <see cref="SharpDX.XAudio2.VoiceSendFlags.UseFilter"/> flag. This method is usable only on sends belonging to source and submix voices and has no effect on mastering voices? sends. </p><p><strong>Note</strong>??<strong><see cref="SharpDX.XAudio2.Voice.GetOutputFilterParameters"/></strong> always returns this send?s actual current filter parameters. However, these may not match the parameters set by the most recent <strong><see cref="SharpDX.XAudio2.Voice.SetOutputFilterParameters"/></strong> call: the actual parameters are only changed the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.SetOutputFilterParameters"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.Voice.SetOutputFilterParameters"/></strong> was called with a deferred operation ID).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::GetOutputFilterParameters']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.getoutputfilterparameters</msdn-id>	
        /// <unmanaged>void IXAudio2Voice::GetOutputFilterParameters([In, Optional] IXAudio2Voice* pDestinationVoice,[Out] XAUDIO2_FILTER_PARAMETERS* pParameters)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::GetOutputFilterParameters</unmanaged-short>	
        public void GetOutputFilterParameters(SharpDX.XAudio2.Voice destinationVoiceRef, out SharpDX.XAudio2.FilterParameters parametersRef) {
            unsafe {
                parametersRef = new SharpDX.XAudio2.FilterParameters();
                fixed (void* parametersRef_ = &parametersRef)
                    SharpDX.XAudio2.LocalInterop.Callivoid(_nativePointer, (void*)((destinationVoiceRef == null)?IntPtr.Zero:destinationVoiceRef.NativePointer), parametersRef_,((void**)(*(void**)_nativePointer))[11]);		
            }
        }
        
        /// <summary>	
        /// <p>Sets the overall volume level for the voice.</p>	
        /// </summary>	
        /// <param name="volume"><dd> <p>Overall volume level to use. See Remarks for more information on volume levels. </p> </dd></param>	
        /// <param name="operationSet"><dd> <p> Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information. </p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>SetVolume</strong> controls a voice's master input volume level. The master volume level is applied at different times depending on the type of voice. For submix and mastering voices the volume level is applied just before the voice's built in filter and effect chain is applied. For source voices the master volume level is applied after the voice's filter and effect chain is applied. </p><p>Volume levels are expressed as floating-point amplitude multipliers between -<see cref="SharpDX.XAudio2.XAudio2.MaximumVolumeLevel"/> and <see cref="SharpDX.XAudio2.XAudio2.MaximumVolumeLevel"/> (-224 to 224), with a maximum gain of 144.5 dB. A volume level of 1.0 means there is no attenuation or gain and 0 means silence. Negative levels can be used to invert the audio's phase. See XAudio2 Volume and Pitch Control for additional information on volume control. </p><p><strong>Note</strong>??<strong><see cref="SharpDX.XAudio2.Voice.GetVolume"/></strong> always returns the volume most recently set by <strong><see cref="SharpDX.XAudio2.Voice.SetVolume"/></strong>. However, it may not actually be in effect yet: it only takes effect the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.SetVolume"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.Voice.SetVolume"/></strong> was called with a deferred operation ID).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::SetVolume']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setvolume</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2Voice::SetVolume([In] float Volume,[In] unsigned int OperationSet)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::SetVolume</unmanaged-short>	
        public void SetVolume(float volume, int operationSet = 0) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, volume, operationSet,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the current overall volume level of the voice.</p>	
        /// </summary>	
        /// <param name="volumeRef"><dd> <p>Returns the current overall volume level of the voice. See Remarks for more information on volume levels.</p> </dd></param>	
        /// <remarks>	
        /// <p>Volume levels are expressed as floating-point amplitude multipliers between -224 to 224, with a maximum gain of 144.5 dB. A volume level of 1 means there is no attenuation or gain and 0 means silence. Negative levels can be used to invert the audio's phase. See XAudio2 Volume and Pitch Control for additional information on volume control. </p><p><strong>Note</strong>??<strong>GetVolume</strong> always returns the volume most recently set by <strong><see cref="SharpDX.XAudio2.Voice.SetVolume"/></strong>. However, it may not actually be in effect yet: it only takes effect the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.SetVolume"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.Voice.SetVolume"/></strong> was called with a deferred operation ID).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::GetVolume']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.getvolume</msdn-id>	
        /// <unmanaged>void IXAudio2Voice::GetVolume([Out] float* pVolume)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::GetVolume</unmanaged-short>	
        internal void GetVolume(out float volumeRef) {
            unsafe {
                fixed (void* volumeRef_ = &volumeRef)
                    SharpDX.XAudio2.LocalInterop.Callivoid(_nativePointer, volumeRef_,((void**)(*(void**)_nativePointer))[13]);		
            }
        }
        
        /// <summary>	
        /// <p>Sets the volume levels for the voice, per channel.</p>	
        /// </summary>	
        /// <param name="channels"><dd> <p>Number of channels in the voice.</p> </dd></param>	
        /// <param name="volumesRef"><dd> <p>Array containing the new volumes of each channel in the voice. The array must have <em>Channels</em> elements. See Remarks for more information on volume levels.</p> </dd></param>	
        /// <param name="operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>SetChannelVolumes</strong> controls a voice's per-channel output levels and is applied just after the voice's final SRC and before its sends. </p><p>This method is valid only for source and submix voices, because mastering voices do not specify volume per channel. </p><p>Volume levels are expressed as floating-point amplitude multipliers between -<see cref="SharpDX.XAudio2.XAudio2.MaximumVolumeLevel"/> and <see cref="SharpDX.XAudio2.XAudio2.MaximumVolumeLevel"/> (-224 to 224), with a maximum gain of 144.5 dB. A volume of 1 means there is no attenuation or gain and 0 means silence. Negative levels can be used to invert the audio's phase. See XAudio2 Volume and Pitch Control for additional information on volume control. </p><p><strong>Note</strong>??<strong><see cref="SharpDX.XAudio2.Voice.GetChannelVolumes"/></strong> always returns the volume levels most recently set by <strong><see cref="SharpDX.XAudio2.Voice.SetChannelVolumes"/></strong>. However, those values may not actually be in effect yet: they only take effect the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.SetChannelVolumes"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.Voice.SetChannelVolumes"/></strong> was called with a deferred operation ID).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::SetChannelVolumes']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setchannelvolumes</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2Voice::SetChannelVolumes([In] unsigned int Channels,[In, Buffer] const float* pVolumes,[In] unsigned int OperationSet)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::SetChannelVolumes</unmanaged-short>	
        public void SetChannelVolumes(int channels, float[] volumesRef, int operationSet = 0) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* volumesRef_ = volumesRef)
                    __result__= 
    				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, channels, volumesRef_, operationSet,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Returns the volume levels for the voice, per channel.</p>	
        /// </summary>	
        /// <param name="channels"><dd> <p>Confirms the channel count of the voice.</p> </dd></param>	
        /// <param name="volumesRef"><dd> <p>Returns the current volume level of each channel in the voice. The array must have at least <em>Channels</em> elements. See Remarks for more information on volume levels.</p> </dd></param>	
        /// <remarks>	
        /// <p>These settings are applied after the effect chain is applied. This method is valid only for source and submix voices, because mastering voices do not specify volume per channel. </p><p>Volume levels are expressed as floating-point amplitude multipliers between -224 to 224, with a maximum gain of 144.5 dB. A volume of 1 means there is no attenuation or gain, 0 means silence, and negative levels can be used to invert the audio's phase. See XAudio2 Volume and Pitch Control for additional information on volume control. </p><p><strong>Note</strong>??<strong>GetChannelVolumes</strong> always returns the volume levels most recently set by <strong><see cref="SharpDX.XAudio2.Voice.SetChannelVolumes"/></strong>. However, those values may not actually be in effect yet: they only take effect the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.SetChannelVolumes"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.Voice.SetChannelVolumes"/></strong> was called with a deferred operation ID). </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::GetChannelVolumes']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.getchannelvolumes</msdn-id>	
        /// <unmanaged>void IXAudio2Voice::GetChannelVolumes([In] unsigned int Channels,[Out, Buffer] float* pVolumes)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::GetChannelVolumes</unmanaged-short>	
        public void GetChannelVolumes(int channels, float[] volumesRef) {
            unsafe {
                fixed (void* volumesRef_ = volumesRef)
                    SharpDX.XAudio2.LocalInterop.Callivoid(_nativePointer, channels, volumesRef_,((void**)(*(void**)_nativePointer))[15]);		
            }
        }
        
        /// <summary>	
        /// <p>Sets the volume level of each channel of the final output for the voice. These channels are mapped to the input channels of a specified destination voice.</p>	
        /// </summary>	
        /// <param name="destinationVoiceRef"><dd> <p>Pointer to a destination <strong><see cref="SharpDX.XAudio2.Voice"/></strong> for which to set volume levels.</p> <p><strong>Note</strong>??If the voice sends to a single target voice then specifying <c>null</c> will cause <strong>SetOutputMatrix</strong> to operate on that target voice.</p> </dd></param>	
        /// <param name="sourceChannels"><dd> <p>Confirms the output channel count of the voice. This is the number of channels that are produced by the last effect in the chain.</p> </dd></param>	
        /// <param name="destinationChannels"><dd> <p>Confirms the input channel count of the destination voice.</p> </dd></param>	
        /// <param name="levelMatrixRef"><dd> <p>Array of [<em>SourceChannels</em> ? <em>DestinationChannels</em>] volume levels sent to the destination voice. The level sent from source channel <em>S</em> to destination channel <em>D</em> is specified in the form <em>pLevelMatrix</em>[<em>SourceChannels</em> ? <em>D</em> + <em>S</em>]. </p> <p>For example, when rendering two-channel stereo input into 5.1 output that is weighted toward the front channels?but is absent from the center and low-frequency channels?the matrix might have the values shown in the following table. </p> <table> <tr><th>Output</th><th>Left Input [Array Index]</th><th>Right Input [Array Index]</th></tr> <tr><td>Left</td><td>1.0 [0]</td><td>0.0 [1]</td></tr> <tr><td>Right</td><td>0.0 [2]</td><td>1.0 [3]</td></tr> <tr><td>Front Center</td><td>0.0 [4]</td><td>0.0 [5]</td></tr> <tr><td>LFE</td><td>0.0 [6]</td><td>0.0 [7]</td></tr> <tr><td>Rear Left</td><td>0.8 [8]</td><td>0.0 [9]</td></tr> <tr><td>Rear Right</td><td>0.0 [10]</td><td>0.8 [11]</td></tr> </table> <p>?</p> <p><strong>Note</strong>??The left and right input are fully mapped to the output left and right channels; 80 percent of the left and right input is mapped to the rear left and right channels.</p> <p>See Remarks for more information on volume levels.</p> </dd></param>	
        /// <param name="operationSet"><dd> <p>Identifies this call as part of a deferred batch. See the XAudio2 Operation Sets overview for more information.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method is valid only for source and submix voices, because mastering voices write directly to the device with no matrix mixing. </p><p>Volume levels are expressed as floating-point amplitude multipliers between -<see cref="SharpDX.XAudio2.XAudio2.MaximumVolumeLevel"/> and <see cref="SharpDX.XAudio2.XAudio2.MaximumVolumeLevel"/> (-224 to 224), with a maximum gain of 144.5 dB. A volume level of 1.0 means there is no attenuation or gain and 0 means silence. Negative levels can be used to invert the audio's phase. See XAudio2 Volume and Pitch Control for additional information on volume control. </p><p>The X3DAudio function <strong>X3DAudioCalculate</strong> can produce an output matrix for use with <strong>SetOutputMatrix</strong> based on a sound's position and a listener's position.</p><p><strong>Note</strong>??<strong><see cref="SharpDX.XAudio2.Voice.GetOutputMatrix"/></strong> always returns the levels most recently set by <strong><see cref="SharpDX.XAudio2.Voice.SetOutputMatrix"/></strong>. However, they may not actually be in effect yet: they only take effect the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.SetOutputMatrix"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.Voice.SetOutputMatrix"/></strong> was called with a deferred operation ID).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::SetOutputMatrix']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.setoutputmatrix</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2Voice::SetOutputMatrix([In, Optional] IXAudio2Voice* pDestinationVoice,[In] unsigned int SourceChannels,[In] unsigned int DestinationChannels,[In, Buffer] const float* pLevelMatrix,[In] unsigned int OperationSet)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::SetOutputMatrix</unmanaged-short>	
        public void SetOutputMatrix(SharpDX.XAudio2.Voice destinationVoiceRef, int sourceChannels, int destinationChannels, float[] levelMatrixRef, int operationSet = 0) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* levelMatrixRef_ = levelMatrixRef)
                    __result__= 
    				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, (void*)((destinationVoiceRef == null)?IntPtr.Zero:destinationVoiceRef.NativePointer), sourceChannels, destinationChannels, levelMatrixRef_, operationSet,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the volume level of each channel of the final output for the voice. These channels are mapped to the input channels of a specified destination voice.</p>	
        /// </summary>	
        /// <param name="destinationVoiceRef"><dd> <p>Pointer specifying the destination <strong><see cref="SharpDX.XAudio2.Voice"/></strong> to retrieve the output matrix for.</p> <p><strong>Note</strong>??If the voice sends to a single target voice then specifying <c>null</c> will cause <strong>GetOutputMatrix</strong> to operate on that target voice.</p> </dd></param>	
        /// <param name="sourceChannels"><dd> <p>Confirms the output channel count of the voice. This is the number of channels that are produced by the last effect in the chain.</p> </dd></param>	
        /// <param name="destinationChannels"><dd> <p>Confirms the input channel count of the destination voice.</p> </dd></param>	
        /// <param name="levelMatrixRef"><dd> <p>Array of [<em>SourceChannels</em> * <em>DestinationChannels</em>] volume levels sent to the destination voice. The level sent from source channel S to destination channel D is returned in the form <em>pLevelMatrix</em>[<em>DestinationChannels</em> ? S + D]. See Remarks for more information on volume levels.</p> </dd></param>	
        /// <remarks>	
        /// <p>This method applies only to source and submix voices, because mastering voices write directly to the device with no matrix mixing. Volume levels are expressed as floating-point amplitude multipliers between -224 to 224, with a maximum gain of 144.5 dB. A volume level of 1 means there is no attenuation or gain and 0 means silence. Negative levels can be used to invert the audio's phase. See XAudio2 Volume and Pitch Control for additional information on volume control. </p><p>See <strong><see cref="SharpDX.Multimedia.WaveFormatExtensible"/></strong> for information on standard channel ordering. </p><p><strong>Note</strong>??<strong>GetOutputMatrix</strong> always returns the levels most recently set by <strong><see cref="SharpDX.XAudio2.Voice.SetOutputMatrix"/></strong>. However, they may not actually be in effect yet: they only take effect the next time the audio engine runs after the <strong><see cref="SharpDX.XAudio2.Voice.SetOutputMatrix"/></strong> call (or after the corresponding <strong><see cref="SharpDX.XAudio2.XAudio2.CommitChanges"/></strong> call, if <strong><see cref="SharpDX.XAudio2.Voice.SetOutputMatrix"/></strong> was called with a deferred operation ID).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::GetOutputMatrix']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.getoutputmatrix</msdn-id>	
        /// <unmanaged>void IXAudio2Voice::GetOutputMatrix([In, Optional] IXAudio2Voice* pDestinationVoice,[In] unsigned int SourceChannels,[In] unsigned int DestinationChannels,[Out, Buffer] float* pLevelMatrix)</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::GetOutputMatrix</unmanaged-short>	
        public void GetOutputMatrix(SharpDX.XAudio2.Voice destinationVoiceRef, int sourceChannels, int destinationChannels, float[] levelMatrixRef) {
            unsafe {
                fixed (void* levelMatrixRef_ = levelMatrixRef)
                    SharpDX.XAudio2.LocalInterop.Callivoid(_nativePointer, (void*)((destinationVoiceRef == null)?IntPtr.Zero:destinationVoiceRef.NativePointer), sourceChannels, destinationChannels, levelMatrixRef_,((void**)(*(void**)_nativePointer))[17]);		
            }
        }
        
        /// <summary>	
        /// <p>Destroys the voice. If necessary, stops the voice and removes it from the XAudio2 graph.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If any other voice is currently sending audio to this voice, the method fails. </p><p><strong>DestroyVoice</strong> waits for the audio processing thread to be idle, so it can take a little while (typically no more than a couple of milliseconds). This is necessary to guarantee that the voice will no longer make any callbacks or read any audio data, so the application can safely free up these resources as soon as the call returns. </p><p>To avoid title thread interruptions from a blocking <strong>DestroyVoice</strong> call, the application can destroy voices on a separate non-critical thread, or the application can use voice pooling strategies to reuse voices rather than destroying them. Note that voices can only be reused with audio that has the same data format and the same number of channels the voice was created with. A voice can play audio data with different sample rates than that of the voice by calling <strong><see cref="SharpDX.XAudio2.SourceVoice.SetFrequencyRatio"/></strong> with an appropriate ratio parameter. </p><p>It is invalid to call <strong>DestroyVoice</strong> from within a callback (that is, <strong><see cref="SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong>).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2Voice::DestroyVoice']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voice.ixaudio2voice.destroyvoice</msdn-id>	
        /// <unmanaged>void IXAudio2Voice::DestroyVoice()</unmanaged>	
        /// <unmanaged-short>IXAudio2Voice::DestroyVoice</unmanaged-short>	
        public void DestroyVoice() {
            unsafe {
                SharpDX.XAudio2.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[18]);		
            }
        }
    }
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong> interface contains methods that notify the client when certain events happen in a given <strong><see cref="SharpDX.XAudio2.SourceVoice"/></strong>. </p><p>This interface should be implemented by the XAudio2 client. XAudio2 calls these methods through an interface reference provided by the client in the <strong><see cref="SharpDX.XAudio2.XAudio2.CreateSourceVoice_"/></strong> method. Methods in this interface return void, rather than an <see cref="SharpDX.Result"/>. 	
    /// </p><p>See the XAudio2 Callbacks topic for restrictions on callback implementation.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2VoiceCallback']/*"/>	
    /// <msdn-id>microsoft.directx_sdk.ixaudio2voicecallback.ixaudio2voicecallback</msdn-id>	
    /// <unmanaged>IXAudio2VoiceCallback</unmanaged>	
    /// <unmanaged-short>IXAudio2VoiceCallback</unmanaged-short>	
    public partial interface VoiceCallback : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p>Called during each processing pass for each voice, just before XAudio2 reads data from the voice's buffer queue.</p>	
        /// </summary>	
        /// <param name="bytesRequired"><dd> <p> The number of bytes that must be submitted immediately to avoid starvation. This allows the implementation of just-in-time streaming scenarios; the client can keep the absolute minimum data queued on the voice at all times, and pass it fresh data just before the data is required. This model provides the lowest possible latency attainable with XAudio2. For xWMA and XMA data <em>BytesRequired</em> will always be zero, since the concept of a frame of xWMA or XMA data is meaningless. </p> <p><strong>Note</strong>??In a situation where there is always plenty of data available on the source voice, <em>BytesRequired</em> should always report zero, because it doesn't need any samples immediately to avoid glitching.</p> </dd></param>	
        /// <remarks>	
        /// <p>For information about <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong> interface methods, see the XAudio2 Callbacks topic.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2VoiceCallback::OnVoiceProcessingPassStart']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voicecallback.ixaudio2voicecallback.onvoiceprocessingpassstart</msdn-id>	
        /// <unmanaged>void IXAudio2VoiceCallback::OnVoiceProcessingPassStart([In] unsigned int BytesRequired)</unmanaged>	
        /// <unmanaged-short>IXAudio2VoiceCallback::OnVoiceProcessingPassStart</unmanaged-short>	
        /* public void OnVoiceProcessingPassStart(int bytesRequired) */
        
        /// <summary>	
        /// <p>Called just after the processing pass for the voice ends.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>For information about <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong> interface methods, see the XAudio2 Callbacks topic.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2VoiceCallback::OnVoiceProcessingPassEnd']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voicecallback.ixaudio2voicecallback.onvoiceprocessingpassend</msdn-id>	
        /// <unmanaged>void IXAudio2VoiceCallback::OnVoiceProcessingPassEnd()</unmanaged>	
        /// <unmanaged-short>IXAudio2VoiceCallback::OnVoiceProcessingPassEnd</unmanaged-short>	
        /* public void OnVoiceProcessingPassEnd() */
        
        /// <summary>	
        /// <p>Called when the voice has just finished playing a contiguous audio stream.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p><strong>OnStreamEnd</strong> is triggered when XAudio2 processes an <strong><see cref="SharpDX.XAudio2.AudioBuffer"/></strong> with the <see cref="SharpDX.XAudio2.BufferFlags.EndOfStream"/> flag set. See the <strong><see cref="SharpDX.XAudio2.SourceVoice.SubmitSourceBuffer"/></strong> method for more information. </p><p>The <strong>OnStreamEnd</strong> callback indicates that XAudio2 has finished consuming the last buffer submitted to the voice. With PCM data, all audio is guaranteed to have been played and the voice can be stopped or destroyed safely.  </p><p>The <strong>OnStreamEnd</strong> callback only indicates that an <strong><see cref="SharpDX.XAudio2.AudioBuffer"/></strong> with the <see cref="SharpDX.XAudio2.BufferFlags.EndOfStream"/> flag set has been processed. The callback is strictly informational and does not change the state of the source voice that triggered it. A voice stays in the start state until <strong><see cref="SharpDX.XAudio2.SourceVoice.Stop"/></strong> is called and will continue to play submitted source buffers and to trigger additional callbacks. </p><p><strong>OnStreamEnd</strong> is guaranteed to be called just after the last byte of the current buffer has been consumed. </p><p>For information about <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong> interface methods, see the XAudio2 Callbacks topic.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2VoiceCallback::OnStreamEnd']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voicecallback.ixaudio2voicecallback.onstreamend</msdn-id>	
        /// <unmanaged>void IXAudio2VoiceCallback::OnStreamEnd()</unmanaged>	
        /// <unmanaged-short>IXAudio2VoiceCallback::OnStreamEnd</unmanaged-short>	
        /* public void OnStreamEnd() */
        
        /// <summary>	
        /// <p>Called when the voice is about to start processing a new audio buffer.</p>	
        /// </summary>	
        /// <param name="bufferContextRef"><dd> <p> Context reference that was assigned to the pContext member of the <strong><see cref="SharpDX.XAudio2.AudioBuffer"/></strong> structure when the buffer was submitted.</p> </dd></param>	
        /// <remarks>	
        /// <p><em>pBufferContext</em> is the context reference originally provided by the <strong>pContext</strong> member of the <strong><see cref="SharpDX.XAudio2.AudioBuffer"/></strong> structure, which may be <c>null</c>. </p><p><strong>OnBufferStart</strong> is guaranteed to be called just before the first byte of the current buffer is consumed. It is appropriate to use this callback for changes to the voice state such as the following. </p><ul> <li>Submitting a new buffer to the voice </li> <li>Adjusting the volume, pitch, and effect parameters of the voice </li> <li>Enabling or disabling an effect in the voice's effect chain</li> </ul>All the actions listed above are synchronous when performed in an XAudio2 callback, so the changes will take effect immediately, affecting the buffer that is about to start.<p>It is also safe to use this callback to write audio data to the buffer directly, which can be useful for low-latency streaming scenarios. However, as with all XAudio2 callbacks, no work should be done that uses a significant amount of processor time or could block execution, including synchronous disk or network reads. </p><p>For information about the <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong> interface methods, see the XAudio2 Callbacks section. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2VoiceCallback::OnBufferStart']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voicecallback.ixaudio2voicecallback.onbufferstart</msdn-id>	
        /// <unmanaged>void IXAudio2VoiceCallback::OnBufferStart([In] void* pBufferContext)</unmanaged>	
        /// <unmanaged-short>IXAudio2VoiceCallback::OnBufferStart</unmanaged-short>	
        /* public void OnBufferStart(System.IntPtr bufferContextRef) */
        
        /// <summary>	
        /// <p>Called when the voice finishes processing a buffer. </p>	
        /// </summary>	
        /// <param name="bufferContextRef"><dd> <p>Context reference assigned to the <strong>pContext</strong> member of the <strong><see cref="SharpDX.XAudio2.AudioBuffer"/></strong> structure when the buffer was submitted.</p> </dd></param>	
        /// <remarks>	
        /// <p>After an <strong>OnBufferEnd</strong> callback the audio memory for the buffer associated with <em>pBufferContext</em> can safely be released. </p><p><em>pBufferContext</em> is the context reference originally provided by the <strong>pContext </strong>member of the <strong><see cref="SharpDX.XAudio2.AudioBuffer"/></strong> structure, which may be <c>null</c>. </p><p><strong>OnBufferEnd</strong> is guaranteed to be called just after the last byte of the current buffer has been consumed and before the first byte of the next buffer is consumed. This callback can be used to overwrite or release the audio data referenced by the completed buffer, and to update other state associated with the voice as appropriate. </p><p>For information about <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong> interface methods, see the XAudio2 Callbacks topic.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2VoiceCallback::OnBufferEnd']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voicecallback.ixaudio2voicecallback.onbufferend</msdn-id>	
        /// <unmanaged>void IXAudio2VoiceCallback::OnBufferEnd([In] void* pBufferContext)</unmanaged>	
        /// <unmanaged-short>IXAudio2VoiceCallback::OnBufferEnd</unmanaged-short>	
        /* public void OnBufferEnd(System.IntPtr bufferContextRef) */
        
        /// <summary>	
        /// <p>Called when the voice reaches the end position of a loop.</p>	
        /// </summary>	
        /// <param name="bufferContextRef"><dd> <p> Context reference that was assigned to the <strong>pContext</strong> member of the <strong><see cref="SharpDX.XAudio2.AudioBuffer"/></strong> structure when the buffer was submitted. </p> </dd></param>	
        /// <remarks>	
        /// <p><em>pBufferContext</em> is the context reference originally provided by the <strong>pContext</strong> member of the <strong><see cref="SharpDX.XAudio2.AudioBuffer"/></strong> structure, which may be <c>null</c>. </p><p><strong>OnLoopEnd</strong> is not sample-accurate; that is, actions in the callback do not occur at the exact moment that a given sample is being processed. It is only guaranteed to be called shortly after the last sample in the loop has been processed. </p><p>For information about the <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong> interface methods, see the XAudio2 Callbacks section.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2VoiceCallback::OnLoopEnd']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voicecallback.ixaudio2voicecallback.onloopend</msdn-id>	
        /// <unmanaged>void IXAudio2VoiceCallback::OnLoopEnd([In] void* pBufferContext)</unmanaged>	
        /// <unmanaged-short>IXAudio2VoiceCallback::OnLoopEnd</unmanaged-short>	
        /* public void OnLoopEnd(System.IntPtr bufferContextRef) */
        
        /// <summary>	
        /// <p>Called when a critical error occurs during voice processing.</p>	
        /// </summary>	
        /// <param name="bufferContextRef"><dd> <p> Context reference that was assigned to the <strong>pContext</strong> member of the <strong><see cref="SharpDX.XAudio2.AudioBuffer"/></strong> structure when the buffer was submitted.</p> </dd></param>	
        /// <param name="error"><dd> <p> The <see cref="SharpDX.Result"/> code of the error encountered.</p> </dd></param>	
        /// <remarks>	
        /// <p><strong>OnVoiceError</strong> is called in the event of an error during voice processing, such as a hardware XMA decoder error on the Xbox 360. The arguments report which buffer was being processed at the time of the error, and its <see cref="SharpDX.Result"/> code. If the error is not recoverable by destroying and re-creating the voice, the <strong>OnCriticalError</strong> engine callback will be called as well. 	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2VoiceCallback::OnVoiceError']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2voicecallback.ixaudio2voicecallback.onvoiceerror</msdn-id>	
        /// <unmanaged>void IXAudio2VoiceCallback::OnVoiceError([In] void* pBufferContext,[In] HRESULT Error)</unmanaged>	
        /// <unmanaged-short>IXAudio2VoiceCallback::OnVoiceError</unmanaged-short>	
        /* public void OnVoiceError(System.IntPtr bufferContextRef, SharpDX.Result error) */
    }
    /// <summary>	
    /// <p><see cref="SharpDX.XAudio2.XAudio2"/> is the interface for the XAudio2 object that manages all audio engine states, the audio processing thread, the voice graph, and so forth. </p><p>This is the only XAudio2 interface that is derived from the COM <strong><see cref="SharpDX.ComObject"/></strong> interface. It controls the lifetime of the XAudio2 object using two methods derived from <strong><see cref="SharpDX.ComObject"/></strong><strong>IXAudio2::AddRef</strong> and <strong>IXAudio2::Release</strong>. No other XAudio2 objects are reference-counted. Their lifetimes are explicitly controlled using <em>create</em> and <em>destroy</em> calls, and are bounded by the lifetime of the XAudio2 object that owns them.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The DirectX SDK versions of XAUDIO2 included three member functions that are not present in the Windows 8 version: <strong>GetDeviceCount</strong>, <strong>GetDeviceDetails</strong>, and <strong>Initialize</strong>. These enumeration methods are no longer provided and standard Windows Audio APIs should be used for device enumeration instead. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2']/*"/>	
    /// <msdn-id>microsoft.directx_sdk.ixaudio2.ixaudio2</msdn-id>	
    /// <unmanaged>IXAudio2</unmanaged>	
    /// <unmanaged-short>IXAudio2</unmanaged-short>	
    [Guid("2B02E3CF-2E0B-4ec3-BE45-1B2A3FE7210D")]
    public partial class XAudio2 : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.XAudio2.XAudio2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public XAudio2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.XAudio2.XAudio2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.XAudio2.XAudio2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.XAudio2.XAudio2(nativePointer);
		}
        
        
        /// <summary>Constant MaximumBufferBytes.</summary>
        /// <unmanaged>XAUDIO2_MAX_BUFFER_BYTES</unmanaged>
        public const int MaximumBufferBytes = unchecked((int)-0x080000000);
        
        /// <summary>Constant MaximumQueuedBuffers.</summary>
        /// <unmanaged>XAUDIO2_MAX_QUEUED_BUFFERS</unmanaged>
        public const int MaximumQueuedBuffers = 64;
        
        /// <summary>Constant MaximumAudioChannels.</summary>
        /// <unmanaged>XAUDIO2_MAX_AUDIO_CHANNELS</unmanaged>
        public const int MaximumAudioChannels = 64;
        
        /// <summary>Constant MinimumSampleRate.</summary>
        /// <unmanaged>XAUDIO2_MIN_SAMPLE_RATE</unmanaged>
        public const int MinimumSampleRate = 1000;
        
        /// <summary>Constant MaximumSampleRate.</summary>
        /// <unmanaged>XAUDIO2_MAX_SAMPLE_RATE</unmanaged>
        public const int MaximumSampleRate = 200000;
        
        /// <summary>Constant MaximumVolumeLevel.</summary>
        /// <unmanaged>XAUDIO2_MAX_VOLUME_LEVEL</unmanaged>
        public const float MaximumVolumeLevel = 1.6777216e+7f;
        
        /// <summary>Constant MinimumFrequencyRatio.</summary>
        /// <unmanaged>XAUDIO2_MIN_FREQ_RATIO</unmanaged>
        public const float MinimumFrequencyRatio = 9.765625e-4f;
        
        /// <summary>Constant MaximumFrequencyRatio.</summary>
        /// <unmanaged>XAUDIO2_MAX_FREQ_RATIO</unmanaged>
        public const float MaximumFrequencyRatio = 1.024e+3f;
        
        /// <summary>Constant DefaultFrequencyRatio.</summary>
        /// <unmanaged>XAUDIO2_DEFAULT_FREQ_RATIO</unmanaged>
        public const float DefaultFrequencyRatio = 2.0e+0f;
        
        /// <summary>Constant MaximumFilterOneOverQ.</summary>
        /// <unmanaged>XAUDIO2_MAX_FILTER_ONEOVERQ</unmanaged>
        public const float MaximumFilterOneOverQ = 1.5e+0f;
        
        /// <summary>Constant MaximumFilterFrequency.</summary>
        /// <unmanaged>XAUDIO2_MAX_FILTER_FREQUENCY</unmanaged>
        public const float MaximumFilterFrequency = 1.0e+0f;
        
        /// <summary>Constant MaximumLoopCount.</summary>
        /// <unmanaged>XAUDIO2_MAX_LOOP_COUNT</unmanaged>
        public const int MaximumLoopCount = 254;
        
        /// <summary>Constant CommitNow.</summary>
        /// <unmanaged>XAUDIO2_COMMIT_NOW</unmanaged>
        public const int CommitNow = 0;
        
        /// <summary>Constant CommitAll.</summary>
        /// <unmanaged>XAUDIO2_COMMIT_ALL</unmanaged>
        public const int CommitAll = 0;
        
        /// <summary>Constant NoLoopRegion.</summary>
        /// <unmanaged>XAUDIO2_NO_LOOP_REGION</unmanaged>
        public const int NoLoopRegion = 0;
        
        /// <summary>Constant DefaultChannels.</summary>
        /// <unmanaged>XAUDIO2_DEFAULT_CHANNELS</unmanaged>
        public const int DefaultChannels = 0;
        
        /// <summary>Constant DefaultSampleRate.</summary>
        /// <unmanaged>XAUDIO2_DEFAULT_SAMPLERATE</unmanaged>
        public const int DefaultSampleRate = 0;
        
        /// <summary>	
        /// <p>Returns current resource usage details, such as available memory or CPU usage.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>For specific information on the statistics returned by <strong>GetPerformanceData</strong>, see the <strong><see cref="SharpDX.XAudio2.PerformanceData"/></strong> structure reference. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2::GetPerformanceData']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2.ixaudio2.getperformancedata</msdn-id>	
        /// <unmanaged>GetPerformanceData</unmanaged>	
        /// <unmanaged-short>GetPerformanceData</unmanaged-short>	
        /// <unmanaged>void IXAudio2::GetPerformanceData([Out] XAUDIO2_PERFORMANCE_DATA* pPerfData)</unmanaged>
        public SharpDX.XAudio2.PerformanceData PerformanceData {
                get { SharpDX.XAudio2.PerformanceData __output__; GetPerformanceData(out __output__); return __output__; }
        }
        
        private int RegisterForCallbacks___vtbl_index = 3;
        /// <summary>	
        /// <p>Adds an <strong><see cref="SharpDX.XAudio2.EngineCallback"/></strong> reference to the <strong>XAudio2</strong> engine callback list.</p>	
        /// </summary>	
        /// <param name="callbackRef">No documentation.</param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method can be called multiple times, allowing different components or layers of the same application to manage their own engine callback implementations separately. </p><p>It is invalid to call <strong>RegisterForCallbacks</strong> from within a callback (that is, <strong><see cref="SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong>). If <strong>RegisterForCallbacks</strong> is called within a callback, it returns <see cref="SharpDX.XAudio2.ResultCode.InvalidCall"/>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2::RegisterForCallbacks']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2.ixaudio2.registerforcallbacks</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2::RegisterForCallbacks([In] IXAudio2EngineCallback* pCallback)</unmanaged>	
        /// <unmanaged-short>IXAudio2::RegisterForCallbacks</unmanaged-short>	
        internal void RegisterForCallbacks_(System.IntPtr callbackRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, (void*)callbackRef,((void**)(*(void**)_nativePointer))[RegisterForCallbacks___vtbl_index]);		
                __result__.CheckError();
            }
        }
        
        private int UnregisterForCallbacks___vtbl_index = 4;
        /// <summary>	
        /// <p>Removes an <strong><see cref="SharpDX.XAudio2.EngineCallback"/></strong> reference from the <strong>XAudio2</strong> engine callback list.</p>	
        /// </summary>	
        /// <param name="callbackRef">No documentation.</param>	
        /// <remarks>	
        /// <p>It is invalid to call <strong>UnregisterForCallbacks</strong> from within a callback (that is, <strong><see cref="SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong>). </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2::UnregisterForCallbacks']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2.ixaudio2.unregisterforcallbacks</msdn-id>	
        /// <unmanaged>void IXAudio2::UnregisterForCallbacks([In] IXAudio2EngineCallback* pCallback)</unmanaged>	
        /// <unmanaged-short>IXAudio2::UnregisterForCallbacks</unmanaged-short>	
        internal void UnregisterForCallbacks_(System.IntPtr callbackRef) {
            unsafe {
                SharpDX.XAudio2.LocalInterop.Callivoid(_nativePointer, (void*)callbackRef,((void**)(*(void**)_nativePointer))[UnregisterForCallbacks___vtbl_index]);		
            }
        }
        
        private int CreateSourceVoice___vtbl_index = 5;
        /// <summary>	
        /// <p>Creates and configures a source voice.</p>	
        /// </summary>	
        /// <param name="sourceVoiceOut"><dd> <p>If successful, returns a reference to the new <strong><see cref="SharpDX.XAudio2.SourceVoice"/></strong> object.</p> </dd></param>	
        /// <param name="sourceFormatRef"><dd> <p>Pointer to a one of the structures in the table below. This structure contains the expected format for all audio buffers submitted to the source voice. XAudio2 supports PCM and ADPCM voice types. </p> <table> <tr><th>Format tag</th><th>Wave format structure</th><th>Size (in bytes)</th></tr> <tr><td><see cref="SharpDX.Multimedia.WaveFormatEncoding.Pcm"/> (0x0001) </td><td> <strong>PCMWAVEFORMAT</strong> </td><td>16</td></tr> <tr><td>-or-</td><td> <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> </td><td>18</td></tr> <tr><td><see cref="SharpDX.Multimedia.WaveFormatEncoding.IeeeFloat"/> (0x0003) [32-bit]</td><td> <strong>PCMWAVEFORMAT</strong> </td><td>18</td></tr> <tr><td><see cref="SharpDX.Multimedia.WaveFormatEncoding.Adpcm"/> (0x0002) [MS-ADPCM]</td><td> <strong>ADPCMWAVEFORMAT</strong> </td><td>50</td></tr> <tr><td><see cref="SharpDX.Multimedia.WaveFormatEncoding.Extensible"/> (0xFFFE)</td><td> <strong><see cref="SharpDX.Multimedia.WaveFormatExtensible"/></strong> </td><td>40</td></tr> </table> <p>?</p> <p>XAudio2 supports the following PCM formats.</p> <ul> <li>8-bit (unsigned) integer PCM </li> <li>16-bit integer PCM (optimal format for XAudio2) </li> <li>20-bit integer PCM (either in 24 or 32 bit containers) </li> <li>24-bit integer PCM (either in 24 or 32 bit containers) </li> <li>32-bit integer PCM </li> <li>32-bit float PCM (preferred format after 16-bit integer)</li> </ul> <p>The number of channels in a source voice must be less than or equal to <see cref="SharpDX.XAudio2.XAudio2.MaximumAudioChannels"/>. The sample rate of a source voice must be between <see cref="SharpDX.XAudio2.XAudio2.MinimumSampleRate"/> and <see cref="SharpDX.XAudio2.XAudio2.MaximumSampleRate"/>.</p> <p><strong>Note</strong>??PCM data formats such as <strong>PCMWAVEFORMAT</strong> and  <strong>ADPCMWAVEFORMAT</strong> that require more information than provided by <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> have a <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure as the first member in their format structures. When you create a source voice with one of those formats, cast the format's structure as a <strong><see cref="SharpDX.Multimedia.WaveFormat"/></strong> structure and use it as the value for <em>pSourceFormat</em>.</p> </dd></param>	
        /// <param name="flags"><dd> <p>Flags that specify the behavior of the source voice. A flag can be 0 or a combination of one or more of the following:</p> <table> <tr><th>Value</th><th>Description</th></tr> <tr><td><see cref="SharpDX.XAudio2.VoiceFlags.NoPitch"/></td><td>No pitch control is available on the voice.?</td></tr> <tr><td><see cref="SharpDX.XAudio2.VoiceFlags.NoSampleRateConversion"/></td><td>No sample rate conversion is available on the voice.  The voice's outputs must have the same sample rate.<p><strong>Note</strong>??The <see cref="SharpDX.XAudio2.VoiceFlags.NoSampleRateConversion"/> flag causes the voice to behave as though the <see cref="SharpDX.XAudio2.VoiceFlags.NoPitch"/> flag also is specified.</p> </td></tr> <tr><td><see cref="SharpDX.XAudio2.VoiceFlags.UseFilter"/></td><td>The filter effect should be available on this voice.?</td></tr> </table> <p>?</p> <p><strong>Note</strong>??The XAUDIO2_VOICE_MUSIC flag is not supported on Windows.</p> </dd></param>	
        /// <param name="maxFrequencyRatio"><dd> <p>Highest allowable frequency ratio that can be set on this voice. The value for this argument must be between <see cref="SharpDX.XAudio2.XAudio2.MinimumFrequencyRatio"/> and <see cref="SharpDX.XAudio2.XAudio2.MaximumFrequencyRatio"/>. Subsequent calls to <strong><see cref="SharpDX.XAudio2.SourceVoice.SetFrequencyRatio"/></strong> are clamped between <see cref="SharpDX.XAudio2.XAudio2.MinimumFrequencyRatio"/> and <strong>MaxFrequencyRatio</strong>. The maximum value for this argument is defined as <see cref="SharpDX.XAudio2.XAudio2.MaximumFrequencyRatio"/>, which allows pitch to be raised by up to 10 octaves. </p> <p>If <em>MaxFrequencyRatio</em> is less than 1.0, the voice will use that ratio immediately after being created (rather than the default of 1.0). </p> <p> </p><table> <tr><th>Xbox 360</th></tr> <tr><td>For XMA voices, there is one more restriction on the <em>MaxFrequencyRatio</em> argument and the voice's sample rate. The product of these two numbers cannot exceed XAUDIO2_MAX_RATIO_TIMES_RATE_XMA_MONO for one-channel voices or XAUDIO2_MAX_RATIO_TIMES_RATE_XMA_MULTICHANNEL for voices with any other number of channels. If the value specified for <em>MaxFrequencyRatio</em> is too high for the specified format, the call to <strong>CreateSourceVoice</strong> fails and produces a debug message.</td></tr> </table> <p>?</p> <p><strong>Note</strong>??You can use the lowest possible <em>MaxFrequencyRatio</em> value to reduce XAudio2's memory usage.</p> </dd></param>	
        /// <param name="callbackRef"><dd> <p>Pointer to a client-provided callback interface, <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong>.</p> </dd></param>	
        /// <param name="sendListRef"><dd> <p>Pointer to a list of <strong><see cref="SharpDX.XAudio2.VoiceSendDescriptors"/></strong> structures that describe the set of destination voices for the source voice. If pSendList is <c>null</c>, the send list defaults to a single output to the first mastering voice created.</p> </dd></param>	
        /// <param name="effectChainRef"><dd> <p>Pointer to a list of <strong><see cref="SharpDX.XAudio2.EffectChain"/></strong> structures that describe an effect chain to use in the source voice.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise, an error code.  </p><p>See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2-specific error codes.</p></returns>	
        /// <remarks>	
        /// <p>Source voices read audio data from the client. They process the data and send it to the XAudio2 processing graph. </p><p>A source voice includes a variable-rate sample rate conversion, to convert data from the source format sample rate to the output rate required for the voice send list. If you use a <c>null</c> send list, the target sample rate will be the mastering voice's input sample rate. If you provide a single voice in pSendList, that voice's input sample rate is the target rate. If you provide multiple voices in the pSendList, all the source voice's output voices must be running at the same input sample rate. </p><p>You cannot create any source or submix voices until a mastering voice exists, and you cannot destory a mastering voice if any source or submix voices still exist. </p><p>Source voices are always processed before any submix or mastering voices. This means that you do not need a ProcessingStage parameter to control the processing order. </p><p>When first created, source voices are in the stopped state. </p><p>XAudio2 uses an internal memory pooler for voices with the same format. This means memory allocation for voices will occur less frequently as more voices are created and then destroyed. To minimize just-in-time allocations, a title can create the anticipated maximum number of voices needed up front, and then delete them as necessary. Voices will then be reused from the XAudio2 pool. The memory pool is tied to an XAudio2 engine instance. You can reclaim all the memory used by an instance of the XAudio2 engine by destroying the XAudio2 object and recreating it as necessary (forcing the memory pool to grow via preallocation would have to be reapplied as needed). </p><p>It is invalid to call <strong>CreateSourceVoice</strong> from within a callback (that is, <strong><see cref="SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong>). If you call <strong>CreateSourceVoice</strong> within a callback, it returns <see cref="SharpDX.XAudio2.ResultCode.InvalidCall"/>. </p><p>The <strong><see cref="SharpDX.XAudio2.EffectChain"/></strong> that is passed in as the pEffectChain argument and any <strong><see cref="SharpDX.XAudio2.EffectDescriptor"/></strong> information contained within it are no longer needed after <strong>CreateSourceVoice</strong> successfully completes, and may be deleted immediately after <strong>CreateSourceVoice</strong> is called.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2::CreateSourceVoice']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2.ixaudio2.createsourcevoice</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2::CreateSourceVoice([Out, Fast] IXAudio2SourceVoice** ppSourceVoice,[In] const void* pSourceFormat,[In] XAUDIO2_VOICE_FLAGS Flags,[In] float MaxFrequencyRatio,[In, Optional] IXAudio2VoiceCallback* pCallback,[In, Optional] const XAUDIO2_VOICE_SENDS* pSendList,[In, Optional] const XAUDIO2_EFFECT_CHAIN* pEffectChain)</unmanaged>	
        /// <unmanaged-short>IXAudio2::CreateSourceVoice</unmanaged-short>	
        internal void CreateSourceVoice_(SharpDX.XAudio2.SourceVoice sourceVoiceOut, System.IntPtr sourceFormatRef, SharpDX.XAudio2.VoiceFlags flags, float maxFrequencyRatio, System.IntPtr callbackRef, SharpDX.XAudio2.VoiceSendDescriptors? sendListRef, SharpDX.XAudio2.EffectChain? effectChainRef) {
            unsafe {
                IntPtr sourceVoiceOut_ = IntPtr.Zero;
                SharpDX.XAudio2.VoiceSendDescriptors sendListRef_;
                if (sendListRef.HasValue)
                    sendListRef_ = sendListRef.Value;				
                SharpDX.XAudio2.EffectChain effectChainRef_;
                if (effectChainRef.HasValue)
                    effectChainRef_ = effectChainRef.Value;				
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, &sourceVoiceOut_, (void*)sourceFormatRef, unchecked((int)flags), maxFrequencyRatio, (void*)callbackRef, (sendListRef.HasValue)?&sendListRef_:(void*)IntPtr.Zero, (effectChainRef.HasValue)?&effectChainRef_:(void*)IntPtr.Zero,((void**)(*(void**)_nativePointer))[CreateSourceVoice___vtbl_index]);		
                ((SharpDX.XAudio2.SourceVoice)sourceVoiceOut).NativePointer = sourceVoiceOut_;
                __result__.CheckError();
            }
        }
        
        private int CreateSubmixVoice__vtbl_index = 6;
        /// <summary>	
        /// <p>Creates and configures a submix voice.</p>	
        /// </summary>	
        /// <param name="submixVoiceOut"><dd> <p>On success, returns a reference to the new <strong><see cref="SharpDX.XAudio2.SubmixVoice"/></strong> object.</p> </dd></param>	
        /// <param name="inputChannels"><dd> <p>Number of channels in the input audio data of the submix voice. <em>InputChannels</em> must be less than or equal to <see cref="SharpDX.XAudio2.XAudio2.MaximumAudioChannels"/>.</p> </dd></param>	
        /// <param name="inputSampleRate"><dd> <p>Sample rate of the input audio data of submix voice. This rate must be a multiple of XAUDIO2_QUANTUM_DENOMINATOR. <em>InputSampleRate</em> must be between <see cref="SharpDX.XAudio2.XAudio2.MinimumSampleRate"/> and <see cref="SharpDX.XAudio2.XAudio2.MaximumSampleRate"/>. </p> </dd></param>	
        /// <param name="flags"><dd> <p>Flags that specify the behavior of the submix voice. It can be 0 or the following:</p> <table> <tr><th>Value</th><th>Description</th></tr> <tr><td><see cref="SharpDX.XAudio2.VoiceFlags.UseFilter"/></td><td>The filter effect should be available on this voice.</td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="processingStage"><dd> <p>An arbitrary number that specifies when this voice is processed with respect to other submix voices, if the XAudio2 engine is running other submix voices. The voice is processed after all other voices that include a smaller <em>ProcessingStage</em> value and before all other voices that include a larger <em>ProcessingStage</em> value. Voices that include the same <em>ProcessingStage</em> value are processed in any order. A submix voice cannot send to another submix voice with a lower or equal <em>ProcessingStage</em> value. This prevents audio being lost due to a submix cycle. </p> </dd></param>	
        /// <param name="sendListRef"><dd> <p>Pointer to a list of <strong><see cref="SharpDX.XAudio2.VoiceSendDescriptors"/></strong> structures that describe the set of destination voices for the submix voice. If <em>pSendList</em> is <c>null</c>, the send list will default to a single output to the first mastering voice created.</p> </dd></param>	
        /// <param name="effectChainRef"><dd> <p>Pointer to a list of <strong><see cref="SharpDX.XAudio2.EffectChain"/></strong> structures that describe an effect chain to use in the submix voice. </p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise, an error code.  </p><p>See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes. </p></returns>	
        /// <remarks>	
        /// <p>Submix voices receive the output of one or more source or submix voices. They process the output, and then send it to another submix voice or to a mastering voice. </p><p>A submix voice performs a sample rate conversion from the input sample rate to the input rate of its output voices in <em>pSendList</em>. If you specify multiple voice sends, they must all have the input same sample rate. </p><p>You cannot create any source or submix voices until a mastering voice exists, and you cannot destroy a mastering voice if any source or submix voices still exist. </p><p>When first created, submix voices are in the started state. </p><p>XAudio2 uses an internal memory pooler for voices with the same format. This means that memory allocation for voices will occur less frequently as more voices are created and then destroyed. To minimize just-in-time allocations, a title can create the anticipated maximum number of voices needed up front, and then delete them as necessary. Voices will then be reused from the XAudio2 pool. The memory pool is tied to an XAudio2 engine instance. You can reclaim all the memory used by an instance of the XAudio2 engine by destroying the XAudio2 object and recreating it as necessary (forcing the memory pool to grow via preallocation would have to be reapplied as needed). </p><p>It is invalid to call <strong>CreateSubmixVoice</strong> from within a callback (that is, <strong><see cref="SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong>). If you call <strong>CreateSubmixVoice</strong> within a callback, it returns <see cref="SharpDX.XAudio2.ResultCode.InvalidCall"/>. </p><p>The <strong><see cref="SharpDX.XAudio2.EffectChain"/></strong> that is passed in as the <em>pEffectChain</em> argument and any <strong><see cref="SharpDX.XAudio2.EffectDescriptor"/></strong> information contained within it are no longer needed after <strong>CreateSubmixVoice</strong> successfully completes, and may be deleted immediately after <strong>CreateSubmixVoice</strong> is called.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2::CreateSubmixVoice']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2.ixaudio2.createsubmixvoice</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2::CreateSubmixVoice([Out, Fast] IXAudio2SubmixVoice** ppSubmixVoice,[In] unsigned int InputChannels,[In] unsigned int InputSampleRate,[In] unsigned int Flags,[In] unsigned int ProcessingStage,[In, Optional] const XAUDIO2_VOICE_SENDS* pSendList,[In, Optional] const XAUDIO2_EFFECT_CHAIN* pEffectChain)</unmanaged>	
        /// <unmanaged-short>IXAudio2::CreateSubmixVoice</unmanaged-short>	
        internal void CreateSubmixVoice(SharpDX.XAudio2.SubmixVoice submixVoiceOut, int inputChannels, int inputSampleRate, int flags, int processingStage, SharpDX.XAudio2.VoiceSendDescriptors? sendListRef, SharpDX.XAudio2.EffectChain? effectChainRef) {
            unsafe {
                IntPtr submixVoiceOut_ = IntPtr.Zero;
                SharpDX.XAudio2.VoiceSendDescriptors sendListRef_;
                if (sendListRef.HasValue)
                    sendListRef_ = sendListRef.Value;				
                SharpDX.XAudio2.EffectChain effectChainRef_;
                if (effectChainRef.HasValue)
                    effectChainRef_ = effectChainRef.Value;				
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, &submixVoiceOut_, inputChannels, inputSampleRate, flags, processingStage, (sendListRef.HasValue)?&sendListRef_:(void*)IntPtr.Zero, (effectChainRef.HasValue)?&effectChainRef_:(void*)IntPtr.Zero,((void**)(*(void**)_nativePointer))[CreateSubmixVoice__vtbl_index]);		
                ((SharpDX.XAudio2.SubmixVoice)submixVoiceOut).NativePointer = submixVoiceOut_;
                __result__.CheckError();
            }
        }
        
        private int CreateMasteringVoice__vtbl_index = 7;
        /// <summary>	
        /// <p>Creates and configures a mastering voice.</p>	
        /// </summary>	
        /// <param name="masteringVoiceOut"><dd> <p> If successful, returns a reference to the new <strong><see cref="SharpDX.XAudio2.MasteringVoice"/></strong> object.</p> </dd></param>	
        /// <param name="inputChannels"><dd> <p>Number of channels the mastering voice expects in its input audio. <em>InputChannels</em> must be less than or equal to <see cref="SharpDX.XAudio2.XAudio2.MaximumAudioChannels"/>. </p> <p>You can set <em>InputChannels</em> to <see cref="SharpDX.XAudio2.XAudio2.DefaultChannels"/>, which causes XAudio2 to try to detect the system speaker configuration setup. </p> </dd></param>	
        /// <param name="inputSampleRate"><dd> <p>Sample rate of the input audio data of the mastering voice. This rate must be a multiple of XAUDIO2_QUANTUM_DENOMINATOR. <em>InputSampleRate</em> must be between <see cref="SharpDX.XAudio2.XAudio2.MinimumSampleRate"/> and <see cref="SharpDX.XAudio2.XAudio2.MaximumSampleRate"/>. </p> <p>You can set <em>InputSampleRate</em> to <see cref="SharpDX.XAudio2.XAudio2.DefaultSampleRate"/>, with the default being determined by the current platform. </p> <p>Windows XP defaults to 44100. </p> <p>Windows Vista and Windows 7 default to the setting specified in the Sound Control Panel. The default for this setting is 44100 (or 48000 if required by the driver). Flags</p> </dd></param>	
        /// <param name="flags"><dd> <p> Flags that specify the behavior of the mastering voice. Must be 0.</p> </dd></param>	
        /// <param name="szDeviceId"><dd> <p>Identifier of the device to receive the output audio. Specifying the default value of <c>null</c> causes XAudio2 to select the global default audio device.</p> </dd></param>	
        /// <param name="effectChainRef"><dd> <p>Pointer to an <strong><see cref="SharpDX.XAudio2.EffectChain"/></strong> structure that describes an effect chain to use in the mastering voice, or <c>null</c> to use no effects.</p> </dd></param>	
        /// <param name="streamCategory"><dd> <p>The audio stream category to use for this mastering voice.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise, an error code. Returns <see cref="SharpDX.Win32.ErrorCode.NotFound"/> if no default audio device exists and <c>null</c> is passed in as the szDeviceId parameter.  </p><p>See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes. </p></returns>	
        /// <remarks>	
        /// <p>Mastering voices receive the output of one or more source or submix voices. They process the data, and send it to the audio output device. </p><p>Typically, you should create a mastering voice with an input sample rate that will be used by the majority of the title's audio content. The mastering voice performs a sample rate conversion from this input sample rate to the actual device output rate. </p><p>You cannot create a source or submix voices until a mastering voice exists. You cannot destroy a mastering voice if any source or submix voices still exist. </p><p>Mastering voices are always processed after all source and submix voices. This means that you need not specify a <em>ProcessingStage</em> parameter to control the processing order. </p><p>XAudio2 only allows one mastering voice to exist at once. If you attempt to create more than one voice, <see cref="SharpDX.XAudio2.ResultCode.InvalidCall"/> is returned. If an additional mastering voice is needed, for example for an output device with a different audio category set, you will need to create an additional XAudio2 instance. </p><p>When first created, mastering voices are in the started state. </p><p>It is invalid to call <strong>CreateMasteringVoice</strong> from within a callback (that is, <strong><see cref="SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong>). If you call <strong>CreateMasteringVoice</strong> within a callback, it returns <see cref="SharpDX.XAudio2.ResultCode.InvalidCall"/>. </p><p>The <strong><see cref="SharpDX.XAudio2.EffectChain"/></strong> that is passed in as the pEffectChain argument and any <strong><see cref="SharpDX.XAudio2.EffectDescriptor"/></strong> information contained within it are no longer needed after <strong>CreateMasteringVoice</strong> successfully completes, and may be deleted immediately after <strong>CreateMasteringVoice</strong> is called. </p><p>Note that the DirectX SDK XAUDIO2 version of <strong>CreateMasteringVoice</strong> took a DeviceIndex argument instead of a szDeviceId and a StreamCategory argument. This reflects the changes needed for the standard Windows device enumeration model.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2::CreateMasteringVoice']/*"/>	
        /// <msdn-id>hh405048</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2::CreateMasteringVoice([Out, Fast] IXAudio2MasteringVoice** ppMasteringVoice,[In] unsigned int InputChannels,[In] unsigned int InputSampleRate,[In] unsigned int Flags,[In, Optional] const wchar_t* szDeviceId,[In, Optional] const XAUDIO2_EFFECT_CHAIN* pEffectChain,[In] AUDIO_STREAM_CATEGORY StreamCategory)</unmanaged>	
        /// <unmanaged-short>IXAudio2::CreateMasteringVoice</unmanaged-short>	
        internal void CreateMasteringVoice(SharpDX.XAudio2.MasteringVoice masteringVoiceOut, int inputChannels, int inputSampleRate, int flags, string szDeviceId, SharpDX.XAudio2.EffectChain? effectChainRef, SharpDX.Multimedia.AudioStreamCategory streamCategory) {
            unsafe {
                IntPtr masteringVoiceOut_ = IntPtr.Zero;
                IntPtr szDeviceId_ = Utilities.StringToHGlobalUni(szDeviceId);
                SharpDX.XAudio2.EffectChain effectChainRef_;
                if (effectChainRef.HasValue)
                    effectChainRef_ = effectChainRef.Value;				
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, &masteringVoiceOut_, inputChannels, inputSampleRate, flags, (void*)szDeviceId_, (effectChainRef.HasValue)?&effectChainRef_:(void*)IntPtr.Zero, unchecked((int)streamCategory),((void**)(*(void**)_nativePointer))[CreateMasteringVoice__vtbl_index]);		
                ((SharpDX.XAudio2.MasteringVoice)masteringVoiceOut).NativePointer = masteringVoiceOut_;
                Marshal.FreeHGlobal(szDeviceId_ );
                __result__.CheckError();
            }
        }
        
        private int StartEngine__vtbl_index = 8;
        /// <summary>	
        /// <p>Starts the audio processing thread.</p>	
        /// </summary>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes. </p></returns>	
        /// <remarks>	
        /// <p>After <strong>StartEngine</strong> is called, all started voices begin to consume audio. All enabled effects start running, and the resulting audio is sent to any connected output devices. When XAudio2 is first initialized, the engine is already in the started state. </p><p>It is invalid to call <strong>StartEngine</strong> from within a callback (that is, <strong><see cref="SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong>). If <strong>StartEngine</strong> is called within a callback, it returns <see cref="SharpDX.XAudio2.ResultCode.InvalidCall"/>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2::StartEngine']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2.ixaudio2.startengine</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2::StartEngine()</unmanaged>	
        /// <unmanaged-short>IXAudio2::StartEngine</unmanaged-short>	
        public void StartEngine() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[StartEngine__vtbl_index]);		
                __result__.CheckError();
            }
        }
        
        private int StopEngine__vtbl_index = 9;
        /// <summary>	
        /// <p>Stops the audio processing thread.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>When <strong>StopEngine</strong> is called, all output is stopped immediately. However, the audio graph is left untouched, preserving effect parameters, effect histories (for example, the data stored by a reverb effect in order to emit echoes of a previous sound), voice states, pending source buffers, cursor positions, and so forth. When the engine is restarted, the resulting audio output will be identical?apart from a period of silence?to the output that would have been produced if the engine had never been stopped. </p><p>It is invalid to call <strong>StopEngine</strong> from within a callback (that is, <strong><see cref="SharpDX.XAudio2.EngineCallback"/></strong> or <strong><see cref="SharpDX.XAudio2.VoiceCallback"/></strong>).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2::StopEngine']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2.ixaudio2.stopengine</msdn-id>	
        /// <unmanaged>void IXAudio2::StopEngine()</unmanaged>	
        /// <unmanaged-short>IXAudio2::StopEngine</unmanaged-short>	
        public void StopEngine() {
            unsafe {
                SharpDX.XAudio2.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[StopEngine__vtbl_index]);		
            }
        }
        
        private int CommitChanges__vtbl_index = 10;
        /// <summary>	
        /// <p>Atomically applies a set of operations that are tagged with a given identifier.</p>	
        /// </summary>	
        /// <param name="operationSet"><dd> <p>Identifier of the set of operations to be applied. To commit all pending operations, pass <strong><see cref="SharpDX.XAudio2.XAudio2.CommitAll"/></strong>. </p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; returns an error code otherwise. See <strong>XAudio2 Error Codes</strong> for descriptions of XAudio2 specific error codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>CommitChanges</strong> does nothing if no operations are tagged with the given identifier. </p><p>See the XAudio2 Operation Sets overview about working with <strong>CommitChanges</strong> and XAudio2 interface methods that may be deferred.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2::CommitChanges']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2.ixaudio2.commitchanges</msdn-id>	
        /// <unmanaged>HRESULT IXAudio2::CommitChanges([In] unsigned int OperationSet)</unmanaged>	
        /// <unmanaged-short>IXAudio2::CommitChanges</unmanaged-short>	
        public void CommitChanges(int operationSet = 0) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.XAudio2.LocalInterop.Calliint(_nativePointer, operationSet,((void**)(*(void**)_nativePointer))[CommitChanges__vtbl_index]);		
                __result__.CheckError();
            }
        }
        
        private int GetPerformanceData__vtbl_index = 11;
        /// <summary>	
        /// <p>Returns current resource usage details, such as available memory or CPU usage.</p>	
        /// </summary>	
        /// <param name="perfDataRef"><dd> <p>On success, reference to an <strong><see cref="SharpDX.XAudio2.PerformanceData"/></strong> structure that is returned. </p> </dd></param>	
        /// <remarks>	
        /// <p>For specific information on the statistics returned by <strong>GetPerformanceData</strong>, see the <strong><see cref="SharpDX.XAudio2.PerformanceData"/></strong> structure reference. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2::GetPerformanceData']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2.ixaudio2.getperformancedata</msdn-id>	
        /// <unmanaged>void IXAudio2::GetPerformanceData([Out] XAUDIO2_PERFORMANCE_DATA* pPerfData)</unmanaged>	
        /// <unmanaged-short>IXAudio2::GetPerformanceData</unmanaged-short>	
        internal void GetPerformanceData(out SharpDX.XAudio2.PerformanceData perfDataRef) {
            unsafe {
                perfDataRef = new SharpDX.XAudio2.PerformanceData();
                fixed (void* perfDataRef_ = &perfDataRef)
                    SharpDX.XAudio2.LocalInterop.Callivoid(_nativePointer, perfDataRef_,((void**)(*(void**)_nativePointer))[GetPerformanceData__vtbl_index]);		
            }
        }
        
        private int SetDebugConfiguration__vtbl_index = 12;
        /// <summary>	
        /// <p>Changes global debug logging options for XAudio2.</p>	
        /// </summary>	
        /// <param name="debugConfigurationRef"><dd> <p>Pointer to a <strong><see cref="SharpDX.XAudio2.DebugConfiguration"/></strong> structure that contains the new debug configuration.</p> </dd></param>	
        /// <param name="reservedRef">No documentation.</param>	
        /// <remarks>	
        /// <p>SetDebugConfiguration sets the debug configuration for the given instance of XAudio2 engine. See <strong><see cref="SharpDX.XAudio2.DebugConfiguration"/></strong> Structure for supported debug options. By default, XAudio2 does not log debug output or break on errors. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IXAudio2::SetDebugConfiguration']/*"/>	
        /// <msdn-id>microsoft.directx_sdk.ixaudio2.ixaudio2.setdebugconfiguration</msdn-id>	
        /// <unmanaged>void IXAudio2::SetDebugConfiguration([In, Value] const XAUDIO2_DEBUG_CONFIGURATION* pDebugConfiguration,[In] void* pReserved)</unmanaged>	
        /// <unmanaged-short>IXAudio2::SetDebugConfiguration</unmanaged-short>	
        public void SetDebugConfiguration(SharpDX.XAudio2.DebugConfiguration debugConfigurationRef, System.IntPtr reservedRef) {
            unsafe {
                SharpDX.XAudio2.LocalInterop.Callivoid(_nativePointer, &debugConfigurationRef, (void*)reservedRef,((void**)(*(void**)_nativePointer))[SetDebugConfiguration__vtbl_index]);		
            }
        }
    }
}
