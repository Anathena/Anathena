// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.DirectManipulation namespace.
//     This code was generated by a tool.
//     Date : 6/25/2016 10:38:13 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.DirectManipulation {

// Disable warning : XML comment is not placed on a valid language element
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
    /// <summary>	
    /// <p>Represents  the animation behavior of content as it approaches the boundary of a given axis or axes.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationAutoScrollBehavior']/*"/>	
    /// <msdn-id>dn280387</msdn-id>	
    /// <unmanaged>IDirectManipulationAutoScrollBehavior</unmanaged>	
    /// <unmanaged-short>IDirectManipulationAutoScrollBehavior</unmanaged-short>	
    [Guid("6D5954D4-2003-4356-9B31-D051C9FF0AF7")]
    public partial class AutoScrollBehavior : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.AutoScrollBehavior"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public AutoScrollBehavior(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.AutoScrollBehavior"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.AutoScrollBehavior(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.AutoScrollBehavior(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Performs the auto-scroll animation for the viewport this behavior is attached to. </p>	
        /// </summary>	
        /// <param name="motionTypes"><dd> <p>A combination of <strong><see cref="SharpDX.DirectManipulation.MotionTypes.Translatex"/></strong> and <strong><see cref="SharpDX.DirectManipulation.MotionTypes.Translatey"/></strong> from <strong><see cref="SharpDX.DirectManipulation.MotionTypes"/></strong>. <strong><see cref="SharpDX.DirectManipulation.MotionTypes.None"/></strong> cannot be specified.</p> </dd></param>	
        /// <param name="scrollMotion"><dd> <p>One of the values from <strong><see cref="SharpDX.DirectManipulation.AutoScrollConfiguration"/></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><strong>SetConfiguration</strong> takes effect immediately. If the content is not in inertia, and <strong><see cref="SharpDX.DirectManipulation.AutoScrollConfiguration.Stop"/></strong> is specified for <em>scrollMotion</em>, then this method returns S_FALSE. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationAutoScrollBehavior::SetConfiguration']/*"/>	
        /// <msdn-id>dn280388</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationAutoScrollBehavior::SetConfiguration([In] DIRECTMANIPULATION_MOTION_TYPES motionTypes,[In] DIRECTMANIPULATION_AUTOSCROLL_CONFIGURATION scrollMotion)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationAutoScrollBehavior::SetConfiguration</unmanaged-short>	
        public void SetConfiguration(SharpDX.DirectManipulation.MotionTypes motionTypes, SharpDX.DirectManipulation.AutoScrollConfiguration scrollMotion) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)motionTypes), unchecked((int)scrollMotion),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Represents a compositor object that associates manipulated content with a drawing surface, such as <strong>canvas</strong> (Windows Store app using JavaScript) or <strong>Canvas</strong> (Windows Store app using C++, C#, or Visual Basic).</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The content of a Direct Manipulation viewport must be manually updated during an input event for custom implementations of <see cref="SharpDX.DirectManipulation.Compositor"/>. Call <strong>Update</strong> to redraw the content within the viewport. </p><p>You specify manual mode on a viewport by calling either of these functions:</p><ul> <li> <strong>SetViewportOptions</strong>, with <strong><see cref="SharpDX.DirectManipulation.ViewportOptions.ManualUpdate"/></strong> specified.</li> <li> <strong>SetUpdateMode</strong>, with <strong><see cref="SharpDX.DirectManipulation.InputMode.Manual"/></strong> specified.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationCompositor']/*"/>	
    /// <msdn-id>hh446975</msdn-id>	
    /// <unmanaged>IDirectManipulationCompositor</unmanaged>	
    /// <unmanaged-short>IDirectManipulationCompositor</unmanaged-short>	
    [Guid("537A0825-0387-4EFA-B62F-71EB1F085A7E")]
    public partial interface Compositor : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p>Associates content with the compositor, assigns a composition device to the content, and specifies the position of the content in the composition tree relative to other composition visuals. </p>	
        /// </summary>	
        /// <param name="content"><dd> <p>The content to add to the composition tree.</p> <p><em>content</em> is placed  between <em>parentVisual</em> and <em>childVisual</em> in the composition tree. </p> </dd></param>	
        /// <param name="device"><dd> <p>The device used to compose the content. </p> <p><strong>Note</strong>??<em>device</em> is created by the application.</p> </dd></param>	
        /// <param name="arentVisualRef"><dd> <p>The parent in the composition tree for the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>	
        /// <param name="childVisual"><dd> <p>The child in the composition tree for the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>All content, regardless of type, must be added to the compositor. This can be primary content, obtained from the viewport by calling <strong>GetPrimaryContent</strong>, or secondary content, such as a panning indicator, created by calling <strong>CreateContent</strong>.	
        /// </p><p>If the application uses a system-provided <strong><see cref="SharpDX.DirectManipulation.Compositor"/></strong>:</p><ul> <li><em>device</em> must be an  <strong><see cref="SharpDX.DirectComposition.Device"/></strong> object, and parent and child visuals must be <strong><see cref="SharpDX.DirectComposition.Visual"/></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> cannot be <c>null</c>. </li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> objects are created and owned by the application.	
        /// </li> <li>When content is added to the composition tree using this method, the new composition visuals are inserted between <em>parentVisual</em> and <em>childVisual</em>. The new visuals should not be destroyed until they are disassociated from the compositor with <strong>RemoveContent</strong>.</li> </ul><p>If the application uses a custom implementation of <strong><see cref="SharpDX.DirectManipulation.Compositor"/></strong>:</p><ul> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> must be a valid type for the compositor. They do not have to be <strong><see cref="SharpDX.DirectComposition.Device"/></strong> or <strong><see cref="SharpDX.DirectComposition.Visual"/></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> can be <c>null</c>, depending on the compositor. </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationCompositor::AddContent']/*"/>	
        /// <msdn-id>Hh768898</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationCompositor::AddContent([In] IDirectManipulationContent* content,[In, Optional] IUnknown* device,[In, Optional] IUnknown* parentVisual,[In, Optional] IUnknown* childVisual)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationCompositor::AddContent</unmanaged-short>	
        /* public void AddContent(SharpDX.DirectManipulation.Content content, SharpDX.ComObject device, SharpDX.ComObject arentVisualRef, SharpDX.ComObject childVisual) */
        
        /// <summary>	
        /// <p>Removes content from the compositor.</p>	
        /// </summary>	
        /// <param name="content"><dd> <p>The content to remove from the composition tree.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method removes content added with <strong>AddContent</strong> and restores the original relationships between parent visuals and child visuals in the composition tree. In other words, <strong>RemoveContent</strong> undoes <strong>AddContent</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationCompositor::RemoveContent']/*"/>	
        /// <msdn-id>Hh768899</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationCompositor::RemoveContent([In] IDirectManipulationContent* content)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationCompositor::RemoveContent</unmanaged-short>	
        /* public void RemoveContent(SharpDX.DirectManipulation.Content content) */
        
        /// <summary>	
        /// <p> </p><p> Sets the update manager used to send compositor updates to Direct Manipulation. </p>	
        /// </summary>	
        /// <param name="updateManager">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Retrieve <em>updateManager</em> by calling <strong>GetUpdateManager</strong>.</p><p>Call this method during Direct Manipulation initialization to connect the compositor to the <em>update manager</em>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationCompositor::SetUpdateManager']/*"/>	
        /// <msdn-id>Hh768900</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationCompositor::SetUpdateManager([In] IDirectManipulationUpdateManager* updateManager)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationCompositor::SetUpdateManager</unmanaged-short>	
        /* public void SetUpdateManager(SharpDX.DirectManipulation.UpdateManager updateManager) */
        
        /// <summary>	
        /// <p>Commits all pending updates in the compositor to the system for rendering.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method enables Direct Manipulation to flush any pending changes to its visuals before a system event, such as a process suspension.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationCompositor::Flush']/*"/>	
        /// <msdn-id>jj647930</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationCompositor::Flush()</unmanaged>	
        /// <unmanaged-short>IDirectManipulationCompositor::Flush</unmanaged-short>	
        /* public void Flush() */
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationCompositor2']/*"/>	
    /// <unmanaged>IDirectManipulationCompositor2</unmanaged>	
    /// <unmanaged-short>IDirectManipulationCompositor2</unmanaged-short>	
    [Guid("D38C7822-F1CB-43CB-B4B9-AC0C767A412E")]
    public partial class Compositor2 : SharpDX.DirectManipulation.CompositorNative {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.Compositor2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Compositor2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.Compositor2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.Compositor2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.Compositor2(nativePointer);
		}
        
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="content">No documentation.</param>	
        /// <param name="device">No documentation.</param>	
        /// <param name="arentVisualRef">No documentation.</param>	
        /// <param name="childVisual">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationCompositor2::AddContentWithCrossProcessChaining']/*"/>	
        /// <unmanaged>HRESULT IDirectManipulationCompositor2::AddContentWithCrossProcessChaining([In] IDirectManipulationPrimaryContent* content,[In, Optional] IUnknown* device,[In, Optional] IUnknown* parentVisual,[In, Optional] IUnknown* childVisual)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationCompositor2::AddContentWithCrossProcessChaining</unmanaged-short>	
        public void AddContentWithCrossProcessChaining(SharpDX.DirectManipulation.PrimaryContent content, SharpDX.ComObject device, SharpDX.ComObject arentVisualRef, SharpDX.ComObject childVisual) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((content == null)?IntPtr.Zero:content.NativePointer), (void*)((device == null)?IntPtr.Zero:device.NativePointer), (void*)((arentVisualRef == null)?IntPtr.Zero:arentVisualRef.NativePointer), (void*)((childVisual == null)?IntPtr.Zero:childVisual.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Represents a compositor object that associates manipulated content with a drawing surface, such as <strong>canvas</strong> (Windows Store app using JavaScript) or <strong>Canvas</strong> (Windows Store app using C++, C#, or Visual Basic).</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The content of a Direct Manipulation viewport must be manually updated during an input event for custom implementations of <see cref="SharpDX.DirectManipulation.Compositor"/>. Call <strong>Update</strong> to redraw the content within the viewport. </p><p>You specify manual mode on a viewport by calling either of these functions:</p><ul> <li> <strong>SetViewportOptions</strong>, with <strong><see cref="SharpDX.DirectManipulation.ViewportOptions.ManualUpdate"/></strong> specified.</li> <li> <strong>SetUpdateMode</strong>, with <strong><see cref="SharpDX.DirectManipulation.InputMode.Manual"/></strong> specified.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationCompositor']/*"/>	
    /// <msdn-id>hh446975</msdn-id>	
    /// <unmanaged>IDirectManipulationCompositor</unmanaged>	
    /// <unmanaged-short>IDirectManipulationCompositor</unmanaged-short>	
    [Guid("537A0825-0387-4EFA-B62F-71EB1F085A7E")]
    public partial class CompositorNative : SharpDX.ComObjectCallback, SharpDX.DirectManipulation.Compositor {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.CompositorNative"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CompositorNative(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.CompositorNative"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.CompositorNative(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.CompositorNative(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Associates content with the compositor, assigns a composition device to the content, and specifies the position of the content in the composition tree relative to other composition visuals. </p>	
        /// </summary>	
        /// <param name="content"><dd> <p>The content to add to the composition tree.</p> <p><em>content</em> is placed  between <em>parentVisual</em> and <em>childVisual</em> in the composition tree. </p> </dd></param>	
        /// <param name="device"><dd> <p>The device used to compose the content. </p> <p><strong>Note</strong>??<em>device</em> is created by the application.</p> </dd></param>	
        /// <param name="arentVisualRef"><dd> <p>The parent in the composition tree for the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>	
        /// <param name="childVisual"><dd> <p>The child in the composition tree for the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>All content, regardless of type, must be added to the compositor. This can be primary content, obtained from the viewport by calling <strong>GetPrimaryContent</strong>, or secondary content, such as a panning indicator, created by calling <strong>CreateContent</strong>.	
        /// </p><p>If the application uses a system-provided <strong><see cref="SharpDX.DirectManipulation.Compositor"/></strong>:</p><ul> <li><em>device</em> must be an  <strong><see cref="SharpDX.DirectComposition.Device"/></strong> object, and parent and child visuals must be <strong><see cref="SharpDX.DirectComposition.Visual"/></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> cannot be <c>null</c>. </li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> objects are created and owned by the application.	
        /// </li> <li>When content is added to the composition tree using this method, the new composition visuals are inserted between <em>parentVisual</em> and <em>childVisual</em>. The new visuals should not be destroyed until they are disassociated from the compositor with <strong>RemoveContent</strong>.</li> </ul><p>If the application uses a custom implementation of <strong><see cref="SharpDX.DirectManipulation.Compositor"/></strong>:</p><ul> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> must be a valid type for the compositor. They do not have to be <strong><see cref="SharpDX.DirectComposition.Device"/></strong> or <strong><see cref="SharpDX.DirectComposition.Visual"/></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> can be <c>null</c>, depending on the compositor. </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationCompositor::AddContent']/*"/>	
        /// <msdn-id>Hh768898</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationCompositor::AddContent([In] IDirectManipulationContent* content,[In, Optional] IUnknown* device,[In, Optional] IUnknown* parentVisual,[In, Optional] IUnknown* childVisual)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationCompositor::AddContent</unmanaged-short>	
        internal void AddContent_(SharpDX.DirectManipulation.Content content, SharpDX.ComObject device, SharpDX.ComObject arentVisualRef, SharpDX.ComObject childVisual) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((content == null)?IntPtr.Zero:content.NativePointer), (void*)((device == null)?IntPtr.Zero:device.NativePointer), (void*)((arentVisualRef == null)?IntPtr.Zero:arentVisualRef.NativePointer), (void*)((childVisual == null)?IntPtr.Zero:childVisual.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes content from the compositor.</p>	
        /// </summary>	
        /// <param name="content"><dd> <p>The content to remove from the composition tree.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method removes content added with <strong>AddContent</strong> and restores the original relationships between parent visuals and child visuals in the composition tree. In other words, <strong>RemoveContent</strong> undoes <strong>AddContent</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationCompositor::RemoveContent']/*"/>	
        /// <msdn-id>Hh768899</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationCompositor::RemoveContent([In] IDirectManipulationContent* content)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationCompositor::RemoveContent</unmanaged-short>	
        internal void RemoveContent_(SharpDX.DirectManipulation.Content content) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((content == null)?IntPtr.Zero:content.NativePointer),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> </p><p> Sets the update manager used to send compositor updates to Direct Manipulation. </p>	
        /// </summary>	
        /// <param name="updateManager">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Retrieve <em>updateManager</em> by calling <strong>GetUpdateManager</strong>.</p><p>Call this method during Direct Manipulation initialization to connect the compositor to the <em>update manager</em>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationCompositor::SetUpdateManager']/*"/>	
        /// <msdn-id>Hh768900</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationCompositor::SetUpdateManager([In] IDirectManipulationUpdateManager* updateManager)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationCompositor::SetUpdateManager</unmanaged-short>	
        internal void SetUpdateManager_(SharpDX.DirectManipulation.UpdateManager updateManager) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((updateManager == null)?IntPtr.Zero:updateManager.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Commits all pending updates in the compositor to the system for rendering.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method enables Direct Manipulation to flush any pending changes to its visuals before a system event, such as a process suspension.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationCompositor::Flush']/*"/>	
        /// <msdn-id>jj647930</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationCompositor::Flush()</unmanaged>	
        /// <unmanaged-short>IDirectManipulationCompositor::Flush</unmanaged-short>	
        internal void Flush_() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Encapsulates content inside a viewport, where content represents a visual surface clipped inside the viewport.</p><p>The content has a set of transforms that controls the visual movement of the surface during manipulation and inertia.</p><p><strong>Note</strong>??When implementing a Direct Manipulation object, ensure that the <strong><see cref="SharpDX.ComObject"/></strong> implementation supports multithreading through thread-safe reference counting. For more information, see <strong>InterlockedIncrement</strong> and <strong>InterlockedDecrement</strong>.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The system provides an implementation of <strong><see cref="SharpDX.DirectManipulation.Content"/></strong>. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationContent']/*"/>	
    /// <msdn-id>hh446983</msdn-id>	
    /// <unmanaged>IDirectManipulationContent</unmanaged>	
    /// <unmanaged-short>IDirectManipulationContent</unmanaged-short>	
    [Guid("B89962CB-3D89-442B-BB58-5098FA0F9F16")]
    public partial class Content : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.Content"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Content(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.Content"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.Content(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.Content(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves or sets the bounding rectangle of the content, relative to the bounding rectangle of the viewport (if defined).</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If the bounding rectangle  has not been set using <strong>SetContentRect</strong>, then <strong>UI_E_VALUE_NOT_SET</strong> is returned. However, the actual content rectangle is (-FLT_MAX, -FLT_MAX, FLT_MAX, FLT_MAX).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationContent::GetContentRect']/*"/>	
        /// <msdn-id>Hh768901</msdn-id>	
        /// <unmanaged>GetContentRect / SetContentRect</unmanaged>	
        /// <unmanaged-short>GetContentRect</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectManipulationContent::GetContentRect([Out] RECT* contentSize)</unmanaged>
        public SharpDX.Mathematics.Interop.RawRectangle ContentRect {
                get { SharpDX.Mathematics.Interop.RawRectangle __output__; GetContentRect(out __output__); return __output__; }
                set { SetContentRect(value); }
        }
        
        /// <summary>	
        /// <p>Retrieves the bounding rectangle of the content, relative to the bounding rectangle of the viewport (if defined).</p>	
        /// </summary>	
        /// <param name="contentSize"><dd> <p>The bounding rectangle of the content.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If the bounding rectangle  has not been set using <strong>SetContentRect</strong>, then <strong>UI_E_VALUE_NOT_SET</strong> is returned. However, the actual content rectangle is (-FLT_MAX, -FLT_MAX, FLT_MAX, FLT_MAX).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationContent::GetContentRect']/*"/>	
        /// <msdn-id>Hh768901</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationContent::GetContentRect([Out] RECT* contentSize)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationContent::GetContentRect</unmanaged-short>	
        internal void GetContentRect(out SharpDX.Mathematics.Interop.RawRectangle contentSize) {
            unsafe {
                contentSize = new SharpDX.Mathematics.Interop.RawRectangle();
                SharpDX.Result __result__;
                fixed (void* contentSize_ = &contentSize)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, contentSize_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies the bounding rectangle of the content, relative to its viewport.	
        /// </p>	
        /// </summary>	
        /// <param name="contentSize"><dd> <p>The bounding rectangle of the content.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The default bounding rectangle is (-FLT_MAX, -FLT_MAX, FLT_MAX, FLT_MAX).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationContent::SetContentRect']/*"/>	
        /// <msdn-id>Hh768903</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationContent::SetContentRect([In] const RECT* contentSize)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationContent::SetContentRect</unmanaged-short>	
        internal void SetContentRect(SharpDX.Mathematics.Interop.RawRectangle contentSize) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, &contentSize,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the viewport that contains the content.</p>	
        /// </summary>	
        /// <param name="riid"><dd> <p>A reference to the identifier of the interface to use.</p> </dd></param>	
        /// <param name="@object"><dd> <p>The viewport object.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationContent::GetViewport']/*"/>	
        /// <msdn-id>hh447011</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationContent::GetViewport([In] const GUID&amp; riid,[Out] void** object)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationContent::GetViewport</unmanaged-short>	
        public void GetViewport(System.Guid riid, out System.IntPtr @object) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* @object_ = &@object)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, &riid, @object_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> </p><p>Retrieves the tag object set on this content. </p>	
        /// </summary>	
        /// <param name="riid"><dd> <p>A reference to the identifier of the interface to use. The tag object typically implements this interface.</p> </dd></param>	
        /// <param name="@object"><dd> <p>The tag object.</p> </dd></param>	
        /// <param name="id"><dd> <p>The ID portion of the tag.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><strong>GetTag</strong> and <strong>SetTag</strong> are useful for associating an external COM object with the content without an external mapping between the two. They can also be used to pass information to callbacks generated for the content.</p><p><strong>GetTag</strong> queries the tag value for the specified interface and returns a reference to that interface.</p><p>A tag is a pairing of an integer ID (<em>id</em>) with a Component Object Model (COM) object (<em>object</em>). It can be used by an app to identify a motion.	
        /// The parameters are optional, so that the method can return both parts of the tag, the identifier portion, or the tag object. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationContent::GetTag']/*"/>	
        /// <msdn-id>hh447009</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationContent::GetTag([In] const GUID&amp; riid,[Out, Optional] void** object,[Out, Optional] unsigned int* id)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationContent::GetTag</unmanaged-short>	
        public void GetTag(System.Guid riid, out System.IntPtr @object, out int id) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* @object_ = &@object)
                    fixed (void* id_ = &id)
                        __result__= 
        				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, &riid, @object_, id_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies the tag object for the content. </p>	
        /// </summary>	
        /// <param name="@object"><dd> <p>The object portion of the tag.</p> </dd></param>	
        /// <param name="id"><dd> <p>The ID portion of the tag.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> <strong>GetTag</strong> and <strong>SetTag</strong> are useful for associating an external COM object with the content without an external mapping between the two. They can also be used to pass information to callbacks generated for the content.</p><p>A tag is a pairing of an integer ID  (<em>id</em>) with a Component Object Model (COM) object (<em>object</em>). It can be used by an app to store and retrieve an arbitrary object associated with the content.</p><p>The <em>object</em> parameter is optional, so that the method can set just the identifier portion. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationContent::SetTag']/*"/>	
        /// <msdn-id>hh447021</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationContent::SetTag([In, Optional] IUnknown* object,[In] unsigned int id)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationContent::SetTag</unmanaged-short>	
        public void SetTag(SharpDX.ComObject @object, int id) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((@object == null)?IntPtr.Zero:@object.NativePointer), id,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the final transform applied to the content.</p>	
        /// </summary>	
        /// <param name="matrix"><dd> <p>The transform matrix.</p> </dd></param>	
        /// <param name="pointCount"><dd> <p>The size of the transform matrix. This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This transform might contain the other custom curves applied during manipulation and inertia.</p><p>This transform contains both the content transform and the sync transform set with <strong>SyncContentTransform</strong>. 	
        /// </p><p></p><dl> <dt>The relationship between the three primary transforms is defined as:</dt> <dd> <code>Output transform = Pixel rounding (Sync transform * Content transform)</code> </dd> </dl>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationContent::GetOutputTransform']/*"/>	
        /// <msdn-id>hh447007</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationContent::GetOutputTransform([Out, Buffer] float* matrix,[In] unsigned int pointCount)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationContent::GetOutputTransform</unmanaged-short>	
        internal void GetOutputTransform(float[] matrix, int pointCount) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* matrix_ = matrix)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, matrix_, pointCount,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Retrieves the transform applied to the content.</p>	
        /// </summary>	
        /// <param name="matrix"><dd> <p>The transform matrix.</p> </dd></param>	
        /// <param name="pointCount"><dd> <p>The size of the transform matrix. This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This transform contains the default overpan and bounce curves during manipulation and inertia.</p><p>This transform does not contain the sync transform set with <strong>SyncContentTransform</strong>.</p><p></p><dl> <dt>The relationship between the three primary transforms is defined as:</dt> <dd> <code>Output transform = Pixel rounding (Sync transform * Content transform)</code> </dd> </dl><p>When this method returns, the format of <em>matrix</em> is:</p><dl> <dd><em>matrix</em>[0]=ScaleX</dd> <dd><em>matrix</em>[1]=Unused</dd> <dd><em>matrix</em>[2]=Unused</dd> <dd><em>matrix</em>[3]=ScaleY	
        /// </dd> <dd><em>matrix</em>[4]=TranslateX</dd> <dd><em>matrix</em>[5]=TranslateY</dd> </dl>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationContent::GetContentTransform']/*"/>	
        /// <msdn-id>Hh768902</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationContent::GetContentTransform([Out, Buffer] float* matrix,[In] unsigned int pointCount)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationContent::GetContentTransform</unmanaged-short>	
        internal void GetContentTransform(float[] matrix, int pointCount) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* matrix_ = matrix)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, matrix_, pointCount,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Modifies the content transform while maintaining the output transform.</p>	
        /// </summary>	
        /// <param name="matrix"><dd> <p>The transform matrix.</p> </dd></param>	
        /// <param name="pointCount"><dd> <p>The size of the transform matrix. This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method will fail if the viewport state is <strong><see cref="SharpDX.DirectManipulation.Status.Running"/></strong>, <strong><see cref="SharpDX.DirectManipulation.Status.Inertia"/></strong> or <strong><see cref="SharpDX.DirectManipulation.Status.Suspended"/></strong>.</p><p>This method is useful when the application wants to apply transforms on top of the content transforms at the end of a manipulation, while preserving the visual output transform of the content.</p><p></p><dl> <dt>The relationship between the three primary transforms is defined as:</dt> <dd> <code>Output transform = Pixel rounding (Sync transform * Content transform)</code> </dd> </dl>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationContent::SyncContentTransform']/*"/>	
        /// <msdn-id>Hh768904</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationContent::SyncContentTransform([In, Buffer] const float* matrix,[In] unsigned int pointCount)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationContent::SyncContentTransform</unmanaged-short>	
        internal void SyncContentTransform(float[] matrix, int pointCount) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* matrix_ = matrix)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, matrix_, pointCount,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a service for managing associations between a contact and a viewport.</p><p> <strong>SetContact</strong> is called when a <strong>WM_POINTERDOWN</strong> message is received. Upon receiving a <strong>WM_POINTERDOWN</strong>, the application can use the coordinates of the input to hit-test and determine the viewports to which the contact is associated.	
    /// </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationDeferContactService']/*"/>	
    /// <msdn-id>dn972377</msdn-id>	
    /// <unmanaged>IDirectManipulationDeferContactService</unmanaged>	
    /// <unmanaged-short>IDirectManipulationDeferContactService</unmanaged-short>	
    [Guid("652D5C71-FE60-4A98-BE70-E5F21291E7F1")]
    public partial class DeferContactService : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.DeferContactService"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DeferContactService(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.DeferContactService"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.DeferContactService(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.DeferContactService(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Specifies the amount of time to defer the execution of a call to <strong>SetContact</strong> for this <em>referenceId</em>.</p><p><strong>DeferContact</strong> must be called before <strong>SetContact</strong>.</p>	
        /// </summary>	
        /// <param name="pointerId">No documentation.</param>	
        /// <param name="timeout">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationDeferContactService::DeferContact']/*"/>	
        /// <msdn-id>dn972380</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationDeferContactService::DeferContact([In] unsigned int pointerId,[In] unsigned int timeout)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationDeferContactService::DeferContact</unmanaged-short>	
        public void DeferContact(int pointerId, int timeout) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, pointerId, timeout,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Cancel all scheduled calls to <strong>SetContact</strong> for this <em>referenceId</em>.    </p>	
        /// </summary>	
        /// <param name="pointerId">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function fails if the timeout specified in <strong>DeferContact</strong> has already been reached.  </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationDeferContactService::CancelContact']/*"/>	
        /// <msdn-id>dn972378</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationDeferContactService::CancelContact([In] unsigned int pointerId)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationDeferContactService::CancelContact</unmanaged-short>	
        public void CancelContact(int pointerId) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, pointerId,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="pointerId">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationDeferContactService::CancelDeferral']/*"/>	
        /// <unmanaged>HRESULT IDirectManipulationDeferContactService::CancelDeferral([In] unsigned int pointerId)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationDeferContactService::CancelDeferral</unmanaged-short>	
        public void CancelDeferral(int pointerId) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, pointerId,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents behaviors for drag and drop interactions, which are triggered by cross-slide or press-and-hold gestures. </p><p>Call <strong>AddBehavior</strong> to apply the behavior on a viewport and <strong>RemoveBehavior</strong> to remove it.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If <strong>AddConfiguration</strong>, <strong>RemoveConfiguration</strong>, <strong>ActivateConfiguration</strong>, or <strong>SetManualGesture</strong> has been called successfully on a viewport, <strong>AddBehavior</strong> fails for the remaining lifetime of the viewport. </p><p>Once the behavior is added to the viewport, calls to <strong>AddConfiguration</strong>, <strong>RemoveConfiguration</strong>, <strong>ActivateConfiguration</strong>, or <strong>SetManualGesture</strong> will fail until <strong>RemoveBehavior</strong> is called.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationDragDropBehavior']/*"/>	
    /// <msdn-id>dn280389</msdn-id>	
    /// <unmanaged>IDirectManipulationDragDropBehavior</unmanaged>	
    /// <unmanaged-short>IDirectManipulationDragDropBehavior</unmanaged-short>	
    [Guid("814B5AF5-C2C8-4270-A9B7-A198CE8D02FA")]
    public partial class DragDropBehavior : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.DragDropBehavior"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DragDropBehavior(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.DragDropBehavior"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.DragDropBehavior(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.DragDropBehavior(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the configuration of the drag-drop interaction for the viewport this behavior is attached to. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The configuration of the behavior can be set before or after it has been added to a viewport. If a configuration change is made while an interaction is occurring, the new configuration takes effect on the next interaction. ?	
        /// </p><p> <strong><see cref="SharpDX.DirectManipulation.Viewport.ActivateConfiguration"/></strong> should not be called prior to calling <strong><see cref="SharpDX.DirectManipulation.DragDropBehavior.SetConfiguration"/></strong>. This will result in  unexpected behavior.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationDragDropBehavior::SetConfiguration']/*"/>	
        /// <msdn-id>dn280391</msdn-id>	
        /// <unmanaged>SetConfiguration</unmanaged>	
        /// <unmanaged-short>SetConfiguration</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectManipulationDragDropBehavior::SetConfiguration([In] DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION configuration)</unmanaged>
        public SharpDX.DirectManipulation.DragDropConfiguration Configuration {
                set { SetConfiguration(value); }
        }
        
        /// <summary>	
        /// <p>Gets the status of the drag-drop interaction for the viewport this behavior is attached to. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method returns the drag-drop status at the time of the call and not at the time when the return value is read.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationDragDropBehavior::GetStatus']/*"/>	
        /// <msdn-id>dn280390</msdn-id>	
        /// <unmanaged>GetStatus</unmanaged>	
        /// <unmanaged-short>GetStatus</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectManipulationDragDropBehavior::GetStatus([Out] DIRECTMANIPULATION_DRAG_DROP_STATUS* status)</unmanaged>
        public SharpDX.DirectManipulation.DragDropStatus Status {
                get { SharpDX.DirectManipulation.DragDropStatus __output__; GetStatus(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Sets the configuration of the drag-drop interaction for the viewport this behavior is attached to. </p>	
        /// </summary>	
        /// <param name="configuration"><dd> <p>Combination  of values from <strong><see cref="SharpDX.DirectManipulation.DragDropConfiguration"/></strong>.</p> <p>For the configuration to be valid, <em>configuration</em> must contain exactly one of the following three values:</p><ul> <li><strong><see cref="SharpDX.DirectManipulation.DragDropConfiguration.SelectOnly"/></strong></li> <li><strong><see cref="SharpDX.DirectManipulation.DragDropConfiguration.SelectDrag"/></strong></li> <li><strong><see cref="SharpDX.DirectManipulation.DragDropConfiguration.HoldDrag"/></strong></li> </ul> <p>If <strong><see cref="SharpDX.DirectManipulation.DragDropConfiguration.SelectOnly"/></strong> or  <strong><see cref="SharpDX.DirectManipulation.DragDropConfiguration.SelectDrag"/></strong> is specified, one of <strong><see cref="SharpDX.DirectManipulation.DragDropConfiguration.Vertical"/></strong> or <strong><see cref="SharpDX.DirectManipulation.DragDropConfiguration.Horizontal"/></strong> is required.</p> <p>If <strong><see cref="SharpDX.DirectManipulation.DragDropConfiguration.HoldDrag"/></strong> is specified, both <strong><see cref="SharpDX.DirectManipulation.DragDropConfiguration.Vertical"/></strong> and <strong><see cref="SharpDX.DirectManipulation.DragDropConfiguration.Horizontal"/></strong> are required.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The configuration of the behavior can be set before or after it has been added to a viewport. If a configuration change is made while an interaction is occurring, the new configuration takes effect on the next interaction. ?	
        /// </p><p> <strong><see cref="SharpDX.DirectManipulation.Viewport.ActivateConfiguration"/></strong> should not be called prior to calling <strong><see cref="SharpDX.DirectManipulation.DragDropBehavior.SetConfiguration"/></strong>. This will result in  unexpected behavior.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationDragDropBehavior::SetConfiguration']/*"/>	
        /// <msdn-id>dn280391</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationDragDropBehavior::SetConfiguration([In] DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION configuration)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationDragDropBehavior::SetConfiguration</unmanaged-short>	
        internal void SetConfiguration(SharpDX.DirectManipulation.DragDropConfiguration configuration) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)configuration),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the status of the drag-drop interaction for the viewport this behavior is attached to. </p>	
        /// </summary>	
        /// <param name="status"><dd> <p>One of the values from <strong><see cref="SharpDX.DirectManipulation.DragDropStatus"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method returns the drag-drop status at the time of the call and not at the time when the return value is read.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationDragDropBehavior::GetStatus']/*"/>	
        /// <msdn-id>dn280390</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationDragDropBehavior::GetStatus([Out] DIRECTMANIPULATION_DRAG_DROP_STATUS* status)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationDragDropBehavior::GetStatus</unmanaged-short>	
        internal void GetStatus(out SharpDX.DirectManipulation.DragDropStatus status) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* status_ = &status)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, status_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Defines methods to handle drag-drop behavior events.</p><p><strong>Note</strong>??When implementing this interface, ensure that the <strong><see cref="SharpDX.ComObject"/></strong> implementation supports multithreading through thread-safe reference counting. For more information, see <strong>InterlockedIncrement</strong> and <strong>InterlockedDecrement</strong>.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationDragDropEventHandler']/*"/>	
    /// <msdn-id>dn280392</msdn-id>	
    /// <unmanaged>IDirectManipulationDragDropEventHandler</unmanaged>	
    /// <unmanaged-short>IDirectManipulationDragDropEventHandler</unmanaged-short>	
    [Guid("1FA11B10-701B-41AE-B5F2-49E36BD595AA")]
    public partial class DragDropEventHandler : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.DragDropEventHandler"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DragDropEventHandler(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.DragDropEventHandler"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.DragDropEventHandler(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.DragDropEventHandler(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Called when a status change happens in the viewport that the drag-and-drop behavior is attached to. </p>	
        /// </summary>	
        /// <param name="viewport"><dd> <p>The updated viewport.</p> </dd></param>	
        /// <param name="current"><dd> <p>The current state of the drag-drop interaction from <strong><see cref="SharpDX.DirectManipulation.DragDropStatus"/></strong>. </p> </dd></param>	
        /// <param name="previous"><dd> <p>The previous state of the drag-drop interaction from <strong><see cref="SharpDX.DirectManipulation.DragDropStatus"/></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If a class  is implementing <strong><see cref="SharpDX.DirectManipulation.ViewportEventHandler"/></strong> it should also implement <strong><see cref="SharpDX.DirectManipulation.DragDropEventHandler"/></strong> if that viewport will use drag and drop. Direct Manipulation will query the <strong><see cref="SharpDX.DirectManipulation.ViewportEventHandler"/></strong> instances to verify that  they also implement <strong><see cref="SharpDX.DirectManipulation.DragDropEventHandler"/></strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationDragDropEventHandler::OnDragDropStatusChange']/*"/>	
        /// <msdn-id>dn280393</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationDragDropEventHandler::OnDragDropStatusChange([In] IDirectManipulationViewport2* viewport,[In] DIRECTMANIPULATION_DRAG_DROP_STATUS current,[In] DIRECTMANIPULATION_DRAG_DROP_STATUS previous)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationDragDropEventHandler::OnDragDropStatusChange</unmanaged-short>	
        public void OnDragDropStatusChange(SharpDX.DirectManipulation.Viewport2 viewport, SharpDX.DirectManipulation.DragDropStatus current, SharpDX.DirectManipulation.DragDropStatus previous) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((viewport == null)?IntPtr.Zero:viewport.NativePointer), unchecked((int)current), unchecked((int)previous),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a time-keeping object that measures the latency of the composition infrastructure used by the application and provides this data to Direct Manipulation.	
    /// </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationFrameInfoProvider']/*"/>	
    /// <msdn-id>jj647931</msdn-id>	
    /// <unmanaged>IDirectManipulationFrameInfoProvider</unmanaged>	
    /// <unmanaged-short>IDirectManipulationFrameInfoProvider</unmanaged-short>	
    [Guid("fb759dba-6f4c-4c01-874e-19c8a05907f9")]
    public partial class FrameInfoProvider : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.FrameInfoProvider"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FrameInfoProvider(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.FrameInfoProvider"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.FrameInfoProvider(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.FrameInfoProvider(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the composition timing information from the compositor.</p>	
        /// </summary>	
        /// <param name="time"><dd> <p>The current time, in milliseconds.</p> </dd></param>	
        /// <param name="rocessTimeRef"><dd> <p>The time, in milliseconds, when the compositor begins constructing the next frame.</p> </dd></param>	
        /// <param name="compositionTime"><dd> <p>The time, in milliseconds, when the compositor finishes composing and drawing the next frame on the screen.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The system implementation of <strong><see cref="SharpDX.DirectManipulation.FrameInfoProvider"/></strong> uses DirectComposition. <strong>GetFrameStatistics</strong> is used to calculate the parameter values for <strong>GetNextFrameInfo</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationFrameInfoProvider::GetNextFrameInfo']/*"/>	
        /// <msdn-id>hh446977</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationFrameInfoProvider::GetNextFrameInfo([Out] unsigned longlong* time,[Out] unsigned longlong* processTime,[Out] unsigned longlong* compositionTime)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationFrameInfoProvider::GetNextFrameInfo</unmanaged-short>	
        public void GetNextFrameInfo(out long time, out long rocessTimeRef, out long compositionTime) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* time_ = &time)
                    fixed (void* rocessTimeRef_ = &rocessTimeRef)
                        fixed (void* compositionTime_ = &compositionTime)
                            __result__= 
            				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, time_, rocessTimeRef_, compositionTime_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Defines methods to handle interactions when they are detected.</p><p><strong>Note</strong>??When implementing this interface, ensure that the <strong><see cref="SharpDX.ComObject"/></strong> implementation supports multithreading through thread-safe reference counting. For more information, see <strong>InterlockedIncrement</strong> and <strong>InterlockedDecrement</strong>.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationInteractionEventHandler']/*"/>	
    /// <msdn-id>dn280394</msdn-id>	
    /// <unmanaged>IDirectManipulationInteractionEventHandler</unmanaged>	
    /// <unmanaged-short>IDirectManipulationInteractionEventHandler</unmanaged-short>	
    [Guid("E43F45B8-42B4-403E-B1F2-273B8F510830")]
    public partial class InteractionEventHandler : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.InteractionEventHandler"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public InteractionEventHandler(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.InteractionEventHandler"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.InteractionEventHandler(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.InteractionEventHandler(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Called when an interaction is detected.</p>	
        /// </summary>	
        /// <param name="viewport"><dd> <p>The viewport on which the interaction was detected.</p> </dd></param>	
        /// <param name="interaction"><dd> <p>One of the values from <strong><see cref="SharpDX.DirectManipulation.InteractionType"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationInteractionEventHandler::OnInteraction']/*"/>	
        /// <msdn-id>dn280395</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationInteractionEventHandler::OnInteraction([In] IDirectManipulationViewport2* viewport,[In] DIRECTMANIPULATION_INTERACTION_TYPE interaction)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationInteractionEventHandler::OnInteraction</unmanaged-short>	
        public void OnInteraction(SharpDX.DirectManipulation.Viewport2 viewport, SharpDX.DirectManipulation.InteractionType interaction) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((viewport == null)?IntPtr.Zero:viewport.NativePointer), unchecked((int)interaction),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Provides access to all the Direct Manipulation features and APIs available to the client application</p><p>This is the first COM object (the object factory) created by the application to retrieve other COM objects in the Direct Manipulation API surface. It also serves to activate and deactivate Direct Manipulation functionality on a per-<see cref="System.IntPtr"/> basis.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationManager']/*"/>	
    /// <msdn-id>hh447028</msdn-id>	
    /// <unmanaged>IDirectManipulationManager</unmanaged>	
    /// <unmanaged-short>IDirectManipulationManager</unmanaged-short>	
    [Guid("FBF5D3B4-70C7-4163-9322-5A6F660D6FBC")]
    public partial class Manager : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.Manager"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Manager(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.Manager"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.Manager(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.Manager(nativePointer);
		}
        
        
        /// <summary>Constant VerticalIndicatorContent.</summary>
        /// <unmanaged>CLSID_VerticalIndicatorContent</unmanaged>
        public static readonly System.Guid VerticalIndicatorContent = new System.Guid("a10b5f17-afe0-4aa2-91e9-3e7001d2e6b4");
        
        /// <summary>Constant HorizontalIndicatorContent.</summary>
        /// <unmanaged>CLSID_HorizontalIndicatorContent</unmanaged>
        public static readonly System.Guid HorizontalIndicatorContent = new System.Guid("e7d18cf5-3ec7-44d5-a76b-3770f3cf903d");
        
        /// <summary>Constant VirtualViewportContent.</summary>
        /// <unmanaged>CLSID_VirtualViewportContent</unmanaged>
        public static readonly System.Guid VirtualViewportContent = new System.Guid("3206a19a-86f0-4cb4-a7f3-16e3b7e2d852");
        
        /// <summary>	
        /// <p>Activates Direct Manipulation for processing input and  handling callbacks on the specified window. </p>	
        /// </summary>	
        /// <param name="window">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The manipulation manager is deactivated, by default. The manager does not receive or respond to input and callbacks until <strong>Activate</strong> is called for the window.  </p><p>Calls to <strong>Activate</strong> and <strong>Deactivate</strong> are reference counted.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationManager::Activate']/*"/>	
        /// <msdn-id>hh447029</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationManager::Activate([In] HWND window)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationManager::Activate</unmanaged-short>	
        public void Activate(System.IntPtr window) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)window,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Deactivates Direct Manipulation for processing input and  handling callbacks on the specified window. </p>	
        /// </summary>	
        /// <param name="window">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The manipulation manager is deactivated by default. The manager does not receive or respond to input until <strong>Activate</strong> is called. The manipulation manager should be deactivated when the app does not receive or respond to input. For example, when the app is minimized.</p><p>Calls to <strong>Activate</strong> and <strong>Deactivate</strong> are reference counted.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationManager::Deactivate']/*"/>	
        /// <msdn-id>hh447036</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationManager::Deactivate([In] HWND window)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationManager::Deactivate</unmanaged-short>	
        public void Deactivate(System.IntPtr window) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)window,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Registers a dedicated thread for hit testing.</p>	
        /// </summary>	
        /// <param name="window"><dd> <p>The handle of the main app window (typically created from the UI thread).</p> </dd></param>	
        /// <param name="hitTestWindow"><dd> <p>The handle of the window in which hit testing is registered (should be created from the hit testing thread). Pass in nullptr to unregister a previously registered hit-test target.</p> </dd></param>	
        /// <param name="type"><dd> <p>One of the values from <strong><see cref="SharpDX.DirectManipulation.HitTestType"/></strong>. Specifies whether the UI window or the hit testing window (or both) receives the hit testing <strong>WM_POINTERDOWN</strong> message , and in what order.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Hit testing is typically performed on the application UI thread. The application receives a <strong>WM_POINTERDOWN</strong> message on which hit-testing is performed. If a manipulation is required, <strong>SetContact</strong> is called on one or more viewports. An application can use the <strong>RegisterHitTestTarget</strong> method to delegate this hit-testing responsibility to a separate hit-testing thread.	
        /// </p><p>Once a dedicated hit-test target is successfully registered, <strong>WM_POINTERDOWN</strong> messages are processed on the hit-testing thread. If a manipulation, such as pan or zoom, is required, <strong>SetContact</strong> is called from this thread.	
        /// </p><p>If <strong>SetContact</strong> is not called from the hit-testing thread, <strong>WM_POINTERDOWN</strong> messages may be processed on the UI thread, depending on the <strong><see cref="SharpDX.DirectManipulation.HitTestType"/></strong> specified during registration.	
        /// </p><p>If <strong>SetContact</strong> is not called by either the hit-test thread or the UI thread, Direct Manipulation ignores the input which is then handled on the UI thread.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationManager::RegisterHitTestTarget']/*"/>	
        /// <msdn-id>Hh768905</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationManager::RegisterHitTestTarget([In] HWND window,[In, Optional] HWND hitTestWindow,[In] DIRECTMANIPULATION_HITTEST_TYPE type)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationManager::RegisterHitTestTarget</unmanaged-short>	
        public void RegisterHitTestTarget(System.IntPtr window, System.IntPtr hitTestWindow, SharpDX.DirectManipulation.HitTestType type) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)window, (void*)hitTestWindow, unchecked((int)type),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Passes keyboard and mouse messages to the manipulation manager on the app's UI thread.</p>	
        /// </summary>	
        /// <param name="message"><dd> <p>The input message to process.</p> </dd></param>	
        /// <param name="handled"><dd> <p><strong>TRUE</strong> if no further processing should be done with this message; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Call this method for mouse and keyboard input.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationManager::ProcessInput']/*"/>	
        /// <msdn-id>hh447040</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationManager::ProcessInput([In] const MSG* message,[Out] BOOL* handled)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationManager::ProcessInput</unmanaged-short>	
        public void ProcessInput(ref SharpDX.Win32.NativeMessage message, out SharpDX.Mathematics.Interop.RawBool handled) {
            unsafe {
                handled = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* message_ = &message)
                    fixed (void* handled_ = &handled)
                        __result__= 
        				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, message_, handled_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a reference to an <strong><see cref="SharpDX.DirectManipulation.UpdateManager"/></strong> object that receives compositor updates. </p>	
        /// </summary>	
        /// <param name="riid">No documentation.</param>	
        /// <param name="@object">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>For the compositor to respond to update events from Direct Manipulation, you must associate <strong><see cref="SharpDX.DirectManipulation.UpdateManager"/></strong> to an <strong><see cref="SharpDX.DirectManipulation.Compositor"/></strong> object during initialization. Use  <strong>GetUpdateManager</strong> to obtain a reference to a <strong><see cref="SharpDX.DirectManipulation.UpdateManager"/></strong> object. Pass this reference to the compositor using the <strong>SetUpdateManager</strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationManager::GetUpdateManager']/*"/>	
        /// <msdn-id>hh447038</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationManager::GetUpdateManager([In] const GUID&amp; riid,[Out] void** object)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationManager::GetUpdateManager</unmanaged-short>	
        public void GetUpdateManager(System.Guid riid, out System.IntPtr @object) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* @object_ = &@object)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, &riid, @object_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>The factory method that is used to create a new <strong><see cref="SharpDX.DirectManipulation.Viewport"/></strong> object.</p><p>The viewport manages the interaction state and mapping of input to output actions.</p>	
        /// </summary>	
        /// <param name="frameInfo">No documentation.</param>	
        /// <param name="window">No documentation.</param>	
        /// <param name="riid">No documentation.</param>	
        /// <param name="@object">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationManager::CreateViewport']/*"/>	
        /// <msdn-id>hh447034</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationManager::CreateViewport([In, Optional] IDirectManipulationFrameInfoProvider* frameInfo,[In] HWND window,[In] const GUID&amp; riid,[Out] void** object)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationManager::CreateViewport</unmanaged-short>	
        internal void CreateViewport(SharpDX.DirectManipulation.FrameInfoProvider frameInfo, System.IntPtr window, System.Guid riid, out System.IntPtr @object) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* @object_ = &@object)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((frameInfo == null)?IntPtr.Zero:frameInfo.NativePointer), (void*)window, &riid, @object_,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>The factory method that is used to create an instance of secondary content (such as a panning indicator) inside a viewport.</p>	
        /// </summary>	
        /// <param name="frameInfo"><dd> <p>The frame info provider for the secondary content. This should match the frame info provider used to create the viewport.</p> </dd></param>	
        /// <param name="clsid"><dd> <p>Class identifier (CLSID) of the secondary content. This ID specifies the content type.</p> </dd></param>	
        /// <param name="riid"><dd> <p>IID of the interface.</p> </dd></param>	
        /// <param name="@object"><dd> <p>The secondary content object that implements the specified interface.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Primary content is automatically created at the same time as the viewport and has a one-to-one relationship to a viewport. Therefore, it is not possible to create, add, or remove primary content.</p><p>Secondary content is created independently from the viewport. There is no limit to how much secondary content can be added or removed from a viewport. All secondary content transforms are derived from those supported by the primary content with specific rules applied based on the intended purpose of the element (identified by its Class identifier (CLSID)).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationManager::CreateContent']/*"/>	
        /// <msdn-id>hh447030</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationManager::CreateContent([In, Optional] IDirectManipulationFrameInfoProvider* frameInfo,[In] const GUID&amp; clsid,[In] const GUID&amp; riid,[Out] void** object)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationManager::CreateContent</unmanaged-short>	
        internal void CreateContent(SharpDX.DirectManipulation.FrameInfoProvider frameInfo, System.Guid clsid, System.Guid riid, out System.IntPtr @object) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* @object_ = &@object)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((frameInfo == null)?IntPtr.Zero:frameInfo.NativePointer), &clsid, &riid, @object_,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides a method to create configuration behaviors that can be attached to a viewport. </p><p><strong>Note</strong>??To obtain an <strong><see cref="SharpDX.DirectManipulation.Manager2"/></strong> interface reference, <strong>QueryInterface</strong> on an existing <strong><see cref="SharpDX.DirectManipulation.Manager"/></strong> interface reference.  </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationManager2']/*"/>	
    /// <msdn-id>dn280396</msdn-id>	
    /// <unmanaged>IDirectManipulationManager2</unmanaged>	
    /// <unmanaged-short>IDirectManipulationManager2</unmanaged-short>	
    [Guid("FA1005E9-3D16-484C-BFC9-62B61E56EC4E")]
    public partial class Manager2 : SharpDX.DirectManipulation.Manager {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.Manager2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Manager2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.Manager2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.Manager2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.Manager2(nativePointer);
		}
        
        
        /// <summary>Constant DragDropConfigurationBehavior.</summary>
        /// <unmanaged>CLSID_DragDropConfigurationBehavior</unmanaged>
        public static readonly System.Guid DragDropConfigurationBehavior = new System.Guid("09b01b3e-ba6c-454d-82e8-95e352329f23");
        
        /// <summary>Constant AutoScrollBehavior.</summary>
        /// <unmanaged>CLSID_AutoScrollBehavior</unmanaged>
        public static readonly System.Guid AutoScrollBehavior = new System.Guid("26126a51-3c70-4c9a-aec2-948849eeb093");
        
        /// <summary>	
        /// <p>Factory method to create a behavior.</p>	
        /// </summary>	
        /// <param name="clsid"><dd> <p>CLSID of the behavior. The CLSID specifies the type of behavior.</p> </dd></param>	
        /// <param name="riid"><dd> <p>The IID of the behavior interface to create.</p> </dd></param>	
        /// <param name="@object"><dd> <p>The new behavior object that implements the specified interface.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationManager2::CreateBehavior']/*"/>	
        /// <msdn-id>dn280397</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationManager2::CreateBehavior([In] const GUID&amp; clsid,[In] const GUID&amp; riid,[Out] void** object)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationManager2::CreateBehavior</unmanaged-short>	
        internal void CreateBehavior(System.Guid clsid, System.Guid riid, out System.IntPtr @object) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* @object_ = &@object)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, &clsid, &riid, @object_,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationManager3']/*"/>	
    /// <unmanaged>IDirectManipulationManager3</unmanaged>	
    /// <unmanaged-short>IDirectManipulationManager3</unmanaged-short>	
    [Guid("2CB6B33D-FFE8-488C-B750-FBDFE88DCA8C")]
    public partial class Manager3 : SharpDX.DirectManipulation.Manager2 {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.Manager3"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Manager3(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.Manager3"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.Manager3(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.Manager3(nativePointer);
		}
        
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="clsid">No documentation.</param>	
        /// <param name="riid">No documentation.</param>	
        /// <param name="@object">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationManager3::GetService']/*"/>	
        /// <unmanaged>HRESULT IDirectManipulationManager3::GetService([In] const GUID&amp; clsid,[In] const GUID&amp; riid,[Out] void** object)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationManager3::GetService</unmanaged-short>	
        public void GetService(System.Guid clsid, System.Guid riid, out System.IntPtr @object) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* @object_ = &@object)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, &clsid, &riid, @object_,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Encapsulates the primary content inside a viewport. Primary content is the content specified during the creation of a viewport.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationPrimaryContent']/*"/>	
    /// <msdn-id>Hh768906</msdn-id>	
    /// <unmanaged>IDirectManipulationPrimaryContent</unmanaged>	
    /// <unmanaged-short>IDirectManipulationPrimaryContent</unmanaged-short>	
    [Guid("C12851E4-1698-4625-B9B1-7CA3EC18630B")]
    public partial class PrimaryContent : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.PrimaryContent"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PrimaryContent(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.PrimaryContent"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.PrimaryContent(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.PrimaryContent(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the horizontal alignment of the primary content relative to the viewport.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If you have activated a configuration consisting only of zoom or zoom inertia, specify <see cref="SharpDX.DirectManipulation.HorizontalAlignment.UnlockCenter"/> to respect the zoom center point.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationPrimaryContent::SetHorizontalAlignment']/*"/>	
        /// <msdn-id>Hh768909</msdn-id>	
        /// <unmanaged>SetHorizontalAlignment</unmanaged>	
        /// <unmanaged-short>SetHorizontalAlignment</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetHorizontalAlignment([In] DIRECTMANIPULATION_HORIZONTALALIGNMENT alignment)</unmanaged>
        public SharpDX.DirectManipulation.HorizontalAlignment HorizontalAlignment {
                set { SetHorizontalAlignment(value); }
        }
        
        /// <summary>	
        /// <p>Specifies the vertical alignment of the primary content in the viewport.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If you have activated a configuration consisting only of zoom or zoom inertia, specify <strong><see cref="SharpDX.DirectManipulation.VerticalAlignment.UnlockCenter"/></strong> to respect the zoom center point.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationPrimaryContent::SetVerticalAlignment']/*"/>	
        /// <msdn-id>Hh768914</msdn-id>	
        /// <unmanaged>SetVerticalAlignment</unmanaged>	
        /// <unmanaged-short>SetVerticalAlignment</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetVerticalAlignment([In] DIRECTMANIPULATION_VERTICALALIGNMENT alignment)</unmanaged>
        public SharpDX.DirectManipulation.VerticalAlignment VerticalAlignment {
                set { SetVerticalAlignment(value); }
        }
        
        /// <summary>	
        /// <p> Specifies snap points for the inertia end position at uniform intervals.</p>	
        /// </summary>	
        /// <param name="motion"><dd> <p>One of the <strong><see cref="SharpDX.DirectManipulation.MotionTypes"/></strong> enumeration values.</p> </dd></param>	
        /// <param name="interval"><dd> <p>The interval between each snap point.</p> </dd></param>	
        /// <param name="offset"><dd> <p>The offset from the coordinate specified in <strong>SetSnapCoordinate</strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Snap point locations are in content coordinate units. </p><p>Specify snap points through <strong>SetSnapPoints</strong> or <strong>SetSnapInterval</strong>. </p><p>If snap points are invalid (for example, outside of the content boundaries), they are ignored and the content is always within the content boundaries. </p><p>Snap points are not at boundaries by default. If you wish for content to stop at a boundary, a snap point must be set at the boundary.</p><p> Snap points set by <strong>SetSnapInterval</strong> can be cleared by calling <strong>SetSnapInterval</strong> with an interval of 0.0f.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationPrimaryContent::SetSnapInterval']/*"/>	
        /// <msdn-id>Hh768911</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetSnapInterval([In] DIRECTMANIPULATION_MOTION_TYPES motion,[In] float interval,[In] float offset)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationPrimaryContent::SetSnapInterval</unmanaged-short>	
        public void SetSnapInterval(SharpDX.DirectManipulation.MotionTypes motion, float interval, float offset) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)motion), interval, offset,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies the snap points for the inertia rest position.</p>	
        /// </summary>	
        /// <param name="motion"><dd> <p>One or more of the <strong><see cref="SharpDX.DirectManipulation.MotionTypes"/></strong> enumeration values. Only <strong>DIRECTMANIPULATION_MOTION_TRANSLATE_X</strong>, <strong>DIRECTMANIPULATION_MOTION_TRANSLATE_Y</strong>, or <strong><see cref="SharpDX.DirectManipulation.MotionTypes.Zoom"/></strong> are allowed.</p> </dd></param>	
        /// <param name="ointsRef"><dd> <p>An array of snap points within the boundaries of the content to snap to. Should be specified in increasing order relative to the origin set in <strong>SetSnapCoordinate</strong>.</p> </dd></param>	
        /// <param name="pointCount"><dd> <p> The size of the array of snap points. Should be greater than 0.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If there is no change in the snap points, this method can return <strong>S_FALSE</strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. If invalid snap points are specified, existing snap points might be affected.</p></returns>	
        /// <remarks>	
        /// <p>If snap points are invalid (for example, outside of the content boundaries), they are ignored and the content is always within the content boundaries. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationPrimaryContent::SetSnapPoints']/*"/>	
        /// <msdn-id>Hh768912</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetSnapPoints([In] DIRECTMANIPULATION_MOTION_TYPES motion,[In, Buffer, Optional] const float* points,[In] unsigned int pointCount)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationPrimaryContent::SetSnapPoints</unmanaged-short>	
        public void SetSnapPoints(SharpDX.DirectManipulation.MotionTypes motion, float[] ointsRef, int pointCount) {
            unsafe {
                float[] ointsRef__ = ointsRef;
                SharpDX.Result __result__;
                fixed (void* ointsRef_ = ointsRef__)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)motion), ointsRef_, pointCount,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies the type of snap point.</p>	
        /// </summary>	
        /// <param name="motion"><dd> <p>One or more of the <strong><see cref="SharpDX.DirectManipulation.MotionTypes"/></strong> enumeration values.</p> </dd></param>	
        /// <param name="type"><dd> <p>One of the <strong><see cref="SharpDX.DirectManipulation.SnapPointType"/></strong> enumeration values.</p> <p>If set to <strong>DIRECTMANIPULATION_SNAPPOINT_TYPE_NONE</strong>, snap points specified through <strong>SetSnapPoints</strong> or <strong>SetSnapInterval</strong> are cleared.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationPrimaryContent::SetSnapType']/*"/>	
        /// <msdn-id>Hh768913</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetSnapType([In] DIRECTMANIPULATION_MOTION_TYPES motion,[In] DIRECTMANIPULATION_SNAPPOINT_TYPE type)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationPrimaryContent::SetSnapType</unmanaged-short>	
        public void SetSnapType(SharpDX.DirectManipulation.MotionTypes motion, SharpDX.DirectManipulation.SnapPointType type) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)motion), unchecked((int)type),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Specifies the coordinate system for snap points or snap intervals. </p>	
        /// </summary>	
        /// <param name="motion"><dd> <p>One of the values from <strong><see cref="SharpDX.DirectManipulation.MotionTypes"/></strong>. </p> </dd></param>	
        /// <param name="coordinate"><dd> <p>One of the values from <strong><see cref="SharpDX.DirectManipulation.SnapPointCoordinate"/></strong>. </p> <p>If <em>motion</em> is set to translation (<strong><see cref="SharpDX.DirectManipulation.MotionTypes.Translatex"/></strong> or <strong><see cref="SharpDX.DirectManipulation.MotionTypes.Translatey"/></strong>), all values of <strong><see cref="SharpDX.DirectManipulation.SnapPointCoordinate"/></strong> are valid. </p> <p>If <em>motion</em> is set to <strong><see cref="SharpDX.DirectManipulation.MotionTypes.Zoom"/></strong>, only <strong><see cref="SharpDX.DirectManipulation.SnapPointCoordinate.CoordinateOrigin"/></strong> of <strong><see cref="SharpDX.DirectManipulation.SnapPointCoordinate"/></strong> is valid (<em>origin</em> must be set to 0.0f).</p> </dd></param>	
        /// <param name="origin"><dd> <p>The initial, or starting, snap point. All snap points are relative to this one. Only used when  <strong><see cref="SharpDX.DirectManipulation.SnapPointCoordinate.CoordinateOrigin"/></strong> is set. </p> <p>If <em>motion</em> is set to <strong><see cref="SharpDX.DirectManipulation.MotionTypes.Zoom"/></strong>, then <em>origin</em> must be set to 0.0f.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The origin is relative to the content boundaries. If no boundary has been set (<strong>SetContentRect</strong> is never called) the default boundaries are (-FLT_MAX, FLT_MAX). </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationPrimaryContent::SetSnapCoordinate']/*"/>	
        /// <msdn-id>Hh768910</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetSnapCoordinate([In] DIRECTMANIPULATION_MOTION_TYPES motion,[In] DIRECTMANIPULATION_SNAPPOINT_COORDINATE coordinate,[In] float origin)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationPrimaryContent::SetSnapCoordinate</unmanaged-short>	
        public void SetSnapCoordinate(SharpDX.DirectManipulation.MotionTypes motion, SharpDX.DirectManipulation.SnapPointCoordinate coordinate, float origin) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)motion), unchecked((int)coordinate), origin,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies the minimum and maximum boundaries for zoom.</p>	
        /// </summary>	
        /// <param name="zoomMinimum"><dd> <p>The minimum zoom level allowed. Must be greater than or equal to 0.1f, which corresponds to 100% zoom.</p> </dd></param>	
        /// <param name="zoomMaximum"><dd> <p>The maximum zoom allowed. Must be greater than <em>zoomMinimum</em> and less than FLT_MAX.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If the content is outside the new boundaries, and the viewport is ENABLED or READY, then the content is reset to be within the new boundaries. If inertia configuration is enabled, the reset operation uses an inertia animation. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationPrimaryContent::SetZoomBoundaries']/*"/>	
        /// <msdn-id>Hh768915</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetZoomBoundaries([In] float zoomMinimum,[In] float zoomMaximum)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationPrimaryContent::SetZoomBoundaries</unmanaged-short>	
        public void SetZoomBoundaries(float zoomMinimum, float zoomMaximum) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, zoomMinimum, zoomMaximum,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the horizontal alignment of the primary content relative to the viewport.</p>	
        /// </summary>	
        /// <param name="alignment"><dd> <p>One or more values from <strong><see cref="SharpDX.DirectManipulation.HorizontalAlignment"/></strong>. The default is <strong><see cref="SharpDX.DirectManipulation.HorizontalAlignment.None"/></strong>.</p> <p><strong>Note</strong>??You cannot combine the following options: <see cref="SharpDX.DirectManipulation.HorizontalAlignment.Left"/>, DIRECTMANIPULATION-HORIZONTALALIGNMENT_CENTER, <see cref="SharpDX.DirectManipulation.HorizontalAlignment.Right"/>. <see cref="SharpDX.DirectManipulation.HorizontalAlignment.UnlockCenter"/> can be combined with any option but cannot be configured by itself.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If you have activated a configuration consisting only of zoom or zoom inertia, specify <see cref="SharpDX.DirectManipulation.HorizontalAlignment.UnlockCenter"/> to respect the zoom center point.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationPrimaryContent::SetHorizontalAlignment']/*"/>	
        /// <msdn-id>Hh768909</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetHorizontalAlignment([In] DIRECTMANIPULATION_HORIZONTALALIGNMENT alignment)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationPrimaryContent::SetHorizontalAlignment</unmanaged-short>	
        internal void SetHorizontalAlignment(SharpDX.DirectManipulation.HorizontalAlignment alignment) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)alignment),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies the vertical alignment of the primary content in the viewport.</p>	
        /// </summary>	
        /// <param name="alignment"><dd> <p>One or more values from <strong><see cref="SharpDX.DirectManipulation.VerticalAlignment"/></strong>.</p> <p><strong>Note</strong>??You cannot combine <strong><see cref="SharpDX.DirectManipulation.VerticalAlignment.Top"/></strong>, <strong><see cref="SharpDX.DirectManipulation.VerticalAlignment.Center"/></strong>, or <strong><see cref="SharpDX.DirectManipulation.VerticalAlignment.Bottom"/></strong>. <strong><see cref="SharpDX.DirectManipulation.VerticalAlignment.UnlockCenter"/></strong> can be combined with any option but cannot be configured by itself.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If you have activated a configuration consisting only of zoom or zoom inertia, specify <strong><see cref="SharpDX.DirectManipulation.VerticalAlignment.UnlockCenter"/></strong> to respect the zoom center point.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationPrimaryContent::SetVerticalAlignment']/*"/>	
        /// <msdn-id>Hh768914</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetVerticalAlignment([In] DIRECTMANIPULATION_VERTICALALIGNMENT alignment)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationPrimaryContent::SetVerticalAlignment</unmanaged-short>	
        internal void SetVerticalAlignment(SharpDX.DirectManipulation.VerticalAlignment alignment) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)alignment),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the final transform, including inertia, of the primary content.</p>	
        /// </summary>	
        /// <param name="matrix"><dd> <p>The transformed matrix that represents the inertia ending position.</p> </dd></param>	
        /// <param name="pointCount"><dd> <p>The size of the matrix. </p> <p> This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><strong>Warning</strong>??Calling this method can cause a race condition if inertia has ended or been interrupted. This can also occur during the <strong>OnViewportStatusChanged</strong> callback.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationPrimaryContent::GetInertiaEndTransform']/*"/>	
        /// <msdn-id>Hh768908</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::GetInertiaEndTransform([Out, Buffer] float* matrix,[In] unsigned int pointCount)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationPrimaryContent::GetInertiaEndTransform</unmanaged-short>	
        public void GetInertiaEndTransform(float[] matrix, int pointCount) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* matrix_ = matrix)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, matrix_, pointCount,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Retrieves the center point of the manipulation in content coordinates. If there is no manipulation in progress, retrieves the center point of the viewport.</p>	
        /// </summary>	
        /// <param name="centerX"><dd> <p>The center on the horizontal axis.</p> </dd></param>	
        /// <param name="centerY"><dd> <p>The center on the vertical axis.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationPrimaryContent::GetCenterPoint']/*"/>	
        /// <msdn-id>Hh768907</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationPrimaryContent::GetCenterPoint([Out] float* centerX,[Out] float* centerY)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationPrimaryContent::GetCenterPoint</unmanaged-short>	
        public void GetCenterPoint(out float centerX, out float centerY) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* centerX_ = &centerX)
                    fixed (void* centerY_ = &centerY)
                        __result__= 
        				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, centerX_, centerY_,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>Defines methods for handling manipulation update events.</p><p><strong>Note</strong>??When implementing a Direct Manipulation object, ensure that the <strong><see cref="SharpDX.ComObject"/></strong> implementation supports multithreading through thread-safe reference counting. For more information, see <strong>InterlockedIncrement</strong> and <strong>InterlockedDecrement</strong>.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationUpdateHandler']/*"/>	
    /// <msdn-id>hh447128</msdn-id>	
    /// <unmanaged>IDirectManipulationUpdateHandler</unmanaged>	
    /// <unmanaged-short>IDirectManipulationUpdateHandler</unmanaged-short>	
    [Guid("790B6337-64F8-4FF5-A269-B32BC2AF27A7")]
    public partial class UpdateHandler : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.UpdateHandler"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public UpdateHandler(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.UpdateHandler"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.UpdateHandler(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.UpdateHandler(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Notifies the compositor when to update inertia animation.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationUpdateHandler::Update']/*"/>	
        /// <msdn-id>hh447130</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationUpdateHandler::Update()</unmanaged>	
        /// <unmanaged-short>IDirectManipulationUpdateHandler::Update</unmanaged-short>	
        public void Update() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Updates Direct Manipulation at the current time.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If the application provides its own implementation of <strong><see cref="SharpDX.DirectManipulation.Compositor"/></strong>, this implementation should call <strong>Update</strong> whenever there is a compositor update. Frame timing information can be provided to Direct Manipulation through the <strong><see cref="SharpDX.DirectManipulation.FrameInfoProvider"/></strong> interface.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationUpdateManager']/*"/>	
    /// <msdn-id>hh447142</msdn-id>	
    /// <unmanaged>IDirectManipulationUpdateManager</unmanaged>	
    /// <unmanaged-short>IDirectManipulationUpdateManager</unmanaged-short>	
    [Guid("B0AE62FD-BE34-46E7-9CAA-D361FACBB9CC")]
    public partial class UpdateManager : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.UpdateManager"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public UpdateManager(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.UpdateManager"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.UpdateManager(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.UpdateManager(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Registers a callback that is triggered by a handle.</p>	
        /// </summary>	
        /// <param name="handle"><dd> <p>The event handle that triggers the callback.</p> </dd></param>	
        /// <param name="eventHandler"><dd> <p>The event handler to call when the event is fired.</p> </dd></param>	
        /// <param name="cookie"><dd> <p>The unique ID of the event callback instance.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationUpdateManager::RegisterWaitHandleCallback']/*"/>	
        /// <msdn-id>hh447134</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationUpdateManager::RegisterWaitHandleCallback([In] void* handle,[In] IDirectManipulationUpdateHandler* eventHandler,[Out] unsigned int* cookie)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationUpdateManager::RegisterWaitHandleCallback</unmanaged-short>	
        public void RegisterWaitHandleCallback(System.IntPtr handle, SharpDX.DirectManipulation.UpdateHandler eventHandler, out int cookie) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* cookie_ = &cookie)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)handle, (void*)((eventHandler == null)?IntPtr.Zero:eventHandler.NativePointer), cookie_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Deregisters a callback.</p>	
        /// </summary>	
        /// <param name="cookie"><dd> <p>The unique ID of the event callback instance.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationUpdateManager::UnregisterWaitHandleCallback']/*"/>	
        /// <msdn-id>hh447136</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationUpdateManager::UnregisterWaitHandleCallback([In] unsigned int cookie)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationUpdateManager::UnregisterWaitHandleCallback</unmanaged-short>	
        public void UnregisterWaitHandleCallback(int cookie) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, cookie,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Updates Direct Manipulation at the current time.</p>	
        /// </summary>	
        /// <param name="frameInfo">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If the application provides its own implementation of <strong><see cref="SharpDX.DirectManipulation.Compositor"/></strong>, this implementation should call <strong>Update</strong> whenever there is a compositor update. Frame timing information can be provided to Direct Manipulation through the <strong><see cref="SharpDX.DirectManipulation.FrameInfoProvider"/></strong> interface.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationUpdateManager::Update']/*"/>	
        /// <msdn-id>hh447142</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationUpdateManager::Update([In, Optional] IDirectManipulationFrameInfoProvider* frameInfo)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationUpdateManager::Update</unmanaged-short>	
        public void Update(SharpDX.DirectManipulation.FrameInfoProvider frameInfo) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((frameInfo == null)?IntPtr.Zero:frameInfo.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Defines a region within a window (referred to as a viewport) that is able to receive and process input from user interactions.  The viewport contains content that moves in response to a user interaction. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport']/*"/>	
    /// <msdn-id>hh447144</msdn-id>	
    /// <unmanaged>IDirectManipulationViewport</unmanaged>	
    /// <unmanaged-short>IDirectManipulationViewport</unmanaged-short>	
    [Guid("28b85a3d-60a0-48bd-9ba1-5ce8d9ea3a6d")]
    public partial class Viewport : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.Viewport"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Viewport(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.Viewport"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.Viewport(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.Viewport(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Specifies an  association between a contact and the viewport.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Call this method when it a WM_POINTERDOWN message is received. Upon receiving a WM_POINTERDOWN, the application can use the coordinates of the input to hit-test and determine the viewports to which the contact is associated.	
        /// </p><p>After initialization, Direct Manipulation is not aware of viewport z-order or parent-child relations between viewports. The order of <strong>SetContact</strong> calls defines the viewport tree. To establish the correct viewport hierarchy, <strong>SetContact</strong> should be called first on the child-most viewport, followed by the parent, grand-parent, and so on. 	
        /// </p><p>Use GET_POINTERID_WPARAM to get the reference identifier from a reference message. The contact is removed automatically when WM_POINTERUP is received.	
        /// </p><p>If a contact is associated with one or more viewports using the <strong>SetContact</strong> method, Direct Manipulation will examine further input from that contact and attempt to identify an appropriate manipulation based on the configuration of the associated viewports. If a manipulation is recognized, the application will then receive a WM_POINTERCAPTURECHANGED message for this contact. In this context, the WM_POINTERCAPTURECHANGED message indicates that Direct Manipulation has captured the contact and the application will not receive input from this contact that is consumed for this manipulation.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SetContact']/*"/>	
        /// <msdn-id>Hh768921</msdn-id>	
        /// <unmanaged>SetContact</unmanaged>	
        /// <unmanaged-short>SetContact</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetContact([In] unsigned int pointerId)</unmanaged>
        public int Contact {
                set { SetContact(value); }
        }
        
        /// <summary>	
        /// <p>Gets the state of the viewport.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method returns the viewport state at the time of the call and not at the time when the return value is read.</p><p>This method will fail if called after <strong>Abandon</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::GetStatus']/*"/>	
        /// <msdn-id>hh447167</msdn-id>	
        /// <unmanaged>GetStatus</unmanaged>	
        /// <unmanaged-short>GetStatus</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::GetStatus([Out] DIRECTMANIPULATION_STATUS* status)</unmanaged>
        public SharpDX.DirectManipulation.Status Status {
                get { SharpDX.DirectManipulation.Status __output__; GetStatus(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves or sets the rectangle for the viewport relative to the origin of the viewport coordinate system specified by <strong>SetViewportRect</strong>.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::GetViewportRect']/*"/>	
        /// <msdn-id>Hh768918</msdn-id>	
        /// <unmanaged>GetViewportRect / SetViewportRect</unmanaged>	
        /// <unmanaged-short>GetViewportRect</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::GetViewportRect([Out] RECT* viewport)</unmanaged>
        public SharpDX.Mathematics.Interop.RawRectangle ViewportRect {
                get { SharpDX.Mathematics.Interop.RawRectangle __output__; GetViewportRect(out __output__); return __output__; }
                set { SetViewportRect(value); }
        }
        
        /// <summary>	
        /// <p>Sets how the viewport should handle input and output (non-default).</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Calling this method with <strong><see cref="SharpDX.DirectManipulation.InputMode.Manual"/></strong> set, has the same effect as calling <strong>SetViewportOptions(<see cref="SharpDX.DirectManipulation.ViewportOptions.Input"/>)</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SetViewportOptions']/*"/>	
        /// <msdn-id>jj647932</msdn-id>	
        /// <unmanaged>SetViewportOptions</unmanaged>	
        /// <unmanaged-short>SetViewportOptions</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetViewportOptions([In] DIRECTMANIPULATION_VIEWPORT_OPTIONS options)</unmanaged>
        public SharpDX.DirectManipulation.ViewportOptions ViewportOptions {
                set { SetViewportOptions(value); }
        }
        
        /// <summary>	
        /// <p>Sets which gestures are ignored by Direct Manipulation. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Use this method to specify which gestures the application processes on the UI thread. If a gesture is recognized, it will be passed to the application for processing and ignored by Direct Manipulation.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SetManualGesture']/*"/>	
        /// <msdn-id>jj654881</msdn-id>	
        /// <unmanaged>SetManualGesture</unmanaged>	
        /// <unmanaged-short>SetManualGesture</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetManualGesture([In] DIRECTMANIPULATION_GESTURE_CONFIGURATION configuration)</unmanaged>
        public SharpDX.DirectManipulation.GestureConfiguration ManualGesture {
                set { SetManualGesture(value); }
        }
        
        /// <summary>	
        /// <p>Specifies the motion types supported in a viewport that can be chained to a parent viewport.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SetChaining']/*"/>	
        /// <msdn-id>hh447174</msdn-id>	
        /// <unmanaged>SetChaining</unmanaged>	
        /// <unmanaged-short>SetChaining</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetChaining([In] DIRECTMANIPULATION_MOTION_TYPES enabledTypes)</unmanaged>
        public SharpDX.DirectManipulation.MotionTypes Chaining {
                set { SetChaining(value); }
        }
        
        /// <summary>	
        /// <p>Specifies if input is visible to the UI thread.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p><see cref="SharpDX.DirectManipulation.InputMode.Automatic"/> is the default mode for Direct Manipulation. </p><p> Direct Manipulation consumes all the input that drives the manipulation and the application receives WM_POINTERCAPTURECHANGED messages. 	
        /// </p><p>In some situations an application may want to receive input that is driving a manipulation. Set <see cref="SharpDX.DirectManipulation.InputMode.Manual"/> in this case. The application will receive all input messages, even input used by Direct Manipulation to drive a manipulation. </p><p><strong>Note</strong>??The application will not receive WM_POINTERCAPTURECHANGED messages.	
        /// </p><p>Calling this method with <strong><see cref="SharpDX.DirectManipulation.InputMode.Manual"/></strong> set, has the same effect as calling <strong>SetViewportOptions(<see cref="SharpDX.DirectManipulation.ViewportOptions.Input"/>)</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SetInputMode']/*"/>	
        /// <msdn-id>hh447176</msdn-id>	
        /// <unmanaged>SetInputMode</unmanaged>	
        /// <unmanaged-short>SetInputMode</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetInputMode([In] DIRECTMANIPULATION_INPUT_MODE mode)</unmanaged>
        public SharpDX.DirectManipulation.InputMode InputMode {
                set { SetInputMode(value); }
        }
        
        /// <summary>	
        /// <p> Specifies whether a viewport updates content manually instead of during an input event.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p><see cref="SharpDX.DirectManipulation.InputMode.Automatic"/> is the default mode for Direct Manipulation. In this mode, visual updates are pushed to compositor driven by input. This is the expected mode of operation if the application is using system-provided implementation of <strong><see cref="SharpDX.DirectManipulation.Compositor"/></strong>.	
        /// </p><p>If the application provides its own implementation of <strong><see cref="SharpDX.DirectManipulation.Compositor"/></strong>, it should switch viewport update mode to manual by setting <see cref="SharpDX.DirectManipulation.InputMode.Manual"/>. When in manual mode, the compositor pulls visual updates whenever it calls <strong>Update</strong> on Direct Manipulation.	
        /// </p><p>Calling this method with <strong><see cref="SharpDX.DirectManipulation.InputMode.Manual"/></strong> set, has the same effect as calling <strong>SetViewportOptions(<see cref="SharpDX.DirectManipulation.ViewportOptions.Input"/>)</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SetUpdateMode']/*"/>	
        /// <msdn-id>Hh768922</msdn-id>	
        /// <unmanaged>SetUpdateMode</unmanaged>	
        /// <unmanaged-short>SetUpdateMode</unmanaged-short>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetUpdateMode([In] DIRECTMANIPULATION_INPUT_MODE mode)</unmanaged>
        public SharpDX.DirectManipulation.InputMode UpdateMode {
                set { SetUpdateMode(value); }
        }
        
        /// <summary>	
        /// <p>Starts or resumes input processing by the viewport.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>, or <strong>S_FALSE</strong> if there is no work to do (for example, the viewport is already enabled). Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method directs a viewport to attempt to respond to input.</p><p>Call this method if the <strong>AUTODISABLE</strong> option is set. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::Enable']/*"/>	
        /// <msdn-id>hh447163</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::Enable()</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::Enable</unmanaged-short>	
        public void Enable() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Stops input processing by the viewport.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>When a viewport is disabled, it immediately stops all transforms and moves the content to the final location. </p><p>Call this method when you want to modify multiple attributes atomically. This method can be called at any time. </p><p>The viewport will not resume processing input until <strong>Enable</strong> is called. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::Disable']/*"/>	
        /// <msdn-id>hh447162</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::Disable()</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::Disable</unmanaged-short>	
        public void Disable() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies an  association between a contact and the viewport.</p>	
        /// </summary>	
        /// <param name="pointerId"><dd> <p>The ID of the reference.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Call this method when it a WM_POINTERDOWN message is received. Upon receiving a WM_POINTERDOWN, the application can use the coordinates of the input to hit-test and determine the viewports to which the contact is associated.	
        /// </p><p>After initialization, Direct Manipulation is not aware of viewport z-order or parent-child relations between viewports. The order of <strong>SetContact</strong> calls defines the viewport tree. To establish the correct viewport hierarchy, <strong>SetContact</strong> should be called first on the child-most viewport, followed by the parent, grand-parent, and so on. 	
        /// </p><p>Use GET_POINTERID_WPARAM to get the reference identifier from a reference message. The contact is removed automatically when WM_POINTERUP is received.	
        /// </p><p>If a contact is associated with one or more viewports using the <strong>SetContact</strong> method, Direct Manipulation will examine further input from that contact and attempt to identify an appropriate manipulation based on the configuration of the associated viewports. If a manipulation is recognized, the application will then receive a WM_POINTERCAPTURECHANGED message for this contact. In this context, the WM_POINTERCAPTURECHANGED message indicates that Direct Manipulation has captured the contact and the application will not receive input from this contact that is consumed for this manipulation.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SetContact']/*"/>	
        /// <msdn-id>Hh768921</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetContact([In] unsigned int pointerId)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::SetContact</unmanaged-short>	
        internal void SetContact(int pointerId) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, pointerId,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes a contact that is associated with a viewport.</p>	
        /// </summary>	
        /// <param name="pointerId"><dd> <p>The ID of the reference.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method releases a contact from a specific Direct Manipulation viewport (equivalent to the user removing a touch point). </p><p>The viewport state is not affected unless the last remaining contact on the viewport is removed, in which case the viewport will transition to inertia, if supported. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::ReleaseContact']/*"/>	
        /// <msdn-id>Hh768920</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::ReleaseContact([In] unsigned int pointerId)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::ReleaseContact</unmanaged-short>	
        public void ReleaseContact(int pointerId) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, pointerId,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes all contacts that are associated with the viewport. Inertia is started if the viewport supports inertia.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This is equivalent to calling <strong>ReleaseContact</strong> on every contact associated with the viewport. The outcome is equivalent to the user removing all touch points from the viewport. </p><p>If supported, inertia will be started after calling this method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::ReleaseAllContacts']/*"/>	
        /// <msdn-id>Hh768919</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::ReleaseAllContacts()</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::ReleaseAllContacts</unmanaged-short>	
        public void ReleaseAllContacts() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the state of the viewport.</p>	
        /// </summary>	
        /// <param name="status"><dd> <p>One of the values from <strong><see cref="SharpDX.DirectManipulation.Status"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method returns the viewport state at the time of the call and not at the time when the return value is read.</p><p>This method will fail if called after <strong>Abandon</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::GetStatus']/*"/>	
        /// <msdn-id>hh447167</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::GetStatus([Out] DIRECTMANIPULATION_STATUS* status)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::GetStatus</unmanaged-short>	
        internal void GetStatus(out SharpDX.DirectManipulation.Status status) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* status_ = &status)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, status_,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the tag value of a viewport.</p>	
        /// </summary>	
        /// <param name="riid"><dd> <p>IID to the interface.</p> </dd></param>	
        /// <param name="@object"><dd> <p>The object portion of the tag.</p> </dd></param>	
        /// <param name="id"><dd> <p>The identifier portion of the tag.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>A tag is a pairing of an integer ID with a Component Object Model (COM) object. It can be used by an app to identify the viewport.</p><p> The out parameters are optional, so the method can return an ID, the viewport object, or both.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::GetTag']/*"/>	
        /// <msdn-id>hh447168</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::GetTag([In] const GUID&amp; riid,[Out, Optional] void** object,[Out, Optional] unsigned int* id)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::GetTag</unmanaged-short>	
        public void GetTag(System.Guid riid, out System.IntPtr @object, out int id) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* @object_ = &@object)
                    fixed (void* id_ = &id)
                        __result__= 
        				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, &riid, @object_, id_,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a viewport tag.</p>	
        /// </summary>	
        /// <param name="@object"><dd> <p>The object portion of the tag.</p> </dd></param>	
        /// <param name="id"><dd> <p>The ID portion of the tag.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>A tag is a pairing of an integer ID with a Component Object Model (COM) object. It can be used by an app to identify the viewport.</p><p> The object parameter is optional, so that the method can set just an ID.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SetTag']/*"/>	
        /// <msdn-id>hh447180</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetTag([In, Optional] IUnknown* object,[In] unsigned int id)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::SetTag</unmanaged-short>	
        public void SetTag(SharpDX.ComObject @object, int id) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((@object == null)?IntPtr.Zero:@object.NativePointer), id,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the rectangle for the viewport relative to the origin of the viewport coordinate system specified by <strong>SetViewportRect</strong>.</p>	
        /// </summary>	
        /// <param name="viewport">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::GetViewportRect']/*"/>	
        /// <msdn-id>Hh768918</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::GetViewportRect([Out] RECT* viewport)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::GetViewportRect</unmanaged-short>	
        internal void GetViewportRect(out SharpDX.Mathematics.Interop.RawRectangle viewport) {
            unsafe {
                viewport = new SharpDX.Mathematics.Interop.RawRectangle();
                SharpDX.Result __result__;
                fixed (void* viewport_ = &viewport)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, viewport_,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Sets the bounding rectangle for the viewport, relative to the origin of the viewport coordinate system.</p>	
        /// </summary>	
        /// <param name="viewport"><dd> <p>The bounding rectangle.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The viewport rectangle specifies the region of content that is visible to the user. In conjunction with the primary content rectangle, the viewport rectangle is used to determine chaining behaviors.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SetViewportRect']/*"/>	
        /// <msdn-id>Hh768923</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetViewportRect([In] const RECT* viewport)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::SetViewportRect</unmanaged-short>	
        internal void SetViewportRect(SharpDX.Mathematics.Interop.RawRectangle viewport) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, &viewport,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Moves the viewport to a specific area of the primary content and specifies whether to animate the transition.</p>	
        /// </summary>	
        /// <param name="left"><dd> <p>The leftmost coordinate of the rectangle in the primary content coordinate space.</p> </dd></param>	
        /// <param name="top"><dd> <p>The topmost coordinate of the rectangle in the primary content coordinate space.</p> </dd></param>	
        /// <param name="right"><dd> <p>The rightmost coordinate of the rectangle in the primary content coordinate space.</p> </dd></param>	
        /// <param name="bottom"><dd> <p>The bottommost coordinate of the rectangle in the primary content coordinate space.</p> </dd></param>	
        /// <param name="animate"><dd> <p>Specifies whether to animate the zoom behavior.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::ZoomToRect']/*"/>	
        /// <msdn-id>hh447184</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::ZoomToRect([In] const float left,[In] const float top,[In] const float right,[In] const float bottom,[In] BOOL animate)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::ZoomToRect</unmanaged-short>	
        public void ZoomToRect(float left, float top, float right, float bottom, SharpDX.Mathematics.Interop.RawBool animate) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint13(_nativePointer, left, top, right, bottom, animate,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies the transform from the viewport coordinate system to the window client coordinate system. </p>	
        /// </summary>	
        /// <param name="matrix"><dd> <p>The transform matrix, in row-wise order: _11, _12, _21, _22, _31, _32.</p> </dd></param>	
        /// <param name="pointCount"><dd> <p>The size of the transform matrix. This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Call this function to specify the viewport position, scaling and orientation on the screen. Viewport position, scaling, orientation and size are uniquely determined by the viewport transform and the viewport rectangle. The application can specify the viewport transform using this method, and the viewport rectangle using <strong>SetViewportRect</strong>. 	
        /// </p><p>The viewport rectangle (the rectangular area inside the content that is visible to the user) is specified in viewport coordinates. If the viewport rectangle top-left point is (0,0), the viewport rectangle is positioned exactly at the viewport coordinate system origin. Viewports offset from the viewport coordinate system origin can be specified in two ways:</p><ul> <li>Through the viewport rectangle top-left point</li> <li>Through the viewport transform translation component (_31, _32)</li> </ul><p>The viewport transform converts from the viewport coordinate system to the window client coordinate system. Direct Manipulation ignores the window RTL property, so the client area origin is always the top-left point. 	
        /// The transforms are applied in the following order:	
        /// </p><ol> <li>Viewport rectangle offset</li> <li>Viewport transform (from viewport to client coordinate system)</li> <li>Client to screen mapping (from client to screen coordinate system)	
        /// </li> </ol>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SetViewportTransform']/*"/>	
        /// <msdn-id>Hh768924</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetViewportTransform([In, Buffer] const float* matrix,[In] unsigned int pointCount)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::SetViewportTransform</unmanaged-short>	
        public void SetViewportTransform(float[] matrix, int pointCount) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* matrix_ = matrix)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, matrix_, pointCount,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies a display transform for the viewport, and synchronizes the output transform with the new value of the display transform.</p>	
        /// </summary>	
        /// <param name="matrix"><dd> <p>The transform matrix, in row-wise order: _11, _12, _21, _22, _31, _32.</p> </dd></param>	
        /// <param name="pointCount"><dd> <p>The size of the transform matrix. This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If the application performs special output processing of the content outside of the compositor (content not fully captured in the viewport transform), it should call this method to specify the display transform for the special processing.	
        /// </p><p>The display transform affects how manipulation updates are applied to the output transform. For example, if the display transform is set to scale 3x, panning will move the content 3x the original distance. 	
        /// </p><p>When a display transform is changed using this method, the output transform will be synchronized to the new value of the display transform.	
        /// </p><p>This method cannot be called if the viewport status is <strong><see cref="SharpDX.DirectManipulation.Status.Running"/></strong> or <strong><see cref="SharpDX.DirectManipulation.Status.Inertia"/></strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SyncDisplayTransform']/*"/>	
        /// <msdn-id>Hh768926</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SyncDisplayTransform([In, Buffer] const float* matrix,[In] unsigned int pointCount)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::SyncDisplayTransform</unmanaged-short>	
        public void SyncDisplayTransform(float[] matrix, int pointCount) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* matrix_ = matrix)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, matrix_, pointCount,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the primary content of a viewport that implements <strong><see cref="SharpDX.DirectManipulation.Content"/></strong> and <strong><see cref="SharpDX.DirectManipulation.PrimaryContent"/></strong>. </p><p>Primary content is an element that gets transformed (e.g. moved, scaled, rotated) in response to a user interaction. Primary content is created at the same time as the viewport and cannot be added or removed.</p>	
        /// </summary>	
        /// <param name="riid">No documentation.</param>	
        /// <param name="@object">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This method gets the content of the viewport that implements <strong><see cref="SharpDX.DirectManipulation.Content"/></strong> and <strong><see cref="SharpDX.DirectManipulation.PrimaryContent"/></strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::GetPrimaryContent']/*"/>	
        /// <msdn-id>hh447166</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::GetPrimaryContent([In] const GUID&amp; riid,[Out] void** object)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::GetPrimaryContent</unmanaged-short>	
        public void GetPrimaryContent(System.Guid riid, out System.IntPtr @object) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* @object_ = &@object)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, &riid, @object_,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds secondary content, such as a panning indicator, to a viewport.</p>	
        /// </summary>	
        /// <param name="content"><dd> <p>The content to add to the viewport.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Secondary content is created by calling <strong>CreateContent</strong>. Once added, the secondary content will move relative to the primary content in response to a manipulation. Its motion is determined by rules associated with each type of secondary content.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::AddContent']/*"/>	
        /// <msdn-id>hh447158</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::AddContent([In] IDirectManipulationContent* content)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::AddContent</unmanaged-short>	
        public void AddContent(SharpDX.DirectManipulation.Content content) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((content == null)?IntPtr.Zero:content.NativePointer),((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes secondary content from a viewport.</p>	
        /// </summary>	
        /// <param name="content"><dd> <p>The content object to remove.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Secondary content can be removed from the viewport at any time.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::RemoveContent']/*"/>	
        /// <msdn-id>hh447171</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::RemoveContent([In] IDirectManipulationContent* content)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::RemoveContent</unmanaged-short>	
        public void RemoveContent(SharpDX.DirectManipulation.Content content) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((content == null)?IntPtr.Zero:content.NativePointer),((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets how the viewport should handle input and output (non-default).</p>	
        /// </summary>	
        /// <param name="options"><dd> <p>One or more of the values from <strong><see cref="SharpDX.DirectManipulation.ViewportOptions"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method with <strong><see cref="SharpDX.DirectManipulation.InputMode.Manual"/></strong> set, has the same effect as calling <strong>SetViewportOptions(<see cref="SharpDX.DirectManipulation.ViewportOptions.Input"/>)</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SetViewportOptions']/*"/>	
        /// <msdn-id>jj647932</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetViewportOptions([In] DIRECTMANIPULATION_VIEWPORT_OPTIONS options)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::SetViewportOptions</unmanaged-short>	
        internal void SetViewportOptions(SharpDX.DirectManipulation.ViewportOptions options) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)options),((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds an interaction configuration for the viewport.</p>	
        /// </summary>	
        /// <param name="configuration"><dd> <p>One of the values from <strong><see cref="SharpDX.DirectManipulation.Configuration"/></strong> that specifies the interaction configuration for the viewport.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>An interaction configuration specifies how the manipulation engine responds to input and which manipulations are supported. Any number of possible configurations can be added to the viewport using <strong>AddConfiguration</strong> before processing input. </p><p>Configurations can be switched by the application at runtime using <strong>ActivateConfiguration</strong>.  </p><p>When a configuration is no longer required (and is not currently active), it can be removed using <strong>RemoveConfiguration</strong>. </p><p>If a configuration has not been added using <strong>AddConfiguration</strong>, it can be automatically added and then activated by calling <strong>ActivateConfiguration</strong>. </p><p><strong>Note</strong>??If input processing is occurring, this call will fail.</p><p>This method fails if a drag and drop behavior has been specified. </p><p>A drag and drop behavior object cannot be attached after successfully calling this method.</p><p>You cannot add another drag and drop behavior after an existing one has already been added.</p><p>This method is designed to allow an application to switch pre-added configurations, as a configuration cannot be changed while a manipulation is occurring. Under most circumstances it is better to update the configuration using <strong>ActivateConfiguration</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::AddConfiguration']/*"/>	
        /// <msdn-id>hh447156</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::AddConfiguration([In] DIRECTMANIPULATION_CONFIGURATION configuration)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::AddConfiguration</unmanaged-short>	
        public void AddConfiguration(SharpDX.DirectManipulation.Configuration configuration) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)configuration),((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes an interaction configuration for the viewport.</p>	
        /// </summary>	
        /// <param name="configuration"><dd> <p>One of the values from <strong><see cref="SharpDX.DirectManipulation.Configuration"/></strong> that specifies the interaction configuration for the viewport.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method removes a possible configuration that was added by using <strong>AddConfiguration</strong>. This method can be called only if the configuration is not active.</p><p>An interaction configuration specifies how the manipulation engine responds to input and which gestures are supported. Any number of configurations can be added to the viewport using <strong>AddConfiguration</strong>. Configurations can be switched by the application at runtime using <strong>ActivateConfiguration</strong>. When a configuration is no longer required (and is not currently active), it can be removed using <strong>RemoveConfiguration</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::RemoveConfiguration']/*"/>	
        /// <msdn-id>hh447170</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::RemoveConfiguration([In] DIRECTMANIPULATION_CONFIGURATION configuration)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::RemoveConfiguration</unmanaged-short>	
        public void RemoveConfiguration(SharpDX.DirectManipulation.Configuration configuration) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)configuration),((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the configuration for input interaction.</p>	
        /// </summary>	
        /// <param name="configuration"><dd> <p>One or more values from <strong><see cref="SharpDX.DirectManipulation.Configuration"/></strong> that specify the interaction configuration for the viewport.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>An interaction configuration specifies how the manipulation engine responds to input and which manipulations are supported. Any number of possible configurations can be added to the viewport using <strong>AddConfiguration</strong> before processing input. </p><p>Configurations can be switched by the application at runtime using <strong>ActivateConfiguration</strong>.  </p><p>When a configuration is no longer required (and is not currently active), it can be removed using <strong>RemoveConfiguration</strong>. </p><p>If a configuration has not been added using <strong>AddConfiguration</strong>, it can be automatically added and then activated by calling <strong>ActivateConfiguration</strong>. </p><p><strong>Note</strong>??If input processing is occurring, this call will fail.</p><p>This method fails if a drag and drop behavior has been specified. </p><p>A drag and drop behavior object cannot be attached after successfully calling this method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::ActivateConfiguration']/*"/>	
        /// <msdn-id>hh447154</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::ActivateConfiguration([In] DIRECTMANIPULATION_CONFIGURATION configuration)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::ActivateConfiguration</unmanaged-short>	
        public void ActivateConfiguration(SharpDX.DirectManipulation.Configuration configuration) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)configuration),((void**)(*(void**)_nativePointer))[22]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets which gestures are ignored by Direct Manipulation. </p>	
        /// </summary>	
        /// <param name="configuration">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Use this method to specify which gestures the application processes on the UI thread. If a gesture is recognized, it will be passed to the application for processing and ignored by Direct Manipulation.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SetManualGesture']/*"/>	
        /// <msdn-id>jj654881</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetManualGesture([In] DIRECTMANIPULATION_GESTURE_CONFIGURATION configuration)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::SetManualGesture</unmanaged-short>	
        internal void SetManualGesture(SharpDX.DirectManipulation.GestureConfiguration configuration) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)configuration),((void**)(*(void**)_nativePointer))[23]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies the motion types supported in a viewport that can be chained to a parent viewport.</p>	
        /// </summary>	
        /// <param name="enabledTypes"><dd> <p>One of the values from <strong><see cref="SharpDX.DirectManipulation.MotionTypes"/></strong> that specifies the motion types that are enabled for this viewport.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SetChaining']/*"/>	
        /// <msdn-id>hh447174</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetChaining([In] DIRECTMANIPULATION_MOTION_TYPES enabledTypes)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::SetChaining</unmanaged-short>	
        internal void SetChaining(SharpDX.DirectManipulation.MotionTypes enabledTypes) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)enabledTypes),((void**)(*(void**)_nativePointer))[24]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds a new event handler to listen for viewport events.</p>	
        /// </summary>	
        /// <param name="window"><dd> <p>The handle of a window owned by the thread for the event callback.</p> </dd></param>	
        /// <param name="eventHandler"><dd> <p>The handler that is called when viewport status and update events occur. The specified object must implement the <strong><see cref="SharpDX.DirectManipulation.ViewportEventHandler"/></strong> interface.</p> </dd></param>	
        /// <param name="cookie"><dd> <p>The handle that represents this event handler callback.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The event callback is fired from the thread that owns the specified window. Consecutive events of the same callback method may be coalesced. 	
        /// </p><p><strong>Note</strong>??If the viewport has a drag-drop behavior attached, the event handler should implement <strong><see cref="SharpDX.DirectManipulation.DragDropEventHandler"/></strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::AddEventHandler']/*"/>	
        /// <msdn-id>hh447161</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::AddEventHandler([In, Optional] HWND window,[In] IDirectManipulationViewportEventHandler* eventHandler,[Out] unsigned int* cookie)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::AddEventHandler</unmanaged-short>	
        public void AddEventHandler(System.IntPtr window, SharpDX.DirectManipulation.ViewportEventHandler eventHandler, out int cookie) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* cookie_ = &cookie)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)window, (void*)((eventHandler == null)?IntPtr.Zero:eventHandler.NativePointer), cookie_,((void**)(*(void**)_nativePointer))[25]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes an existing event handler from the viewport.</p>	
        /// </summary>	
        /// <param name="cookie"><dd> <p>A value that was returned by a previous call to <strong>AddEventHandler</strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::RemoveEventHandler']/*"/>	
        /// <msdn-id>hh447173</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::RemoveEventHandler([In] unsigned int cookie)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::RemoveEventHandler</unmanaged-short>	
        public void RemoveEventHandler(int cookie) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, cookie,((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies if input is visible to the UI thread.</p>	
        /// </summary>	
        /// <param name="mode"><dd> <p>One of the values from <strong><see cref="SharpDX.DirectManipulation.InputMode"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><see cref="SharpDX.DirectManipulation.InputMode.Automatic"/> is the default mode for Direct Manipulation. </p><p> Direct Manipulation consumes all the input that drives the manipulation and the application receives WM_POINTERCAPTURECHANGED messages. 	
        /// </p><p>In some situations an application may want to receive input that is driving a manipulation. Set <see cref="SharpDX.DirectManipulation.InputMode.Manual"/> in this case. The application will receive all input messages, even input used by Direct Manipulation to drive a manipulation. </p><p><strong>Note</strong>??The application will not receive WM_POINTERCAPTURECHANGED messages.	
        /// </p><p>Calling this method with <strong><see cref="SharpDX.DirectManipulation.InputMode.Manual"/></strong> set, has the same effect as calling <strong>SetViewportOptions(<see cref="SharpDX.DirectManipulation.ViewportOptions.Input"/>)</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SetInputMode']/*"/>	
        /// <msdn-id>hh447176</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetInputMode([In] DIRECTMANIPULATION_INPUT_MODE mode)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::SetInputMode</unmanaged-short>	
        internal void SetInputMode(SharpDX.DirectManipulation.InputMode mode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)mode),((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Specifies whether a viewport updates content manually instead of during an input event.</p>	
        /// </summary>	
        /// <param name="mode"><dd> <p>One of the values from <strong><see cref="SharpDX.DirectManipulation.InputMode"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><see cref="SharpDX.DirectManipulation.InputMode.Automatic"/> is the default mode for Direct Manipulation. In this mode, visual updates are pushed to compositor driven by input. This is the expected mode of operation if the application is using system-provided implementation of <strong><see cref="SharpDX.DirectManipulation.Compositor"/></strong>.	
        /// </p><p>If the application provides its own implementation of <strong><see cref="SharpDX.DirectManipulation.Compositor"/></strong>, it should switch viewport update mode to manual by setting <see cref="SharpDX.DirectManipulation.InputMode.Manual"/>. When in manual mode, the compositor pulls visual updates whenever it calls <strong>Update</strong> on Direct Manipulation.	
        /// </p><p>Calling this method with <strong><see cref="SharpDX.DirectManipulation.InputMode.Manual"/></strong> set, has the same effect as calling <strong>SetViewportOptions(<see cref="SharpDX.DirectManipulation.ViewportOptions.Input"/>)</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::SetUpdateMode']/*"/>	
        /// <msdn-id>Hh768922</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::SetUpdateMode([In] DIRECTMANIPULATION_INPUT_MODE mode)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::SetUpdateMode</unmanaged-short>	
        internal void SetUpdateMode(SharpDX.DirectManipulation.InputMode mode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, unchecked((int)mode),((void**)(*(void**)_nativePointer))[28]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Stops the manipulation and returns the viewport to a ready state.  	
        /// </p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If a mandatory snap point has been configured, the content may animate to the nearest snap point.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::Stop']/*"/>	
        /// <msdn-id>Hh768925</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::Stop()</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::Stop</unmanaged-short>	
        public void Stop() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[29]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Releases all resources that are used by the viewport and prepares it for destruction from memory.	
        /// </p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Once <strong>Abandon</strong> has been called, do not make subsequent function calls on the viewport. If a function is called after <strong>Abandon</strong>, <strong>E_INVALID_STATE</strong> will be returned.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport::Abandon']/*"/>	
        /// <msdn-id>Hh768916</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport::Abandon()</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport::Abandon</unmanaged-short>	
        public void Abandon() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[30]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides management of behaviors on a viewport. A behavior affects the functionality of a particular part of the Direct Manipulation workflow. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong><see cref="SharpDX.DirectManipulation.Viewport2"/></strong> can be used in place of <strong><see cref="SharpDX.DirectManipulation.Viewport"/></strong>.	
    /// </p><p>Behaviors are created using <strong><see cref="SharpDX.DirectManipulation.Manager2"/></strong> and an appropriate class ID.</p><p>A behavior can be attached or removed at any time and takes effect immediately (even during an active manipulation or inertia animation).</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport2']/*"/>	
    /// <msdn-id>dn280398</msdn-id>	
    /// <unmanaged>IDirectManipulationViewport2</unmanaged>	
    /// <unmanaged-short>IDirectManipulationViewport2</unmanaged-short>	
    [Guid("923CCAAC-61E1-4385-B726-017AF189882A")]
    public partial class Viewport2 : SharpDX.DirectManipulation.Viewport {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.Viewport2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Viewport2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.Viewport2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.Viewport2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.Viewport2(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Adds a behavior to the viewport and returns a cookie to the caller.</p>	
        /// </summary>	
        /// <param name="behavior"><dd> <p>A behavior created using the <strong>CreateBehavior</strong> method.</p> </dd></param>	
        /// <param name="cookie"><dd> <p>A cookie is returned so the caller can remove this behavior later. This allows the caller to release any reference on the behavior and let Direct Manipulation maintain an appropriate lifetime, similar to event handlers. </p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. Attaching a behavior that is already attached to this viewport or another viewport results in a failure.</p></returns>	
        /// <remarks>	
        /// <p>A behavior takes effect immediately after <strong>AddBehavior</strong> is called. This must be considered when adding a behavior during an active manipulation or inertia phase.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport2::AddBehavior']/*"/>	
        /// <msdn-id>dn280399</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport2::AddBehavior([In] IUnknown* behavior,[Out] unsigned int* cookie)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport2::AddBehavior</unmanaged-short>	
        public void AddBehavior(SharpDX.ComObject behavior, out int cookie) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* cookie_ = &cookie)
                    __result__= 
    				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((behavior == null)?IntPtr.Zero:behavior.NativePointer), cookie_,((void**)(*(void**)_nativePointer))[31]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes a behavior from the viewport that matches the given cookie.</p>	
        /// </summary>	
        /// <param name="cookie"><dd> <p>A valid cookie returned from the <strong>AddBehavior</strong> call on the same viewport.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. If the behavior has already been removed or if the behavior is not attached to this viewport a failure is returned.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport2::RemoveBehavior']/*"/>	
        /// <msdn-id>dn280401</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport2::RemoveBehavior([In] unsigned int cookie)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport2::RemoveBehavior</unmanaged-short>	
        public void RemoveBehavior(int cookie) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, cookie,((void**)(*(void**)_nativePointer))[32]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes all behaviors added to the viewport.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><strong>RemoveAllBehaviors</strong> only returns an error if the removal of a behavior from the viewport was unsuccessful. In the event that a specific behavior is not removed successfully, <strong>RemoveAllBehaviors</strong> removes all remaining behaviors.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewport2::RemoveAllBehaviors']/*"/>	
        /// <msdn-id>dn280400</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewport2::RemoveAllBehaviors()</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewport2::RemoveAllBehaviors</unmanaged-short>	
        public void RemoveAllBehaviors() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[33]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Called when content inside a viewport is updated.	
    /// </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This method is called once for each  content change in the viewport. This can result in multiple <strong>OnContentUpdated</strong> calls. For instance, when the position of the content is changed, you can use <strong>IDirectManipualtionContent::GetContentTransform</strong> to retrieve the new value.</p><p>If you have actions that need to be executed once for a viewport update, implement <strong>OnViewportUpdated</strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewportEventHandler']/*"/>	
    /// <msdn-id>hh447148</msdn-id>	
    /// <unmanaged>IDirectManipulationViewportEventHandler</unmanaged>	
    /// <unmanaged-short>IDirectManipulationViewportEventHandler</unmanaged-short>	
    [Guid("952121DA-D69F-45F9-B0F9-F23944321A6D")]
    public partial class ViewportEventHandler : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectManipulation.ViewportEventHandler"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ViewportEventHandler(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectManipulation.ViewportEventHandler"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectManipulation.ViewportEventHandler(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectManipulation.ViewportEventHandler(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Called when the status of a viewport changes.</p>	
        /// </summary>	
        /// <param name="viewport"><dd> <p>The viewport for which status has changed.</p> </dd></param>	
        /// <param name="current"><dd> <p>The new status of the viewport.</p> </dd></param>	
        /// <param name="previous"><dd> <p>The previous status of the viewport.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If you call <strong>GetStatus</strong> from within this handler, the status returned is not guaranteed to be the same as at the time of the call. This is because of the asynchronous nature of the notification.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewportEventHandler::OnViewportStatusChanged']/*"/>	
        /// <msdn-id>hh447150</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewportEventHandler::OnViewportStatusChanged([In] IDirectManipulationViewport* viewport,[In] DIRECTMANIPULATION_STATUS current,[In] DIRECTMANIPULATION_STATUS previous)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewportEventHandler::OnViewportStatusChanged</unmanaged-short>	
        public void OnViewportStatusChanged(SharpDX.DirectManipulation.Viewport viewport, SharpDX.DirectManipulation.Status current, SharpDX.DirectManipulation.Status previous) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((viewport == null)?IntPtr.Zero:viewport.NativePointer), unchecked((int)current), unchecked((int)previous),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Called after all content in the viewport has been updated.</p>	
        /// </summary>	
        /// <param name="viewport"><dd> <p>The viewport that has been updated.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If you have actions that need to be executed once for a viewport update, implement <strong>OnViewportUpdated</strong>. <strong>OnContentUpdated</strong> is called once for each  content change in the viewport. This can result in multiple <strong>OnContentUpdated</strong> calls. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewportEventHandler::OnViewportUpdated']/*"/>	
        /// <msdn-id>hh447152</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewportEventHandler::OnViewportUpdated([In] IDirectManipulationViewport* viewport)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewportEventHandler::OnViewportUpdated</unmanaged-short>	
        public void OnViewportUpdated(SharpDX.DirectManipulation.Viewport viewport) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((viewport == null)?IntPtr.Zero:viewport.NativePointer),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Called when content inside a viewport is updated.	
        /// </p>	
        /// </summary>	
        /// <param name="viewport"><dd> <p>The viewport that is updated.</p> </dd></param>	
        /// <param name="content"><dd> <p>The content in the viewport that has changed.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method is called once for each  content change in the viewport. This can result in multiple <strong>OnContentUpdated</strong> calls. For instance, when the position of the content is changed, you can use <strong>IDirectManipualtionContent::GetContentTransform</strong> to retrieve the new value.</p><p>If you have actions that need to be executed once for a viewport update, implement <strong>OnViewportUpdated</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirectManipulationViewportEventHandler::OnContentUpdated']/*"/>	
        /// <msdn-id>hh447148</msdn-id>	
        /// <unmanaged>HRESULT IDirectManipulationViewportEventHandler::OnContentUpdated([In] IDirectManipulationViewport* viewport,[In] IDirectManipulationContent* content)</unmanaged>	
        /// <unmanaged-short>IDirectManipulationViewportEventHandler::OnContentUpdated</unmanaged-short>	
        public void OnContentUpdated(SharpDX.DirectManipulation.Viewport viewport, SharpDX.DirectManipulation.Content content) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectManipulation.LocalInterop.Calliint(_nativePointer, (void*)((viewport == null)?IntPtr.Zero:viewport.NativePointer), (void*)((content == null)?IntPtr.Zero:content.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
    }
}
