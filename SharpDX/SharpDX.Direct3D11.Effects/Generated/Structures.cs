// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.Direct3D11 namespace.
//     This code was generated by a tool.
//     Date : 6/25/2016 10:38:08 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.Direct3D11 {

#pragma warning disable 282
#pragma warning disable 649
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
    
    /// <summary>	
    /// <p>Describes an effect.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><see cref="SharpDX.Direct3D11.EffectDescription"/> is used with <strong><see cref="SharpDX.Direct3D11.Effect.GetDescription"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_DESC']/*"/>	
    /// <msdn-id>ff476303</msdn-id>	
    /// <unmanaged>D3DX11_EFFECT_DESC</unmanaged>	
    /// <unmanaged-short>D3DX11_EFFECT_DESC</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct EffectDescription {	
        
        /// <summary>	
        /// <dd> <p>Number of constant buffers in this effect.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_DESC::ConstantBuffers']/*"/>	
        /// <msdn-id>ff476303</msdn-id>	
        /// <unmanaged>unsigned int ConstantBuffers</unmanaged>	
        /// <unmanaged-short>unsigned int ConstantBuffers</unmanaged-short>	
        public int ConstantBufferCount;
        
        /// <summary>	
        /// <dd> <p>Number of global variables in this effect.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_DESC::GlobalVariables']/*"/>	
        /// <msdn-id>ff476303</msdn-id>	
        /// <unmanaged>unsigned int GlobalVariables</unmanaged>	
        /// <unmanaged-short>unsigned int GlobalVariables</unmanaged-short>	
        public int GlobalVariableCount;
        
        /// <summary>	
        /// <dd> <p>Number of global interfaces in this effect.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_DESC::InterfaceVariables']/*"/>	
        /// <msdn-id>ff476303</msdn-id>	
        /// <unmanaged>unsigned int InterfaceVariables</unmanaged>	
        /// <unmanaged-short>unsigned int InterfaceVariables</unmanaged-short>	
        public int InterfaceVariableCount;
        
        /// <summary>	
        /// <dd> <p>Number of techniques in this effect.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_DESC::Techniques']/*"/>	
        /// <msdn-id>ff476303</msdn-id>	
        /// <unmanaged>unsigned int Techniques</unmanaged>	
        /// <unmanaged-short>unsigned int Techniques</unmanaged-short>	
        public int TechniqueCount;
        
        /// <summary>	
        /// <dd> <p>Number of groups in this effect.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_DESC::Groups']/*"/>	
        /// <msdn-id>ff476303</msdn-id>	
        /// <unmanaged>unsigned int Groups</unmanaged>	
        /// <unmanaged-short>unsigned int Groups</unmanaged-short>	
        public int GroupCount;
    }
    
    /// <summary>	
    /// <p>Describes an effect group.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><see cref="SharpDX.Direct3D11.EffectGroupDescription"/> is used with <strong><see cref="SharpDX.Direct3D11.EffectTechnique.GetDescription"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_GROUP_DESC']/*"/>	
    /// <msdn-id>ff476314</msdn-id>	
    /// <unmanaged>D3DX11_GROUP_DESC</unmanaged>	
    /// <unmanaged-short>D3DX11_GROUP_DESC</unmanaged-short>	
    public  partial struct EffectGroupDescription {	
        
        /// <summary>	
        /// <dd> <p>Name of this group (only <strong><c>null</c></strong> if global).</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_GROUP_DESC::Name']/*"/>	
        /// <msdn-id>ff476314</msdn-id>	
        /// <unmanaged>const char* Name</unmanaged>	
        /// <unmanaged-short>char Name</unmanaged-short>	
        public string Name;
        
        /// <summary>	
        /// <dd> <p>Number of techniques contained in group.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_GROUP_DESC::Techniques']/*"/>	
        /// <msdn-id>ff476314</msdn-id>	
        /// <unmanaged>unsigned int Techniques</unmanaged>	
        /// <unmanaged-short>unsigned int Techniques</unmanaged-short>	
        public int Techniques;
        
        /// <summary>	
        /// <dd> <p>Number of annotations on this group.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_GROUP_DESC::Annotations']/*"/>	
        /// <msdn-id>ff476314</msdn-id>	
        /// <unmanaged>unsigned int Annotations</unmanaged>	
        /// <unmanaged-short>unsigned int Annotations</unmanaged-short>	
        public int Annotations;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential)]
        internal partial struct __Native {	
            public System.IntPtr Name;
            public int Techniques;
            public int Annotations;
		    // Method to free unmanaged allocation
            internal unsafe void __MarshalFree()
            {   
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }
		
		// Method to free unmanaged allocation
        internal unsafe void __MarshalFree(ref __Native @ref)
        {   
            @ref.__MarshalFree();
        }
		
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:Marshal.PtrToStringAnsi(@ref.Name);
            this.Techniques = @ref.Techniques;
            this.Annotations = @ref.Annotations;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Utilities.StringToHGlobalAnsi(this.Name);
            @ref.Techniques = this.Techniques;
            @ref.Annotations = this.Annotations;
		
		}
    }
    
    /// <summary>	
    /// <p>Describes an effect pass, which contains pipeline state.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><see cref="SharpDX.Direct3D11.EffectPassDescription"/> is used with <strong><see cref="SharpDX.Direct3D11.EffectPass.GetDescription"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_PASS_DESC']/*"/>	
    /// <msdn-id>ff476319</msdn-id>	
    /// <unmanaged>D3DX11_PASS_DESC</unmanaged>	
    /// <unmanaged-short>D3DX11_PASS_DESC</unmanaged-short>	
    public  partial struct EffectPassDescription {	
        
        /// <summary>	
        /// <dd> <p>Name of this pass (<strong><c>null</c></strong> if not anonymous).</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_PASS_DESC::Name']/*"/>	
        /// <msdn-id>ff476319</msdn-id>	
        /// <unmanaged>const char* Name</unmanaged>	
        /// <unmanaged-short>char Name</unmanaged-short>	
        public string Name;
        
        /// <summary>	
        /// <dd> <p>Number of annotations on this pass.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_PASS_DESC::Annotations']/*"/>	
        /// <msdn-id>ff476319</msdn-id>	
        /// <unmanaged>unsigned int Annotations</unmanaged>	
        /// <unmanaged-short>unsigned int Annotations</unmanaged-short>	
        public int AnnotationCount;
        
        /// <summary>	
        /// <dd> <p>Signature from the vertex shader or geometry shader (if there is no vertex shader) or <strong><c>null</c></strong> if neither exists.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_PASS_DESC::pIAInputSignature']/*"/>	
        /// <msdn-id>ff476319</msdn-id>	
        /// <unmanaged>unsigned char* pIAInputSignature</unmanaged>	
        /// <unmanaged-short>unsigned char pIAInputSignature</unmanaged-short>	
        internal System.IntPtr PIAInputSignature;
        
        /// <summary>	
        /// <dd> <p>Singature size in bytes.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_PASS_DESC::IAInputSignatureSize']/*"/>	
        /// <msdn-id>ff476319</msdn-id>	
        /// <unmanaged>unsigned int IAInputSignatureSize</unmanaged>	
        /// <unmanaged-short>unsigned int IAInputSignatureSize</unmanaged-short>	
        internal int IAInputSignatureSize;
        
        /// <summary>	
        /// <dd> <p>The stencil-reference value used in the depth-stencil state.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_PASS_DESC::StencilRef']/*"/>	
        /// <msdn-id>ff476319</msdn-id>	
        /// <unmanaged>unsigned int StencilRef</unmanaged>	
        /// <unmanaged-short>unsigned int StencilRef</unmanaged-short>	
        public int StencilReference;
        
        /// <summary>	
        /// <dd> <p>The sample mask for the blend state.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_PASS_DESC::SampleMask']/*"/>	
        /// <msdn-id>ff476319</msdn-id>	
        /// <unmanaged>unsigned int SampleMask</unmanaged>	
        /// <unmanaged-short>unsigned int SampleMask</unmanaged-short>	
        public int SampleMask;
        
        /// <summary>	
        /// <dd> <p>The per-component blend factors (RGBA) for the blend state.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_PASS_DESC::BlendFactor']/*"/>	
        /// <msdn-id>ff476319</msdn-id>	
        /// <unmanaged>SHARPDX_COLOR4 BlendFactor</unmanaged>	
        /// <unmanaged-short>SHARPDX_COLOR4 BlendFactor</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawColor4 BlendFactor;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential)]
        internal partial struct __Native {	
            public System.IntPtr Name;
            public int AnnotationCount;
            public System.IntPtr PIAInputSignature;
            public int IAInputSignatureSize;
            public int StencilReference;
            public int SampleMask;
            public SharpDX.Mathematics.Interop.RawColor4 BlendFactor;
		    // Method to free unmanaged allocation
            internal unsafe void __MarshalFree()
            {   
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }
		
		// Method to free unmanaged allocation
        internal unsafe void __MarshalFree(ref __Native @ref)
        {   
            @ref.__MarshalFree();
        }
		
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:Marshal.PtrToStringAnsi(@ref.Name);
            this.AnnotationCount = @ref.AnnotationCount;
            this.PIAInputSignature = @ref.PIAInputSignature;
            this.IAInputSignatureSize = @ref.IAInputSignatureSize;
            this.StencilReference = @ref.StencilReference;
            this.SampleMask = @ref.SampleMask;
            this.BlendFactor = @ref.BlendFactor;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Utilities.StringToHGlobalAnsi(this.Name);
            @ref.AnnotationCount = this.AnnotationCount;
            @ref.PIAInputSignature = this.PIAInputSignature;
            @ref.IAInputSignatureSize = this.IAInputSignatureSize;
            @ref.StencilReference = this.StencilReference;
            @ref.SampleMask = this.SampleMask;
            @ref.BlendFactor = this.BlendFactor;
		
		}
    }
    
    /// <summary>	
    /// <p>Describes an effect pass.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><see cref="SharpDX.Direct3D11.EffectPassShaderDescription"/> is used with <strong><see cref="SharpDX.Direct3D11.EffectPass"/></strong> Get*ShaderDesc methods.</p><p>If this is an inline shader assignment, the returned interface will be an anonymous shader variable, which is not retrievable any other way.   It's name in the variable description will be "$Anonymous". If there is no assignment of this type in the pass block, pShaderVariable != <strong><c>null</c></strong>,  but pShaderVariable-&gt;IsValid() == <strong><see cref="SharpDX.Result.False"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_PASS_SHADER_DESC']/*"/>	
    /// <msdn-id>ff476320</msdn-id>	
    /// <unmanaged>D3DX11_PASS_SHADER_DESC</unmanaged>	
    /// <unmanaged-short>D3DX11_PASS_SHADER_DESC</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct EffectPassShaderDescription {	
        
        /// <summary>	
        /// <dd> <p>The variable that this shader came from.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_PASS_SHADER_DESC::pShaderVariable']/*"/>	
        /// <msdn-id>ff476320</msdn-id>	
        /// <unmanaged>ID3DX11EffectShaderVariable* pShaderVariable</unmanaged>	
        /// <unmanaged-short>ID3DX11EffectShaderVariable pShaderVariable</unmanaged-short>	
        internal System.IntPtr VariablePointer;
        
        /// <summary>	
        /// <dd> <p>The element of pShaderVariable (if an array) or 0 if not applicable.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_PASS_SHADER_DESC::ShaderIndex']/*"/>	
        /// <msdn-id>ff476320</msdn-id>	
        /// <unmanaged>unsigned int ShaderIndex</unmanaged>	
        /// <unmanaged-short>unsigned int ShaderIndex</unmanaged-short>	
        public int Index;
    }
    
    /// <summary>	
    /// <p>Describes an effect shader.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><see cref="SharpDX.Direct3D11.EffectShaderDescription"/> is used with <strong><see cref="SharpDX.Direct3D11.EffectShaderVariable.GetShaderDescription"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_SHADER_DESC']/*"/>	
    /// <msdn-id>ff476304</msdn-id>	
    /// <unmanaged>D3DX11_EFFECT_SHADER_DESC</unmanaged>	
    /// <unmanaged-short>D3DX11_EFFECT_SHADER_DESC</unmanaged-short>	
    public  partial struct EffectShaderDescription {	
        
        /// <summary>	
        /// <dd> <p>Passed into CreateInputLayout. Only valid on a vertex shader or geometry shader. See <strong><see cref="SharpDX.Direct3D11.Device.CreateInputLayout"/></strong>.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_SHADER_DESC::pInputSignature']/*"/>	
        /// <msdn-id>ff476304</msdn-id>	
        /// <unmanaged>const unsigned char* pInputSignature</unmanaged>	
        /// <unmanaged-short>unsigned char pInputSignature</unmanaged-short>	
        internal System.IntPtr InputSignaturePointer;
        
        /// <summary>	
        /// <dd> <p><strong>TRUE</strong> is the shader is defined inline; otherwise <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_SHADER_DESC::IsInline']/*"/>	
        /// <msdn-id>ff476304</msdn-id>	
        /// <unmanaged>BOOL IsInline</unmanaged>	
        /// <unmanaged-short>BOOL IsInline</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool IsInline;
        
        /// <summary>	
        /// <dd> <p>Shader bytecode.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_SHADER_DESC::pBytecode']/*"/>	
        /// <msdn-id>ff476304</msdn-id>	
        /// <unmanaged>const unsigned char* pBytecode</unmanaged>	
        /// <unmanaged-short>unsigned char pBytecode</unmanaged-short>	
        internal System.IntPtr BytecodePointer;
        
        /// <summary>	
        /// <dd> <p>The length of pBytecode. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_SHADER_DESC::BytecodeLength']/*"/>	
        /// <msdn-id>ff476304</msdn-id>	
        /// <unmanaged>unsigned int BytecodeLength</unmanaged>	
        /// <unmanaged-short>unsigned int BytecodeLength</unmanaged-short>	
        internal int BytecodeLength;
        
        /// <summary>	
        /// <dd> <p>Stream out declaration string (for geometry shader with SO).</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_SHADER_DESC::SODecls']/*"/>	
        /// <msdn-id>ff476304</msdn-id>	
        /// <unmanaged>const void* SODecls[4]</unmanaged>	
        /// <unmanaged-short>void SODecls</unmanaged-short>	
        internal System.IntPtr[] SODecls { 
            get { return _SODecls ?? (_SODecls = new System.IntPtr[4]);}
        }
        internal System.IntPtr[] _SODecls;
        
        /// <summary>	
        /// <dd> <p>Indicates which stream is rasterized.  D3D11 geometry shaders can output up to four streams of data, one of which can be rasterized.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_SHADER_DESC::RasterizedStream']/*"/>	
        /// <msdn-id>ff476304</msdn-id>	
        /// <unmanaged>unsigned int RasterizedStream</unmanaged>	
        /// <unmanaged-short>unsigned int RasterizedStream</unmanaged-short>	
        public int RasterizedStream;
        
        /// <summary>	
        /// <dd> <p>Number of entries in the input signature.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_SHADER_DESC::NumInputSignatureEntries']/*"/>	
        /// <msdn-id>ff476304</msdn-id>	
        /// <unmanaged>unsigned int NumInputSignatureEntries</unmanaged>	
        /// <unmanaged-short>unsigned int NumInputSignatureEntries</unmanaged-short>	
        public int InputParameterCount;
        
        /// <summary>	
        /// <dd> <p>Number of entries in the output signature.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_SHADER_DESC::NumOutputSignatureEntries']/*"/>	
        /// <msdn-id>ff476304</msdn-id>	
        /// <unmanaged>unsigned int NumOutputSignatureEntries</unmanaged>	
        /// <unmanaged-short>unsigned int NumOutputSignatureEntries</unmanaged-short>	
        public int OutputParameterCount;
        
        /// <summary>	
        /// <dd> <p>Number of entries in the patch constant signature.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_SHADER_DESC::NumPatchConstantSignatureEntries']/*"/>	
        /// <msdn-id>ff476304</msdn-id>	
        /// <unmanaged>unsigned int NumPatchConstantSignatureEntries</unmanaged>	
        /// <unmanaged-short>unsigned int NumPatchConstantSignatureEntries</unmanaged-short>	
        public int PatchConstantSignatureEntrieCount;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential)]
        internal partial struct __Native {	
            public System.IntPtr InputSignaturePointer;
            public SharpDX.Mathematics.Interop.RawBool IsInline;
            public System.IntPtr BytecodePointer;
            public int BytecodeLength;
            public System.IntPtr SODecls;
            System.IntPtr __SODecls1;
            System.IntPtr __SODecls2;
            System.IntPtr __SODecls3;
            public int RasterizedStream;
            public int InputParameterCount;
            public int OutputParameterCount;
            public int PatchConstantSignatureEntrieCount;
		    // Method to free unmanaged allocation
            internal unsafe void __MarshalFree()
            {   
            }
        }
		
		// Method to free unmanaged allocation
        internal unsafe void __MarshalFree(ref __Native @ref)
        {   
            @ref.__MarshalFree();
        }
		
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.InputSignaturePointer = @ref.InputSignaturePointer;
            this.IsInline = @ref.IsInline;
            this.BytecodePointer = @ref.BytecodePointer;
            this.BytecodeLength = @ref.BytecodeLength;
            fixed (void* __to = &this.SODecls[0]) fixed (void* __from = &@ref.SODecls) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 4*sizeof ( System.IntPtr));
            this.RasterizedStream = @ref.RasterizedStream;
            this.InputParameterCount = @ref.InputParameterCount;
            this.OutputParameterCount = @ref.OutputParameterCount;
            this.PatchConstantSignatureEntrieCount = @ref.PatchConstantSignatureEntrieCount;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.InputSignaturePointer = this.InputSignaturePointer;
            @ref.IsInline = this.IsInline;
            @ref.BytecodePointer = this.BytecodePointer;
            @ref.BytecodeLength = this.BytecodeLength;
            fixed (void* __to = &@ref.SODecls) fixed (void* __from = &this.SODecls[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 4*sizeof ( System.IntPtr));
            @ref.RasterizedStream = this.RasterizedStream;
            @ref.InputParameterCount = this.InputParameterCount;
            @ref.OutputParameterCount = this.OutputParameterCount;
            @ref.PatchConstantSignatureEntrieCount = this.PatchConstantSignatureEntrieCount;
		
		}
    }
    
    /// <summary>	
    /// <p>Describes an effect technique.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><see cref="SharpDX.Direct3D11.EffectTechniqueDescription"/> is used with <strong><see cref="SharpDX.Direct3D11.EffectTechnique.GetDescription"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_TECHNIQUE_DESC']/*"/>	
    /// <msdn-id>ff476326</msdn-id>	
    /// <unmanaged>D3DX11_TECHNIQUE_DESC</unmanaged>	
    /// <unmanaged-short>D3DX11_TECHNIQUE_DESC</unmanaged-short>	
    public  partial struct EffectTechniqueDescription {	
        
        /// <summary>	
        /// <dd> <p>Name of this technique (<c>null</c> if not anonymous).</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_TECHNIQUE_DESC::Name']/*"/>	
        /// <msdn-id>ff476326</msdn-id>	
        /// <unmanaged>const char* Name</unmanaged>	
        /// <unmanaged-short>char Name</unmanaged-short>	
        public string Name;
        
        /// <summary>	
        /// <dd> <p>Number of passes contained in the technique.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_TECHNIQUE_DESC::Passes']/*"/>	
        /// <msdn-id>ff476326</msdn-id>	
        /// <unmanaged>unsigned int Passes</unmanaged>	
        /// <unmanaged-short>unsigned int Passes</unmanaged-short>	
        public int PassCount;
        
        /// <summary>	
        /// <dd> <p>Number of annotations on this technique.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_TECHNIQUE_DESC::Annotations']/*"/>	
        /// <msdn-id>ff476326</msdn-id>	
        /// <unmanaged>unsigned int Annotations</unmanaged>	
        /// <unmanaged-short>unsigned int Annotations</unmanaged-short>	
        public int AnnotationCount;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential)]
        internal partial struct __Native {	
            public System.IntPtr Name;
            public int PassCount;
            public int AnnotationCount;
		    // Method to free unmanaged allocation
            internal unsafe void __MarshalFree()
            {   
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
            }
        }
		
		// Method to free unmanaged allocation
        internal unsafe void __MarshalFree(ref __Native @ref)
        {   
            @ref.__MarshalFree();
        }
		
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:Marshal.PtrToStringAnsi(@ref.Name);
            this.PassCount = @ref.PassCount;
            this.AnnotationCount = @ref.AnnotationCount;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Utilities.StringToHGlobalAnsi(this.Name);
            @ref.PassCount = this.PassCount;
            @ref.AnnotationCount = this.AnnotationCount;
		
		}
    }
    
    /// <summary>	
    /// <p>Describes an effect-variable type.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><see cref="SharpDX.Direct3D11.EffectTypeDescription"/> is used with <strong><see cref="SharpDX.Direct3D11.EffectType.GetDescription"/></strong> </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_TYPE_DESC']/*"/>	
    /// <msdn-id>ff476305</msdn-id>	
    /// <unmanaged>D3DX11_EFFECT_TYPE_DESC</unmanaged>	
    /// <unmanaged-short>D3DX11_EFFECT_TYPE_DESC</unmanaged-short>	
    public  partial struct EffectTypeDescription {	
        
        /// <summary>	
        /// <dd> <p>Name of the type, for example "float4" or "MyStruct".</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_TYPE_DESC::TypeName']/*"/>	
        /// <msdn-id>ff476305</msdn-id>	
        /// <unmanaged>const char* TypeName</unmanaged>	
        /// <unmanaged-short>char TypeName</unmanaged-short>	
        public string TypeName;
        
        /// <summary>	
        /// <dd> <p>The variable class (see <strong>D3D10_SHADER_VARIABLE_CLASS</strong>). </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_TYPE_DESC::Class']/*"/>	
        /// <msdn-id>ff476305</msdn-id>	
        /// <unmanaged>D3D_SHADER_VARIABLE_CLASS Class</unmanaged>	
        /// <unmanaged-short>D3D_SHADER_VARIABLE_CLASS Class</unmanaged-short>	
        public SharpDX.D3DCompiler.ShaderVariableClass Class;
        
        /// <summary>	
        /// <dd> <p>The variable type (see <strong>D3D10_SHADER_VARIABLE_TYPE</strong>).</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_TYPE_DESC::Type']/*"/>	
        /// <msdn-id>ff476305</msdn-id>	
        /// <unmanaged>D3D_SHADER_VARIABLE_TYPE Type</unmanaged>	
        /// <unmanaged-short>D3D_SHADER_VARIABLE_TYPE Type</unmanaged-short>	
        public SharpDX.D3DCompiler.ShaderVariableType Type;
        
        /// <summary>	
        /// <dd> <p>Number of elements in this type (0 if not an array).</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_TYPE_DESC::Elements']/*"/>	
        /// <msdn-id>ff476305</msdn-id>	
        /// <unmanaged>unsigned int Elements</unmanaged>	
        /// <unmanaged-short>unsigned int Elements</unmanaged-short>	
        public int Elements;
        
        /// <summary>	
        /// <dd> <p>Number of members (0 if not a structure).</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_TYPE_DESC::Members']/*"/>	
        /// <msdn-id>ff476305</msdn-id>	
        /// <unmanaged>unsigned int Members</unmanaged>	
        /// <unmanaged-short>unsigned int Members</unmanaged-short>	
        public int Members;
        
        /// <summary>	
        /// <dd> <p>Number of rows in this type (0 if not a numeric primitive).</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_TYPE_DESC::Rows']/*"/>	
        /// <msdn-id>ff476305</msdn-id>	
        /// <unmanaged>unsigned int Rows</unmanaged>	
        /// <unmanaged-short>unsigned int Rows</unmanaged-short>	
        public int Rows;
        
        /// <summary>	
        /// <dd> <p>Number of columns in this type (0 if not a numeric primitive).</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_TYPE_DESC::Columns']/*"/>	
        /// <msdn-id>ff476305</msdn-id>	
        /// <unmanaged>unsigned int Columns</unmanaged>	
        /// <unmanaged-short>unsigned int Columns</unmanaged-short>	
        public int Columns;
        
        /// <summary>	
        /// <dd> <p>Number of bytes required to represent this data type, when tightly packed.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_TYPE_DESC::PackedSize']/*"/>	
        /// <msdn-id>ff476305</msdn-id>	
        /// <unmanaged>unsigned int PackedSize</unmanaged>	
        /// <unmanaged-short>unsigned int PackedSize</unmanaged-short>	
        public int PackedSize;
        
        /// <summary>	
        /// <dd> <p>Number of bytes occupied by this data type, when laid out in a constant buffer.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_TYPE_DESC::UnpackedSize']/*"/>	
        /// <msdn-id>ff476305</msdn-id>	
        /// <unmanaged>unsigned int UnpackedSize</unmanaged>	
        /// <unmanaged-short>unsigned int UnpackedSize</unmanaged-short>	
        public int UnpackedSize;
        
        /// <summary>	
        /// <dd> <p>Number of bytes to seek between elements, when laid out in a constant buffer.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_TYPE_DESC::Stride']/*"/>	
        /// <msdn-id>ff476305</msdn-id>	
        /// <unmanaged>unsigned int Stride</unmanaged>	
        /// <unmanaged-short>unsigned int Stride</unmanaged-short>	
        public int Stride;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential)]
        internal partial struct __Native {	
            public System.IntPtr TypeName;
            public SharpDX.D3DCompiler.ShaderVariableClass Class;
            public SharpDX.D3DCompiler.ShaderVariableType Type;
            public int Elements;
            public int Members;
            public int Rows;
            public int Columns;
            public int PackedSize;
            public int UnpackedSize;
            public int Stride;
		    // Method to free unmanaged allocation
            internal unsafe void __MarshalFree()
            {   
                if (this.TypeName != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.TypeName);		
            }
        }
		
		// Method to free unmanaged allocation
        internal unsafe void __MarshalFree(ref __Native @ref)
        {   
            @ref.__MarshalFree();
        }
		
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.TypeName = ( @ref.TypeName == IntPtr.Zero )?null:Marshal.PtrToStringAnsi(@ref.TypeName);
            this.Class = @ref.Class;
            this.Type = @ref.Type;
            this.Elements = @ref.Elements;
            this.Members = @ref.Members;
            this.Rows = @ref.Rows;
            this.Columns = @ref.Columns;
            this.PackedSize = @ref.PackedSize;
            this.UnpackedSize = @ref.UnpackedSize;
            this.Stride = @ref.Stride;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.TypeName = ( this.TypeName == null )?IntPtr.Zero : Utilities.StringToHGlobalAnsi(this.TypeName);
            @ref.Class = this.Class;
            @ref.Type = this.Type;
            @ref.Elements = this.Elements;
            @ref.Members = this.Members;
            @ref.Rows = this.Rows;
            @ref.Columns = this.Columns;
            @ref.PackedSize = this.PackedSize;
            @ref.UnpackedSize = this.UnpackedSize;
            @ref.Stride = this.Stride;
		
		}
    }
    
    /// <summary>	
    /// <p>Describes an effect variable.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><see cref="SharpDX.Direct3D11.EffectVariableDescription"/> is used with <strong><see cref="SharpDX.Direct3D11.EffectVariable.GetDescription"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_VARIABLE_DESC']/*"/>	
    /// <msdn-id>ff476306</msdn-id>	
    /// <unmanaged>D3DX11_EFFECT_VARIABLE_DESC</unmanaged>	
    /// <unmanaged-short>D3DX11_EFFECT_VARIABLE_DESC</unmanaged-short>	
    public  partial struct EffectVariableDescription {	
        
        /// <summary>	
        /// <dd> <p>Name of this variable, annotation, or structure member.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_VARIABLE_DESC::Name']/*"/>	
        /// <msdn-id>ff476306</msdn-id>	
        /// <unmanaged>const char* Name</unmanaged>	
        /// <unmanaged-short>char Name</unmanaged-short>	
        public string Name;
        
        /// <summary>	
        /// <dd> <p>Semantic string of this variable or structure member (<c>null</c> for annotations or if not present).</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_VARIABLE_DESC::Semantic']/*"/>	
        /// <msdn-id>ff476306</msdn-id>	
        /// <unmanaged>const char* Semantic</unmanaged>	
        /// <unmanaged-short>char Semantic</unmanaged-short>	
        public string Semantic;
        
        /// <summary>	
        /// <dd> <p>Optional flags for effect variables.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_VARIABLE_DESC::Flags']/*"/>	
        /// <msdn-id>ff476306</msdn-id>	
        /// <unmanaged>D3DX11_EFFECT_VARIABLE_FLAGS Flags</unmanaged>	
        /// <unmanaged-short>D3DX11_EFFECT_VARIABLE_FLAGS Flags</unmanaged-short>	
        public SharpDX.Direct3D11.EffectVariableFlags Flags;
        
        /// <summary>	
        /// <dd> <p>Number of annotations on this variable (always 0 for annotations).</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_VARIABLE_DESC::Annotations']/*"/>	
        /// <msdn-id>ff476306</msdn-id>	
        /// <unmanaged>unsigned int Annotations</unmanaged>	
        /// <unmanaged-short>unsigned int Annotations</unmanaged-short>	
        public int AnnotationCount;
        
        /// <summary>	
        /// <dd> <p>Offset into containing cbuffer or tbuffer (always 0 for annotations or variables not in constant buffers).</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_VARIABLE_DESC::BufferOffset']/*"/>	
        /// <msdn-id>ff476306</msdn-id>	
        /// <unmanaged>unsigned int BufferOffset</unmanaged>	
        /// <unmanaged-short>unsigned int BufferOffset</unmanaged-short>	
        public int BufferOffset;
        
        /// <summary>	
        /// <dd> <p>Used if the variable has been explicitly bound using the register keyword. Check Flags for <see cref="SharpDX.Direct3D11.EffectVariableFlags.ExplicitBindPoint"/>.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_EFFECT_VARIABLE_DESC::ExplicitBindPoint']/*"/>	
        /// <msdn-id>ff476306</msdn-id>	
        /// <unmanaged>unsigned int ExplicitBindPoint</unmanaged>	
        /// <unmanaged-short>unsigned int ExplicitBindPoint</unmanaged-short>	
        public int ExplicitBindPoint;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential)]
        internal partial struct __Native {	
            public System.IntPtr Name;
            public System.IntPtr Semantic;
            public SharpDX.Direct3D11.EffectVariableFlags Flags;
            public int AnnotationCount;
            public int BufferOffset;
            public int ExplicitBindPoint;
		    // Method to free unmanaged allocation
            internal unsafe void __MarshalFree()
            {   
                if (this.Name != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Name);		
                if (this.Semantic != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.Semantic);		
            }
        }
		
		// Method to free unmanaged allocation
        internal unsafe void __MarshalFree(ref __Native @ref)
        {   
            @ref.__MarshalFree();
        }
		
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Name = ( @ref.Name == IntPtr.Zero )?null:Marshal.PtrToStringAnsi(@ref.Name);
            this.Semantic = ( @ref.Semantic == IntPtr.Zero )?null:Marshal.PtrToStringAnsi(@ref.Semantic);
            this.Flags = @ref.Flags;
            this.AnnotationCount = @ref.AnnotationCount;
            this.BufferOffset = @ref.BufferOffset;
            this.ExplicitBindPoint = @ref.ExplicitBindPoint;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Name = ( this.Name == null )?IntPtr.Zero : Utilities.StringToHGlobalAnsi(this.Name);
            @ref.Semantic = ( this.Semantic == null )?IntPtr.Zero : Utilities.StringToHGlobalAnsi(this.Semantic);
            @ref.Flags = this.Flags;
            @ref.AnnotationCount = this.AnnotationCount;
            @ref.BufferOffset = this.BufferOffset;
            @ref.ExplicitBindPoint = this.ExplicitBindPoint;
		
		}
    }
    
    /// <summary>	
    /// <p>Indicates the device state.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A state-block mask indicates the device states that a pass or a technique changes.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK']/*"/>	
    /// <msdn-id>ff476325</msdn-id>	
    /// <unmanaged>D3DX11_STATE_BLOCK_MASK</unmanaged>	
    /// <unmanaged-short>D3DX11_STATE_BLOCK_MASK</unmanaged-short>	
    public  partial struct StateBlockMask {	
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the vertex shader state. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::VS']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char VS</unmanaged>	
        /// <unmanaged-short>unsigned char VS</unmanaged-short>	
        public byte VertexShader;
        
        /// <summary>	
        /// <dd> <p>Array of vertex-shader samplers. The array is a multi-byte bitmask where each bit represents one sampler slot. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::VSSamplers']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char VSSamplers[2]</unmanaged>	
        /// <unmanaged-short>unsigned char VSSamplers</unmanaged-short>	
        public byte[] VSSamplers { 
            get { return _VSSamplers ?? (_VSSamplers = new byte[2]);}
        }
        internal byte[] _VSSamplers;
        
        /// <summary>	
        /// <dd> <p>Array of vertex-shader resources. The array is a multi-byte bitmask where each bit represents one resource slot. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::VSShaderResources']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char VSShaderResources[16]</unmanaged>	
        /// <unmanaged-short>unsigned char VSShaderResources</unmanaged-short>	
        public byte[] VSShaderResources { 
            get { return _VSShaderResources ?? (_VSShaderResources = new byte[16]);}
        }
        internal byte[] _VSShaderResources;
        
        /// <summary>	
        /// <dd> <p>Array of vertex-shader constant buffers. The array is a multi-byte bitmask where each bit represents one constant buffer slot. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::VSConstantBuffers']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char VSConstantBuffers[2]</unmanaged>	
        /// <unmanaged-short>unsigned char VSConstantBuffers</unmanaged-short>	
        public byte[] VSConstantBuffers { 
            get { return _VSConstantBuffers ?? (_VSConstantBuffers = new byte[2]);}
        }
        internal byte[] _VSConstantBuffers;
        
        /// <summary>	
        /// <dd> <p>Array of vertex-shader interfaces. The array is a multi-byte bitmask where each bit represents one interface slot.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::VSInterfaces']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char VSInterfaces[32]</unmanaged>	
        /// <unmanaged-short>unsigned char VSInterfaces</unmanaged-short>	
        public byte[] VSInterfaces { 
            get { return _VSInterfaces ?? (_VSInterfaces = new byte[32]);}
        }
        internal byte[] _VSInterfaces;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the hull shader state. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::HS']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char HS</unmanaged>	
        /// <unmanaged-short>unsigned char HS</unmanaged-short>	
        public byte HullShader;
        
        /// <summary>	
        /// <dd> <p>Array of hull-shader samplers. The array is a multi-byte bitmask where each bit represents one sampler slot. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::HSSamplers']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char HSSamplers[2]</unmanaged>	
        /// <unmanaged-short>unsigned char HSSamplers</unmanaged-short>	
        public byte[] HSSamplers { 
            get { return _HSSamplers ?? (_HSSamplers = new byte[2]);}
        }
        internal byte[] _HSSamplers;
        
        /// <summary>	
        /// <dd> <p>Array of hull-shader resources. The array is a multi-byte bitmask where each bit represents one resource slot.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::HSShaderResources']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char HSShaderResources[16]</unmanaged>	
        /// <unmanaged-short>unsigned char HSShaderResources</unmanaged-short>	
        public byte[] HSShaderResources { 
            get { return _HSShaderResources ?? (_HSShaderResources = new byte[16]);}
        }
        internal byte[] _HSShaderResources;
        
        /// <summary>	
        /// <dd> <p>Array of hull-shader constant buffers. The array is a multi-byte bitmask where each bit represents one constant buffer slot.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::HSConstantBuffers']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char HSConstantBuffers[2]</unmanaged>	
        /// <unmanaged-short>unsigned char HSConstantBuffers</unmanaged-short>	
        public byte[] HSConstantBuffers { 
            get { return _HSConstantBuffers ?? (_HSConstantBuffers = new byte[2]);}
        }
        internal byte[] _HSConstantBuffers;
        
        /// <summary>	
        /// <dd> <p>Array of hull-shader interfaces. The array is a multi-byte bitmask where each bit represents one interface slot.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::HSInterfaces']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char HSInterfaces[32]</unmanaged>	
        /// <unmanaged-short>unsigned char HSInterfaces</unmanaged-short>	
        public byte[] HSInterfaces { 
            get { return _HSInterfaces ?? (_HSInterfaces = new byte[32]);}
        }
        internal byte[] _HSInterfaces;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the domain shader state. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::DS']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char DS</unmanaged>	
        /// <unmanaged-short>unsigned char DS</unmanaged-short>	
        public byte DomainShader;
        
        /// <summary>	
        /// <dd> <p>Array of domain-shader samplers. The array is a multi-byte bitmask where each bit represents one sampler slot.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::DSSamplers']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char DSSamplers[2]</unmanaged>	
        /// <unmanaged-short>unsigned char DSSamplers</unmanaged-short>	
        public byte[] DSSamplers { 
            get { return _DSSamplers ?? (_DSSamplers = new byte[2]);}
        }
        internal byte[] _DSSamplers;
        
        /// <summary>	
        /// <dd> <p>Array of domain-shader resources. The array is a multi-byte bitmask where each bit represents one resource slot.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::DSShaderResources']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char DSShaderResources[16]</unmanaged>	
        /// <unmanaged-short>unsigned char DSShaderResources</unmanaged-short>	
        public byte[] DSShaderResources { 
            get { return _DSShaderResources ?? (_DSShaderResources = new byte[16]);}
        }
        internal byte[] _DSShaderResources;
        
        /// <summary>	
        /// <dd> <p>Array of domain-shader constant buffers. The array is a multi-byte bitmask where each bit represents one buffer slot.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::DSConstantBuffers']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char DSConstantBuffers[2]</unmanaged>	
        /// <unmanaged-short>unsigned char DSConstantBuffers</unmanaged-short>	
        public byte[] DSConstantBuffers { 
            get { return _DSConstantBuffers ?? (_DSConstantBuffers = new byte[2]);}
        }
        internal byte[] _DSConstantBuffers;
        
        /// <summary>	
        /// <dd> <p>Array of domain-shader interfaces. The array is a multi-byte bitmask where each bit represents one interface slot.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::DSInterfaces']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char DSInterfaces[32]</unmanaged>	
        /// <unmanaged-short>unsigned char DSInterfaces</unmanaged-short>	
        public byte[] DSInterfaces { 
            get { return _DSInterfaces ?? (_DSInterfaces = new byte[32]);}
        }
        internal byte[] _DSInterfaces;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the geometry shader state. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::GS']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char GS</unmanaged>	
        /// <unmanaged-short>unsigned char GS</unmanaged-short>	
        public byte GeometryShader;
        
        /// <summary>	
        /// <dd> <p>Array of geometry-shader samplers. The array is a multi-byte bitmask where each bit represents one sampler slot. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::GSSamplers']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char GSSamplers[2]</unmanaged>	
        /// <unmanaged-short>unsigned char GSSamplers</unmanaged-short>	
        public byte[] GSSamplers { 
            get { return _GSSamplers ?? (_GSSamplers = new byte[2]);}
        }
        internal byte[] _GSSamplers;
        
        /// <summary>	
        /// <dd> <p>Array of geometry-shader resources. The array is a multi-byte bitmask where each bit represents one resource slot.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::GSShaderResources']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char GSShaderResources[16]</unmanaged>	
        /// <unmanaged-short>unsigned char GSShaderResources</unmanaged-short>	
        public byte[] GSShaderResources { 
            get { return _GSShaderResources ?? (_GSShaderResources = new byte[16]);}
        }
        internal byte[] _GSShaderResources;
        
        /// <summary>	
        /// <dd> <p>Array of geometry-shader constant buffers. The array is a multi-byte bitmask where each bit represents one buffer slot. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::GSConstantBuffers']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char GSConstantBuffers[2]</unmanaged>	
        /// <unmanaged-short>unsigned char GSConstantBuffers</unmanaged-short>	
        public byte[] GSConstantBuffers { 
            get { return _GSConstantBuffers ?? (_GSConstantBuffers = new byte[2]);}
        }
        internal byte[] _GSConstantBuffers;
        
        /// <summary>	
        /// <dd> <p>Array of geometry-shader interfaces. The array is a multi-byte bitmask where each bit represents one interface slot.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::GSInterfaces']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char GSInterfaces[32]</unmanaged>	
        /// <unmanaged-short>unsigned char GSInterfaces</unmanaged-short>	
        public byte[] GSInterfaces { 
            get { return _GSInterfaces ?? (_GSInterfaces = new byte[32]);}
        }
        internal byte[] _GSInterfaces;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the pixel shader state.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::PS']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char PS</unmanaged>	
        /// <unmanaged-short>unsigned char PS</unmanaged-short>	
        public byte PixelShader;
        
        /// <summary>	
        /// <dd> <p>Array of pixel-shader samplers. The array is a multi-byte bitmask where each bit represents one sampler slot. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::PSSamplers']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char PSSamplers[2]</unmanaged>	
        /// <unmanaged-short>unsigned char PSSamplers</unmanaged-short>	
        public byte[] PSSamplers { 
            get { return _PSSamplers ?? (_PSSamplers = new byte[2]);}
        }
        internal byte[] _PSSamplers;
        
        /// <summary>	
        /// <dd> <p>Array of pixel-shader resources. The array is a multi-byte bitmask where each bit represents one resource slot. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::PSShaderResources']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char PSShaderResources[16]</unmanaged>	
        /// <unmanaged-short>unsigned char PSShaderResources</unmanaged-short>	
        public byte[] PSShaderResources { 
            get { return _PSShaderResources ?? (_PSShaderResources = new byte[16]);}
        }
        internal byte[] _PSShaderResources;
        
        /// <summary>	
        /// <dd> <p>Array of pixel-shader constant buffers. The array is a multi-byte bitmask where each bit represents one constant buffer slot. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::PSConstantBuffers']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char PSConstantBuffers[2]</unmanaged>	
        /// <unmanaged-short>unsigned char PSConstantBuffers</unmanaged-short>	
        public byte[] PSConstantBuffers { 
            get { return _PSConstantBuffers ?? (_PSConstantBuffers = new byte[2]);}
        }
        internal byte[] _PSConstantBuffers;
        
        /// <summary>	
        /// <dd> <p>Array of pixel-shader interfaces. The array is a multi-byte bitmask where each bit represents one interface slot. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::PSInterfaces']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char PSInterfaces[32]</unmanaged>	
        /// <unmanaged-short>unsigned char PSInterfaces</unmanaged-short>	
        public byte[] PSInterfaces { 
            get { return _PSInterfaces ?? (_PSInterfaces = new byte[32]);}
        }
        internal byte[] _PSInterfaces;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the pixel shader unordered access views.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::PSUnorderedAccessViews']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char PSUnorderedAccessViews</unmanaged>	
        /// <unmanaged-short>unsigned char PSUnorderedAccessViews</unmanaged-short>	
        public byte PSUnorderedAccessViews;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the compute shader state.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::CS']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char CS</unmanaged>	
        /// <unmanaged-short>unsigned char CS</unmanaged-short>	
        public byte ComputeShader;
        
        /// <summary>	
        /// <dd> <p>Array of compute-shader samplers. The array is a multi-byte bitmask where each bit represents one sampler slot. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::CSSamplers']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char CSSamplers[2]</unmanaged>	
        /// <unmanaged-short>unsigned char CSSamplers</unmanaged-short>	
        public byte[] CSSamplers { 
            get { return _CSSamplers ?? (_CSSamplers = new byte[2]);}
        }
        internal byte[] _CSSamplers;
        
        /// <summary>	
        /// <dd> <p>Array of compute-shader resources. The array is a multi-byte bitmask where each bit represents one resource slot.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::CSShaderResources']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char CSShaderResources[16]</unmanaged>	
        /// <unmanaged-short>unsigned char CSShaderResources</unmanaged-short>	
        public byte[] CSShaderResources { 
            get { return _CSShaderResources ?? (_CSShaderResources = new byte[16]);}
        }
        internal byte[] _CSShaderResources;
        
        /// <summary>	
        /// <dd> <p>Array of compute-shader constant buffers. The array is a multi-byte bitmask where each bit represents one constant buffer slot.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::CSConstantBuffers']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char CSConstantBuffers[2]</unmanaged>	
        /// <unmanaged-short>unsigned char CSConstantBuffers</unmanaged-short>	
        public byte[] CSConstantBuffers { 
            get { return _CSConstantBuffers ?? (_CSConstantBuffers = new byte[2]);}
        }
        internal byte[] _CSConstantBuffers;
        
        /// <summary>	
        /// <dd> <p>Array of compute-shader interfaces. The array is a multi-byte bitmask where each bit represents one interface slot.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::CSInterfaces']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char CSInterfaces[32]</unmanaged>	
        /// <unmanaged-short>unsigned char CSInterfaces</unmanaged-short>	
        public byte[] CSInterfaces { 
            get { return _CSInterfaces ?? (_CSInterfaces = new byte[32]);}
        }
        internal byte[] _CSInterfaces;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the compute shader unordered access views.</p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::CSUnorderedAccessViews']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char CSUnorderedAccessViews</unmanaged>	
        /// <unmanaged-short>unsigned char CSUnorderedAccessViews</unmanaged-short>	
        public byte CSUnorderedAccessViews;
        
        /// <summary>	
        /// <dd> <p>Array of vertex buffers. The array is a multi-byte bitmask where each bit represents one resource slot. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::IAVertexBuffers']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char IAVertexBuffers[4]</unmanaged>	
        /// <unmanaged-short>unsigned char IAVertexBuffers</unmanaged-short>	
        public byte[] IAVertexBuffers { 
            get { return _IAVertexBuffers ?? (_IAVertexBuffers = new byte[4]);}
        }
        internal byte[] _IAVertexBuffers;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the index buffer state. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::IAIndexBuffer']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char IAIndexBuffer</unmanaged>	
        /// <unmanaged-short>unsigned char IAIndexBuffer</unmanaged-short>	
        public byte IAIndexBuffer;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the input layout state. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::IAInputLayout']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char IAInputLayout</unmanaged>	
        /// <unmanaged-short>unsigned char IAInputLayout</unmanaged-short>	
        public byte IAInputLayout;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the primitive topology state. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::IAPrimitiveTopology']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char IAPrimitiveTopology</unmanaged>	
        /// <unmanaged-short>unsigned char IAPrimitiveTopology</unmanaged-short>	
        public byte IAPrimitiveTopology;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the render targets states. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::OMRenderTargets']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char OMRenderTargets</unmanaged>	
        /// <unmanaged-short>unsigned char OMRenderTargets</unmanaged-short>	
        public byte OMRenderTargets;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the depth-stencil state. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::OMDepthStencilState']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char OMDepthStencilState</unmanaged>	
        /// <unmanaged-short>unsigned char OMDepthStencilState</unmanaged-short>	
        public byte OMDepthStencilState;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the blend state. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::OMBlendState']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char OMBlendState</unmanaged>	
        /// <unmanaged-short>unsigned char OMBlendState</unmanaged-short>	
        public byte OMBlendState;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the viewports states. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::RSViewports']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char RSViewports</unmanaged>	
        /// <unmanaged-short>unsigned char RSViewports</unmanaged-short>	
        public byte RSViewports;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the scissor rectangles states. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::RSScissorRects']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char RSScissorRects</unmanaged>	
        /// <unmanaged-short>unsigned char RSScissorRects</unmanaged-short>	
        public byte RSScissorRects;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the rasterizer state. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::RSRasterizerState']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char RSRasterizerState</unmanaged>	
        /// <unmanaged-short>unsigned char RSRasterizerState</unmanaged-short>	
        public byte RSRasterizerState;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the stream-out buffers states. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::SOBuffers']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char SOBuffers</unmanaged>	
        /// <unmanaged-short>unsigned char SOBuffers</unmanaged-short>	
        public byte SOBuffers;
        
        /// <summary>	
        /// <dd> <p>Boolean value indicating whether to save the predication state. </p> </dd>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DX11_STATE_BLOCK_MASK::Predication']/*"/>	
        /// <msdn-id>ff476325</msdn-id>	
        /// <unmanaged>unsigned char Predication</unmanaged>	
        /// <unmanaged-short>unsigned char Predication</unmanaged-short>	
        public byte Predication;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential)]
        internal partial struct __Native {	
            public byte VertexShader;
            public byte VSSamplers;
            byte __VSSamplers1;
            public byte VSShaderResources;
            byte __VSShaderResources1;
            byte __VSShaderResources2;
            byte __VSShaderResources3;
            byte __VSShaderResources4;
            byte __VSShaderResources5;
            byte __VSShaderResources6;
            byte __VSShaderResources7;
            byte __VSShaderResources8;
            byte __VSShaderResources9;
            byte __VSShaderResources10;
            byte __VSShaderResources11;
            byte __VSShaderResources12;
            byte __VSShaderResources13;
            byte __VSShaderResources14;
            byte __VSShaderResources15;
            public byte VSConstantBuffers;
            byte __VSConstantBuffers1;
            public byte VSInterfaces;
            byte __VSInterfaces1;
            byte __VSInterfaces2;
            byte __VSInterfaces3;
            byte __VSInterfaces4;
            byte __VSInterfaces5;
            byte __VSInterfaces6;
            byte __VSInterfaces7;
            byte __VSInterfaces8;
            byte __VSInterfaces9;
            byte __VSInterfaces10;
            byte __VSInterfaces11;
            byte __VSInterfaces12;
            byte __VSInterfaces13;
            byte __VSInterfaces14;
            byte __VSInterfaces15;
            byte __VSInterfaces16;
            byte __VSInterfaces17;
            byte __VSInterfaces18;
            byte __VSInterfaces19;
            byte __VSInterfaces20;
            byte __VSInterfaces21;
            byte __VSInterfaces22;
            byte __VSInterfaces23;
            byte __VSInterfaces24;
            byte __VSInterfaces25;
            byte __VSInterfaces26;
            byte __VSInterfaces27;
            byte __VSInterfaces28;
            byte __VSInterfaces29;
            byte __VSInterfaces30;
            byte __VSInterfaces31;
            public byte HullShader;
            public byte HSSamplers;
            byte __HSSamplers1;
            public byte HSShaderResources;
            byte __HSShaderResources1;
            byte __HSShaderResources2;
            byte __HSShaderResources3;
            byte __HSShaderResources4;
            byte __HSShaderResources5;
            byte __HSShaderResources6;
            byte __HSShaderResources7;
            byte __HSShaderResources8;
            byte __HSShaderResources9;
            byte __HSShaderResources10;
            byte __HSShaderResources11;
            byte __HSShaderResources12;
            byte __HSShaderResources13;
            byte __HSShaderResources14;
            byte __HSShaderResources15;
            public byte HSConstantBuffers;
            byte __HSConstantBuffers1;
            public byte HSInterfaces;
            byte __HSInterfaces1;
            byte __HSInterfaces2;
            byte __HSInterfaces3;
            byte __HSInterfaces4;
            byte __HSInterfaces5;
            byte __HSInterfaces6;
            byte __HSInterfaces7;
            byte __HSInterfaces8;
            byte __HSInterfaces9;
            byte __HSInterfaces10;
            byte __HSInterfaces11;
            byte __HSInterfaces12;
            byte __HSInterfaces13;
            byte __HSInterfaces14;
            byte __HSInterfaces15;
            byte __HSInterfaces16;
            byte __HSInterfaces17;
            byte __HSInterfaces18;
            byte __HSInterfaces19;
            byte __HSInterfaces20;
            byte __HSInterfaces21;
            byte __HSInterfaces22;
            byte __HSInterfaces23;
            byte __HSInterfaces24;
            byte __HSInterfaces25;
            byte __HSInterfaces26;
            byte __HSInterfaces27;
            byte __HSInterfaces28;
            byte __HSInterfaces29;
            byte __HSInterfaces30;
            byte __HSInterfaces31;
            public byte DomainShader;
            public byte DSSamplers;
            byte __DSSamplers1;
            public byte DSShaderResources;
            byte __DSShaderResources1;
            byte __DSShaderResources2;
            byte __DSShaderResources3;
            byte __DSShaderResources4;
            byte __DSShaderResources5;
            byte __DSShaderResources6;
            byte __DSShaderResources7;
            byte __DSShaderResources8;
            byte __DSShaderResources9;
            byte __DSShaderResources10;
            byte __DSShaderResources11;
            byte __DSShaderResources12;
            byte __DSShaderResources13;
            byte __DSShaderResources14;
            byte __DSShaderResources15;
            public byte DSConstantBuffers;
            byte __DSConstantBuffers1;
            public byte DSInterfaces;
            byte __DSInterfaces1;
            byte __DSInterfaces2;
            byte __DSInterfaces3;
            byte __DSInterfaces4;
            byte __DSInterfaces5;
            byte __DSInterfaces6;
            byte __DSInterfaces7;
            byte __DSInterfaces8;
            byte __DSInterfaces9;
            byte __DSInterfaces10;
            byte __DSInterfaces11;
            byte __DSInterfaces12;
            byte __DSInterfaces13;
            byte __DSInterfaces14;
            byte __DSInterfaces15;
            byte __DSInterfaces16;
            byte __DSInterfaces17;
            byte __DSInterfaces18;
            byte __DSInterfaces19;
            byte __DSInterfaces20;
            byte __DSInterfaces21;
            byte __DSInterfaces22;
            byte __DSInterfaces23;
            byte __DSInterfaces24;
            byte __DSInterfaces25;
            byte __DSInterfaces26;
            byte __DSInterfaces27;
            byte __DSInterfaces28;
            byte __DSInterfaces29;
            byte __DSInterfaces30;
            byte __DSInterfaces31;
            public byte GeometryShader;
            public byte GSSamplers;
            byte __GSSamplers1;
            public byte GSShaderResources;
            byte __GSShaderResources1;
            byte __GSShaderResources2;
            byte __GSShaderResources3;
            byte __GSShaderResources4;
            byte __GSShaderResources5;
            byte __GSShaderResources6;
            byte __GSShaderResources7;
            byte __GSShaderResources8;
            byte __GSShaderResources9;
            byte __GSShaderResources10;
            byte __GSShaderResources11;
            byte __GSShaderResources12;
            byte __GSShaderResources13;
            byte __GSShaderResources14;
            byte __GSShaderResources15;
            public byte GSConstantBuffers;
            byte __GSConstantBuffers1;
            public byte GSInterfaces;
            byte __GSInterfaces1;
            byte __GSInterfaces2;
            byte __GSInterfaces3;
            byte __GSInterfaces4;
            byte __GSInterfaces5;
            byte __GSInterfaces6;
            byte __GSInterfaces7;
            byte __GSInterfaces8;
            byte __GSInterfaces9;
            byte __GSInterfaces10;
            byte __GSInterfaces11;
            byte __GSInterfaces12;
            byte __GSInterfaces13;
            byte __GSInterfaces14;
            byte __GSInterfaces15;
            byte __GSInterfaces16;
            byte __GSInterfaces17;
            byte __GSInterfaces18;
            byte __GSInterfaces19;
            byte __GSInterfaces20;
            byte __GSInterfaces21;
            byte __GSInterfaces22;
            byte __GSInterfaces23;
            byte __GSInterfaces24;
            byte __GSInterfaces25;
            byte __GSInterfaces26;
            byte __GSInterfaces27;
            byte __GSInterfaces28;
            byte __GSInterfaces29;
            byte __GSInterfaces30;
            byte __GSInterfaces31;
            public byte PixelShader;
            public byte PSSamplers;
            byte __PSSamplers1;
            public byte PSShaderResources;
            byte __PSShaderResources1;
            byte __PSShaderResources2;
            byte __PSShaderResources3;
            byte __PSShaderResources4;
            byte __PSShaderResources5;
            byte __PSShaderResources6;
            byte __PSShaderResources7;
            byte __PSShaderResources8;
            byte __PSShaderResources9;
            byte __PSShaderResources10;
            byte __PSShaderResources11;
            byte __PSShaderResources12;
            byte __PSShaderResources13;
            byte __PSShaderResources14;
            byte __PSShaderResources15;
            public byte PSConstantBuffers;
            byte __PSConstantBuffers1;
            public byte PSInterfaces;
            byte __PSInterfaces1;
            byte __PSInterfaces2;
            byte __PSInterfaces3;
            byte __PSInterfaces4;
            byte __PSInterfaces5;
            byte __PSInterfaces6;
            byte __PSInterfaces7;
            byte __PSInterfaces8;
            byte __PSInterfaces9;
            byte __PSInterfaces10;
            byte __PSInterfaces11;
            byte __PSInterfaces12;
            byte __PSInterfaces13;
            byte __PSInterfaces14;
            byte __PSInterfaces15;
            byte __PSInterfaces16;
            byte __PSInterfaces17;
            byte __PSInterfaces18;
            byte __PSInterfaces19;
            byte __PSInterfaces20;
            byte __PSInterfaces21;
            byte __PSInterfaces22;
            byte __PSInterfaces23;
            byte __PSInterfaces24;
            byte __PSInterfaces25;
            byte __PSInterfaces26;
            byte __PSInterfaces27;
            byte __PSInterfaces28;
            byte __PSInterfaces29;
            byte __PSInterfaces30;
            byte __PSInterfaces31;
            public byte PSUnorderedAccessViews;
            public byte ComputeShader;
            public byte CSSamplers;
            byte __CSSamplers1;
            public byte CSShaderResources;
            byte __CSShaderResources1;
            byte __CSShaderResources2;
            byte __CSShaderResources3;
            byte __CSShaderResources4;
            byte __CSShaderResources5;
            byte __CSShaderResources6;
            byte __CSShaderResources7;
            byte __CSShaderResources8;
            byte __CSShaderResources9;
            byte __CSShaderResources10;
            byte __CSShaderResources11;
            byte __CSShaderResources12;
            byte __CSShaderResources13;
            byte __CSShaderResources14;
            byte __CSShaderResources15;
            public byte CSConstantBuffers;
            byte __CSConstantBuffers1;
            public byte CSInterfaces;
            byte __CSInterfaces1;
            byte __CSInterfaces2;
            byte __CSInterfaces3;
            byte __CSInterfaces4;
            byte __CSInterfaces5;
            byte __CSInterfaces6;
            byte __CSInterfaces7;
            byte __CSInterfaces8;
            byte __CSInterfaces9;
            byte __CSInterfaces10;
            byte __CSInterfaces11;
            byte __CSInterfaces12;
            byte __CSInterfaces13;
            byte __CSInterfaces14;
            byte __CSInterfaces15;
            byte __CSInterfaces16;
            byte __CSInterfaces17;
            byte __CSInterfaces18;
            byte __CSInterfaces19;
            byte __CSInterfaces20;
            byte __CSInterfaces21;
            byte __CSInterfaces22;
            byte __CSInterfaces23;
            byte __CSInterfaces24;
            byte __CSInterfaces25;
            byte __CSInterfaces26;
            byte __CSInterfaces27;
            byte __CSInterfaces28;
            byte __CSInterfaces29;
            byte __CSInterfaces30;
            byte __CSInterfaces31;
            public byte CSUnorderedAccessViews;
            public byte IAVertexBuffers;
            byte __IAVertexBuffers1;
            byte __IAVertexBuffers2;
            byte __IAVertexBuffers3;
            public byte IAIndexBuffer;
            public byte IAInputLayout;
            public byte IAPrimitiveTopology;
            public byte OMRenderTargets;
            public byte OMDepthStencilState;
            public byte OMBlendState;
            public byte RSViewports;
            public byte RSScissorRects;
            public byte RSRasterizerState;
            public byte SOBuffers;
            public byte Predication;
		    // Method to free unmanaged allocation
            internal unsafe void __MarshalFree()
            {   
            }
        }
		
		// Method to free unmanaged allocation
        internal unsafe void __MarshalFree(ref __Native @ref)
        {   
            @ref.__MarshalFree();
        }
		
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.VertexShader = @ref.VertexShader;
            fixed (void* __to = &this.VSSamplers[0]) fixed (void* __from = &@ref.VSSamplers) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.VSShaderResources[0]) fixed (void* __from = &@ref.VSShaderResources) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = &this.VSConstantBuffers[0]) fixed (void* __from = &@ref.VSConstantBuffers) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.VSInterfaces[0]) fixed (void* __from = &@ref.VSInterfaces) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 32*sizeof ( byte));
            this.HullShader = @ref.HullShader;
            fixed (void* __to = &this.HSSamplers[0]) fixed (void* __from = &@ref.HSSamplers) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.HSShaderResources[0]) fixed (void* __from = &@ref.HSShaderResources) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = &this.HSConstantBuffers[0]) fixed (void* __from = &@ref.HSConstantBuffers) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.HSInterfaces[0]) fixed (void* __from = &@ref.HSInterfaces) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 32*sizeof ( byte));
            this.DomainShader = @ref.DomainShader;
            fixed (void* __to = &this.DSSamplers[0]) fixed (void* __from = &@ref.DSSamplers) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.DSShaderResources[0]) fixed (void* __from = &@ref.DSShaderResources) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = &this.DSConstantBuffers[0]) fixed (void* __from = &@ref.DSConstantBuffers) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.DSInterfaces[0]) fixed (void* __from = &@ref.DSInterfaces) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 32*sizeof ( byte));
            this.GeometryShader = @ref.GeometryShader;
            fixed (void* __to = &this.GSSamplers[0]) fixed (void* __from = &@ref.GSSamplers) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.GSShaderResources[0]) fixed (void* __from = &@ref.GSShaderResources) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = &this.GSConstantBuffers[0]) fixed (void* __from = &@ref.GSConstantBuffers) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.GSInterfaces[0]) fixed (void* __from = &@ref.GSInterfaces) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 32*sizeof ( byte));
            this.PixelShader = @ref.PixelShader;
            fixed (void* __to = &this.PSSamplers[0]) fixed (void* __from = &@ref.PSSamplers) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.PSShaderResources[0]) fixed (void* __from = &@ref.PSShaderResources) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = &this.PSConstantBuffers[0]) fixed (void* __from = &@ref.PSConstantBuffers) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.PSInterfaces[0]) fixed (void* __from = &@ref.PSInterfaces) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 32*sizeof ( byte));
            this.PSUnorderedAccessViews = @ref.PSUnorderedAccessViews;
            this.ComputeShader = @ref.ComputeShader;
            fixed (void* __to = &this.CSSamplers[0]) fixed (void* __from = &@ref.CSSamplers) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.CSShaderResources[0]) fixed (void* __from = &@ref.CSShaderResources) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = &this.CSConstantBuffers[0]) fixed (void* __from = &@ref.CSConstantBuffers) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &this.CSInterfaces[0]) fixed (void* __from = &@ref.CSInterfaces) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 32*sizeof ( byte));
            this.CSUnorderedAccessViews = @ref.CSUnorderedAccessViews;
            fixed (void* __to = &this.IAVertexBuffers[0]) fixed (void* __from = &@ref.IAVertexBuffers) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 4*sizeof ( byte));
            this.IAIndexBuffer = @ref.IAIndexBuffer;
            this.IAInputLayout = @ref.IAInputLayout;
            this.IAPrimitiveTopology = @ref.IAPrimitiveTopology;
            this.OMRenderTargets = @ref.OMRenderTargets;
            this.OMDepthStencilState = @ref.OMDepthStencilState;
            this.OMBlendState = @ref.OMBlendState;
            this.RSViewports = @ref.RSViewports;
            this.RSScissorRects = @ref.RSScissorRects;
            this.RSRasterizerState = @ref.RSRasterizerState;
            this.SOBuffers = @ref.SOBuffers;
            this.Predication = @ref.Predication;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.VertexShader = this.VertexShader;
            fixed (void* __to = &@ref.VSSamplers) fixed (void* __from = &this.VSSamplers[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &@ref.VSShaderResources) fixed (void* __from = &this.VSShaderResources[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = &@ref.VSConstantBuffers) fixed (void* __from = &this.VSConstantBuffers[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &@ref.VSInterfaces) fixed (void* __from = &this.VSInterfaces[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 32*sizeof ( byte));
            @ref.HullShader = this.HullShader;
            fixed (void* __to = &@ref.HSSamplers) fixed (void* __from = &this.HSSamplers[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &@ref.HSShaderResources) fixed (void* __from = &this.HSShaderResources[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = &@ref.HSConstantBuffers) fixed (void* __from = &this.HSConstantBuffers[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &@ref.HSInterfaces) fixed (void* __from = &this.HSInterfaces[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 32*sizeof ( byte));
            @ref.DomainShader = this.DomainShader;
            fixed (void* __to = &@ref.DSSamplers) fixed (void* __from = &this.DSSamplers[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &@ref.DSShaderResources) fixed (void* __from = &this.DSShaderResources[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = &@ref.DSConstantBuffers) fixed (void* __from = &this.DSConstantBuffers[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &@ref.DSInterfaces) fixed (void* __from = &this.DSInterfaces[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 32*sizeof ( byte));
            @ref.GeometryShader = this.GeometryShader;
            fixed (void* __to = &@ref.GSSamplers) fixed (void* __from = &this.GSSamplers[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &@ref.GSShaderResources) fixed (void* __from = &this.GSShaderResources[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = &@ref.GSConstantBuffers) fixed (void* __from = &this.GSConstantBuffers[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &@ref.GSInterfaces) fixed (void* __from = &this.GSInterfaces[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 32*sizeof ( byte));
            @ref.PixelShader = this.PixelShader;
            fixed (void* __to = &@ref.PSSamplers) fixed (void* __from = &this.PSSamplers[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &@ref.PSShaderResources) fixed (void* __from = &this.PSShaderResources[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = &@ref.PSConstantBuffers) fixed (void* __from = &this.PSConstantBuffers[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &@ref.PSInterfaces) fixed (void* __from = &this.PSInterfaces[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 32*sizeof ( byte));
            @ref.PSUnorderedAccessViews = this.PSUnorderedAccessViews;
            @ref.ComputeShader = this.ComputeShader;
            fixed (void* __to = &@ref.CSSamplers) fixed (void* __from = &this.CSSamplers[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &@ref.CSShaderResources) fixed (void* __from = &this.CSShaderResources[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 16*sizeof ( byte));
            fixed (void* __to = &@ref.CSConstantBuffers) fixed (void* __from = &this.CSConstantBuffers[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 2*sizeof ( byte));
            fixed (void* __to = &@ref.CSInterfaces) fixed (void* __from = &this.CSInterfaces[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 32*sizeof ( byte));
            @ref.CSUnorderedAccessViews = this.CSUnorderedAccessViews;
            fixed (void* __to = &@ref.IAVertexBuffers) fixed (void* __from = &this.IAVertexBuffers[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 4*sizeof ( byte));
            @ref.IAIndexBuffer = this.IAIndexBuffer;
            @ref.IAInputLayout = this.IAInputLayout;
            @ref.IAPrimitiveTopology = this.IAPrimitiveTopology;
            @ref.OMRenderTargets = this.OMRenderTargets;
            @ref.OMDepthStencilState = this.OMDepthStencilState;
            @ref.OMBlendState = this.OMBlendState;
            @ref.RSViewports = this.RSViewports;
            @ref.RSScissorRects = this.RSScissorRects;
            @ref.RSRasterizerState = this.RSRasterizerState;
            @ref.SOBuffers = this.SOBuffers;
            @ref.Predication = this.Predication;
		
		}
    }
}
