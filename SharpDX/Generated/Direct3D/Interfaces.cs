// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.Direct3D namespace.
//     This code was generated by a tool.
//     Date : 6/25/2016 10:38:10 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.Direct3D {

// Disable warning : XML comment is not placed on a valid language element
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
    /// <summary>	
    /// <p>This interface is used to return arbitrary length data.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An <strong><see cref="SharpDX.Direct3D.Blob"/></strong> is obtained by calling <strong>D3D10CreateBlob</strong>.</p><p>The  <strong>ID3DBlob</strong> interface is type defined in the  D3DCommon.h header file as a  <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface, which is fully defined in the  D3DCommon.h header file. <strong>ID3DBlob</strong> is version neutral and can be used in code for any Direct3D version.</p><p>Blobs can be used as a data buffer, storing vertex, adjacency, and material information during mesh optimization and loading operations. Also, these objects are used to return object code and error messages in APIs that compile vertex, geometry and pixel shaders.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Blob']/*"/>	
    /// <msdn-id>bb173507</msdn-id>	
    /// <unmanaged>ID3D10Blob</unmanaged>	
    /// <unmanaged-short>ID3D10Blob</unmanaged-short>	
    [Guid("8BA5FB08-5195-40e2-AC58-0D989C3A0102")]
    public partial class Blob : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D.Blob"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Blob(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D.Blob"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D.Blob(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D.Blob(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get a reference to the data.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Blob::GetBufferPointer']/*"/>	
        /// <msdn-id>bb173508</msdn-id>	
        /// <unmanaged>GetBufferPointer</unmanaged>	
        /// <unmanaged-short>GetBufferPointer</unmanaged-short>	
        /// <unmanaged>void* ID3D10Blob::GetBufferPointer()</unmanaged>
        public System.IntPtr BufferPointer {
                get { return GetBufferPointer(); }
        }
        
        /// <summary>	
        /// <p>Get the size.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Blob::GetBufferSize']/*"/>	
        /// <msdn-id>bb173509</msdn-id>	
        /// <unmanaged>GetBufferSize</unmanaged>	
        /// <unmanaged-short>GetBufferSize</unmanaged-short>	
        /// <unmanaged>SIZE_T ID3D10Blob::GetBufferSize()</unmanaged>
        public SharpDX.PointerSize BufferSize {
                get { return GetBufferSize(); }
        }
        
        /// <summary>	
        /// <p>Get a reference to the data.</p>	
        /// </summary>	
        /// <returns><p>Returns a reference.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Blob::GetBufferPointer']/*"/>	
        /// <msdn-id>bb173508</msdn-id>	
        /// <unmanaged>void* ID3D10Blob::GetBufferPointer()</unmanaged>	
        /// <unmanaged-short>ID3D10Blob::GetBufferPointer</unmanaged-short>	
        internal System.IntPtr GetBufferPointer() {
            unsafe {
                System.IntPtr __result__;
                __result__= 
				SharpDX.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get the size.</p>	
        /// </summary>	
        /// <returns><p>The size of the data, in bytes.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Blob::GetBufferSize']/*"/>	
        /// <msdn-id>bb173509</msdn-id>	
        /// <unmanaged>SIZE_T ID3D10Blob::GetBufferSize()</unmanaged>	
        /// <unmanaged-short>ID3D10Blob::GetBufferSize</unmanaged-short>	
        internal SharpDX.PointerSize GetBufferSize() {
            unsafe {
                SharpDX.PointerSize __result__;
                __result__= 
				SharpDX.LocalInterop.CallivoidPtr(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>A multithread interface accesses multithread settings and can only be used if the thread-safe layer is turned on. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is obtained by querying it from the <strong>ID3D10Device Interface</strong> using IUnknown::QueryInterface.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Multithread']/*"/>	
    /// <msdn-id>bb173816</msdn-id>	
    /// <unmanaged>ID3D10Multithread</unmanaged>	
    /// <unmanaged-short>ID3D10Multithread</unmanaged-short>	
    [Guid("9B7E4E00-342C-4106-A19F-4F2704F689F0")]
    public partial class DeviceMultithread : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D.DeviceMultithread"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DeviceMultithread(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D.DeviceMultithread"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D.DeviceMultithread(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D.DeviceMultithread(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Enter a device's critical section.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Entering a device's critical section prevents other threads from simultaneously calling that device's methods (if <strong>multithread protection</strong> is set to true), calling DXGI methods, and calling the methods of all resource, view, shader, state, and asynchronous interfaces.</p><p>This function should be used in multithreaded applications when there is a series of graphics commands that must happen in order. This function is typically called at the beginning of the series of graphics commands, and <strong><see cref="SharpDX.Direct3D.DeviceMultithread.Leave"/></strong> is typically called after those graphics commands.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Multithread::Enter']/*"/>	
        /// <msdn-id>bb173817</msdn-id>	
        /// <unmanaged>void ID3D10Multithread::Enter()</unmanaged>	
        /// <unmanaged-short>ID3D10Multithread::Enter</unmanaged-short>	
        public void Enter() {
            unsafe {
                SharpDX.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
            }
        }
        
        /// <summary>	
        /// <p>Leave a device's critical section.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This function is typically used in multithreaded applications when there is a series of graphics commands that must happen in order. <strong><see cref="SharpDX.Direct3D.DeviceMultithread.Enter"/></strong> is typically called at the beginning of a series of graphics commands, and this function is typically called after those graphics commands.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Multithread::Leave']/*"/>	
        /// <msdn-id>bb173819</msdn-id>	
        /// <unmanaged>void ID3D10Multithread::Leave()</unmanaged>	
        /// <unmanaged-short>ID3D10Multithread::Leave</unmanaged-short>	
        public void Leave() {
            unsafe {
                SharpDX.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
            }
        }
        
        /// <summary>	
        /// <p>Turn multithreading on or off.</p>	
        /// </summary>	
        /// <param name="bMTProtect"><dd>  <p>True to turn multithreading on, false to turn it off.</p> </dd></param>	
        /// <returns><p>True if multithreading was turned on prior to calling this method, false otherwise.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Multithread::SetMultithreadProtected']/*"/>	
        /// <msdn-id>bb173820</msdn-id>	
        /// <unmanaged>BOOL ID3D10Multithread::SetMultithreadProtected([In] BOOL bMTProtect)</unmanaged>	
        /// <unmanaged-short>ID3D10Multithread::SetMultithreadProtected</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool SetMultithreadProtected(SharpDX.Mathematics.Interop.RawBool bMTProtect) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.LocalInterop.CalliSharpDXMathematicsInteropRawBool12(_nativePointer, bMTProtect,((void**)(*(void**)_nativePointer))[5]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Find out if multithreading is turned on or not.</p>	
        /// </summary>	
        /// <returns><p>Whether or not multithreading is turned on. True means on, false means off.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Multithread::GetMultithreadProtected']/*"/>	
        /// <msdn-id>bb173818</msdn-id>	
        /// <unmanaged>BOOL ID3D10Multithread::GetMultithreadProtected()</unmanaged>	
        /// <unmanaged-short>ID3D10Multithread::GetMultithreadProtected</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool GetMultithreadProtected() {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer,((void**)(*(void**)_nativePointer))[6]);		
                return __result__;
            }
        }
    }
}
