// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.Direct3D12 namespace.
//     This code was generated by a tool.
//     Date : 6/25/2016 10:38:11 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.Direct3D12 {

// Disable warning : XML comment is not placed on a valid language element
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
    /// <summary>	
    /// <p>Represents the allocations of storage for graphics processing unit (GPU) commands.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Use <strong><see cref="SharpDX.Direct3D12.Device.CreateCommandAllocator"/></strong> to create a command allocator object. </p><p>The command allocator object corresponds to the underlying allocations in which GPU commands are stored.  The command allocator object applies to both direct command lists and bundles.  You must use a command allocator object in a DirectX 12 app.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandAllocator']/*"/>	
    /// <msdn-id>dn770463</msdn-id>	
    /// <unmanaged>ID3D12CommandAllocator</unmanaged>	
    /// <unmanaged-short>ID3D12CommandAllocator</unmanaged-short>	
    [Guid("6102dee4-af59-4b09-b999-b44d73f09b24")]
    public partial class CommandAllocator : SharpDX.Direct3D12.Pageable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.CommandAllocator"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CommandAllocator(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.CommandAllocator"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.CommandAllocator(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.CommandAllocator(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Indicates to re-use the memory that is associated with the command allocator.</p>	
        /// </summary>	
        /// <returns><p>This method returns <strong>E_FAIL</strong> if there is an actively recording command list referencing the command allocator.  The debug layer will also issue an error in this case.   See Direct3D 12 Return Codes for other possible return values.</p></returns>	
        /// <remarks>	
        /// <p>Apps call <strong>Reset</strong> to re-use the memory that is associated with a command allocator.  From this call to <strong>Reset</strong>, the runtime and driver determine that the graphics processing unit (GPU) is no longer executing any command lists that have recorded commands with the command allocator.</p><p>Unlike <strong><see cref="SharpDX.Direct3D12.GraphicsCommandList.Reset"/></strong>, it is not recommended that you call <strong>Reset</strong> on the command allocator while a command list is still being executed. </p><p>The debug layer will issue a warning if it can't prove that there are no pending GPU references to command lists that have recorded commands in the allocator.</p><p>The debug layer will issue an error if <strong>Reset</strong> is called concurrently by multiple threads (on the same allocator object).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandAllocator::Reset']/*"/>	
        /// <msdn-id>dn770464</msdn-id>	
        /// <unmanaged>HRESULT ID3D12CommandAllocator::Reset()</unmanaged>	
        /// <unmanaged-short>ID3D12CommandAllocator::Reset</unmanaged-short>	
        public void Reset() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandList']/*"/>	
    /// <unmanaged>ID3D12CommandList</unmanaged>	
    /// <unmanaged-short>ID3D12CommandList</unmanaged-short>	
    [Guid("7116d91c-e7e4-47ce-b8c6-ec8168f437e5")]
    public partial class CommandList : SharpDX.Direct3D12.DeviceChild {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.CommandList"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CommandList(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.CommandList"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.CommandList(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.CommandList(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Gets the type of the command list, such as direct, bundle, compute, or copy. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandList::GetType']/*"/>	
        /// <msdn-id>dn903824</msdn-id>	
        /// <unmanaged>GetType</unmanaged>	
        /// <unmanaged-short>GetType</unmanaged-short>	
        /// <unmanaged>D3D12_COMMAND_LIST_TYPE ID3D12CommandList::GetType()</unmanaged>
        public SharpDX.Direct3D12.CommandListType TypeInfo {
                get { return GetTypeInfo(); }
        }
        
        /// <summary>	
        /// <p> Gets the type of the command list, such as direct, bundle, compute, or copy. </p>	
        /// </summary>	
        /// <returns><p> This method returns the type of the command list,  as a <strong><see cref="SharpDX.Direct3D12.CommandListType"/></strong> enumeration constant,  such as direct, bundle, compute, or copy. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandList::GetType']/*"/>	
        /// <msdn-id>dn903824</msdn-id>	
        /// <unmanaged>D3D12_COMMAND_LIST_TYPE ID3D12CommandList::GetType()</unmanaged>	
        /// <unmanaged-short>ID3D12CommandList::GetType</unmanaged-short>	
        internal SharpDX.Direct3D12.CommandListType GetTypeInfo() {
            unsafe {
                SharpDX.Direct3D12.CommandListType __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.CalliSharpDXDirect3D12CommandListType(_nativePointer,((void**)(*(void**)_nativePointer))[8]);		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue']/*"/>	
    /// <unmanaged>ID3D12CommandQueue</unmanaged>	
    /// <unmanaged-short>ID3D12CommandQueue</unmanaged-short>	
    [Guid("0ec870a6-5d7e-4c22-8cfc-5baae07616ed")]
    public partial class CommandQueue : SharpDX.Direct3D12.Pageable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.CommandQueue"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CommandQueue(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.CommandQueue"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.CommandQueue(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.CommandQueue(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>This method is used to determine the rate at which the GPU timestamp counter increments.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>For more information, refer to Timing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue::GetTimestampFrequency']/*"/>	
        /// <msdn-id>dn903826</msdn-id>	
        /// <unmanaged>GetTimestampFrequency</unmanaged>	
        /// <unmanaged-short>GetTimestampFrequency</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D12CommandQueue::GetTimestampFrequency([Out] unsigned longlong* pFrequency)</unmanaged>
        public long TimestampFrequency {
                get { long __output__; GetTimestampFrequency(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Describes a command queue.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> This structure is passed into <strong>CreateCommandQueue</strong>. </p><p> This structure is returned by <strong><see cref="SharpDX.Direct3D12.CommandQueue.GetDescription"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue::GetDesc']/*"/>	
        /// <msdn-id>dn903796</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>D3D12_COMMAND_QUEUE_DESC ID3D12CommandQueue::GetDesc()</unmanaged>
        public SharpDX.Direct3D12.CommandQueueDescription Description {
                get { return GetDescription(); }
        }
        
        /// <summary>	
        /// <p> Updates mappings of tile locations in reserved resources to memory locations in a resource heap. </p>	
        /// </summary>	
        /// <param name="resourceRef"><dd> <p> A reference to the reserved resource. </p> </dd></param>	
        /// <param name="numResourceRegions"><dd> <p> The number of reserved resource regions. </p> </dd></param>	
        /// <param name="resourceRegionStartCoordinatesRef"><dd> <p> An array of <strong><see cref="SharpDX.Direct3D12.TiledResourceCoordinate"/></strong> structures that describe the starting coordinates of the reserved resource regions. The <em>NumResourceRegions</em> parameter specifies the number of <strong><see cref="SharpDX.Direct3D12.TiledResourceCoordinate"/></strong> structures in the array. </p> </dd></param>	
        /// <param name="resourceRegionSizesRef"><dd> <p> An array of <strong><see cref="SharpDX.Direct3D12.TileRegionSize"/></strong> structures that describe the sizes of the reserved resource regions. The <em>NumResourceRegions</em> parameter specifies the number of <strong><see cref="SharpDX.Direct3D12.TileRegionSize"/></strong> structures in the array. </p> </dd></param>	
        /// <param name="heapRef"><dd> <p> A reference to the resource heap. </p> </dd></param>	
        /// <param name="numRanges"><dd> <p> The number of tile  ranges. </p> </dd></param>	
        /// <param name="rangeFlagsRef"><dd> <p> A reference to an  array of <strong><see cref="SharpDX.Direct3D12.TileRangeFlags"/></strong> values that describes each tile range. The <em>NumRanges</em> parameter specifies the number of values in the array. </p> </dd></param>	
        /// <param name="heapRangeStartOffsetsRef"><dd> <p> An array of offsets into the resource heap. These are 0-based tile offsets, counting in tiles (not bytes). </p> </dd></param>	
        /// <param name="rangeTileCountsRef"><dd> <p> An array of tiles. An array of values that specify the number of tiles in each tile range. The <em>NumRanges</em> parameter specifies the number of values in the array. </p> </dd></param>	
        /// <param name="flags"><dd> <p> A combination of <strong><see cref="SharpDX.Direct3D12.TileMappingFlags"/></strong> values that are combined by using a bitwise OR operation. </p> </dd></param>	
        /// <remarks>	
        /// <p>Use <strong>UpdateTileMappings</strong> to map the virtual pages of a reserved resource to the physical pages of a heap. The mapping does not have to be in order. The operation is similar to  <strong><see cref="SharpDX.Direct3D11.DeviceContext2.UpdateTileMappings"/></strong> with the one key difference that D3D12 allows a reserved resource to have tiles from multiple heaps.</p><p> In a single call to <strong>UpdateTileMappings</strong>, you can map one or more ranges of resource tiles to one or more ranges of heap tiles.  </p><p> You can organize the parameters of  <strong>UpdateTileMappings</strong> in these ways to perform an update: </p><ul> <li><strong>Reserved resource whose mappings are updated.</strong> Mappings start off all <c>null</c> when a resource is initially created. </li> <li><strong>Set of tile regions on the reserved resource whose mappings are updated.</strong> You can make one <strong>UpdateTileMappings</strong> call to update many mappings or multiple calls with a bit more API call overhead as well if that is more convenient. <ul> <li><em>NumResourceRegions</em> specifies how many regions there are.</li> <li><em>pResourceRegionStartCoordinates</em> and <em>pResourceRegionSizes</em> are each arrays that identify the start location and extend of each region. If <em>NumResourceRegions</em> is 1, for convenience either or both of the arrays that describe the regions can be <c>null</c>.  <c>null</c> for <em>pResourceRegionStartCoordinates</em> means the start coordinate is all 0s, and <c>null</c> for <em>pResourceRegionSizes</em> identifies a default region that is the full set of tiles for the entire reserved resource, including all mipmaps, array slices, or both.  </li> <li> <p> If <em>pResourceRegionStartCoordinates</em> isn't <c>null</c> and <em>pResourceRegionSizes</em> is <c>null</c>, the region size defaults to 1 tile for all regions.  This makes it easy to define mappings for a set of individual tiles each at disparate locations by providing an array of locations in <em>pResourceRegionStartCoordinates</em> without having to send an array of <em>pResourceRegionSizes</em> all set to 1. </p> </li> </ul> <p>The updates are applied from first region to last; so, if regions overlap in a single call, the updates later in the list overwrite the areas that overlap with previous updates.</p> </li> <li><strong>Heap that provides memory where tile mappings can go.</strong> If <strong>UpdateTileMappings</strong> only defines <c>null</c> mappings, you don't need to specify a heap.</li> <li><strong>Set of tile ranges where mappings are going.</strong> Each given tile range can specify one of a few types of ranges: a range of tiles in a heap (default), a count of tiles in the reserved resource to map to a single tile in a heap (sharing the tile), a count of tile mappings in the reserved resource to skip and leave as they are, or a count of tiles in the heap to map to <c>null</c>.<p><em>NumRanges</em> specifies the number of tile ranges, where the total tiles identified across all ranges must match the total number of tiles in the tile regions from the previously described reserved resource.  Mappings are defined by iterating through the tiles in the tile regions in sequential order - x then y then z order for box regions - while walking through the set of tile ranges in sequential order.  The breakdown of tile regions doesn't have to line up with the breakdown of tile ranges, but the total number of tiles on both sides must be equal so that each reserved resource tile specified has a mapping specified. </p> <p><em>pRangeFlags</em>, <em>pHeapRangeStartOffsets</em>, and <em>pRangeTileCounts</em> are all arrays, of size <em>NumRanges</em>, that describe the tile ranges.  If <em>pRangeFlags</em> is <c>null</c>, all ranges are sequential tiles in the heap; otherwise, for each range i,<em>pRangeFlags[i]</em> identifies how the mappings in that range of tiles work: </p> <ul> <li> If <em>pRangeFlags[i]</em> is <strong><see cref="SharpDX.Direct3D12.TileRangeFlags.None"/></strong>, that range defines sequential tiles in the heap, with the number of tiles being <em>pRangeTileCounts[i]</em> and the starting location <em>pHeapRangeStartOffsets[i]</em>.  If <em>NumRanges</em> is 1, <em>pRangeTileCounts</em> can be <c>null</c> and defaults to the total number of tiles specified by all the tile regions. </li> <li> If <em>pRangeFlags[i]</em> is <strong>D3D12_TILE_RANGE_REUSE_SINGLE_TILE</strong>, <em>pHeapRangeStartOffsets[i]</em> identifies the single tile in the heap to map to, and <em>pRangeTileCounts[i]</em> specifies how many tiles from the tile regions to map to that heap location.  If <em>NumRanges</em> is 1, <em>pRangeTileCounts</em> can be <c>null</c> and defaults to the total number of tiles specified by all the tile regions. </li> <li> If <em>pRangeFlags[i]</em> is <strong>D3D12_TILE_RANGE_NULL</strong>, <em>pRangeTileCounts[i]</em> specifies how many tiles from the tile regions to map to <c>null</c>.  If <em>NumRanges</em> is 1, <em>pRangeTileCounts</em> can be <c>null</c> and defaults to the total number of tiles specified by all the tile regions. <em>pHeapRangeStartOffsets[i]</em> is ignored for <c>null</c> mappings. </li> <li> If <em>pRangeFlags[i]</em> is <strong>D3D12_TILE_RANGE_SKIP</strong>, <em>pRangeTileCounts[i]</em> specifies how many tiles from the tile regions to skip over and leave existing mappings unchanged for.  This can be useful if a tile region conveniently bounds an area of tile mappings to update except with some exceptions that need to be left the same as whatever they were mapped to before. <em>pHeapRangeStartOffsets[i]</em> is ignored for SKIP mappings. </li> </ul> </li> <li><strong>Flags parameter for overall options.</strong> <strong><see cref="SharpDX.Direct3D12.TileMappingFlags.NoHazard"/></strong>. Refer to the description of this flag in <strong><see cref="SharpDX.Direct3D12.TileMappingFlags"/></strong>.</li> </ul><p> If tile mappings have changed on a reserved resource that the app will render, the app must clear, by using the fixed function <strong>Clear</strong> APIs, the tiles that have changed within the area being rendered (mapped or not). If an app doesn't clear in these situations, the app receives undefined values when it reads from the reserved resource. </p><p> If an app needs to preserve existing memory contents of areas in a reserved resource where mappings have changed, the app can first save the contents where tile mappings have changed, by copying them using <strong>CopyTileMappings</strong>, issuing the required <strong>Clear</strong>, and then copying the contents back. </p><p> Suppose a tile is mapped into multiple reserved resources at the same time and tile contents are manipulated by any means (render, copy, and so on) via one of the reserved resources. Then, if the same tile is to be rendered via any other reserved resource, the tile must be cleared first as previously described. </p><p> Here are some examples of common <strong>UpdateTileMappings</strong> cases: </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue::UpdateTileMappings']/*"/>	
        /// <msdn-id>dn788641</msdn-id>	
        /// <unmanaged>void ID3D12CommandQueue::UpdateTileMappings([In] ID3D12Resource* pResource,[In] unsigned int NumResourceRegions,[In, Buffer, Optional] const D3D12_TILED_RESOURCE_COORDINATE* pResourceRegionStartCoordinates,[In, Buffer, Optional] const D3D12_TILE_REGION_SIZE* pResourceRegionSizes,[In, Optional] ID3D12Heap* pHeap,[In] unsigned int NumRanges,[In, Buffer, Optional] const D3D12_TILE_RANGE_FLAGS* pRangeFlags,[In, Buffer, Optional] const unsigned int* pHeapRangeStartOffsets,[In, Buffer, Optional] const unsigned int* pRangeTileCounts,[In] D3D12_TILE_MAPPING_FLAGS Flags)</unmanaged>	
        /// <unmanaged-short>ID3D12CommandQueue::UpdateTileMappings</unmanaged-short>	
        public void UpdateTileMappings(SharpDX.Direct3D12.Resource resourceRef, int numResourceRegions, SharpDX.Direct3D12.TiledResourceCoordinate[] resourceRegionStartCoordinatesRef, SharpDX.Direct3D12.TileRegionSize[] resourceRegionSizesRef, SharpDX.Direct3D12.Heap heapRef, int numRanges, SharpDX.Direct3D12.TileRangeFlags[] rangeFlagsRef, int[] heapRangeStartOffsetsRef, int[] rangeTileCountsRef, SharpDX.Direct3D12.TileMappingFlags flags) {
            unsafe {
                SharpDX.Direct3D12.TiledResourceCoordinate[] resourceRegionStartCoordinatesRef__ = resourceRegionStartCoordinatesRef;
                SharpDX.Direct3D12.TileRegionSize[] resourceRegionSizesRef__ = resourceRegionSizesRef;
                SharpDX.Direct3D12.TileRangeFlags[] rangeFlagsRef__ = rangeFlagsRef;
                int[] heapRangeStartOffsetsRef__ = heapRangeStartOffsetsRef;
                int[] rangeTileCountsRef__ = rangeTileCountsRef;
                fixed (void* resourceRegionStartCoordinatesRef_ = resourceRegionStartCoordinatesRef__)
                    fixed (void* resourceRegionSizesRef_ = resourceRegionSizesRef__)
                        fixed (void* rangeFlagsRef_ = rangeFlagsRef__)
                            fixed (void* heapRangeStartOffsetsRef_ = heapRangeStartOffsetsRef__)
                                fixed (void* rangeTileCountsRef_ = rangeTileCountsRef__)
                                    SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), numResourceRegions, resourceRegionStartCoordinatesRef_, resourceRegionSizesRef_, (void*)((heapRef == null)?IntPtr.Zero:heapRef.NativePointer), numRanges, rangeFlagsRef_, heapRangeStartOffsetsRef_, rangeTileCountsRef_, unchecked((int)flags),((void**)(*(void**)_nativePointer))[8]);		
            }
        }
        
        /// <summary>	
        /// <p>Copies mappings from a source reserved resource to a destination reserved resource.</p>	
        /// </summary>	
        /// <param name="dstResourceRef"><dd> <p>A reference to the destination reserved resource.</p> </dd></param>	
        /// <param name="dstRegionStartCoordinateRef"><dd> <p> A reference to a <strong><see cref="SharpDX.Direct3D12.TiledResourceCoordinate"/></strong> structure that describes the starting coordinates of the destination reserved resource. </p> </dd></param>	
        /// <param name="srcResourceRef"><dd> <p>A reference to the source reserved resource.</p> </dd></param>	
        /// <param name="srcRegionStartCoordinateRef"><dd> <p> A reference to a <strong><see cref="SharpDX.Direct3D12.TiledResourceCoordinate"/></strong> structure that describes the starting coordinates of the source reserved resource. </p> </dd></param>	
        /// <param name="regionSizeRef"><dd> <p> A reference to a <strong><see cref="SharpDX.Direct3D12.TileRegionSize"/></strong> structure that describes the size of the reserved region. </p> </dd></param>	
        /// <param name="flags"><dd> <p> One member of <strong><see cref="SharpDX.Direct3D12.TileMappingFlags"/></strong>. </p> </dd></param>	
        /// <remarks>	
        /// <p>Use <strong>CopyTileMappings</strong> to copy the tile mappings from one reserved resource to another, either to duplicate a resource mapping, or to initialize a new mapping before modifying it using <strong>UpdateTileMappings</strong>.</p><p><strong>CopyTileMappings</strong> helps with tasks such as shifting mappings around within and across reserved resources, for example, scrolling tiles.  The source and destination regions can overlap; the result of the copy in this situation is as if the source was saved to a temporary location  and from there written to the destination. </p><p>The destination and the source regions must each entirely fit in their resource or behavior is undefined and the debug layer will emit an error.</p><p> For more info on tiled resources, refer to the  "DirectX tiled resources" section within DirectX programming. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue::CopyTileMappings']/*"/>	
        /// <msdn-id>dn788629</msdn-id>	
        /// <unmanaged>void ID3D12CommandQueue::CopyTileMappings([In] ID3D12Resource* pDstResource,[In] const D3D12_TILED_RESOURCE_COORDINATE* pDstRegionStartCoordinate,[In] ID3D12Resource* pSrcResource,[In] const D3D12_TILED_RESOURCE_COORDINATE* pSrcRegionStartCoordinate,[In] const D3D12_TILE_REGION_SIZE* pRegionSize,[In] D3D12_TILE_MAPPING_FLAGS Flags)</unmanaged>	
        /// <unmanaged-short>ID3D12CommandQueue::CopyTileMappings</unmanaged-short>	
        public void CopyTileMappings(SharpDX.Direct3D12.Resource dstResourceRef, SharpDX.Direct3D12.TiledResourceCoordinate dstRegionStartCoordinateRef, SharpDX.Direct3D12.Resource srcResourceRef, SharpDX.Direct3D12.TiledResourceCoordinate srcRegionStartCoordinateRef, SharpDX.Direct3D12.TileRegionSize regionSizeRef, SharpDX.Direct3D12.TileMappingFlags flags) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((dstResourceRef == null)?IntPtr.Zero:dstResourceRef.NativePointer), &dstRegionStartCoordinateRef, (void*)((srcResourceRef == null)?IntPtr.Zero:srcResourceRef.NativePointer), &srcRegionStartCoordinateRef, &regionSizeRef, unchecked((int)flags),((void**)(*(void**)_nativePointer))[9]);		
            }
        }
        
        /// <summary>	
        /// <p>Submits an array of command lists for execution.</p>	
        /// </summary>	
        /// <param name="numCommandLists"><dd> <p> The number of command lists to be executed. </p> </dd></param>	
        /// <param name="commandListsOut"><dd> <p> The array of <strong><see cref="SharpDX.Direct3D12.CommandList"/></strong> command lists to be executed. </p> </dd></param>	
        /// <remarks>	
        /// <p> The driver is free to patch the submitted command lists. It is the calling application?s responsibility to ensure that the graphics processing unit (GPU) is not currently reading the any of the submitted command lists from a previous execution. </p><p> Applications are encouraged to batch together command list executions to reduce fixed costs associated with submitted commands to the GPU. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue::ExecuteCommandLists']/*"/>	
        /// <msdn-id>dn788631</msdn-id>	
        /// <unmanaged>void ID3D12CommandQueue::ExecuteCommandLists([In] unsigned int NumCommandLists,[In, Buffer] const ID3D12CommandList** ppCommandLists)</unmanaged>	
        /// <unmanaged-short>ID3D12CommandQueue::ExecuteCommandLists</unmanaged-short>	
        public void ExecuteCommandLists(int numCommandLists, SharpDX.Direct3D12.CommandList[] commandListsOut) {
            unsafe {
                IntPtr* commandListsOut_ = (IntPtr*)0;
                if ( commandListsOut != null ) {
                    IntPtr* commandListsOut__ = stackalloc IntPtr[commandListsOut.Length];
                    commandListsOut_ = commandListsOut__;
                    for (int i = 0; i < commandListsOut.Length; i++)                        
                        commandListsOut_[i] =  (commandListsOut[i] == null)? IntPtr.Zero : commandListsOut[i].NativePointer;
                }
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, numCommandLists, commandListsOut_,((void**)(*(void**)_nativePointer))[10]);		
            }
        }
        
        /// <summary>	
        /// <p>Submits an array of command lists for execution.</p>	
        /// </summary>	
        /// <param name="numCommandLists"><dd> <p> The number of command lists to be executed. </p> </dd></param>	
        /// <param name="commandListsOut"><dd> <p> The array of <strong><see cref="SharpDX.Direct3D12.CommandList"/></strong> command lists to be executed. </p> </dd></param>	
        /// <remarks>	
        /// <p> The driver is free to patch the submitted command lists. It is the calling application?s responsibility to ensure that the graphics processing unit (GPU) is not currently reading the any of the submitted command lists from a previous execution. </p><p> Applications are encouraged to batch together command list executions to reduce fixed costs associated with submitted commands to the GPU. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue::ExecuteCommandLists']/*"/>	
        /// <msdn-id>dn788631</msdn-id>	
        /// <unmanaged>void ID3D12CommandQueue::ExecuteCommandLists([In] unsigned int NumCommandLists,[In, Buffer] const ID3D12CommandList** ppCommandLists)</unmanaged>	
        /// <unmanaged-short>ID3D12CommandQueue::ExecuteCommandLists</unmanaged-short>	
        public void ExecuteCommandLists(int numCommandLists, SharpDX.ComArray<SharpDX.Direct3D12.CommandList> commandListsOut) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, numCommandLists, (void*)((commandListsOut == null)?IntPtr.Zero:commandListsOut.NativePointer),((void**)(*(void**)_nativePointer))[10]);		
            }
        }
        
        /// <summary>	
        /// <p>Submits an array of command lists for execution.</p>	
        /// </summary>	
        /// <param name="numCommandLists"><dd> <p> The number of command lists to be executed. </p> </dd></param>	
        /// <param name="commandListsOut"><dd> <p> The array of <strong><see cref="SharpDX.Direct3D12.CommandList"/></strong> command lists to be executed. </p> </dd></param>	
        /// <remarks>	
        /// <p> The driver is free to patch the submitted command lists. It is the calling application?s responsibility to ensure that the graphics processing unit (GPU) is not currently reading the any of the submitted command lists from a previous execution. </p><p> Applications are encouraged to batch together command list executions to reduce fixed costs associated with submitted commands to the GPU. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue::ExecuteCommandLists']/*"/>	
        /// <msdn-id>dn788631</msdn-id>	
        /// <unmanaged>void ID3D12CommandQueue::ExecuteCommandLists([In] unsigned int NumCommandLists,[In, Buffer] const ID3D12CommandList** ppCommandLists)</unmanaged>	
        /// <unmanaged-short>ID3D12CommandQueue::ExecuteCommandLists</unmanaged-short>	
        private void ExecuteCommandLists(int numCommandLists, System.IntPtr commandListsOut) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, numCommandLists, (void*)commandListsOut,((void**)(*(void**)_nativePointer))[10]);		
            }
        }
        
        /// <summary>	
        /// <p> For internal use only.</p>	
        /// </summary>	
        /// <param name="metadata"><dd>  <p> Internal. </p> </dd></param>	
        /// <param name="dataRef"><dd>  <p> Internal.</p> </dd></param>	
        /// <param name="size"><dd>  <p> Internal.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue::SetMarker']/*"/>	
        /// <msdn-id>dn986872</msdn-id>	
        /// <unmanaged>void ID3D12CommandQueue::SetMarker([In] unsigned int Metadata,[In, Buffer, Optional] const void* pData,[In] unsigned int Size)</unmanaged>	
        /// <unmanaged-short>ID3D12CommandQueue::SetMarker</unmanaged-short>	
        public void SetMarker(int metadata, System.IntPtr dataRef, int size) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, metadata, (void*)dataRef, size,((void**)(*(void**)_nativePointer))[11]);		
            }
        }
        
        /// <summary>	
        /// <p> For internal use only. </p>	
        /// </summary>	
        /// <param name="metadata"><dd>  <p> Internal.</p> </dd></param>	
        /// <param name="dataRef"><dd>  <p> Internal.</p> </dd></param>	
        /// <param name="size"><dd>  <p> Internal.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue::BeginEvent']/*"/>	
        /// <msdn-id>dn986870</msdn-id>	
        /// <unmanaged>void ID3D12CommandQueue::BeginEvent([In] unsigned int Metadata,[In, Buffer, Optional] const void* pData,[In] unsigned int Size)</unmanaged>	
        /// <unmanaged-short>ID3D12CommandQueue::BeginEvent</unmanaged-short>	
        public void BeginEvent(int metadata, System.IntPtr dataRef, int size) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, metadata, (void*)dataRef, size,((void**)(*(void**)_nativePointer))[12]);		
            }
        }
        
        /// <summary>	
        /// <p> For internal use only.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue::EndEvent']/*"/>	
        /// <msdn-id>dn986871</msdn-id>	
        /// <unmanaged>void ID3D12CommandQueue::EndEvent()</unmanaged>	
        /// <unmanaged-short>ID3D12CommandQueue::EndEvent</unmanaged-short>	
        public void EndEvent() {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[13]);		
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="fenceRef">No documentation.</param>	
        /// <param name="value">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue::Signal']/*"/>	
        /// <unmanaged>HRESULT ID3D12CommandQueue::Signal([In] ID3D12Fence* pFence,[In] unsigned longlong Value)</unmanaged>	
        /// <unmanaged-short>ID3D12CommandQueue::Signal</unmanaged-short>	
        public void Signal(SharpDX.Direct3D12.Fence fenceRef, long value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, (void*)((fenceRef == null)?IntPtr.Zero:fenceRef.NativePointer), value,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Waits until the specified fence reaches or exceeds the specified value.</p>	
        /// </summary>	
        /// <param name="fenceRef"><dd>  <p> A reference to the <strong><see cref="SharpDX.Direct3D12.Fence"/></strong> object. </p> </dd></param>	
        /// <param name="value"><dd>  <p>The value that the command queue is waiting for the fence to reach or exceed.  So when  <strong><see cref="SharpDX.Direct3D12.Fence.GetCompletedValue"/></strong> is greater than or equal to <em>Value</em>, the wait is terminated.</p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue::Wait']/*"/>	
        /// <msdn-id>dn899173</msdn-id>	
        /// <unmanaged>HRESULT ID3D12CommandQueue::Wait([In] ID3D12Fence* pFence,[In] unsigned longlong Value)</unmanaged>	
        /// <unmanaged-short>ID3D12CommandQueue::Wait</unmanaged-short>	
        public void Wait(SharpDX.Direct3D12.Fence fenceRef, long value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, (void*)((fenceRef == null)?IntPtr.Zero:fenceRef.NativePointer), value,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>This method is used to determine the rate at which the GPU timestamp counter increments.</p>	
        /// </summary>	
        /// <param name="frequencyRef"><dd>  <p>The GPU timestamp counter frequency (in ticks/second).</p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>For more information, refer to Timing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue::GetTimestampFrequency']/*"/>	
        /// <msdn-id>dn903826</msdn-id>	
        /// <unmanaged>HRESULT ID3D12CommandQueue::GetTimestampFrequency([Out] unsigned longlong* pFrequency)</unmanaged>	
        /// <unmanaged-short>ID3D12CommandQueue::GetTimestampFrequency</unmanaged-short>	
        internal void GetTimestampFrequency(out long frequencyRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* frequencyRef_ = &frequencyRef)
                    __result__= 
    				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, frequencyRef_,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>This method samples the CPU and GPU timestamp counters at the same moment in time. </p>	
        /// </summary>	
        /// <param name="gpuTimestampRef"><dd>  <p>The value of the GPU timestamp counter.</p> </dd></param>	
        /// <param name="cpuTimestampRef"><dd>  <p>The value of the CPU timestamp counter.</p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>For more information, refer to Timing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue::GetClockCalibration']/*"/>	
        /// <msdn-id>dn903825</msdn-id>	
        /// <unmanaged>HRESULT ID3D12CommandQueue::GetClockCalibration([Out] unsigned longlong* pGpuTimestamp,[Out] unsigned longlong* pCpuTimestamp)</unmanaged>	
        /// <unmanaged-short>ID3D12CommandQueue::GetClockCalibration</unmanaged-short>	
        public void GetClockCalibration(out long gpuTimestampRef, out long cpuTimestampRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* gpuTimestampRef_ = &gpuTimestampRef)
                    fixed (void* cpuTimestampRef_ = &cpuTimestampRef)
                        __result__= 
        				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, gpuTimestampRef_, cpuTimestampRef_,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Describes a command queue.</p>	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <remarks>	
        /// <p> This structure is passed into <strong>CreateCommandQueue</strong>. </p><p> This structure is returned by <strong><see cref="SharpDX.Direct3D12.CommandQueue.GetDescription"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandQueue::GetDesc']/*"/>	
        /// <msdn-id>dn903796</msdn-id>	
        /// <unmanaged>D3D12_COMMAND_QUEUE_DESC ID3D12CommandQueue::GetDesc()</unmanaged>	
        /// <unmanaged-short>ID3D12CommandQueue::GetDesc</unmanaged-short>	
        internal SharpDX.Direct3D12.CommandQueueDescription GetDescription() {
            unsafe {
                SharpDX.Direct3D12.CommandQueueDescription __result__;
                SharpDX.Direct3D12.LocalInterop.CallivoidPtr(_nativePointer,(void*)&__result__,((void**)(*(void**)_nativePointer))[18]);		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p> A command signature object enables apps to specify indirect drawing, including the buffer format, command type and resource bindings to be used.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> To create a command signature, call <strong><see cref="SharpDX.Direct3D12.Device.CreateCommandSignature"/></strong>, as described in Indirect Drawing. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12CommandSignature']/*"/>	
    /// <msdn-id>dn891446</msdn-id>	
    /// <unmanaged>ID3D12CommandSignature</unmanaged>	
    /// <unmanaged-short>ID3D12CommandSignature</unmanaged-short>	
    [Guid("c36a797c-ec80-4f0a-8985-a7b2475082d1")]
    public partial class CommandSignature : SharpDX.Direct3D12.Pageable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.CommandSignature"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CommandSignature(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.CommandSignature"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.CommandSignature(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.CommandSignature(nativePointer);
		}
        
    }
    /// <summary>	
    /// <p> Provides methods to monitor and debug a command list.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DebugCommandList']/*"/>	
    /// <msdn-id>dn950154</msdn-id>	
    /// <unmanaged>ID3D12DebugCommandList</unmanaged>	
    /// <unmanaged-short>ID3D12DebugCommandList</unmanaged-short>	
    [Guid("09e0bf36-54ac-484f-8847-4baeeab6053f")]
    public partial class DebugCommandList : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.DebugCommandList"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DebugCommandList(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.DebugCommandList"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.DebugCommandList(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.DebugCommandList(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Returns or sets the debug feature flags that have been set on a command list. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DebugCommandList::GetFeatureMask']/*"/>	
        /// <msdn-id>dn950156</msdn-id>	
        /// <unmanaged>GetFeatureMask / SetFeatureMask</unmanaged>	
        /// <unmanaged-short>GetFeatureMask</unmanaged-short>	
        /// <unmanaged>D3D12_DEBUG_FEATURE ID3D12DebugCommandList::GetFeatureMask()</unmanaged>
        public SharpDX.Direct3D12.DebugFeature FeatureMask {
                get { return GetFeatureMask(); }
                set { SetFeatureMask(value); }
        }
        
        /// <summary>	
        /// <p> Checks whether a resource, or subresource, is in a specified state, or not.</p>	
        /// </summary>	
        /// <param name="resourceRef"><dd>  <p>Specifies the  <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> to check.</p> </dd></param>	
        /// <param name="subresource"><dd>  <p>The index of the subresource to check. This can be set to an index, or D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES.</p> </dd></param>	
        /// <param name="state"><dd>  <p>Specifies the state to check for. This can be one or more <see cref="SharpDX.Direct3D12.ResourceStates"/> flags Or'ed together.</p> </dd></param>	
        /// <returns><p>This method returns true if the resource or subresource is in the specified state, false otherwise.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DebugCommandList::AssertResourceState']/*"/>	
        /// <msdn-id>dn950155</msdn-id>	
        /// <unmanaged>BOOL ID3D12DebugCommandList::AssertResourceState([In] ID3D12Resource* pResource,[In] unsigned int Subresource,[In] unsigned int State)</unmanaged>	
        /// <unmanaged-short>ID3D12DebugCommandList::AssertResourceState</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool AssertResourceState(SharpDX.Direct3D12.Resource resourceRef, int subresource, int state) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), subresource, state,((void**)(*(void**)_nativePointer))[3]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Turns the debug features for a command list on or off.</p>	
        /// </summary>	
        /// <param name="mask"><dd>  <p> A combination of feature-mask flags that are combined by using a bitwise OR operation. If a flag is present, that feature will be set to on, otherwise the feature will be set to off.  </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DebugCommandList::SetFeatureMask']/*"/>	
        /// <msdn-id>dn950157</msdn-id>	
        /// <unmanaged>HRESULT ID3D12DebugCommandList::SetFeatureMask([In] D3D12_DEBUG_FEATURE Mask)</unmanaged>	
        /// <unmanaged-short>ID3D12DebugCommandList::SetFeatureMask</unmanaged-short>	
        internal void SetFeatureMask(SharpDX.Direct3D12.DebugFeature mask) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, unchecked((int)mask),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Returns the debug feature flags that have been set on a command list. </p>	
        /// </summary>	
        /// <returns><p> A bit mask containing the set debug features. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DebugCommandList::GetFeatureMask']/*"/>	
        /// <msdn-id>dn950156</msdn-id>	
        /// <unmanaged>D3D12_DEBUG_FEATURE ID3D12DebugCommandList::GetFeatureMask()</unmanaged>	
        /// <unmanaged-short>ID3D12DebugCommandList::GetFeatureMask</unmanaged-short>	
        internal SharpDX.Direct3D12.DebugFeature GetFeatureMask() {
            unsafe {
                SharpDX.Direct3D12.DebugFeature __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.CalliSharpDXDirect3D12DebugFeature(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p> Provides methods to monitor and debug a command queue. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DebugCommandQueue']/*"/>	
    /// <msdn-id>dn950158</msdn-id>	
    /// <unmanaged>ID3D12DebugCommandQueue</unmanaged>	
    /// <unmanaged-short>ID3D12DebugCommandQueue</unmanaged-short>	
    [Guid("09e0bf36-54ac-484f-8847-4baeeab6053a")]
    public partial class DebugCommandQueue : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.DebugCommandQueue"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DebugCommandQueue(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.DebugCommandQueue"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.DebugCommandQueue(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.DebugCommandQueue(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Provides methods to monitor and debug a command queue. </p>	
        /// </summary>	
        /// <param name="resourceRef">No documentation.</param>	
        /// <param name="subresource">No documentation.</param>	
        /// <param name="state">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DebugCommandQueue::AssertResourceState']/*"/>	
        /// <msdn-id>dn950158</msdn-id>	
        /// <unmanaged>BOOL ID3D12DebugCommandQueue::AssertResourceState([In] ID3D12Resource* pResource,[In] unsigned int Subresource,[In] unsigned int State)</unmanaged>	
        /// <unmanaged-short>ID3D12DebugCommandQueue::AssertResourceState</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool AssertResourceState(SharpDX.Direct3D12.Resource resourceRef, int subresource, int state) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), subresource, state,((void**)(*(void**)_nativePointer))[3]);		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p> This interface represents a graphics device for debugging. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DebugDevice']/*"/>	
    /// <msdn-id>dn986873</msdn-id>	
    /// <unmanaged>ID3D12DebugDevice</unmanaged>	
    /// <unmanaged-short>ID3D12DebugDevice</unmanaged-short>	
    [Guid("3febd6dd-4973-4787-8194-e45f9e28923e")]
    public partial class DebugDevice : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.DebugDevice"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DebugDevice(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.DebugDevice"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.DebugDevice(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.DebugDevice(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets or sets a bit field of flags that indicates which debug features are on or off. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DebugDevice::GetFeatureMask']/*"/>	
        /// <msdn-id>dn986874</msdn-id>	
        /// <unmanaged>GetFeatureMask / SetFeatureMask</unmanaged>	
        /// <unmanaged-short>GetFeatureMask</unmanaged-short>	
        /// <unmanaged>D3D12_DEBUG_FEATURE ID3D12DebugDevice::GetFeatureMask()</unmanaged>
        public SharpDX.Direct3D12.DebugFeature FeatureMask {
                get { return GetFeatureMask(); }
                set { SetFeatureMask(value); }
        }
        
        /// <summary>	
        /// <p> Set a bit field of flags that will turn debug features on and off. </p>	
        /// </summary>	
        /// <param name="mask"><dd>  <p> Feature-mask flags, as a bitwise-OR'd combination of <strong><see cref="SharpDX.Direct3D12.DebugFeature"/></strong> enumeration constants. If a flag is present, that feature will be set to on; otherwise, the feature will be set to off. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. <strong><see cref="SharpDX.Result"/></strong> </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DebugDevice::SetFeatureMask']/*"/>	
        /// <msdn-id>dn986876</msdn-id>	
        /// <unmanaged>HRESULT ID3D12DebugDevice::SetFeatureMask([In] D3D12_DEBUG_FEATURE Mask)</unmanaged>	
        /// <unmanaged-short>ID3D12DebugDevice::SetFeatureMask</unmanaged-short>	
        internal void SetFeatureMask(SharpDX.Direct3D12.DebugFeature mask) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, unchecked((int)mask),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Gets a bit field of flags that indicates which debug features are on or off. </p>	
        /// </summary>	
        /// <returns><p> Mask of feature-mask flags, as a bitwise OR'ed combination of <strong><see cref="SharpDX.Direct3D12.DebugFeature"/></strong> enumeration constants. If a flag is present, then that feature will be set to on, otherwise the feature will be set to off.  </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DebugDevice::GetFeatureMask']/*"/>	
        /// <msdn-id>dn986874</msdn-id>	
        /// <unmanaged>D3D12_DEBUG_FEATURE ID3D12DebugDevice::GetFeatureMask()</unmanaged>	
        /// <unmanaged-short>ID3D12DebugDevice::GetFeatureMask</unmanaged-short>	
        internal SharpDX.Direct3D12.DebugFeature GetFeatureMask() {
            unsafe {
                SharpDX.Direct3D12.DebugFeature __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.CalliSharpDXDirect3D12DebugFeature(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Reports information about a device object's lifetime. </p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p> A value from the <strong><see cref="SharpDX.Direct3D12.RldoFlags"/></strong> enumeration. This method uses the value in <em>Flags</em> to determine the amount of information to report about a device object's lifetime. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. <strong><see cref="SharpDX.Result"/></strong> </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DebugDevice::ReportLiveDeviceObjects']/*"/>	
        /// <msdn-id>dn986875</msdn-id>	
        /// <unmanaged>HRESULT ID3D12DebugDevice::ReportLiveDeviceObjects([In] D3D12_RLDO_FLAGS Flags)</unmanaged>	
        /// <unmanaged-short>ID3D12DebugDevice::ReportLiveDeviceObjects</unmanaged-short>	
        public void ReportLiveDeviceObjects(SharpDX.Direct3D12.RldoFlags flags) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, unchecked((int)flags),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> A debug interface controls debug settings and validates pipeline state. It can only be used if the debug layer is turned on. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is obtained by querying it from the <strong><see cref="SharpDX.Direct3D12.Device"/></strong> using <code>IUnknown::QueryInterface</code>.  </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Debug']/*"/>	
    /// <msdn-id>dn950153</msdn-id>	
    /// <unmanaged>ID3D12Debug</unmanaged>	
    /// <unmanaged-short>ID3D12Debug</unmanaged-short>	
    [Guid("344488b7-6846-474b-b989-f027448245e0")]
    public partial class DebugInterface : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.DebugInterface"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DebugInterface(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.DebugInterface"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.DebugInterface(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.DebugInterface(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Enables the debug layer. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Debug::EnableDebugLayer']/*"/>	
        /// <msdn-id>dn986877</msdn-id>	
        /// <unmanaged>void ID3D12Debug::EnableDebugLayer()</unmanaged>	
        /// <unmanaged-short>ID3D12Debug::EnableDebugLayer</unmanaged-short>	
        public void EnableDebugLayer() {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
            }
        }
    }
    /// <summary>	
    /// <p>A descriptor heap is a collection of contiguous allocations of descriptors, one allocation for every descriptor. Descriptor heaps contain many object types that are not part of a Pipeline State Object (PSO), such as Shader Resource Views (SRVs), Unordered Access Views (UAVs), Constant Buffer Views (CBVs), and Samplers.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DescriptorHeap']/*"/>	
    /// <msdn-id>dn788648</msdn-id>	
    /// <unmanaged>ID3D12DescriptorHeap</unmanaged>	
    /// <unmanaged-short>ID3D12DescriptorHeap</unmanaged-short>	
    [Guid("8efb471d-616c-4f49-90f7-127bb763fa51")]
    public partial class DescriptorHeap : SharpDX.Direct3D12.Pageable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.DescriptorHeap"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DescriptorHeap(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.DescriptorHeap"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.DescriptorHeap(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.DescriptorHeap(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Gets the descriptor heap description. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DescriptorHeap::GetDesc']/*"/>	
        /// <msdn-id>dn788649</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>D3D12_DESCRIPTOR_HEAP_DESC ID3D12DescriptorHeap::GetDesc()</unmanaged>
        public SharpDX.Direct3D12.DescriptorHeapDescription Description {
                get { return GetDescription(); }
        }
        
        /// <summary>	
        /// <p>Gets the CPU descriptor handle that represents the start of the heap.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart']/*"/>	
        /// <msdn-id>dn899174</msdn-id>	
        /// <unmanaged>GetCPUDescriptorHandleForHeapStart</unmanaged>	
        /// <unmanaged-short>GetCPUDescriptorHandleForHeapStart</unmanaged-short>	
        /// <unmanaged>D3D12_CPU_DESCRIPTOR_HANDLE ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart()</unmanaged>
        public SharpDX.Direct3D12.CpuDescriptorHandle CPUDescriptorHandleForHeapStart {
                get { return GetCPUDescriptorHandleForHeapStart(); }
        }
        
        /// <summary>	
        /// <p>Gets the GPU descriptor handle that represents the start of the heap.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DescriptorHeap::GetGPUDescriptorHandleForHeapStart']/*"/>	
        /// <msdn-id>dn899175</msdn-id>	
        /// <unmanaged>GetGPUDescriptorHandleForHeapStart</unmanaged>	
        /// <unmanaged-short>GetGPUDescriptorHandleForHeapStart</unmanaged-short>	
        /// <unmanaged>D3D12_GPU_DESCRIPTOR_HANDLE ID3D12DescriptorHeap::GetGPUDescriptorHandleForHeapStart()</unmanaged>
        public SharpDX.Direct3D12.GpuDescriptorHandle GPUDescriptorHandleForHeapStart {
                get { return GetGPUDescriptorHandleForHeapStart(); }
        }
        
        /// <summary>	
        /// <p> Gets the descriptor heap description. </p>	
        /// </summary>	
        /// <returns><p> The description of the descriptor heap, as a <strong><see cref="SharpDX.Direct3D12.DescriptorHeapDescription"/></strong> structure. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DescriptorHeap::GetDesc']/*"/>	
        /// <msdn-id>dn788649</msdn-id>	
        /// <unmanaged>D3D12_DESCRIPTOR_HEAP_DESC ID3D12DescriptorHeap::GetDesc()</unmanaged>	
        /// <unmanaged-short>ID3D12DescriptorHeap::GetDesc</unmanaged-short>	
        internal SharpDX.Direct3D12.DescriptorHeapDescription GetDescription() {
            unsafe {
                SharpDX.Direct3D12.DescriptorHeapDescription __result__;
                SharpDX.Direct3D12.LocalInterop.CallivoidPtr(_nativePointer,(void*)&__result__,((void**)(*(void**)_nativePointer))[8]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the CPU descriptor handle that represents the start of the heap.</p>	
        /// </summary>	
        /// <returns><p>Returns the CPU descriptor handle that represents the start of the heap.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart']/*"/>	
        /// <msdn-id>dn899174</msdn-id>	
        /// <unmanaged>D3D12_CPU_DESCRIPTOR_HANDLE ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart()</unmanaged>	
        /// <unmanaged-short>ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart</unmanaged-short>	
        internal SharpDX.Direct3D12.CpuDescriptorHandle GetCPUDescriptorHandleForHeapStart() {
            unsafe {
                SharpDX.Direct3D12.CpuDescriptorHandle __result__;
                SharpDX.Direct3D12.LocalInterop.CallivoidPtr(_nativePointer,(void*)&__result__,((void**)(*(void**)_nativePointer))[9]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the GPU descriptor handle that represents the start of the heap.</p>	
        /// </summary>	
        /// <returns><p>Returns the GPU descriptor handle that represents the start of the heap.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DescriptorHeap::GetGPUDescriptorHandleForHeapStart']/*"/>	
        /// <msdn-id>dn899175</msdn-id>	
        /// <unmanaged>D3D12_GPU_DESCRIPTOR_HANDLE ID3D12DescriptorHeap::GetGPUDescriptorHandleForHeapStart()</unmanaged>	
        /// <unmanaged-short>ID3D12DescriptorHeap::GetGPUDescriptorHandleForHeapStart</unmanaged-short>	
        internal SharpDX.Direct3D12.GpuDescriptorHandle GetGPUDescriptorHandleForHeapStart() {
            unsafe {
                SharpDX.Direct3D12.GpuDescriptorHandle __result__;
                SharpDX.Direct3D12.LocalInterop.CallivoidPtr(_nativePointer,(void*)&__result__,((void**)(*(void**)_nativePointer))[10]);		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Represents a virtual adapter; it is used to create command allocators, command lists, command queues, fences, resources, pipeline state objects, heaps, root signatures, samplers, and many resource views.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Use <strong><see cref="SharpDX.Direct3D12.D3D12.CreateDevice"/></strong> to create a device. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device']/*"/>	
    /// <msdn-id>dn788650</msdn-id>	
    /// <unmanaged>ID3D12Device</unmanaged>	
    /// <unmanaged-short>ID3D12Device</unmanaged-short>	
    [Guid("189819f1-1db6-4b57-be54-1821339b85f7")]
    public partial class Device : SharpDX.Direct3D12.Object {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.Device"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Device(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.Device"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.Device(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.Device(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Reports the number of physical adapters (nodes) that are associated with this device. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::GetNodeCount']/*"/>	
        /// <msdn-id>dn914412</msdn-id>	
        /// <unmanaged>GetNodeCount</unmanaged>	
        /// <unmanaged-short>GetNodeCount</unmanaged-short>	
        /// <unmanaged>unsigned int ID3D12Device::GetNodeCount()</unmanaged>
        public int NodeCount {
                get { return GetNodeCount(); }
        }
        
        /// <summary>	
        /// <p>Gets the reason that the device was removed.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::GetDeviceRemovedReason']/*"/>	
        /// <msdn-id>dn899187</msdn-id>	
        /// <unmanaged>GetDeviceRemovedReason</unmanaged>	
        /// <unmanaged-short>GetDeviceRemovedReason</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D12Device::GetDeviceRemovedReason()</unmanaged>
        public SharpDX.Result DeviceRemovedReason {
                get { return GetDeviceRemovedReason(); }
        }
        
        /// <summary>	
        /// <p>This method ensures the GPU timestamp counter does not stop ticking during idle periods.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>For more information on high definition performance measurement, refer to Timing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::SetStablePowerState']/*"/>	
        /// <msdn-id>dn903835</msdn-id>	
        /// <unmanaged>SetStablePowerState</unmanaged>	
        /// <unmanaged-short>SetStablePowerState</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D12Device::SetStablePowerState([In] BOOL Enable)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool StablePowerState {
                set { SetStablePowerState(value); }
        }
        
        /// <summary>	
        /// <p> Gets a locally unique identifier for the current device (adapter). </p>	
        /// </summary>	
        /// <remarks>	
        /// <p> This method returns a unique identifier for the adapter that is specific to the adapter hardware. Applications can use this identifier to define robust mappings across various APIs (Direct3D 12, DXGI). </p><p> A locally unique identifier (<see cref="long"/>) is a 64-bit value that is guaranteed to be unique only on the system on which it was generated. The uniqueness of a locally unique identifier (<see cref="long"/>) is guaranteed only until the system is restarted. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::GetAdapterLuid']/*"/>	
        /// <msdn-id>dn914411</msdn-id>	
        /// <unmanaged>GetAdapterLuid</unmanaged>	
        /// <unmanaged-short>GetAdapterLuid</unmanaged-short>	
        /// <unmanaged>LUID ID3D12Device::GetAdapterLuid()</unmanaged>
        public long AdapterLuid {
                get { return GetAdapterLuid(); }
        }
        
        /// <summary>	
        /// <p> Reports the number of physical adapters (nodes) that are associated with this device. </p>	
        /// </summary>	
        /// <returns><p> The number of physical adapters (nodes) that this device has. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::GetNodeCount']/*"/>	
        /// <msdn-id>dn914412</msdn-id>	
        /// <unmanaged>unsigned int ID3D12Device::GetNodeCount()</unmanaged>	
        /// <unmanaged-short>ID3D12Device::GetNodeCount</unmanaged-short>	
        internal int GetNodeCount() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[7]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Creates a command queue.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p> Specifies a <see cref="SharpDX.Direct3D12.CommandQueueDescription"/> that describes the command queue. </p> </dd></param>	
        /// <param name="riid"><dd>  <p> The globally unique identifier (<see cref="System.Guid"/>) for the command queue interface. See remarks.  An input parameter. </p> </dd></param>	
        /// <returns><dd>  <p> A reference to a memory block that receives a reference to the <strong><see cref="SharpDX.Direct3D12.CommandQueue"/></strong> interface for the command queue. </p> </dd></returns>	
        /// <remarks>	
        /// <p> The <strong>REFIID</strong>, or <strong><see cref="System.Guid"/></strong>, of the interface to the command queue can be obtained by using the __uuidof() macro. For example, __uuidof(<see cref="SharpDX.Direct3D12.CommandQueue"/>) will get the <strong><see cref="System.Guid"/></strong> of the interface to a command queue. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateCommandQueue']/*"/>	
        /// <msdn-id>dn788657</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::CreateCommandQueue([In] const D3D12_COMMAND_QUEUE_DESC* pDesc,[In] const GUID&amp; riid,[Out] ID3D12CommandQueue** ppCommandQueue)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateCommandQueue</unmanaged-short>	
        private SharpDX.Direct3D12.CommandQueue CreateCommandQueue(SharpDX.Direct3D12.CommandQueueDescription descRef, System.Guid riid) {
            unsafe {
                SharpDX.Direct3D12.CommandQueue commandQueueOut;
                IntPtr commandQueueOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, &descRef, &riid, &commandQueueOut_,((void**)(*(void**)_nativePointer))[8]);		
                commandQueueOut= (commandQueueOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D12.CommandQueue(commandQueueOut_);	
                __result__.CheckError();
                return commandQueueOut;
            }
        }
        
        /// <summary>	
        /// <p>Creates a command allocator object.</p>	
        /// </summary>	
        /// <param name="type"><dd>  <p> A <strong><see cref="SharpDX.Direct3D12.CommandListType"/></strong>-typed value that specifies the type of command allocator to create. The type of command allocator can be the type that records either direct command lists or bundles. </p> </dd></param>	
        /// <param name="riid"><dd>  <p> The globally unique identifier (<strong><see cref="System.Guid"/></strong>) for the command allocator interface (<strong><see cref="SharpDX.Direct3D12.CommandAllocator"/></strong>). The <strong>REFIID</strong>, or <strong><see cref="System.Guid"/></strong>, of the interface to the command allocator can be obtained by using the __uuidof() macro. For example, __uuidof(<see cref="SharpDX.Direct3D12.CommandAllocator"/>) will get the <strong><see cref="System.Guid"/></strong> of the interface to a command allocator. </p> </dd></param>	
        /// <returns><dd>  <p> A reference to a memory block that receives a reference to the <strong><see cref="SharpDX.Direct3D12.CommandAllocator"/></strong> interface for the command allocator. </p> </dd></returns>	
        /// <remarks>	
        /// <p> The device creates command lists from the command allocator. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateCommandAllocator']/*"/>	
        /// <msdn-id>dn788655</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::CreateCommandAllocator([In] D3D12_COMMAND_LIST_TYPE type,[In] const GUID&amp; riid,[Out] ID3D12CommandAllocator** ppCommandAllocator)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateCommandAllocator</unmanaged-short>	
        private SharpDX.Direct3D12.CommandAllocator CreateCommandAllocator(SharpDX.Direct3D12.CommandListType type, System.Guid riid) {
            unsafe {
                SharpDX.Direct3D12.CommandAllocator commandAllocatorOut;
                IntPtr commandAllocatorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, unchecked((int)type), &riid, &commandAllocatorOut_,((void**)(*(void**)_nativePointer))[9]);		
                commandAllocatorOut= (commandAllocatorOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D12.CommandAllocator(commandAllocatorOut_);	
                __result__.CheckError();
                return commandAllocatorOut;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="descRef">No documentation.</param>	
        /// <param name="riid">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateGraphicsPipelineState']/*"/>	
        /// <unmanaged>HRESULT ID3D12Device::CreateGraphicsPipelineState([In] const void* pDesc,[In] const GUID&amp; riid,[Out] ID3D12PipelineState** ppPipelineState)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateGraphicsPipelineState</unmanaged-short>	
        private SharpDX.Direct3D12.PipelineState CreateGraphicsPipelineState(System.IntPtr descRef, System.Guid riid) {
            unsafe {
                SharpDX.Direct3D12.PipelineState pipelineStateOut;
                IntPtr pipelineStateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, (void*)descRef, &riid, &pipelineStateOut_,((void**)(*(void**)_nativePointer))[10]);		
                pipelineStateOut= (pipelineStateOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D12.PipelineState(pipelineStateOut_);	
                __result__.CheckError();
                return pipelineStateOut;
            }
        }
        
        /// <summary>	
        /// <p>Creates a compute pipeline state object.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p> A reference to a <strong><see cref="SharpDX.Direct3D12.ComputePipelineStateDescription"/></strong> structure that describes compute pipeline state. </p> </dd></param>	
        /// <param name="riid"><dd>  <p> The globally unique identifier (<strong><see cref="System.Guid"/></strong>) for the pipeline state interface (<strong><see cref="SharpDX.Direct3D12.PipelineState"/></strong>). The <strong>REFIID</strong>, or <strong><see cref="System.Guid"/></strong>, of the interface to the pipeline state can be obtained by using the __uuidof() macro. For example, __uuidof(<see cref="SharpDX.Direct3D12.PipelineState"/>) will get the <strong><see cref="System.Guid"/></strong> of the interface to a pipeline state. </p> </dd></param>	
        /// <returns><dd>  <p> A reference to a memory block that receives a reference to the <strong><see cref="SharpDX.Direct3D12.PipelineState"/></strong> interface for the pipeline state object. The pipeline state object is an immutable state object.  It contains no methods. </p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateComputePipelineState']/*"/>	
        /// <msdn-id>dn788658</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::CreateComputePipelineState([In] const void* pDesc,[In] const GUID&amp; riid,[Out] ID3D12PipelineState** ppPipelineState)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateComputePipelineState</unmanaged-short>	
        private SharpDX.Direct3D12.PipelineState CreateComputePipelineState(System.IntPtr descRef, System.Guid riid) {
            unsafe {
                SharpDX.Direct3D12.PipelineState pipelineStateOut;
                IntPtr pipelineStateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, (void*)descRef, &riid, &pipelineStateOut_,((void**)(*(void**)_nativePointer))[11]);		
                pipelineStateOut= (pipelineStateOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D12.PipelineState(pipelineStateOut_);	
                __result__.CheckError();
                return pipelineStateOut;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="nodeMask">No documentation.</param>	
        /// <param name="type">No documentation.</param>	
        /// <param name="commandAllocatorRef">No documentation.</param>	
        /// <param name="initialStateRef">No documentation.</param>	
        /// <param name="riid">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateCommandList']/*"/>	
        /// <unmanaged>HRESULT ID3D12Device::CreateCommandList([In] unsigned int nodeMask,[In] D3D12_COMMAND_LIST_TYPE type,[In] ID3D12CommandAllocator* pCommandAllocator,[In, Optional] ID3D12PipelineState* pInitialState,[In] const GUID&amp; riid,[Out] void** ppCommandList)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateCommandList</unmanaged-short>	
        private System.IntPtr CreateCommandList(int nodeMask, SharpDX.Direct3D12.CommandListType type, SharpDX.Direct3D12.CommandAllocator commandAllocatorRef, SharpDX.Direct3D12.PipelineState initialStateRef, System.Guid riid) {
            unsafe {
                System.IntPtr commandListOut;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, nodeMask, unchecked((int)type), (void*)((commandAllocatorRef == null)?IntPtr.Zero:commandAllocatorRef.NativePointer), (void*)((initialStateRef == null)?IntPtr.Zero:initialStateRef.NativePointer), &riid, &commandListOut,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
                return commandListOut;
            }
        }
        
        /// <summary>	
        /// <p> Gets information about the features that are supported by the current graphics driver.</p>	
        /// </summary>	
        /// <param name="feature"><dd>  <p> A <strong><see cref="SharpDX.Direct3D12.Feature"/></strong>-typed value that describes the feature to query for support. </p> </dd></param>	
        /// <param name="featureSupportDataRef"><dd>  <p> The passed structure is filled with data that describes the feature support. To see the structure types, see the Remarks section in <strong><see cref="SharpDX.Direct3D12.Feature"/> enumeration</strong>. </p> </dd></param>	
        /// <param name="featureSupportDataSize"><dd>  <p> The size of the structure passed to the <em>pFeatureSupportData</em> parameter. </p> </dd></param>	
        /// <returns><p> Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise, returns <strong>E_INVALIDARG</strong> if an unsupported data type is passed to the <em>pFeatureSupportData</em> parameter or a size mismatch is detected for the <em>FeatureSupportDataSize</em> parameter. </p></returns>	
        /// <remarks>	
        /// <p>Refer to Capability Querying.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CheckFeatureSupport']/*"/>	
        /// <msdn-id>dn788653</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::CheckFeatureSupport([In] D3D12_FEATURE Feature,[Out, Buffer] void* pFeatureSupportData,[In] unsigned int FeatureSupportDataSize)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CheckFeatureSupport</unmanaged-short>	
        private SharpDX.Result CheckFeatureSupport(SharpDX.Direct3D12.Feature feature, System.IntPtr featureSupportDataRef, int featureSupportDataSize) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, unchecked((int)feature), (void*)featureSupportDataRef, featureSupportDataSize,((void**)(*(void**)_nativePointer))[13]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="descriptorHeapDescRef">No documentation.</param>	
        /// <param name="riid">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateDescriptorHeap']/*"/>	
        /// <unmanaged>HRESULT ID3D12Device::CreateDescriptorHeap([In] const D3D12_DESCRIPTOR_HEAP_DESC* pDescriptorHeapDesc,[In] const GUID&amp; riid,[Out] ID3D12DescriptorHeap** ppvHeap)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateDescriptorHeap</unmanaged-short>	
        private SharpDX.Direct3D12.DescriptorHeap CreateDescriptorHeap(SharpDX.Direct3D12.DescriptorHeapDescription descriptorHeapDescRef, System.Guid riid) {
            unsafe {
                SharpDX.Direct3D12.DescriptorHeap vHeapOut;
                IntPtr vHeapOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, &descriptorHeapDescRef, &riid, &vHeapOut_,((void**)(*(void**)_nativePointer))[14]);		
                vHeapOut= (vHeapOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D12.DescriptorHeap(vHeapOut_);	
                __result__.CheckError();
                return vHeapOut;
            }
        }
        
        /// <summary>	
        /// <p> Gets the size of the handle increment for the given type of descriptor heap. This value is typically used to increment a handle into a descriptor array by the correct amount.</p>	
        /// </summary>	
        /// <param name="descriptorHeapType"><dd> <p> The <strong><see cref="SharpDX.Direct3D12.DescriptorHeapType"/></strong>-typed value that specifies the type of descriptor heap to get the size of the handle increment for. </p> </dd></param>	
        /// <returns><p> Returns the size of the handle increment for the given type of descriptor heap, including any necessary padding.</p></returns>	
        /// <remarks>	
        /// <p>The descriptor size returned by this method is used as one input to the helper structures <strong>CD3DX12_CPU_DESCRIPTOR_HANDLE</strong> and <strong>CD3DX12_GPU_DESCRIPTOR_HANDLE</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::GetDescriptorHandleIncrementSize']/*"/>	
        /// <msdn-id>dn899186</msdn-id>	
        /// <unmanaged>unsigned int ID3D12Device::GetDescriptorHandleIncrementSize([In] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::GetDescriptorHandleIncrementSize</unmanaged-short>	
        public int GetDescriptorHandleIncrementSize(SharpDX.Direct3D12.DescriptorHeapType descriptorHeapType) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, unchecked((int)descriptorHeapType),((void**)(*(void**)_nativePointer))[15]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="nodeMask">No documentation.</param>	
        /// <param name="blobWithRootSignatureRef">No documentation.</param>	
        /// <param name="blobLengthInBytes">No documentation.</param>	
        /// <param name="riid">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateRootSignature']/*"/>	
        /// <unmanaged>HRESULT ID3D12Device::CreateRootSignature([In] unsigned int nodeMask,[In, Buffer] const void* pBlobWithRootSignature,[In] SIZE_T blobLengthInBytes,[In] const GUID&amp; riid,[Out] ID3D12RootSignature** ppvRootSignature)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateRootSignature</unmanaged-short>	
        private SharpDX.Direct3D12.RootSignature CreateRootSignature(int nodeMask, System.IntPtr blobWithRootSignatureRef, SharpDX.PointerSize blobLengthInBytes, System.Guid riid) {
            unsafe {
                SharpDX.Direct3D12.RootSignature vRootSignatureOut;
                IntPtr vRootSignatureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, nodeMask, (void*)blobWithRootSignatureRef, (void*)blobLengthInBytes, &riid, &vRootSignatureOut_,((void**)(*(void**)_nativePointer))[16]);		
                vRootSignatureOut= (vRootSignatureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D12.RootSignature(vRootSignatureOut_);	
                __result__.CheckError();
                return vRootSignatureOut;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="descRef">No documentation.</param>	
        /// <param name="destDescriptor">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateConstantBufferView']/*"/>	
        /// <unmanaged>void ID3D12Device::CreateConstantBufferView([In, Optional] const D3D12_CONSTANT_BUFFER_VIEW_DESC* pDesc,[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateConstantBufferView</unmanaged-short>	
        public void CreateConstantBufferView(SharpDX.Direct3D12.ConstantBufferViewDescription? descRef, SharpDX.Direct3D12.CpuDescriptorHandle destDescriptor) {
            unsafe {
                SharpDX.Direct3D12.ConstantBufferViewDescription descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                SharpDX.Direct3D12.LocalInterop.Callivoid11(_nativePointer, (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, destDescriptor,((void**)(*(void**)_nativePointer))[17]);		
            }
        }
        
        /// <summary>	
        /// <p>Creates a shader-resource view for accessing data in a resource.</p>	
        /// </summary>	
        /// <param name="resourceRef"><dd>  <p>A reference to the <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> object that represents the shader resource.</p> </dd></param>	
        /// <param name="descRef"><dd>  <p>A reference to a <strong><see cref="SharpDX.Direct3D12.ShaderResourceViewDescription"/></strong> structure that describes the shader-resource view. </p> </dd></param>	
        /// <param name="destDescriptor"><dd>  <p>Describes the CPU descriptor handle that represents the shader-resource view. This handle can be created in a shader-visible or non-shader-visible descriptor heap.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateShaderResourceView']/*"/>	
        /// <msdn-id>dn788672</msdn-id>	
        /// <unmanaged>void ID3D12Device::CreateShaderResourceView([In, Optional] ID3D12Resource* pResource,[In, Optional] const D3D12_SHADER_RESOURCE_VIEW_DESC* pDesc,[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateShaderResourceView</unmanaged-short>	
        public void CreateShaderResourceView(SharpDX.Direct3D12.Resource resourceRef, SharpDX.Direct3D12.ShaderResourceViewDescription? descRef, SharpDX.Direct3D12.CpuDescriptorHandle destDescriptor) {
            unsafe {
                SharpDX.Direct3D12.ShaderResourceViewDescription descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                SharpDX.Direct3D12.LocalInterop.Callivoid12(_nativePointer, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, destDescriptor,((void**)(*(void**)_nativePointer))[18]);		
            }
        }
        
        /// <summary>	
        /// <p> Creates a view for unordered accessing. </p>	
        /// </summary>	
        /// <param name="resourceRef"><dd>  <p> A reference to the <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> object that represents the unordered access. </p> </dd></param>	
        /// <param name="counterResourceRef"><dd>  <p> The <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> for the counter (if any) associated with the UAV. </p> <p> If <em>pCounterResource</em> is not specified, the <strong>CounterOffsetInBytes</strong> member of the <strong><see cref="SharpDX.Direct3D12.UnorderedAccessViewDescription.BufferResource"/></strong> structure must be 0. </p> <p> If <em>pCounterResource</em> is specified, then there is a counter associated with the UAV, and the runtime performs validation of the following requirements: </p> <ul> <li> The <strong>StructureByteStride</strong> member of the <strong><see cref="SharpDX.Direct3D12.UnorderedAccessViewDescription.BufferResource"/></strong> structure must be greater than 0. </li> <li> The format must be <see cref="SharpDX.DXGI.Format.Unknown"/>. </li> <li> The <see cref="SharpDX.Direct3D12.BufferUnorderedAccessViewFlags.Raw"/> flag (a <strong><see cref="SharpDX.Direct3D12.BufferUnorderedAccessViewFlags"/></strong> enumeration constant) must not be set. </li> <li> Both of the resources (<em>pResource</em> and <em>pCounterResource</em>) must be buffers. </li> <li> The <strong>CounterOffsetInBytes</strong> member of the <strong><see cref="SharpDX.Direct3D12.UnorderedAccessViewDescription.BufferResource"/></strong> structure must be a multiple of 4 bytes, and must be within the range of the counter resource. </li> <li><em>pResource</em> cannot be <c>null</c> </li> <li><em>pDesc</em> cannot be <c>null</c>. </li> </ul> </dd></param>	
        /// <param name="descRef"><dd>  <p> A reference to a <strong><see cref="SharpDX.Direct3D12.UnorderedAccessViewDescription"/></strong> structure that describes the unordered-access view. </p> </dd></param>	
        /// <param name="destDescriptor"><dd>  <p>Describes the CPU descriptor handle that represents the start of the heap that holds the unordered-access view. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateUnorderedAccessView']/*"/>	
        /// <msdn-id>dn788674</msdn-id>	
        /// <unmanaged>void ID3D12Device::CreateUnorderedAccessView([In, Optional] ID3D12Resource* pResource,[In, Optional] ID3D12Resource* pCounterResource,[In, Optional] const D3D12_UNORDERED_ACCESS_VIEW_DESC* pDesc,[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateUnorderedAccessView</unmanaged-short>	
        public void CreateUnorderedAccessView(SharpDX.Direct3D12.Resource resourceRef, SharpDX.Direct3D12.Resource counterResourceRef, SharpDX.Direct3D12.UnorderedAccessViewDescription? descRef, SharpDX.Direct3D12.CpuDescriptorHandle destDescriptor) {
            unsafe {
                SharpDX.Direct3D12.UnorderedAccessViewDescription descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                SharpDX.Direct3D12.LocalInterop.Callivoid13(_nativePointer, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (void*)((counterResourceRef == null)?IntPtr.Zero:counterResourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, destDescriptor,((void**)(*(void**)_nativePointer))[19]);		
            }
        }
        
        /// <summary>	
        /// <p>Creates a render-target view for accessing resource data.</p>	
        /// </summary>	
        /// <param name="resourceRef"><dd>  <p> A reference to the <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> object that represents the render target. </p> </dd></param>	
        /// <param name="descRef"><dd>  <p> A reference to a <strong><see cref="SharpDX.Direct3D12.RenderTargetViewDescription"/></strong> structure that describes the render-target view. </p> </dd></param>	
        /// <param name="destDescriptor"><dd>  <p> Describes the CPU descriptor handle that represents the start of the heap that holds the render-target view. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateRenderTargetView']/*"/>	
        /// <msdn-id>dn788668</msdn-id>	
        /// <unmanaged>void ID3D12Device::CreateRenderTargetView([In, Optional] ID3D12Resource* pResource,[In, Optional] const D3D12_RENDER_TARGET_VIEW_DESC* pDesc,[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateRenderTargetView</unmanaged-short>	
        public void CreateRenderTargetView(SharpDX.Direct3D12.Resource resourceRef, SharpDX.Direct3D12.RenderTargetViewDescription? descRef, SharpDX.Direct3D12.CpuDescriptorHandle destDescriptor) {
            unsafe {
                SharpDX.Direct3D12.RenderTargetViewDescription descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                SharpDX.Direct3D12.LocalInterop.Callivoid12(_nativePointer, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, destDescriptor,((void**)(*(void**)_nativePointer))[20]);		
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="resourceRef">No documentation.</param>	
        /// <param name="descRef">No documentation.</param>	
        /// <param name="destDescriptor">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateDepthStencilView']/*"/>	
        /// <unmanaged>void ID3D12Device::CreateDepthStencilView([In, Optional] ID3D12Resource* pResource,[In, Optional] const D3D12_DEPTH_STENCIL_VIEW_DESC* pDesc,[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateDepthStencilView</unmanaged-short>	
        public void CreateDepthStencilView(SharpDX.Direct3D12.Resource resourceRef, SharpDX.Direct3D12.DepthStencilViewDescription? descRef, SharpDX.Direct3D12.CpuDescriptorHandle destDescriptor) {
            unsafe {
                SharpDX.Direct3D12.DepthStencilViewDescription descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                SharpDX.Direct3D12.LocalInterop.Callivoid12(_nativePointer, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, destDescriptor,((void**)(*(void**)_nativePointer))[21]);		
            }
        }
        
        /// <summary>	
        /// <p>Create a sampler object that encapsulates sampling information for a texture.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>A reference to a <strong><see cref="SharpDX.Direct3D12.SamplerStateDescription"/></strong> structure that describes the sampler. </p> </dd></param>	
        /// <param name="destDescriptor"><dd>  <p>Describes the CPU descriptor handle that represents the start of the heap that holds the sampler.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateSampler']/*"/>	
        /// <msdn-id>dn788671</msdn-id>	
        /// <unmanaged>void ID3D12Device::CreateSampler([In, Value] const D3D12_SAMPLER_DESC* pDesc,[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateSampler</unmanaged-short>	
        public void CreateSampler(SharpDX.Direct3D12.SamplerStateDescription descRef, SharpDX.Direct3D12.CpuDescriptorHandle destDescriptor) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid11(_nativePointer, &descRef, destDescriptor,((void**)(*(void**)_nativePointer))[22]);		
            }
        }
        
        /// <summary>	
        /// <p> Copies descriptors from a source to a destination. </p>	
        /// </summary>	
        /// <param name="numDestDescriptorRanges"><dd>  <p> The number of destination descriptor ranges to copy to. </p> </dd></param>	
        /// <param name="destDescriptorRangeStartsRef"><dd>  <p> An array of CPU_descriptor_handle objects to copy to. </p> </dd></param>	
        /// <param name="destDescriptorRangeSizesRef"><dd>  <p> An array of destination descriptor range sizes to copy to. </p> </dd></param>	
        /// <param name="numSrcDescriptorRanges"><dd>  <p> The number of source descriptor ranges to copy from. </p> </dd></param>	
        /// <param name="srcDescriptorRangeStartsRef"><dd>  <p> An array of CPU_descriptor_handle objects to copy from. </p> </dd></param>	
        /// <param name="srcDescriptorRangeSizesRef"><dd>  <p> An array of source descriptor range sizes to copy from. </p> </dd></param>	
        /// <param name="descriptorHeapsType"><dd>  <p> The <strong><see cref="SharpDX.Direct3D12.DescriptorHeapType"/></strong>-typed value that specifies the type of descriptor heap to copy with. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CopyDescriptors']/*"/>	
        /// <msdn-id>dn899176</msdn-id>	
        /// <unmanaged>void ID3D12Device::CopyDescriptors([In] unsigned int NumDestDescriptorRanges,[In, Buffer] const D3D12_CPU_DESCRIPTOR_HANDLE* pDestDescriptorRangeStarts,[In, Buffer, Optional] const unsigned int* pDestDescriptorRangeSizes,[In] unsigned int NumSrcDescriptorRanges,[In, Buffer] const D3D12_CPU_DESCRIPTOR_HANDLE* pSrcDescriptorRangeStarts,[In, Buffer, Optional] const unsigned int* pSrcDescriptorRangeSizes,[In] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CopyDescriptors</unmanaged-short>	
        public void CopyDescriptors(int numDestDescriptorRanges, SharpDX.Direct3D12.CpuDescriptorHandle[] destDescriptorRangeStartsRef, int[] destDescriptorRangeSizesRef, int numSrcDescriptorRanges, SharpDX.Direct3D12.CpuDescriptorHandle[] srcDescriptorRangeStartsRef, int[] srcDescriptorRangeSizesRef, SharpDX.Direct3D12.DescriptorHeapType descriptorHeapsType) {
            unsafe {
                int[] destDescriptorRangeSizesRef__ = destDescriptorRangeSizesRef;
                int[] srcDescriptorRangeSizesRef__ = srcDescriptorRangeSizesRef;
                fixed (void* destDescriptorRangeStartsRef_ = destDescriptorRangeStartsRef)
                    fixed (void* destDescriptorRangeSizesRef_ = destDescriptorRangeSizesRef__)
                        fixed (void* srcDescriptorRangeStartsRef_ = srcDescriptorRangeStartsRef)
                            fixed (void* srcDescriptorRangeSizesRef_ = srcDescriptorRangeSizesRef__)
                                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, numDestDescriptorRanges, destDescriptorRangeStartsRef_, destDescriptorRangeSizesRef_, numSrcDescriptorRanges, srcDescriptorRangeStartsRef_, srcDescriptorRangeSizesRef_, unchecked((int)descriptorHeapsType),((void**)(*(void**)_nativePointer))[23]);		
            }
        }
        
        /// <summary>	
        /// <p> Copies descriptors from a source to a destination. </p>	
        /// </summary>	
        /// <param name="numDescriptors"><dd>  <p> The number of descriptors to copy. </p> </dd></param>	
        /// <param name="destDescriptorRangeStart"><dd>  <p> A CPU_descriptor_handle that describes the destination descriptors to start to copy to. </p> </dd></param>	
        /// <param name="srcDescriptorRangeStart"><dd>  <p> A CPU_descriptor_handle that describes the source descriptors to start to copy from. </p> </dd></param>	
        /// <param name="descriptorHeapsType"><dd>  <p> The <strong><see cref="SharpDX.Direct3D12.DescriptorHeapType"/></strong>-typed value that specifies the type of descriptor heap to copy with. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CopyDescriptorsSimple']/*"/>	
        /// <msdn-id>dn899177</msdn-id>	
        /// <unmanaged>void ID3D12Device::CopyDescriptorsSimple([In] unsigned int NumDescriptors,[In] D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart,[In] D3D12_CPU_DESCRIPTOR_HANDLE SrcDescriptorRangeStart,[In] D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CopyDescriptorsSimple</unmanaged-short>	
        public void CopyDescriptorsSimple(int numDescriptors, SharpDX.Direct3D12.CpuDescriptorHandle destDescriptorRangeStart, SharpDX.Direct3D12.CpuDescriptorHandle srcDescriptorRangeStart, SharpDX.Direct3D12.DescriptorHeapType descriptorHeapsType) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid15(_nativePointer, numDescriptors, destDescriptorRangeStart, srcDescriptorRangeStart, unchecked((int)descriptorHeapsType),((void**)(*(void**)_nativePointer))[24]);		
            }
        }
        
        /// <summary>	
        /// <p> Gets the size and alignment of memory required for a collection of resources on this adapter. </p>	
        /// </summary>	
        /// <param name="visibleMask"><dd>  <p> For single GPU operation, set this to zero.  If there are multiple GPU nodes, set bits to identify the nodes (the  device's physical adapters). Each bit in the mask corresponds to a single node. Refer to Multi-Adapter.</p> </dd></param>	
        /// <param name="numResourceDescs"><dd>  <p> The number of resource descriptors in the <em>pResourceDescs</em> array. </p> </dd></param>	
        /// <param name="resourceDescsRef"><dd>  <p> An array of <strong><see cref="SharpDX.Direct3D12.ResourceDescription"/></strong> structures that described the resources to get info about. </p> </dd></param>	
        /// <returns><p> Returns a <strong><see cref="SharpDX.Direct3D12.ResourceAllocationInformation"/></strong> structure that provides info about video memory allocated for the specified array of resources. </p></returns>	
        /// <remarks>	
        /// <p> When using <strong>CreatePlacedResource</strong>, the application must use this method to understand the size and alignment characteristics of texture resources.  The results of this method vary depending on the particular adapter, and must be treated as unique to this adapter and driver version. </p><p> Applications cannot use the output of <strong>GetResourceAllocationInfo</strong> to understand packed mip properties of textures. To understand packed mip properties of textures, applications must use <strong>GetResourceTiling</strong>.  Texture resource sizes significantly differ from the information returned by <strong>GetResourceTiling</strong>, because some adapter architectures allocate extra memory for textures to reduce the effective bandwidth during common rendering scenarios.  This even includes textures that have constraints on their texture layouts or have standardized texture layouts.  That extra memory cannot be sparsely mapped or remapped by an application using <strong>CreateReservedResource</strong> and  <strong>UpdateTileMappings</strong>, so it isn't reported in <strong>GetResourceTiling</strong>. </p><p> Applications can forgo using <strong>GetResourceAllocationInfo</strong> for buffer resources (<strong><see cref="SharpDX.Direct3D12.ResourceDimension"/></strong>_BUFFER).  Buffers have the same size on all adapters, which is merely the smallest multiple of 64KB which is greater or equal to <strong><see cref="SharpDX.Direct3D12.ResourceDescription"/></strong>::<strong>Width</strong>. </p><p> When multiple resource descriptions are passed in, the C++ algorithm for calculating a structure size and alignment are used.  For example, a three-element array with two tiny 64KB-aligned resources and a tiny 4MB-aligned resource reports differing sizes based on the order of the array.  If the 4MB aligned resource is in the middle, the resulting <strong>Size</strong> is 12MB.  Otherwise, the resulting <strong>Size</strong> is 8MB.  The <strong>Alignment</strong> returned would always be 4MB, as it is the superset of all alignments in the resource array. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::GetResourceAllocationInfo']/*"/>	
        /// <msdn-id>dn788680</msdn-id>	
        /// <unmanaged>D3D12_RESOURCE_ALLOCATION_INFO ID3D12Device::GetResourceAllocationInfo([In] unsigned int visibleMask,[In] unsigned int numResourceDescs,[In, Buffer] const D3D12_RESOURCE_DESC* pResourceDescs)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::GetResourceAllocationInfo</unmanaged-short>	
        public SharpDX.Direct3D12.ResourceAllocationInformation GetResourceAllocationInfo(int visibleMask, int numResourceDescs, SharpDX.Direct3D12.ResourceDescription[] resourceDescsRef) {
            unsafe {
                SharpDX.Direct3D12.ResourceAllocationInformation __result__;
                fixed (void* resourceDescsRef_ = resourceDescsRef)
                    SharpDX.Direct3D12.LocalInterop.CallivoidPtr(_nativePointer,(void*)&__result__, visibleMask, numResourceDescs, resourceDescsRef_,((void**)(*(void**)_nativePointer))[25]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Divulges the equivalent custom heap properties that are used for non-custom heap types, based on the adapter's architectural properties. </p>	
        /// </summary>	
        /// <param name="nodeMask"><dd>  <p> For single-GPU operation, set this to zero.  If there are multiple GPU nodes, set a bit to identify the node (the  device's physical adapter). Each bit in the mask corresponds to a single node. Only 1 bit must be set. See Multi-Adapter. </p> </dd></param>	
        /// <param name="heapType"><dd>  <p> A <strong><see cref="SharpDX.Direct3D12.HeapType"/></strong>-typed value that specifies the heap to get properties for. <see cref="SharpDX.Direct3D12.HeapType.Custom"/> is not supported as a parameter value. </p> </dd></param>	
        /// <returns><p> Returns a <strong><see cref="SharpDX.Direct3D12.HeapProperties"/></strong> structure that provides properties for the specified heap. The <strong>Type</strong> member of the returned <see cref="SharpDX.Direct3D12.HeapProperties"/> is always <see cref="SharpDX.Direct3D12.HeapType.Custom"/>. </p><p> When <strong><see cref="SharpDX.Direct3D12.FeatureDataArchitecture"/></strong>::UMA is <see cref="SharpDX.Result.False"/>, the returned <see cref="SharpDX.Direct3D12.HeapProperties"/> members convert as follows: </p><table> <tr><th>Heap Type</th><th>How the returned <see cref="SharpDX.Direct3D12.HeapProperties"/> members convert</th></tr> <tr><td><see cref="SharpDX.Direct3D12.HeapType.Upload"/></td><td><strong>CPUPageProperty</strong> = WRITE_COMBINE, <strong>MemoryPoolPreference</strong> = L0.</td></tr> <tr><td><see cref="SharpDX.Direct3D12.HeapType.Default"/></td><td><strong>CPUPageProperty</strong> = NOT_AVAILABLE, <strong>MemoryPoolPreference</strong> = L1.</td></tr> <tr><td><see cref="SharpDX.Direct3D12.HeapType.Readback"/></td><td><strong>CPUPageProperty</strong> = WRITE_BACK, <strong>MemoryPoolPreference</strong> = L0.</td></tr> </table><p>?</p><p> When D3D12_FEATURE_DATA_ARCHITECTURE::UMA is TRUE and D3D12_FEATURE_DATA_ARCHITECTURE::CacheCoherentUMA is <see cref="SharpDX.Result.False"/>, the returned <see cref="SharpDX.Direct3D12.HeapProperties"/> members convert as follows: </p><table> <tr><th>Heap Type</th><th>How the returned <see cref="SharpDX.Direct3D12.HeapProperties"/> members convert</th></tr> <tr><td><see cref="SharpDX.Direct3D12.HeapType.Upload"/></td><td><strong>CPUPageProperty</strong> = WRITE_COMBINE, <strong>MemoryPoolPreference</strong> = L0.</td></tr> <tr><td><see cref="SharpDX.Direct3D12.HeapType.Default"/></td><td><strong>CPUPageProperty</strong> = NOT_AVAILABLE, <strong>MemoryPoolPreference</strong> = L0.</td></tr> <tr><td><see cref="SharpDX.Direct3D12.HeapType.Readback"/></td><td><strong>CPUPageProperty</strong> = WRITE_BACK, <strong>MemoryPoolPreference</strong> = L0.</td></tr> </table><p>?</p><p> When D3D12_FEATURE_DATA_ARCHITECTURE::UMA is TRUE and D3D12_FEATURE_DATA_ARCHITECTURE::CacheCoherentUMA is TRUE, the returned <see cref="SharpDX.Direct3D12.HeapProperties"/> members convert as follows: </p><table> <tr><th>Heap Type</th><th>How the returned <see cref="SharpDX.Direct3D12.HeapProperties"/> members convert</th></tr> <tr><td><see cref="SharpDX.Direct3D12.HeapType.Upload"/></td><td><strong>CPUPageProperty</strong> = WRITE_BACK, <strong>MemoryPoolPreference</strong> = L0.</td></tr> <tr><td><see cref="SharpDX.Direct3D12.HeapType.Default"/></td><td><strong>CPUPageProperty</strong> = NOT_AVAILABLE, <strong>MemoryPoolPreference</strong> = L0.</td></tr> <tr><td><see cref="SharpDX.Direct3D12.HeapType.Readback"/></td><td><strong>CPUPageProperty</strong> = WRITE_BACK, <strong>MemoryPoolPreference</strong> = L0.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::GetCustomHeapProperties']/*"/>	
        /// <msdn-id>dn788678</msdn-id>	
        /// <unmanaged>D3D12_HEAP_PROPERTIES ID3D12Device::GetCustomHeapProperties([In] unsigned int nodeMask,[In] D3D12_HEAP_TYPE heapType)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::GetCustomHeapProperties</unmanaged-short>	
        public SharpDX.Direct3D12.HeapProperties GetCustomHeapProperties(int nodeMask, SharpDX.Direct3D12.HeapType heapType) {
            unsafe {
                SharpDX.Direct3D12.HeapProperties __result__;
                SharpDX.Direct3D12.LocalInterop.CallivoidPtr(_nativePointer,(void*)&__result__, nodeMask, unchecked((int)heapType),((void**)(*(void**)_nativePointer))[26]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Creates both a resource and an implicit heap, such that the heap is big enough to contain the entire resource and the resource is mapped to the heap. </p>	
        /// </summary>	
        /// <param name="heapPropertiesRef"><dd>  <p> A reference to a <strong><see cref="SharpDX.Direct3D12.HeapProperties"/></strong> structure that provides properties for the resource's heap. </p> </dd></param>	
        /// <param name="heapFlags"><dd>  <p> Heap options, as a bitwise-OR'd combination of <strong><see cref="SharpDX.Direct3D12.HeapFlags"/></strong> enumeration constants. </p> </dd></param>	
        /// <param name="resourceDescRef"><dd>  <p> A reference to a <strong><see cref="SharpDX.Direct3D12.ResourceDescription"/></strong> structure that describes the resource. </p> </dd></param>	
        /// <param name="initialResourceState"><dd>  <p> The initial state of the resource, as a bitwise-OR'd combination of <strong><see cref="SharpDX.Direct3D12.ResourceStates"/></strong> enumeration constants. </p> <p> When a resource is created together with a <strong><see cref="SharpDX.Direct3D12.HeapType"/></strong>_UPLOAD heap, <em>InitialResourceState</em> must be <strong>D3D12_RESOURCE_STATE</strong>_GENERIC_READ. When a resource is created together with a <see cref="SharpDX.Direct3D12.HeapType.Readback"/> heap, <em>InitialResourceState</em> must be <see cref="SharpDX.Direct3D12.ResourceStates.CopyDestination"/>. </p> </dd></param>	
        /// <param name="optimizedClearValueRef"><dd>  <p> Specifies a <strong><see cref="SharpDX.Direct3D12.ClearValue"/></strong> that describes the default value for a clear color. </p> <p><em>pOptimizedClearValue</em> specifies a value for which clear operations are most optimal. When the created resource is a texture with either the <strong>D3D12_RESOURCE_FLAG</strong>_ALLOW_RENDER_TARGET or <see cref="SharpDX.Direct3D12.ResourceFlags.AllowDepthStencil"/> flags, applications should choose the value that the clear operation will most commonly be called with. Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the one passed into resource creation. <em>pOptimizedClearValue</em> must be <c>null</c> when used with <strong><see cref="SharpDX.Direct3D12.ResourceDimension"/></strong>_BUFFER. </p> </dd></param>	
        /// <param name="riidResource"><dd>  <p> The globally unique identifier (<strong><see cref="System.Guid"/></strong>) for the resource interface. This is an input parameter. The <strong>REFIID</strong>, or <strong><see cref="System.Guid"/></strong>, of the interface to the resource can be obtained by using the __uuidof() macro. For example, __uuidof(<strong><see cref="SharpDX.Direct3D12.Resource"/></strong>) will get the <strong><see cref="System.Guid"/></strong> of the interface to a resource. </p> <p> While riidResource is, most commonly, the <see cref="System.Guid"/> for <strong><see cref="SharpDX.Direct3D12.Resource"/></strong>, it may be any <see cref="System.Guid"/> for any interface. If the resource object doesn't support the interface for this <see cref="System.Guid"/>, creation will fail with E_NOINTERFACE. </p> </dd></param>	
        /// <returns><dd>  <p> A reference to memory that receives the requested interface reference to the created resource object. <em>ppvResource</em> can be <c>null</c>, to enable capability testing. When <em>ppvResource</em> is <c>null</c>, no object will be created and S_FALSE will be returned when <em>pResourceDesc</em> is valid. </p> </dd></returns>	
        /// <remarks>	
        /// <p> This method creates both a resource and a heap, such that the heap is big enough to contain the entire resource and the resource is mapped to the heap. The created heap is known as an implicit heap, because the heap object cannot be obtained by the application. The application must ensure the GPU will no longer read or write to this resource before releasing the final reference on the resource. </p><p> The implicit heap is made resident for GPU access before the method returns to the application. See Residency. </p><p> The resource GPU VA mapping cannot be changed. See <strong><see cref="SharpDX.Direct3D12.CommandQueue.UpdateTileMappings"/></strong> and Volume Tiled Resources. </p><p> This method may be called by multiple threads concurrently. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateCommittedResource']/*"/>	
        /// <msdn-id>dn899178</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::CreateCommittedResource([In] const D3D12_HEAP_PROPERTIES* pHeapProperties,[In] D3D12_HEAP_FLAGS HeapFlags,[In, Value] const D3D12_RESOURCE_DESC* pResourceDesc,[In] D3D12_RESOURCE_STATES InitialResourceState,[In, Optional] const D3D12_CLEAR_VALUE* pOptimizedClearValue,[In] const GUID&amp; riidResource,[Out] ID3D12Resource** ppvResource)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateCommittedResource</unmanaged-short>	
        private SharpDX.Direct3D12.Resource CreateCommittedResource(ref SharpDX.Direct3D12.HeapProperties heapPropertiesRef, SharpDX.Direct3D12.HeapFlags heapFlags, SharpDX.Direct3D12.ResourceDescription resourceDescRef, SharpDX.Direct3D12.ResourceStates initialResourceState, SharpDX.Direct3D12.ClearValue? optimizedClearValueRef, System.Guid riidResource) {
            unsafe {
                SharpDX.Direct3D12.ClearValue optimizedClearValueRef_;
                if (optimizedClearValueRef.HasValue)
                    optimizedClearValueRef_ = optimizedClearValueRef.Value;				
                SharpDX.Direct3D12.Resource vResourceOut;
                IntPtr vResourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* heapPropertiesRef_ = &heapPropertiesRef)
                    __result__= 
    				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, heapPropertiesRef_, unchecked((int)heapFlags), &resourceDescRef, unchecked((int)initialResourceState), (optimizedClearValueRef.HasValue)?&optimizedClearValueRef_:(void*)IntPtr.Zero, &riidResource, &vResourceOut_,((void**)(*(void**)_nativePointer))[27]);		
                vResourceOut= (vResourceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D12.Resource(vResourceOut_);	
                __result__.CheckError();
                return vResourceOut;
            }
        }
        
        /// <summary>	
        /// <p> Creates a heap that can be used with placed resources and reserved resources. </p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p> A reference to a <strong><see cref="SharpDX.Direct3D12.HeapDescription"/></strong> structure that describes the heap. </p> </dd></param>	
        /// <param name="riid"><dd>  <p> The globally unique identifier (<strong><see cref="System.Guid"/></strong>) for the heap interface. This is an input parameter. The <strong>REFIID</strong>, or <strong><see cref="System.Guid"/></strong>, of the interface to the heap can be obtained by using the __uuidof() macro. For example, __uuidof(<strong><see cref="SharpDX.Direct3D12.Heap"/></strong>) will get the <strong><see cref="System.Guid"/></strong> of the interface to a heap. <em>riid</em> is, most commonly, the <see cref="System.Guid"/> for <strong><see cref="SharpDX.Direct3D12.Heap"/></strong>, but it may be any <see cref="System.Guid"/> for any interface. If the resource object does not support the interface for the specified <see cref="System.Guid"/>, creation will fail with E_NOINTERFACE. </p> </dd></param>	
        /// <returns><dd>  <p> A reference to a memory block that receives a reference to the heap. <em>ppvHeap</em> can be <c>null</c>, to enable capability testing. When <em>ppvHeap</em> is <c>null</c>, no object will be created and S_FALSE will be returned when <em>pDesc</em> is valid. </p> </dd></returns>	
        /// <remarks>	
        /// <p><strong>CreateHeap</strong> creates a heap that can be used with placed resources and reserved resources. Before releasing the final reference on the heap, the application must ensure that the GPU will no longer read or write to this heap. Placed resource objects will hold a reference on the heap they are created on, but reserved resources will not hold a reference for each mapping made to a heap. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateHeap']/*"/>	
        /// <msdn-id>dn788664</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::CreateHeap([In] const D3D12_HEAP_DESC* pDesc,[In] const GUID&amp; riid,[Out] ID3D12Heap** ppvHeap)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateHeap</unmanaged-short>	
        private SharpDX.Direct3D12.Heap CreateHeap(ref SharpDX.Direct3D12.HeapDescription descRef, System.Guid riid) {
            unsafe {
                SharpDX.Direct3D12.Heap vHeapOut;
                IntPtr vHeapOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, descRef_, &riid, &vHeapOut_,((void**)(*(void**)_nativePointer))[28]);		
                vHeapOut= (vHeapOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D12.Heap(vHeapOut_);	
                __result__.CheckError();
                return vHeapOut;
            }
        }
        
        /// <summary>	
        /// <p> Creates a resource that is placed in a specific heap. Placed resources are the lightest weight resource objects available, and are the fastest to create and destroy. </p>	
        /// </summary>	
        /// <param name="heapRef"><dd>  <p> A reference to the <strong><see cref="SharpDX.Direct3D12.Heap"/></strong> interface that represents the heap in which the resource is placed. </p> </dd></param>	
        /// <param name="heapOffset"><dd>  <p> The offset, in bytes, to the resource. The <em>HeapOffset</em> must be a multiple of the resource's alignment, and <em>HeapOffset</em> plus the resource size must be smaller than or equal to the heap size. <strong>GetResourceAllocationInfo</strong> must be used to understand the sizes of texture resources. </p> </dd></param>	
        /// <param name="descRef"><dd>  <p> A reference to a <strong><see cref="SharpDX.Direct3D12.ResourceDescription"/></strong> structure that describes the resource. </p> </dd></param>	
        /// <param name="initialState"><dd>  <p> The initial state of the resource, as a bitwise-OR'd combination of <strong><see cref="SharpDX.Direct3D12.ResourceStates"/></strong> enumeration constants. </p> <p> When a resource is created together with a <see cref="SharpDX.Direct3D12.HeapType.Upload"/> heap, <em>InitialState</em> must be <see cref="SharpDX.Direct3D12.ResourceStates.GenericRead"/>. When a resource is created together with a <see cref="SharpDX.Direct3D12.HeapType.Readback"/> heap, <em>InitialState</em> must be <see cref="SharpDX.Direct3D12.ResourceStates.CopyDestination"/>. </p> </dd></param>	
        /// <param name="optimizedClearValueRef"><dd>  <p> Specifies a <strong><see cref="SharpDX.Direct3D12.ClearValue"/></strong> that describes the default value for a clear color. </p> <p><em>pOptimizedClearValue</em> specifies a value for which clear operations are most optimal. When the created resource is a texture with either the <see cref="SharpDX.Direct3D12.ResourceFlags.AllowRenderTarget"/> or <see cref="SharpDX.Direct3D12.ResourceFlags.AllowDepthStencil"/> flags, applications should choose the value that the clear operation will most commonly be called with. Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the one passed into resource creation. <em>pOptimizedClearValue</em> must be <c>null</c> when used with <see cref="SharpDX.Direct3D12.ResourceDimension.Buffer"/>. </p> </dd></param>	
        /// <param name="riid"><dd>  <p> The globally unique identifier (<strong><see cref="System.Guid"/></strong>) for the resource interface. This is an input parameter. </p> <p> The <strong>REFIID</strong>, or <strong><see cref="System.Guid"/></strong>, of the interface to the resource can be obtained by using the __uuidof() macro. For example, __uuidof(<strong><see cref="SharpDX.Direct3D12.Resource"/></strong>) will get the <strong><see cref="System.Guid"/></strong> of the interface to a resource. Although <strong>riid</strong> is, most commonly, the <see cref="System.Guid"/> for <strong><see cref="SharpDX.Direct3D12.Resource"/></strong>, it may be any <see cref="System.Guid"/> for any interface.  If the resource object doesn't support the interface for this <see cref="System.Guid"/>, creation will fail with E_NOINTERFACE. </p> </dd></param>	
        /// <returns><dd>  <p> A reference to a memory block that receives a reference to the resource. <em>ppvResource</em> can be <c>null</c>, to enable capability testing.  When <em>ppvResource</em> is <c>null</c>, no object will be created and S_FALSE will be returned when <em>pResourceDesc</em> and other parameters are valid. </p> </dd></returns>	
        /// <remarks>	
        /// <p><strong>CreatePlacedResource</strong> is similar to fully mapping a reserved resource to an offset within a heap; but the virtual address space associated with a heap may be reused as well. </p><p> Placed resources are lighter weight than committed resources to create and destroy, because no heap is created or destroyed during this operation.  However, placed resources enable an even lighter weight technique to reuse memory than resource creation and destruction: reuse through aliasing and aliasing barriers. Multiple placed resources may simultaneously overlap each other on the same heap, but only a single overlapping resource can be used at a time. </p><p> There are two placed resource usage semantics, a simple model and an advanced model. The simple model is recommended, and is the most likely model for tool support, until the advanced model is proven to be required by the app. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreatePlacedResource']/*"/>	
        /// <msdn-id>dn899180</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::CreatePlacedResource([In] ID3D12Heap* pHeap,[In] unsigned longlong HeapOffset,[In] const D3D12_RESOURCE_DESC* pDesc,[In] D3D12_RESOURCE_STATES InitialState,[In, Optional] const D3D12_CLEAR_VALUE* pOptimizedClearValue,[In] const GUID&amp; riid,[Out] ID3D12Resource** ppvResource)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreatePlacedResource</unmanaged-short>	
        private SharpDX.Direct3D12.Resource CreatePlacedResource(SharpDX.Direct3D12.Heap heapRef, long heapOffset, ref SharpDX.Direct3D12.ResourceDescription descRef, SharpDX.Direct3D12.ResourceStates initialState, SharpDX.Direct3D12.ClearValue? optimizedClearValueRef, System.Guid riid) {
            unsafe {
                SharpDX.Direct3D12.ClearValue optimizedClearValueRef_;
                if (optimizedClearValueRef.HasValue)
                    optimizedClearValueRef_ = optimizedClearValueRef.Value;				
                SharpDX.Direct3D12.Resource vResourceOut;
                IntPtr vResourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, (void*)((heapRef == null)?IntPtr.Zero:heapRef.NativePointer), heapOffset, descRef_, unchecked((int)initialState), (optimizedClearValueRef.HasValue)?&optimizedClearValueRef_:(void*)IntPtr.Zero, &riid, &vResourceOut_,((void**)(*(void**)_nativePointer))[29]);		
                vResourceOut= (vResourceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D12.Resource(vResourceOut_);	
                __result__.CheckError();
                return vResourceOut;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="descRef">No documentation.</param>	
        /// <param name="initialState">No documentation.</param>	
        /// <param name="optimizedClearValueRef">No documentation.</param>	
        /// <param name="riid">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateReservedResource']/*"/>	
        /// <unmanaged>HRESULT ID3D12Device::CreateReservedResource([In] const D3D12_RESOURCE_DESC* pDesc,[In] D3D12_RESOURCE_STATES InitialState,[In, Optional] const D3D12_CLEAR_VALUE* pOptimizedClearValue,[In] const GUID&amp; riid,[Out] ID3D12Resource** ppvResource)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateReservedResource</unmanaged-short>	
        private SharpDX.Direct3D12.Resource CreateReservedResource(ref SharpDX.Direct3D12.ResourceDescription descRef, SharpDX.Direct3D12.ResourceStates initialState, SharpDX.Direct3D12.ClearValue? optimizedClearValueRef, System.Guid riid) {
            unsafe {
                SharpDX.Direct3D12.ClearValue optimizedClearValueRef_;
                if (optimizedClearValueRef.HasValue)
                    optimizedClearValueRef_ = optimizedClearValueRef.Value;				
                SharpDX.Direct3D12.Resource vResourceOut;
                IntPtr vResourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, descRef_, unchecked((int)initialState), (optimizedClearValueRef.HasValue)?&optimizedClearValueRef_:(void*)IntPtr.Zero, &riid, &vResourceOut_,((void**)(*(void**)_nativePointer))[30]);		
                vResourceOut= (vResourceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D12.Resource(vResourceOut_);	
                __result__.CheckError();
                return vResourceOut;
            }
        }
        
        /// <summary>	
        /// <p> Creates a shared handle to an heap, resource, or fence object. </p>	
        /// </summary>	
        /// <param name="objectRef"><dd>  <p> A reference to the <strong><see cref="SharpDX.Direct3D12.DeviceChild"/></strong> interface that represents the heap, resource, or fence object to create for sharing. The following interfaces (derived from <strong><see cref="SharpDX.Direct3D12.DeviceChild"/></strong>) are supported: </p> <ul> <li> <strong><see cref="SharpDX.Direct3D12.Heap"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D12.Fence"/></strong> </li> </ul> </dd></param>	
        /// <param name="attributesRef"><dd>  <p> A reference to a <strong><see cref="SharpDX.Win32.SecurityAttributes"/></strong> structure that contains two separate but related data members: an optional security descriptor, and a <strong>Boolean</strong> value that determines whether child processes can inherit the returned handle. </p> <p> Set this parameter to <strong><c>null</c></strong> if you want child processes that the application might create to not  inherit  the handle returned by <strong>CreateSharedHandle</strong>, and if you want the resource that is associated with the returned handle to get a default security descriptor. </p> <p> The <strong>lpSecurityDescriptor</strong> member of the structure specifies a <strong>SECURITY_DESCRIPTOR</strong> for the resource. Set this member to <strong><c>null</c></strong> if you want the runtime to assign a default security descriptor to the resource that is associated with the returned handle. The ACLs in the default security descriptor for the resource come from the primary or impersonation token of the creator. For more info, see Synchronization Object Security and Access Rights. </p> </dd></param>	
        /// <param name="access"><dd>  <p>Currently the only value this parameter accepts is GENERIC_ALL.</p> </dd></param>	
        /// <param name="name"><dd>  <p> A <strong><c>null</c></strong>-terminated <strong>UNICODE</strong> string that contains the name to associate with the shared heap. The name is limited to MAX_PATH characters. Name comparison is case-sensitive. </p> <p> If <em>Name</em> matches the name of an existing resource, <strong>CreateSharedHandle</strong> fails with <see cref="SharpDX.DXGI.ResultCode.NameAlreadyExists"/>. This occurs because these objects share the same namespace. </p> <p> The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users. </p> <p> The object can be created in a private namespace. For more information, see Object Namespaces. </p> </dd></param>	
        /// <param name="handleRef"><dd>  <p> A reference to a variable that receives the NT HANDLE value to the resource to share. You can use this handle in calls to access the resource. </p> </dd></param>	
        /// <returns><p> Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise, returns one of the following values: </p><ul> <li><see cref="SharpDX.DXGI.ResultCode.InvalidCall"/> if one of the parameters is invalid. </li> <li><see cref="SharpDX.DXGI.ResultCode.NameAlreadyExists"/> if the supplied name of the resource to share is already associated with another resource. </li> <li>E_ACCESSDENIED if the object is being created in a protected namespace.</li> <li>E_OUTOFMEMORY if sufficient memory is not available to create the handle.</li> <li> Possibly other error codes that are described in the Direct3D 12 Return Codes topic. </li> </ul></returns>	
        /// <remarks>	
        /// <p> Both heaps and committed resources can be shared. Sharing a committed resource shares the implicit heap along with the committed resource description, such that a compatible resource description can be mapped to the heap from another device.  </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateSharedHandle']/*"/>	
        /// <msdn-id>dn899183</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::CreateSharedHandle([In] ID3D12DeviceChild* pObject,[In, Optional] const SECURITY_ATTRIBUTES* pAttributes,[In] unsigned int Access,[In, Optional] const wchar_t* Name,[Out] void** pHandle)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateSharedHandle</unmanaged-short>	
        internal void CreateSharedHandle(SharpDX.Direct3D12.DeviceChild objectRef, SharpDX.Win32.SecurityAttributes? attributesRef, int access, string name, out System.IntPtr handleRef) {
            unsafe {
                SharpDX.Win32.SecurityAttributes attributesRef_;
                if (attributesRef.HasValue)
                    attributesRef_ = attributesRef.Value;				
                IntPtr name_ = Utilities.StringToHGlobalUni(name);
                SharpDX.Result __result__;
                fixed (void* handleRef_ = &handleRef)
                    __result__= 
    				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, (void*)((objectRef == null)?IntPtr.Zero:objectRef.NativePointer), (attributesRef.HasValue)?&attributesRef_:(void*)IntPtr.Zero, access, (void*)name_, handleRef_,((void**)(*(void**)_nativePointer))[31]);		
                Marshal.FreeHGlobal(name_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Opens a handle for shared resources, shared heaps, and shared fences, by using HANDLE and REFIID. </p>	
        /// </summary>	
        /// <param name="nTHandle"><dd>  <p> The handle that was output by the call to  <strong><see cref="SharpDX.Direct3D12.Device.CreateSharedHandle"/></strong>. </p> </dd></param>	
        /// <param name="riid"><dd>  <p> The globally unique identifier (<strong><see cref="System.Guid"/></strong>) for one of the following interfaces: </p> <ul> <li> <strong><see cref="SharpDX.Direct3D12.Heap"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D12.Fence"/></strong> </li> </ul> <p> The <strong>REFIID</strong>, or <strong><see cref="System.Guid"/></strong>, of the interface can be obtained by using the __uuidof() macro. For example, __uuidof(<see cref="SharpDX.Direct3D12.Heap"/>) will get the <strong><see cref="System.Guid"/></strong> of the interface to a resource. </p> </dd></param>	
        /// <param name="vObjOut"><dd>  <p> A reference to a memory block that receives a reference to one of the following interfaces: </p> <ul> <li> <strong><see cref="SharpDX.Direct3D12.Heap"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D12.Fence"/></strong> </li> </ul> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::OpenSharedHandle']/*"/>	
        /// <msdn-id>dn903831</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::OpenSharedHandle([In] void* NTHandle,[In] const GUID&amp; riid,[Out, Optional] void** ppvObj)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::OpenSharedHandle</unmanaged-short>	
        public void OpenSharedHandle(System.IntPtr nTHandle, System.Guid riid, out System.IntPtr vObjOut) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* vObjOut_ = &vObjOut)
                    __result__= 
    				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, (void*)nTHandle, &riid, vObjOut_,((void**)(*(void**)_nativePointer))[32]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Opens a handle for shared resources, shared heaps, and shared fences, by using Name and Access. </p>	
        /// </summary>	
        /// <param name="name"><dd>  <p> The name that was optionally passed as the <em>Name</em> parameter in the call to  <strong><see cref="SharpDX.Direct3D12.Device.CreateSharedHandle"/></strong>. </p> </dd></param>	
        /// <param name="access"><dd>  <p> The access level that was specified in the <em>Access</em> parameter in the call to  <strong><see cref="SharpDX.Direct3D12.Device.CreateSharedHandle"/></strong>. </p> </dd></param>	
        /// <param name="nTHandleRef"><dd>  <p> Pointer to the shared handle. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::OpenSharedHandleByName']/*"/>	
        /// <msdn-id>dn903832</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::OpenSharedHandleByName([In] const wchar_t* Name,[In] unsigned int Access,[Out] void** pNTHandle)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::OpenSharedHandleByName</unmanaged-short>	
        public void OpenSharedHandleByName(string name, int access, out System.IntPtr nTHandleRef) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalUni(name);
                SharpDX.Result __result__;
                fixed (void* nTHandleRef_ = &nTHandleRef)
                    __result__= 
    				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, (void*)name_, access, nTHandleRef_,((void**)(*(void**)_nativePointer))[33]);		
                Marshal.FreeHGlobal(name_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Makes objects resident for the device.</p>	
        /// </summary>	
        /// <param name="numObjects"><dd>  <p> The number of objects  in the <em>ppObjects</em> array to make resident for the device. </p> </dd></param>	
        /// <param name="objectsOut"><dd>  <p>A reference to a memory block that contains an array of <strong><see cref="SharpDX.Direct3D12.Pageable"/></strong> interface references for the objects. </p> <p>Even though most D3D12 objects inherit from <strong><see cref="SharpDX.Direct3D12.Pageable"/></strong>, residency changes are only supported on the following objects:Descriptor Heaps, Heaps, Committed Resources, and Query Heaps</p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p><strong>MakeResident</strong> loads the data associated with a resource from disk, and re-allocates the memory from the resource's appropriate memory pool. This method should be called on the object which owns the physical memory.	
        /// </p><p>Use this method, and <strong>Evict</strong>, to manage GPU video memory, noting that this was done automatically in D3D11, but now has to be done by the app in D3D12.</p><p><strong>MakeResident</strong> and <strong>Evict</strong> can help applications manage the residency budget on many adapters. <strong>MakeResident</strong> explicitly pages-in data and, then, precludes page-out so the GPU can access the data. <strong>Evict</strong> enables page-out.</p><p>Some GPU architectures do not benefit from residency manipulation, due to the lack of sufficient GPU virtual address space. Use <strong><see cref="SharpDX.Direct3D12.FeatureDataGpuVirtualAddressSupport"/></strong> and <strong><see cref="SharpDX.DXGI.Adapter3.QueryVideoMemoryInfo"/></strong> to recognize when the maximum GPU VA space per-process is too small or roughly the same size as the residency budget. For such architectures, the residency budget will always be constrained by the amount of GPU virtual address space. <strong>Evict</strong> will not free-up any residency budget on such systems.	
        /// </p><p>Applications must handle <strong>MakeResident</strong> failures, even if there appears to be enough residency budget available. Physical memory fragmentation and adapter architecture quirks can preclude the utilization of large contiguous ranges. Applications should free up more residency budget before trying again.	
        /// </p><p><strong>MakeResident</strong> is ref-counted, such that <strong>Evict</strong> must be called the same amount of times as <strong>MakeResident</strong> before <strong>Evict</strong> takes effect. Objects that support residency are made resident during creation, so a single <strong>Evict</strong> call will actually evict the object. </p><p>Applications must use fences to ensure the GPU doesn't use non-resident objects. <strong>MakeResident</strong> must return before the GPU executes a command list that references the object. <strong>Evict</strong> must be called after the GPU finishes executing a command list that references the object.</p><p>Evicted objects still consume the same GPU virtual address and same amount of GPU virtual address space. Therefore, resource descriptors and other GPU virtual address references are not invalidated after <strong>Evict</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::MakeResident']/*"/>	
        /// <msdn-id>dn788682</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::MakeResident([In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::MakeResident</unmanaged-short>	
        public void MakeResident(int numObjects, SharpDX.Direct3D12.Pageable[] objectsOut) {
            unsafe {
                IntPtr* objectsOut_ = (IntPtr*)0;
                if ( objectsOut != null ) {
                    IntPtr* objectsOut__ = stackalloc IntPtr[objectsOut.Length];
                    objectsOut_ = objectsOut__;
                    for (int i = 0; i < objectsOut.Length; i++)                        
                        objectsOut_[i] =  (objectsOut[i] == null)? IntPtr.Zero : objectsOut[i].NativePointer;
                }
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, numObjects, objectsOut_,((void**)(*(void**)_nativePointer))[34]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Makes objects resident for the device.</p>	
        /// </summary>	
        /// <param name="numObjects"><dd>  <p> The number of objects  in the <em>ppObjects</em> array to make resident for the device. </p> </dd></param>	
        /// <param name="objectsOut"><dd>  <p>A reference to a memory block that contains an array of <strong><see cref="SharpDX.Direct3D12.Pageable"/></strong> interface references for the objects. </p> <p>Even though most D3D12 objects inherit from <strong><see cref="SharpDX.Direct3D12.Pageable"/></strong>, residency changes are only supported on the following objects:Descriptor Heaps, Heaps, Committed Resources, and Query Heaps</p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p><strong>MakeResident</strong> loads the data associated with a resource from disk, and re-allocates the memory from the resource's appropriate memory pool. This method should be called on the object which owns the physical memory.	
        /// </p><p>Use this method, and <strong>Evict</strong>, to manage GPU video memory, noting that this was done automatically in D3D11, but now has to be done by the app in D3D12.</p><p><strong>MakeResident</strong> and <strong>Evict</strong> can help applications manage the residency budget on many adapters. <strong>MakeResident</strong> explicitly pages-in data and, then, precludes page-out so the GPU can access the data. <strong>Evict</strong> enables page-out.</p><p>Some GPU architectures do not benefit from residency manipulation, due to the lack of sufficient GPU virtual address space. Use <strong><see cref="SharpDX.Direct3D12.FeatureDataGpuVirtualAddressSupport"/></strong> and <strong><see cref="SharpDX.DXGI.Adapter3.QueryVideoMemoryInfo"/></strong> to recognize when the maximum GPU VA space per-process is too small or roughly the same size as the residency budget. For such architectures, the residency budget will always be constrained by the amount of GPU virtual address space. <strong>Evict</strong> will not free-up any residency budget on such systems.	
        /// </p><p>Applications must handle <strong>MakeResident</strong> failures, even if there appears to be enough residency budget available. Physical memory fragmentation and adapter architecture quirks can preclude the utilization of large contiguous ranges. Applications should free up more residency budget before trying again.	
        /// </p><p><strong>MakeResident</strong> is ref-counted, such that <strong>Evict</strong> must be called the same amount of times as <strong>MakeResident</strong> before <strong>Evict</strong> takes effect. Objects that support residency are made resident during creation, so a single <strong>Evict</strong> call will actually evict the object. </p><p>Applications must use fences to ensure the GPU doesn't use non-resident objects. <strong>MakeResident</strong> must return before the GPU executes a command list that references the object. <strong>Evict</strong> must be called after the GPU finishes executing a command list that references the object.</p><p>Evicted objects still consume the same GPU virtual address and same amount of GPU virtual address space. Therefore, resource descriptors and other GPU virtual address references are not invalidated after <strong>Evict</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::MakeResident']/*"/>	
        /// <msdn-id>dn788682</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::MakeResident([In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::MakeResident</unmanaged-short>	
        public void MakeResident(int numObjects, SharpDX.ComArray<SharpDX.Direct3D12.Pageable> objectsOut) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, numObjects, (void*)((objectsOut == null)?IntPtr.Zero:objectsOut.NativePointer),((void**)(*(void**)_nativePointer))[34]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Makes objects resident for the device.</p>	
        /// </summary>	
        /// <param name="numObjects"><dd>  <p> The number of objects  in the <em>ppObjects</em> array to make resident for the device. </p> </dd></param>	
        /// <param name="objectsOut"><dd>  <p>A reference to a memory block that contains an array of <strong><see cref="SharpDX.Direct3D12.Pageable"/></strong> interface references for the objects. </p> <p>Even though most D3D12 objects inherit from <strong><see cref="SharpDX.Direct3D12.Pageable"/></strong>, residency changes are only supported on the following objects:Descriptor Heaps, Heaps, Committed Resources, and Query Heaps</p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p><strong>MakeResident</strong> loads the data associated with a resource from disk, and re-allocates the memory from the resource's appropriate memory pool. This method should be called on the object which owns the physical memory.	
        /// </p><p>Use this method, and <strong>Evict</strong>, to manage GPU video memory, noting that this was done automatically in D3D11, but now has to be done by the app in D3D12.</p><p><strong>MakeResident</strong> and <strong>Evict</strong> can help applications manage the residency budget on many adapters. <strong>MakeResident</strong> explicitly pages-in data and, then, precludes page-out so the GPU can access the data. <strong>Evict</strong> enables page-out.</p><p>Some GPU architectures do not benefit from residency manipulation, due to the lack of sufficient GPU virtual address space. Use <strong><see cref="SharpDX.Direct3D12.FeatureDataGpuVirtualAddressSupport"/></strong> and <strong><see cref="SharpDX.DXGI.Adapter3.QueryVideoMemoryInfo"/></strong> to recognize when the maximum GPU VA space per-process is too small or roughly the same size as the residency budget. For such architectures, the residency budget will always be constrained by the amount of GPU virtual address space. <strong>Evict</strong> will not free-up any residency budget on such systems.	
        /// </p><p>Applications must handle <strong>MakeResident</strong> failures, even if there appears to be enough residency budget available. Physical memory fragmentation and adapter architecture quirks can preclude the utilization of large contiguous ranges. Applications should free up more residency budget before trying again.	
        /// </p><p><strong>MakeResident</strong> is ref-counted, such that <strong>Evict</strong> must be called the same amount of times as <strong>MakeResident</strong> before <strong>Evict</strong> takes effect. Objects that support residency are made resident during creation, so a single <strong>Evict</strong> call will actually evict the object. </p><p>Applications must use fences to ensure the GPU doesn't use non-resident objects. <strong>MakeResident</strong> must return before the GPU executes a command list that references the object. <strong>Evict</strong> must be called after the GPU finishes executing a command list that references the object.</p><p>Evicted objects still consume the same GPU virtual address and same amount of GPU virtual address space. Therefore, resource descriptors and other GPU virtual address references are not invalidated after <strong>Evict</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::MakeResident']/*"/>	
        /// <msdn-id>dn788682</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::MakeResident([In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::MakeResident</unmanaged-short>	
        private void MakeResident(int numObjects, System.IntPtr objectsOut) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, numObjects, (void*)objectsOut,((void**)(*(void**)_nativePointer))[34]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p><strong>Evict</strong> enables the page-out of data, which precludes GPU access of that data.</p>	
        /// </summary>	
        /// <param name="numObjects"><dd>  <p> The number of objects in the <em>ppObjects</em> array to evict from the device. </p> </dd></param>	
        /// <param name="objectsOut"><dd>  <p> A reference to a memory block that contains an array of <strong><see cref="SharpDX.Direct3D12.Pageable"/></strong> interface references for the objects. </p> <p>Even though most D3D12 objects inherit from <strong><see cref="SharpDX.Direct3D12.Pageable"/></strong>, residency changes are only supported on the following objects:Descriptor Heaps, Heaps, Committed Resources, and Query Heaps</p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p><strong>Evict</strong> persists the data associated with a resource to disk, and then removes the resource from the memory pool where it was located. This method should be called on the object which owns the physical memory: either a committed resource (which owns both virtual  and physical memory assignments) or a heap - noting that reserved resources do not have physical memory, and placed resources are borrowing memory from a heap.	
        /// </p><p>Refer to the remarks for <strong>MakeResident</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::Evict']/*"/>	
        /// <msdn-id>dn788676</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::Evict([In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::Evict</unmanaged-short>	
        public void Evict(int numObjects, SharpDX.Direct3D12.Pageable[] objectsOut) {
            unsafe {
                IntPtr* objectsOut_ = (IntPtr*)0;
                if ( objectsOut != null ) {
                    IntPtr* objectsOut__ = stackalloc IntPtr[objectsOut.Length];
                    objectsOut_ = objectsOut__;
                    for (int i = 0; i < objectsOut.Length; i++)                        
                        objectsOut_[i] =  (objectsOut[i] == null)? IntPtr.Zero : objectsOut[i].NativePointer;
                }
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, numObjects, objectsOut_,((void**)(*(void**)_nativePointer))[35]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p><strong>Evict</strong> enables the page-out of data, which precludes GPU access of that data.</p>	
        /// </summary>	
        /// <param name="numObjects"><dd>  <p> The number of objects in the <em>ppObjects</em> array to evict from the device. </p> </dd></param>	
        /// <param name="objectsOut"><dd>  <p> A reference to a memory block that contains an array of <strong><see cref="SharpDX.Direct3D12.Pageable"/></strong> interface references for the objects. </p> <p>Even though most D3D12 objects inherit from <strong><see cref="SharpDX.Direct3D12.Pageable"/></strong>, residency changes are only supported on the following objects:Descriptor Heaps, Heaps, Committed Resources, and Query Heaps</p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p><strong>Evict</strong> persists the data associated with a resource to disk, and then removes the resource from the memory pool where it was located. This method should be called on the object which owns the physical memory: either a committed resource (which owns both virtual  and physical memory assignments) or a heap - noting that reserved resources do not have physical memory, and placed resources are borrowing memory from a heap.	
        /// </p><p>Refer to the remarks for <strong>MakeResident</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::Evict']/*"/>	
        /// <msdn-id>dn788676</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::Evict([In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::Evict</unmanaged-short>	
        public void Evict(int numObjects, SharpDX.ComArray<SharpDX.Direct3D12.Pageable> objectsOut) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, numObjects, (void*)((objectsOut == null)?IntPtr.Zero:objectsOut.NativePointer),((void**)(*(void**)_nativePointer))[35]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p><strong>Evict</strong> enables the page-out of data, which precludes GPU access of that data.</p>	
        /// </summary>	
        /// <param name="numObjects"><dd>  <p> The number of objects in the <em>ppObjects</em> array to evict from the device. </p> </dd></param>	
        /// <param name="objectsOut"><dd>  <p> A reference to a memory block that contains an array of <strong><see cref="SharpDX.Direct3D12.Pageable"/></strong> interface references for the objects. </p> <p>Even though most D3D12 objects inherit from <strong><see cref="SharpDX.Direct3D12.Pageable"/></strong>, residency changes are only supported on the following objects:Descriptor Heaps, Heaps, Committed Resources, and Query Heaps</p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p><strong>Evict</strong> persists the data associated with a resource to disk, and then removes the resource from the memory pool where it was located. This method should be called on the object which owns the physical memory: either a committed resource (which owns both virtual  and physical memory assignments) or a heap - noting that reserved resources do not have physical memory, and placed resources are borrowing memory from a heap.	
        /// </p><p>Refer to the remarks for <strong>MakeResident</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::Evict']/*"/>	
        /// <msdn-id>dn788676</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::Evict([In] unsigned int NumObjects,[In, Buffer] const ID3D12Pageable** ppObjects)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::Evict</unmanaged-short>	
        private void Evict(int numObjects, System.IntPtr objectsOut) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, numObjects, (void*)objectsOut,((void**)(*(void**)_nativePointer))[35]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="initialValue">No documentation.</param>	
        /// <param name="flags">No documentation.</param>	
        /// <param name="riid">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateFence']/*"/>	
        /// <unmanaged>HRESULT ID3D12Device::CreateFence([In] unsigned longlong InitialValue,[In] D3D12_FENCE_FLAGS Flags,[In] const GUID&amp; riid,[Out] ID3D12Fence** ppFence)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateFence</unmanaged-short>	
        private SharpDX.Direct3D12.Fence CreateFence(long initialValue, SharpDX.Direct3D12.FenceFlags flags, System.Guid riid) {
            unsafe {
                SharpDX.Direct3D12.Fence fenceOut;
                IntPtr fenceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, initialValue, unchecked((int)flags), &riid, &fenceOut_,((void**)(*(void**)_nativePointer))[36]);		
                fenceOut= (fenceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D12.Fence(fenceOut_);	
                __result__.CheckError();
                return fenceOut;
            }
        }
        
        /// <summary>	
        /// <p>Gets the reason that the device was removed.</p>	
        /// </summary>	
        /// <returns><p>This method returns the reason that the device was removed.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::GetDeviceRemovedReason']/*"/>	
        /// <msdn-id>dn899187</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::GetDeviceRemovedReason()</unmanaged>	
        /// <unmanaged-short>ID3D12Device::GetDeviceRemovedReason</unmanaged-short>	
        internal SharpDX.Result GetDeviceRemovedReason() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[37]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Gets a resource layout that can be copied. Helps the app fill-in  <strong><see cref="SharpDX.Direct3D12.PlacedSubResourceFootprint"/></strong> and  <strong><see cref="SharpDX.Direct3D12.SubResourceFootprint"/></strong> when suballocating space in upload heaps. </p>	
        /// </summary>	
        /// <param name="resourceDescRef">No documentation.</param>	
        /// <param name="firstSubresource">No documentation.</param>	
        /// <param name="numSubresources">No documentation.</param>	
        /// <param name="baseOffset">No documentation.</param>	
        /// <param name="layoutsRef">No documentation.</param>	
        /// <param name="numRowsRef">No documentation.</param>	
        /// <param name="rowSizeInBytesRef">No documentation.</param>	
        /// <param name="totalBytesRef">No documentation.</param>	
        /// <remarks>	
        /// <p> This routine assists the application in filling out <strong><see cref="SharpDX.Direct3D12.PlacedSubResourceFootprint"/></strong> and <strong><see cref="SharpDX.Direct3D12.SubResourceFootprint"/></strong> structures, when suballocating space in upload heaps. The resulting structures are GPU adapter-agnostic, meaning that the values will not vary from one GPU adapter to the next. <strong>GetCopyableFootprints</strong> uses specified details about resource formats, texture layouts, and alignment requirements (from the <strong><see cref="SharpDX.Direct3D12.ResourceDescription"/></strong> structure)  to fill out the subresource structures. Applications have access to all these details, so this method, or a variation of it, could be  written as part of the app. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::GetCopyableFootprints']/*"/>	
        /// <msdn-id>dn986878</msdn-id>	
        /// <unmanaged>void ID3D12Device::GetCopyableFootprints([In] const D3D12_RESOURCE_DESC* pResourceDesc,[In] unsigned int FirstSubresource,[In] unsigned int NumSubresources,[In] unsigned longlong BaseOffset,[Out, Buffer, Optional] D3D12_PLACED_SUBRESOURCE_FOOTPRINT* pLayouts,[Out, Buffer, Optional] unsigned int* pNumRows,[Out, Buffer, Optional] unsigned longlong* pRowSizeInBytes,[Out, Optional] unsigned longlong* pTotalBytes)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::GetCopyableFootprints</unmanaged-short>	
        public void GetCopyableFootprints(ref SharpDX.Direct3D12.ResourceDescription resourceDescRef, int firstSubresource, int numSubresources, long baseOffset, SharpDX.Direct3D12.PlacedSubResourceFootprint[] layoutsRef, int[] numRowsRef, long[] rowSizeInBytesRef, out long totalBytesRef) {
            unsafe {
                SharpDX.Direct3D12.PlacedSubResourceFootprint[] layoutsRef__ = layoutsRef;
                int[] numRowsRef__ = numRowsRef;
                long[] rowSizeInBytesRef__ = rowSizeInBytesRef;
                fixed (void* resourceDescRef_ = &resourceDescRef)
                    fixed (void* layoutsRef_ = layoutsRef__)
                        fixed (void* numRowsRef_ = numRowsRef__)
                            fixed (void* rowSizeInBytesRef_ = rowSizeInBytesRef__)
                                fixed (void* totalBytesRef_ = &totalBytesRef)
                                    SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, resourceDescRef_, firstSubresource, numSubresources, baseOffset, layoutsRef_, numRowsRef_, rowSizeInBytesRef_, totalBytesRef_,((void**)(*(void**)_nativePointer))[38]);		
            }
        }
        
        /// <summary>	
        /// <p> Creates a query heap. A query heap contains an array of queries. </p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p> Specifies the query heap in a <strong><see cref="SharpDX.Direct3D12.QueryHeapDescription"/></strong> structure. </p> </dd></param>	
        /// <param name="riid"><dd>  <p> Specifies a REFIID that uniquely identifies the heap. </p> </dd></param>	
        /// <returns><dd>  <p> Specifies a reference to the heap, that will be returned on successful completion of the method. <em>ppvHeap</em> can be <c>null</c>, to enable capability testing. When <em>ppvHeap</em> is <c>null</c>, no object will be created and S_FALSE will be returned when <em>pDesc</em> is valid. </p> </dd></returns>	
        /// <remarks>	
        /// <p> Refer to Queries for more information. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateQueryHeap']/*"/>	
        /// <msdn-id>dn903828</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::CreateQueryHeap([In] const D3D12_QUERY_HEAP_DESC* pDesc,[In] const GUID&amp; riid,[Out] ID3D12QueryHeap** ppvHeap)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateQueryHeap</unmanaged-short>	
        private SharpDX.Direct3D12.QueryHeap CreateQueryHeap(SharpDX.Direct3D12.QueryHeapDescription descRef, System.Guid riid) {
            unsafe {
                SharpDX.Direct3D12.QueryHeap vHeapOut;
                IntPtr vHeapOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, &descRef, &riid, &vHeapOut_,((void**)(*(void**)_nativePointer))[39]);		
                vHeapOut= (vHeapOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D12.QueryHeap(vHeapOut_);	
                __result__.CheckError();
                return vHeapOut;
            }
        }
        
        /// <summary>	
        /// <p>This method ensures the GPU timestamp counter does not stop ticking during idle periods.</p>	
        /// </summary>	
        /// <param name="enable"><dd>  <p>Specifies a <see cref="SharpDX.Mathematics.Interop.RawBool"/> that turns the stable power state on or off.</p> </dd></param>	
        /// <returns><p>This method returns one of the Direct3D 12 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>For more information on high definition performance measurement, refer to Timing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::SetStablePowerState']/*"/>	
        /// <msdn-id>dn903835</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::SetStablePowerState([In] BOOL Enable)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::SetStablePowerState</unmanaged-short>	
        internal void SetStablePowerState(SharpDX.Mathematics.Interop.RawBool enable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint25(_nativePointer, enable,((void**)(*(void**)_nativePointer))[40]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> This method creates a command signature. </p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p> Describes the command signature to be created with the <strong><see cref="SharpDX.Direct3D12.CommandSignatureDescription"/></strong> structure. </p> </dd></param>	
        /// <param name="rootSignatureRef"><dd>  <p> Specifies the  <strong><see cref="SharpDX.Direct3D12.RootSignature"/></strong> that the command signature applies to. </p> </dd></param>	
        /// <param name="riid"><dd>  <p> The globally unique identifier (<strong><see cref="System.Guid"/></strong>) for the command signature interface (<strong><see cref="SharpDX.Direct3D12.CommandSignature"/></strong>). The <strong>REFIID</strong>, or <strong><see cref="System.Guid"/></strong>, of the interface to the command signature can be obtained by using the __uuidof() macro. For example, __uuidof(<strong><see cref="SharpDX.Direct3D12.CommandSignature"/></strong>) will get the <strong><see cref="System.Guid"/></strong> of the interface to a command signature. </p> </dd></param>	
        /// <returns><dd>  <p> Specifies a reference, that on successful completion of the method will point to the created command signature (<strong><see cref="SharpDX.Direct3D12.CommandSignature"/></strong>). </p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::CreateCommandSignature']/*"/>	
        /// <msdn-id>dn903827</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Device::CreateCommandSignature([In] const void* pDesc,[In, Optional] ID3D12RootSignature* pRootSignature,[In] const GUID&amp; riid,[Out] ID3D12CommandSignature** ppvCommandSignature)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::CreateCommandSignature</unmanaged-short>	
        private SharpDX.Direct3D12.CommandSignature CreateCommandSignature(System.IntPtr descRef, SharpDX.Direct3D12.RootSignature rootSignatureRef, System.Guid riid) {
            unsafe {
                SharpDX.Direct3D12.CommandSignature vCommandSignatureOut;
                IntPtr vCommandSignatureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, (void*)descRef, (void*)((rootSignatureRef == null)?IntPtr.Zero:rootSignatureRef.NativePointer), &riid, &vCommandSignatureOut_,((void**)(*(void**)_nativePointer))[41]);		
                vCommandSignatureOut= (vCommandSignatureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D12.CommandSignature(vCommandSignatureOut_);	
                __result__.CheckError();
                return vCommandSignatureOut;
            }
        }
        
        /// <summary>	
        /// <p> Gets info about how a tiled resource is broken into tiles. </p>	
        /// </summary>	
        /// <param name="tiledResourceRef"><dd>  <p> Specifies a tiled <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> to get info about. </p> </dd></param>	
        /// <param name="numTilesForEntireResourceRef"><dd>  <p> A reference to a variable that receives the number of tiles needed to store the entire tiled resource. </p> </dd></param>	
        /// <param name="packedMipDescRef"><dd>  <p> A reference to a <strong><see cref="SharpDX.Direct3D12.PackedMipInformation"/></strong> structure that <strong>GetResourceTiling</strong> fills with info about how the tiled resource's mipmaps are packed. </p> </dd></param>	
        /// <param name="standardTileShapeForNonPackedMipsRef"><dd>  <p> Specifies a <strong><see cref="SharpDX.Direct3D12.TileShape"/></strong> structure that <strong>GetResourceTiling</strong> fills with info about the tile shape. This is info about how pixels fit in the tiles, independent of tiled resource's dimensions, not including packed mipmaps. If the entire tiled resource is packed, this parameter is meaningless because the tiled resource has no defined layout for packed mipmaps. In this situation, <strong>GetResourceTiling</strong> sets the members of <see cref="SharpDX.Direct3D12.TileShape"/> to zeros. </p> </dd></param>	
        /// <param name="numSubresourceTilingsRef"><dd>  <p> A reference to a variable that contains the number of tiles in the subresource. On input, this is the number of subresources to query tilings for; on output, this is the number that was actually retrieved at <em>pSubresourceTilingsForNonPackedMips</em> (clamped to what's available). </p> </dd></param>	
        /// <param name="firstSubresourceTilingToGet"><dd>  <p> The number of the first subresource tile to get. <strong>GetResourceTiling</strong> ignores this parameter if the number that <em>pNumSubresourceTilings</em> points to is 0. </p> </dd></param>	
        /// <param name="subresourceTilingsForNonPackedMipsRef"><dd>  <p> Specifies a <strong><see cref="SharpDX.Direct3D12.SubResourceTiling"/></strong> structure that <strong>GetResourceTiling</strong> fills with info about subresource tiles. If subresource tiles are part of packed mipmaps, <strong>GetResourceTiling</strong> sets the members of <see cref="SharpDX.Direct3D12.SubResourceTiling"/> to zeros, except the <em>StartTileIndexInOverallResource</em> member, which <strong>GetResourceTiling</strong> sets to D3D12_PACKED_TILE (0xffffffff). The D3D12_PACKED_TILE constant indicates that the whole <strong><see cref="SharpDX.Direct3D12.SubResourceTiling"/></strong> structure is meaningless for this situation, and the info that the <em>pPackedMipDesc</em> parameter points to applies. </p> </dd></param>	
        /// <remarks>	
        /// <p> To estimate the total resource size of textures needed when calculating heap sizes and calling <strong>CreatePlacedResource</strong>, use <strong>GetResourceAllocationInfo</strong> instead of <strong>GetResourceTiling</strong>. <strong>GetResourceTiling</strong> cannot be used for this. </p><p> For more information on tiled resources, refer to Volume Tiled Resources. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::GetResourceTiling']/*"/>	
        /// <msdn-id>dn903829</msdn-id>	
        /// <unmanaged>void ID3D12Device::GetResourceTiling([In] ID3D12Resource* pTiledResource,[Out, Optional] unsigned int* pNumTilesForEntireResource,[Out, Optional] D3D12_PACKED_MIP_INFO* pPackedMipDesc,[Out, Optional] D3D12_TILE_SHAPE* pStandardTileShapeForNonPackedMips,[InOut, Optional] unsigned int* pNumSubresourceTilings,[In] unsigned int FirstSubresourceTilingToGet,[Out, Buffer] D3D12_SUBRESOURCE_TILING* pSubresourceTilingsForNonPackedMips)</unmanaged>	
        /// <unmanaged-short>ID3D12Device::GetResourceTiling</unmanaged-short>	
        public void GetResourceTiling(SharpDX.Direct3D12.Resource tiledResourceRef, out int numTilesForEntireResourceRef, out SharpDX.Direct3D12.PackedMipInformation packedMipDescRef, out SharpDX.Direct3D12.TileShape standardTileShapeForNonPackedMipsRef, System.IntPtr numSubresourceTilingsRef, int firstSubresourceTilingToGet, SharpDX.Direct3D12.SubResourceTiling[] subresourceTilingsForNonPackedMipsRef) {
            unsafe {
                packedMipDescRef = new SharpDX.Direct3D12.PackedMipInformation();
                standardTileShapeForNonPackedMipsRef = new SharpDX.Direct3D12.TileShape();
                fixed (void* numTilesForEntireResourceRef_ = &numTilesForEntireResourceRef)
                    fixed (void* packedMipDescRef_ = &packedMipDescRef)
                        fixed (void* standardTileShapeForNonPackedMipsRef_ = &standardTileShapeForNonPackedMipsRef)
                            fixed (void* subresourceTilingsForNonPackedMipsRef_ = subresourceTilingsForNonPackedMipsRef)
                                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((tiledResourceRef == null)?IntPtr.Zero:tiledResourceRef.NativePointer), numTilesForEntireResourceRef_, packedMipDescRef_, standardTileShapeForNonPackedMipsRef_, (void*)numSubresourceTilingsRef, firstSubresourceTilingToGet, subresourceTilingsForNonPackedMipsRef_,((void**)(*(void**)_nativePointer))[42]);		
            }
        }
        
        /// <summary>	
        /// <p> Gets a locally unique identifier for the current device (adapter). </p>	
        /// </summary>	
        /// <returns><p> The locally unique identifier for the adapter. </p></returns>	
        /// <remarks>	
        /// <p> This method returns a unique identifier for the adapter that is specific to the adapter hardware. Applications can use this identifier to define robust mappings across various APIs (Direct3D 12, DXGI). </p><p> A locally unique identifier (<see cref="long"/>) is a 64-bit value that is guaranteed to be unique only on the system on which it was generated. The uniqueness of a locally unique identifier (<see cref="long"/>) is guaranteed only until the system is restarted. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Device::GetAdapterLuid']/*"/>	
        /// <msdn-id>dn914411</msdn-id>	
        /// <unmanaged>LUID ID3D12Device::GetAdapterLuid()</unmanaged>	
        /// <unmanaged-short>ID3D12Device::GetAdapterLuid</unmanaged-short>	
        internal long GetAdapterLuid() {
            unsafe {
                long __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Callilong(_nativePointer,((void**)(*(void**)_nativePointer))[43]);		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>An interface from which other core interfaces inherit from, including <strong><see cref="SharpDX.Direct3D12.CommandList"/></strong>, <strong><see cref="SharpDX.Direct3D12.Pageable"/></strong>, and <strong><see cref="SharpDX.Direct3D12.RootSignature"/></strong>. It provides a method to get back to the device object it was created against.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DeviceChild']/*"/>	
    /// <msdn-id>dn788651</msdn-id>	
    /// <unmanaged>ID3D12DeviceChild</unmanaged>	
    /// <unmanaged-short>ID3D12DeviceChild</unmanaged-short>	
    [Guid("905db94b-a00c-4140-9df5-2b64ca9ea357")]
    public partial class DeviceChild : SharpDX.Direct3D12.Object {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.DeviceChild"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DeviceChild(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.DeviceChild"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.DeviceChild(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.DeviceChild(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets a reference to the device that created this interface. </p>	
        /// </summary>	
        /// <param name="riid"><dd>  <p> The globally unique identifier (<strong><see cref="System.Guid"/></strong>) for the device interface. The <strong>REFIID</strong>, or <strong><see cref="System.Guid"/></strong>, of the interface to the device can be obtained by using the __uuidof() macro. For example, __uuidof(<strong><see cref="SharpDX.Direct3D12.Device"/></strong>) will get the <strong><see cref="System.Guid"/></strong> of the interface to a device. </p> </dd></param>	
        /// <param name="vDeviceOut"><dd>  <p> A reference to a memory block that receives a reference to the <strong><see cref="SharpDX.Direct3D12.Device"/></strong> interface for the device. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p> Any returned interfaces have their reference count incremented by one, so be sure to call ::release() on the returned references before they are freed or else you will have a memory leak. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12DeviceChild::GetDevice']/*"/>	
        /// <msdn-id>dn788652</msdn-id>	
        /// <unmanaged>HRESULT ID3D12DeviceChild::GetDevice([In] const GUID&amp; riid,[Out, Optional] void** ppvDevice)</unmanaged>	
        /// <unmanaged-short>ID3D12DeviceChild::GetDevice</unmanaged-short>	
        public void GetDevice(System.Guid riid, out System.IntPtr vDeviceOut) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* vDeviceOut_ = &vDeviceOut)
                    __result__= 
    				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, &riid, vDeviceOut_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Fence']/*"/>	
    /// <unmanaged>ID3D12Fence</unmanaged>	
    /// <unmanaged-short>ID3D12Fence</unmanaged-short>	
    [Guid("0a753dcf-c4d8-4b91-adf6-be5a60d95a76")]
    public partial class Fence : SharpDX.Direct3D12.Pageable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.Fence"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Fence(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.Fence"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.Fence(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.Fence(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the current value of the fence.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Fence::GetCompletedValue']/*"/>	
        /// <msdn-id>dn899189</msdn-id>	
        /// <unmanaged>GetCompletedValue</unmanaged>	
        /// <unmanaged-short>GetCompletedValue</unmanaged-short>	
        /// <unmanaged>unsigned longlong ID3D12Fence::GetCompletedValue()</unmanaged>
        public long CompletedValue {
                get { return GetCompletedValue(); }
        }
        
        /// <summary>	
        /// <p>Gets the current value of the fence.</p>	
        /// </summary>	
        /// <returns><p>Returns the current value of the fence.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Fence::GetCompletedValue']/*"/>	
        /// <msdn-id>dn899189</msdn-id>	
        /// <unmanaged>unsigned longlong ID3D12Fence::GetCompletedValue()</unmanaged>	
        /// <unmanaged-short>ID3D12Fence::GetCompletedValue</unmanaged-short>	
        internal long GetCompletedValue() {
            unsafe {
                long __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Callilong(_nativePointer,((void**)(*(void**)_nativePointer))[8]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="value">No documentation.</param>	
        /// <param name="hEvent">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Fence::SetEventOnCompletion']/*"/>	
        /// <unmanaged>HRESULT ID3D12Fence::SetEventOnCompletion([In] unsigned longlong Value,[In] void* hEvent)</unmanaged>	
        /// <unmanaged-short>ID3D12Fence::SetEventOnCompletion</unmanaged-short>	
        public void SetEventOnCompletion(long value, System.IntPtr hEvent) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, value, (void*)hEvent,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the fence to the specified value.</p>	
        /// </summary>	
        /// <param name="value"><dd>  <p>The value to set the fence to.</p> </dd></param>	
        /// <returns><p>This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p>Use this method to set a fence value from the CPU side. Use <strong><see cref="SharpDX.Direct3D12.CommandQueue.Signal"/></strong> to set a fence from the GPU side.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Fence::Signal']/*"/>	
        /// <msdn-id>dn899191</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Fence::Signal([In] unsigned longlong Value)</unmanaged>	
        /// <unmanaged-short>ID3D12Fence::Signal</unmanaged-short>	
        public void Signal(long value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, value,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList']/*"/>	
    /// <unmanaged>ID3D12GraphicsCommandList</unmanaged>	
    /// <unmanaged-short>ID3D12GraphicsCommandList</unmanaged-short>	
    [Guid("5b160d0f-ac1b-4185-8ba8-b3ae42a5a455")]
    public partial class GraphicsCommandList : SharpDX.Direct3D12.CommandList {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.GraphicsCommandList"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public GraphicsCommandList(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.GraphicsCommandList"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.GraphicsCommandList(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.GraphicsCommandList(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Bind information about the primitive type, and data order that describes input data for the input assembler stage.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::IASetPrimitiveTopology']/*"/>	
        /// <msdn-id>dn903885</msdn-id>	
        /// <unmanaged>IASetPrimitiveTopology</unmanaged>	
        /// <unmanaged-short>IASetPrimitiveTopology</unmanaged-short>	
        /// <unmanaged>void ID3D12GraphicsCommandList::IASetPrimitiveTopology([In] D3D_PRIMITIVE_TOPOLOGY PrimitiveTopology)</unmanaged>
        public SharpDX.Direct3D.PrimitiveTopology PrimitiveTopology {
                set { SetPrimitiveTopology(value); }
        }
        
        /// <summary>	
        /// <p>Sets the blend factor that modulate values for a pixel shader, render target, or both.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> If you created the blend-state object with <see cref="SharpDX.Direct3D11.BlendOption.BlendFactor"/> or <see cref="SharpDX.Direct3D11.BlendOption.InverseBlendFactor"/>, the blending stage uses the non-<c>null</c> array of blend factors. </p><p> If you didn't create the blend-state object with <see cref="SharpDX.Direct3D11.BlendOption.BlendFactor"/> or <see cref="SharpDX.Direct3D11.BlendOption.InverseBlendFactor"/>, the blending stage does not use the non-<c>null</c> array of blend factors; the runtime stores the blend factors. </p><p> If you pass <c>null</c>, the runtime uses or stores a blend factor equal to { 1, 1, 1, 1 }. </p><p> <see cref="SharpDX.Direct3D11.BlendOption.BlendFactor"/> and <see cref="SharpDX.Direct3D11.BlendOption.InverseBlendFactor"/> are <strong><see cref="SharpDX.Direct3D12.BlendOption"/></strong> enumeration constants. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::OMSetBlendFactor']/*"/>	
        /// <msdn-id>dn903886</msdn-id>	
        /// <unmanaged>OMSetBlendFactor</unmanaged>	
        /// <unmanaged-short>OMSetBlendFactor</unmanaged-short>	
        /// <unmanaged>void ID3D12GraphicsCommandList::OMSetBlendFactor([In, Optional] const SHARPDX_VECTOR4* BlendFactor)</unmanaged>
        public SharpDX.Mathematics.Interop.RawVector4 BlendFactor {
                set { SetBlendFactor(value); }
        }
        
        /// <summary>	
        /// <p>Sets the reference value for depth stencil tests.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::OMSetStencilRef']/*"/>	
        /// <msdn-id>dn903887</msdn-id>	
        /// <unmanaged>OMSetStencilRef</unmanaged>	
        /// <unmanaged-short>OMSetStencilRef</unmanaged-short>	
        /// <unmanaged>void ID3D12GraphicsCommandList::OMSetStencilRef([In] unsigned int StencilRef)</unmanaged>
        public int StencilReference {
                set { SetStencilReference(value); }
        }
        
        /// <summary>	
        /// <p> Sets all shaders and programs most of the fixed-function state of the graphics processing unit (GPU) pipeline. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetPipelineState']/*"/>	
        /// <msdn-id>dn903918</msdn-id>	
        /// <unmanaged>SetPipelineState</unmanaged>	
        /// <unmanaged-short>SetPipelineState</unmanaged-short>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetPipelineState([In] ID3D12PipelineState* pPipelineState)</unmanaged>
        public SharpDX.Direct3D12.PipelineState PipelineState {
                set { SetPipelineState(value); }
        }
        
        /// <summary>	
        /// <p> Indicates that recording to the command list has finished. </p>	
        /// </summary>	
        /// <returns><p> Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise, returns one of the following values: </p><ul> <li><strong>E_FAIL</strong> if the command list has already been closed, or an invalid API was called during command list recording. </li> <li><strong>E_OUTOFMEMORY</strong> if the operating system ran out of memory during recording. </li> <li><strong>E_INVALIDARG</strong> if an invalid argument was passed to the command list API during recording. </li> </ul><p> See Direct3D 12 Return Codes for other possible return values. </p></returns>	
        /// <remarks>	
        /// <p> The runtime will validate that the command list has not previously been closed.  If an error was encountered during recording, the error code is returned here.  The runtime won't call the close device driver interface (DDI) in this case. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::Close']/*"/>	
        /// <msdn-id>dn903855</msdn-id>	
        /// <unmanaged>HRESULT ID3D12GraphicsCommandList::Close()</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::Close</unmanaged-short>	
        public void Close() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Resets a command list back to its initial state as if a new command list was just created. </p>	
        /// </summary>	
        /// <param name="allocatorRef"><dd>  <p> A reference to the <strong><see cref="SharpDX.Direct3D12.CommandAllocator"/></strong> object that the device creates command lists from. </p> </dd></param>	
        /// <param name="initialStateRef"><dd>  <p>A reference to the <strong><see cref="SharpDX.Direct3D12.PipelineState"/></strong> object that contains the initial pipeline state for the command list.  This is optional and can be <c>null</c>.  If <c>null</c>, the runtime sets a dummy initial pipeline state so that drivers don't have to deal with undefined state.  The overhead for this is low, particularly for a command list, for which the overall cost of recording the command list likely dwarfs the cost of one initial state setting.  So there is little cost in  not setting the initial pipeline state parameter if it isn't convenient.  </p> <p>For bundles on the other hand, it might make more sense to try to set the initial state parameter since bundles are likely smaller overall and can be reused frequently.</p> </dd></param>	
        /// <returns><p> Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise, returns one of the following values: </p><ul> <li><strong>E_FAIL</strong> if the command list was not in the "closed" state when the <strong>Reset</strong> call was made, or the per-device limit would have been exceeded. </li> <li><strong>E_OUTOFMEMORY</strong> if the operating system ran out of memory. </li> <li><strong>E_INVALIDARG</strong> if the allocator is currently being used with another command list in the "recording" state or if the specified allocator was created with the wrong type. </li> </ul><p> See Direct3D 12 Return Codes for other possible return values. </p></returns>	
        /// <remarks>	
        /// <p> By using <strong>Reset</strong>, you can re-use command list tracking structures without any allocations. Unlike <strong><see cref="SharpDX.Direct3D12.CommandAllocator.Reset"/></strong>, you can call <strong>Reset</strong> while the command list is still being executed. A typical pattern is to submit a command list and then immediately reset it to reuse the allocated memory for another command list. </p><p> You can use <strong>Reset</strong> for both direct command lists and bundles. </p><p> The command allocator that <strong>Reset</strong> takes as input can be associated with no more than one recording command list at a time.  The allocator type, direct command list or bundle, must match the type of command list that is being created. </p><p> If a bundle doesn't specify a resource heap, it can't make changes to which descriptor tables are bound. Either way, bundles can't change the resource heap within the bundle. If a heap is specified for a bundle, the heap must match the calling 'parent' command list?s heap. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::Reset']/*"/>	
        /// <msdn-id>dn903895</msdn-id>	
        /// <unmanaged>HRESULT ID3D12GraphicsCommandList::Reset([In] ID3D12CommandAllocator* pAllocator,[In, Optional] ID3D12PipelineState* pInitialState)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::Reset</unmanaged-short>	
        public void Reset(SharpDX.Direct3D12.CommandAllocator allocatorRef, SharpDX.Direct3D12.PipelineState initialStateRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, (void*)((allocatorRef == null)?IntPtr.Zero:allocatorRef.NativePointer), (void*)((initialStateRef == null)?IntPtr.Zero:initialStateRef.NativePointer),((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Resets the state of a direct command list back to the state it was in when the command list was created.  </p>	
        /// </summary>	
        /// <param name="pipelineStateRef"><dd>  <p> A reference to the <strong><see cref="SharpDX.Direct3D12.PipelineState"/></strong> object that contains the initial pipeline state for the command list. </p> </dd></param>	
        /// <remarks>	
        /// <p> It is invalid to call <strong>ClearState</strong> on a bundle.  If an app calls <strong>ClearState</strong> on a bundle, the call to <strong>Close</strong> will return <strong>E_FAIL</strong>. </p><p> When <strong>ClearState</strong> is called, all currently bound resources are unbound.  The primitive topology is set to <strong><see cref="SharpDX.Direct3D.PrimitiveTopology.Undefined"/></strong>.  Viewports, scissor rectangles, stencil reference value, and the blend factor are set to empty values (all zeros).  Predication is disabled. </p><p> The app-provided pipeline state object becomes bound as the currently set pipeline state object. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::ClearState']/*"/>	
        /// <msdn-id>dn903847</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::ClearState([In, Optional] ID3D12PipelineState* pPipelineState)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::ClearState</unmanaged-short>	
        public void ClearState(SharpDX.Direct3D12.PipelineState pipelineStateRef) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((pipelineStateRef == null)?IntPtr.Zero:pipelineStateRef.NativePointer),((void**)(*(void**)_nativePointer))[11]);		
            }
        }
        
        /// <summary>	
        /// <p> Draws non-indexed, instanced primitives. </p>	
        /// </summary>	
        /// <param name="vertexCountPerInstance"><dd>  <p> Number of vertices to draw. </p> </dd></param>	
        /// <param name="instanceCount"><dd>  <p> Number of instances to draw. </p> </dd></param>	
        /// <param name="startVertexLocation"><dd>  <p> Index of the first vertex. </p> </dd></param>	
        /// <param name="startInstanceLocation"><dd>  <p> A value added to each index before reading per-instance data from a vertex buffer. </p> </dd></param>	
        /// <remarks>	
        /// <p> A draw API submits work to the rendering pipeline. </p><p> Instancing might extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be to draw the same object with different positions and colors. </p><p> The vertex data for an instanced draw call typically comes from a vertex buffer that is bound to the pipeline. But, you could also provide the vertex data from a shader that has instanced data identified with a system-value semantic (SV_InstanceID). </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::DrawInstanced']/*"/>	
        /// <msdn-id>dn903877</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::DrawInstanced([In] unsigned int VertexCountPerInstance,[In] unsigned int InstanceCount,[In] unsigned int StartVertexLocation,[In] unsigned int StartInstanceLocation)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::DrawInstanced</unmanaged-short>	
        public void DrawInstanced(int vertexCountPerInstance, int instanceCount, int startVertexLocation, int startInstanceLocation) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, vertexCountPerInstance, instanceCount, startVertexLocation, startInstanceLocation,((void**)(*(void**)_nativePointer))[12]);		
            }
        }
        
        /// <summary>	
        /// <p> Draws indexed, instanced primitives. </p>	
        /// </summary>	
        /// <param name="indexCountPerInstance"><dd>  <p>Number of indices read from the index buffer for each instance.</p> </dd></param>	
        /// <param name="instanceCount"><dd>  <p>Number of instances to draw.</p> </dd></param>	
        /// <param name="startIndexLocation"><dd>  <p>The location of the first index read by the GPU from the index buffer.</p> </dd></param>	
        /// <param name="baseVertexLocation"><dd>  <p>A value added to each index before reading a vertex from the vertex buffer.</p> </dd></param>	
        /// <param name="startInstanceLocation"><dd>  <p>A value added to each index before reading per-instance data from a vertex buffer.</p> </dd></param>	
        /// <remarks>	
        /// <p>A draw API submits work to the rendering pipeline.</p><p>Instancing might extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be  to draw the same object with different positions and colors. Instancing requires multiple vertex buffers: at least one for per-vertex data  and a second buffer for per-instance data.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::DrawIndexedInstanced']/*"/>	
        /// <msdn-id>dn903874</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::DrawIndexedInstanced([In] unsigned int IndexCountPerInstance,[In] unsigned int InstanceCount,[In] unsigned int StartIndexLocation,[In] int BaseVertexLocation,[In] unsigned int StartInstanceLocation)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::DrawIndexedInstanced</unmanaged-short>	
        public void DrawIndexedInstanced(int indexCountPerInstance, int instanceCount, int startIndexLocation, int baseVertexLocation, int startInstanceLocation) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, indexCountPerInstance, instanceCount, startIndexLocation, baseVertexLocation, startInstanceLocation,((void**)(*(void**)_nativePointer))[13]);		
            }
        }
        
        /// <summary>	
        /// <p>Executes a command list from a thread group.</p>	
        /// </summary>	
        /// <param name="threadGroupCountX"><dd>  <p> The number of groups dispatched in the x direction. <em>ThreadGroupCountX</em> must be less than or equal to <see cref="SharpDX.Direct3D11.ComputeShaderStage.DispatchMaximumThreadGroupsPerDimension"/> (65535). </p> </dd></param>	
        /// <param name="threadGroupCountY"><dd>  <p> The number of groups dispatched in the y direction. <em>ThreadGroupCountY</em> must be less than or equal to <see cref="SharpDX.Direct3D11.ComputeShaderStage.DispatchMaximumThreadGroupsPerDimension"/> (65535). </p> </dd></param>	
        /// <param name="threadGroupCountZ"><dd>  <p> The number of groups dispatched in the z direction.  <em>ThreadGroupCountZ</em> must be less than or equal to <see cref="SharpDX.Direct3D11.ComputeShaderStage.DispatchMaximumThreadGroupsPerDimension"/> (65535). In feature level 10 the value for <em>ThreadGroupCountZ</em> must be 1. </p> </dd></param>	
        /// <remarks>	
        /// <p> You call the <strong>Dispatch</strong> method to execute commands in a compute shader. A compute shader can be run on many threads in parallel, within a thread group. Index a particular thread, within a thread group using a 3D vector given by (x,y,z). </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::Dispatch']/*"/>	
        /// <msdn-id>dn903871</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::Dispatch([In] unsigned int ThreadGroupCountX,[In] unsigned int ThreadGroupCountY,[In] unsigned int ThreadGroupCountZ)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::Dispatch</unmanaged-short>	
        public void Dispatch(int threadGroupCountX, int threadGroupCountY, int threadGroupCountZ) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, threadGroupCountX, threadGroupCountY, threadGroupCountZ,((void**)(*(void**)_nativePointer))[14]);		
            }
        }
        
        /// <summary>	
        /// <p> Copies a region of a buffer from one resource to another. </p>	
        /// </summary>	
        /// <param name="dstBufferRef"><dd>  <p> Specifies the destination <strong><see cref="SharpDX.Direct3D12.Resource"/></strong>. </p> </dd></param>	
        /// <param name="dstOffset"><dd>  <p> Specifies a UINT64 offset (in bytes) into the destination resource. </p> </dd></param>	
        /// <param name="srcBufferRef"><dd>  <p> Specifies the source  <strong><see cref="SharpDX.Direct3D12.Resource"/></strong>. </p> </dd></param>	
        /// <param name="srcOffset"><dd>  <p> Specifies a UINT64 offset (in bytes) into the source resource, to start the copy from. </p> </dd></param>	
        /// <param name="numBytes"><dd>  <p> Specifies the number of bytes to copy. </p> </dd></param>	
        /// <remarks>	
        /// <p> Consider using the <strong>CopyResource</strong> method when copying an entire resource, and use this method for copying regions of a resource. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::CopyBufferRegion']/*"/>	
        /// <msdn-id>dn903856</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::CopyBufferRegion([In] ID3D12Resource* pDstBuffer,[In] unsigned longlong DstOffset,[In] ID3D12Resource* pSrcBuffer,[In] unsigned longlong SrcOffset,[In] unsigned longlong NumBytes)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::CopyBufferRegion</unmanaged-short>	
        public void CopyBufferRegion(SharpDX.Direct3D12.Resource dstBufferRef, long dstOffset, SharpDX.Direct3D12.Resource srcBufferRef, long srcOffset, long numBytes) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((dstBufferRef == null)?IntPtr.Zero:dstBufferRef.NativePointer), dstOffset, (void*)((srcBufferRef == null)?IntPtr.Zero:srcBufferRef.NativePointer), srcOffset, numBytes,((void**)(*(void**)_nativePointer))[15]);		
            }
        }
        
        /// <summary>	
        /// <p> This method uses the GPU to copy texture data between two locations. Both the source and the destination may reference texture data located within either a buffer resource or a texture resource.</p>	
        /// </summary>	
        /// <param name="dstRef"><dd>  <p>Specifies the destination <strong><see cref="SharpDX.Direct3D12.TextureCopyLocation"/></strong>. The subresource referred to must be in the <see cref="SharpDX.Direct3D12.ResourceStates.CopyDestination"/> state.</p> </dd></param>	
        /// <param name="dstX"><dd>  <p> The x-coordinate of the upper left corner of the destination region. </p> </dd></param>	
        /// <param name="dstY"><dd>  <p> The y-coordinate of the upper left corner of the destination region. For a 1D subresource, this must be zero. </p> </dd></param>	
        /// <param name="dstZ"><dd>  <p> The z-coordinate of the upper left corner of the destination region. For a 1D or 2D subresource, this must be zero. </p> </dd></param>	
        /// <param name="srcRef"><dd>  <p> Specifies the source <strong><see cref="SharpDX.Direct3D12.TextureCopyLocation"/></strong>. The subresource referred to must be in the <see cref="SharpDX.Direct3D12.ResourceStates.CopySource"/> state.</p> </dd></param>	
        /// <param name="srcBoxRef"><dd>  <p> Specifies an optional  <see cref="SharpDX.Direct3D12.ResourceRegion"/> that sets the size of the source texture to copy. </p> </dd></param>	
        /// <remarks>	
        /// <p> The source box must be within the size of the source resource. The destination offsets, (x, y, and z), allow the source box to be offset when writing into the destination resource; however, the dimensions of the source box and the offsets must be within the size of the resource. If you try and copy outside the destination resource or specify a source box that is larger than the source resource, the behavior of <strong>CopyTextureRegion</strong> is undefined. If you created a device that supports the debug layer, the debug output reports an error on this invalid <strong>CopyTextureRegion</strong> call. Invalid parameters to <strong>CopyTextureRegion</strong> cause undefined behavior and might result in incorrect rendering, clipping, no copy, or even the removal of the rendering device. </p><p>If the resources are buffers, all coordinates are in bytes; if the resources are textures, all coordinates are in texels. </p><p><strong>CopyTextureRegion</strong> performs the copy on the GPU (similar to a memcpy by the CPU). As a consequence, the source and destination resources: </p><ul> <li>Must be different subresources (although they can be from the same resource).</li> <li> Must have compatible DXGI formats (identical or from the same type group). For example, a <see cref="SharpDX.DXGI.Format.R32G32B32_Float"/> texture can be copied to an <see cref="SharpDX.DXGI.Format.R32G32B32_UInt"/> texture since both of these formats are in the <see cref="SharpDX.DXGI.Format.R32G32B32_Typeless"/> group. <strong>CopyTextureRegion</strong> can copy between a few format types. For more info, see Format Conversion using Direct3D 10.1. </li> </ul><p><strong>CopyTextureRegion</strong> only supports copy; it does not support any stretch, color key, or blend. <strong>CopyTextureRegion</strong> can reinterpret the resource data between a few format types. For more info, see Format Conversion using Direct3D 10.1. </p><p> If your app needs to copy an entire resource, we recommend to use <strong>CopyResource</strong> instead. </p><strong>Note</strong>?? If you use <strong>CopyTextureRegion</strong> with a depth-stencil buffer or a multisampled resource, you must copy the whole subresource. In this situation, you must pass 0 to the <em>DstX</em>, <em>DstY</em>, and <em>DstZ</em> parameters and <strong><c>null</c></strong> to the <em>pSrcBox</em> parameter. In addition, source and destination resources, which are represented by the <em>pSrcResource</em> and <em>pDstResource</em> parameters, should have identical sample count values.?	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::CopyTextureRegion']/*"/>	
        /// <msdn-id>dn903862</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::CopyTextureRegion([In] const D3D12_TEXTURE_COPY_LOCATION* pDst,[In] unsigned int DstX,[In] unsigned int DstY,[In] unsigned int DstZ,[In] const D3D12_TEXTURE_COPY_LOCATION* pSrc,[In, Optional] const D3D12_BOX* pSrcBox)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::CopyTextureRegion</unmanaged-short>	
        public void CopyTextureRegion(SharpDX.Direct3D12.TextureCopyLocation dstRef, int dstX, int dstY, int dstZ, SharpDX.Direct3D12.TextureCopyLocation srcRef, SharpDX.Direct3D12.ResourceRegion? srcBoxRef) {
            unsafe {
                SharpDX.Direct3D12.ResourceRegion srcBoxRef_;
                if (srcBoxRef.HasValue)
                    srcBoxRef_ = srcBoxRef.Value;				
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, &dstRef, dstX, dstY, dstZ, &srcRef, (srcBoxRef.HasValue)?&srcBoxRef_:(void*)IntPtr.Zero,((void**)(*(void**)_nativePointer))[16]);		
            }
        }
        
        /// <summary>	
        /// <p> Copies the entire contents of the source resource to the destination resource. </p>	
        /// </summary>	
        /// <param name="dstResourceRef"><dd>  <p> A reference to the <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> interface that represents the destination resource. </p> </dd></param>	
        /// <param name="srcResourceRef"><dd>  <p> A reference to the <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> interface that represents the source resource. </p> </dd></param>	
        /// <remarks>	
        /// <p><strong>CopyResource</strong> operations are performed on the GPU and do not incur a significant CPU workload linearly dependent on the size of the data to copy. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::CopyResource']/*"/>	
        /// <msdn-id>dn903859</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::CopyResource([In] ID3D12Resource* pDstResource,[In] ID3D12Resource* pSrcResource)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::CopyResource</unmanaged-short>	
        public void CopyResource(SharpDX.Direct3D12.Resource dstResourceRef, SharpDX.Direct3D12.Resource srcResourceRef) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((dstResourceRef == null)?IntPtr.Zero:dstResourceRef.NativePointer), (void*)((srcResourceRef == null)?IntPtr.Zero:srcResourceRef.NativePointer),((void**)(*(void**)_nativePointer))[17]);		
            }
        }
        
        /// <summary>	
        /// <p> Copies tiles from buffer to tiled resource or vice versa. </p>	
        /// </summary>	
        /// <param name="tiledResourceRef"><dd>  <p>A reference to a tiled resource.</p> </dd></param>	
        /// <param name="tileRegionStartCoordinateRef"><dd>  <p> A reference to a <strong><see cref="SharpDX.Direct3D12.TiledResourceCoordinate"/></strong> structure that describes the starting coordinates of the tiled resource. </p> </dd></param>	
        /// <param name="tileRegionSizeRef"><dd>  <p> A reference to a <strong><see cref="SharpDX.Direct3D12.TileRegionSize"/></strong> structure that describes the size of the tiled region. </p> </dd></param>	
        /// <param name="bufferRef"><dd>  <p> A reference to an <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> that represents a default, dynamic, or staging buffer. </p> </dd></param>	
        /// <param name="bufferStartOffsetInBytes"><dd>  <p> The offset in bytes into the buffer at <em>pBuffer</em> to start the operation. </p> </dd></param>	
        /// <param name="flags"><dd>  <p> A combination of <strong><see cref="SharpDX.Direct3D12.TileCopyFlags"/></strong>-typed values that are combined by using a bitwise OR operation and that identifies how to copy tiles. </p> </dd></param>	
        /// <remarks>	
        /// <p><strong>CopyTiles</strong> drops write operations to unmapped areas and handles read operations from unmapped areas (except on <strong>Tier_1</strong> tiled resources, where reading and writing unmapped areas is invalid). </p><p>If a copy operation involves writing to the same memory location multiple times because multiple locations in the destination resource are mapped to the same tile memory, the resulting write operations to multi-mapped tiles are non-deterministic and non-repeatable; that is, accesses to the tile memory happen in whatever order the hardware happens to execute the copy operation.</p><p> The tiles involved in the copy operation can't include tiles that contain packed mipmaps or results of the copy operation are undefined. To transfer data to and from mipmaps that the hardware packs into one tile, you must use the standard (that is, non-tile specific) copy and update APIs (like <strong><see cref="SharpDX.Direct3D11.DeviceContext1.CopySubresourceRegion1"/></strong> and <strong><see cref="SharpDX.Direct3D11.DeviceContext1.UpdateSubresource1"/></strong>) or <strong><see cref="SharpDX.Direct3D11.DeviceContext.GenerateMips"/></strong> for the whole mipmap chain. </p><p> The memory layout of the tiles in the non-tiled buffer resource side of the copy operation is linear in memory within 64 KB tiles, which the hardware and driver swizzle and deswizzle per tile as appropriate when they transfer to and from a tiled resource. For multisample antialiasing (MSAA) surfaces, the hardware and driver traverse each pixel's samples in sample-index order before they move to the next pixel. For tiles that are partially filled on the right side (for a surface that has a width not a multiple of tile width in pixels), the pitch and stride to move down a row is the full size in bytes of the number pixels that would fit across the tile if the tile was full. So, there can be a gap between each row of pixels in memory. Mipmaps that are smaller than a tile are not packed together in the linear layout, which might seem to be a waste of memory space, but as mentioned you can't use <strong>CopyTiles</strong> or <strong><see cref="SharpDX.Direct3D11.DeviceContext2.UpdateTiles"/></strong> to copy to mipmaps that the hardware packs together. You can just use generic copy and update APIs (like <strong><see cref="SharpDX.Direct3D11.DeviceContext1.CopySubresourceRegion1"/></strong> and <strong><see cref="SharpDX.Direct3D11.DeviceContext1.UpdateSubresource1"/></strong>) to copy small mipmaps individually. Although in the case of a generic copy API (like <strong><see cref="SharpDX.Direct3D11.DeviceContext1.CopySubresourceRegion1"/></strong>), the linear memory must be the same dimension as the tiled resource; <strong><see cref="SharpDX.Direct3D11.DeviceContext1.CopySubresourceRegion1"/></strong> can't copy from a buffer resource to a Texture2D for instance. </p><p> For more info about tiled resources, see Tiled resources. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::CopyTiles']/*"/>	
        /// <msdn-id>dn903865</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::CopyTiles([In] ID3D12Resource* pTiledResource,[In] const D3D12_TILED_RESOURCE_COORDINATE* pTileRegionStartCoordinate,[In] const D3D12_TILE_REGION_SIZE* pTileRegionSize,[In] ID3D12Resource* pBuffer,[In] unsigned longlong BufferStartOffsetInBytes,[In] D3D12_TILE_COPY_FLAGS Flags)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::CopyTiles</unmanaged-short>	
        public void CopyTiles(SharpDX.Direct3D12.Resource tiledResourceRef, SharpDX.Direct3D12.TiledResourceCoordinate tileRegionStartCoordinateRef, SharpDX.Direct3D12.TileRegionSize tileRegionSizeRef, SharpDX.Direct3D12.Resource bufferRef, long bufferStartOffsetInBytes, SharpDX.Direct3D12.TileCopyFlags flags) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((tiledResourceRef == null)?IntPtr.Zero:tiledResourceRef.NativePointer), &tileRegionStartCoordinateRef, &tileRegionSizeRef, (void*)((bufferRef == null)?IntPtr.Zero:bufferRef.NativePointer), bufferStartOffsetInBytes, unchecked((int)flags),((void**)(*(void**)_nativePointer))[18]);		
            }
        }
        
        /// <summary>	
        /// <p>Copy a multi-sampled resource into a non-multi-sampled resource.</p>	
        /// </summary>	
        /// <param name="dstResourceRef"><dd>  <p> Destination resource. Must be a created with the <strong><see cref="SharpDX.Direct3D11.ResourceUsage.Default"/></strong> flag and be single-sampled. See <strong><see cref="SharpDX.Direct3D12.Resource"/></strong>. </p> </dd></param>	
        /// <param name="dstSubresource"><dd>  <p> A zero-based index, that identifies the destination subresource. Use <strong>D3D11CalcSubresource</strong> to calculate the index. </p> </dd></param>	
        /// <param name="srcResourceRef"><dd>  <p> Source resource. Must be multisampled. </p> </dd></param>	
        /// <param name="srcSubresource"><dd>  <p> The source subresource of the source resource. </p> </dd></param>	
        /// <param name="format"><dd>  <p> A <strong><see cref="SharpDX.DXGI.Format"/></strong> that indicates how the multisampled resource will be resolved to a single-sampled resource. See remarks. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::ResolveSubresource']/*"/>	
        /// <msdn-id>dn903897</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::ResolveSubresource([In] ID3D12Resource* pDstResource,[In] unsigned int DstSubresource,[In] ID3D12Resource* pSrcResource,[In] unsigned int SrcSubresource,[In] DXGI_FORMAT Format)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::ResolveSubresource</unmanaged-short>	
        public void ResolveSubresource(SharpDX.Direct3D12.Resource dstResourceRef, int dstSubresource, SharpDX.Direct3D12.Resource srcResourceRef, int srcSubresource, SharpDX.DXGI.Format format) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((dstResourceRef == null)?IntPtr.Zero:dstResourceRef.NativePointer), dstSubresource, (void*)((srcResourceRef == null)?IntPtr.Zero:srcResourceRef.NativePointer), srcSubresource, unchecked((int)format),((void**)(*(void**)_nativePointer))[19]);		
            }
        }
        
        /// <summary>	
        /// <p>Bind information about the primitive type, and data order that describes input data for the input assembler stage.</p>	
        /// </summary>	
        /// <param name="primitiveTopology"><dd>  <p> The type of primitive and ordering of the primitive data (see <strong><see cref="SharpDX.Direct3D.PrimitiveTopology"/></strong>). </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::IASetPrimitiveTopology']/*"/>	
        /// <msdn-id>dn903885</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::IASetPrimitiveTopology([In] D3D_PRIMITIVE_TOPOLOGY PrimitiveTopology)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::IASetPrimitiveTopology</unmanaged-short>	
        internal void SetPrimitiveTopology(SharpDX.Direct3D.PrimitiveTopology primitiveTopology) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, unchecked((int)primitiveTopology),((void**)(*(void**)_nativePointer))[20]);		
            }
        }
        
        /// <summary>	
        /// <p> Bind an array of viewports to the rasterizer stage of the pipeline. </p>	
        /// </summary>	
        /// <param name="numViewports"><dd>  <p> Number of viewports to bind. The range of valid values is (0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE). </p> </dd></param>	
        /// <param name="viewportsRef"><dd>  <p> An array of <strong><see cref="SharpDX.Direct3D12.Viewport"/></strong> structures to bind to the device. </p> </dd></param>	
        /// <remarks>	
        /// <p> All viewports must be set atomically as one operation. Any viewports not defined by the call are disabled. </p><p> Which viewport to use is determined by the SV_ViewportArrayIndex semantic output by a geometry shader; if a geometry shader does not specify the semantic, Direct3D will use the first viewport in the array. </p><strong>Note</strong>?? Even though you specify float values to the members of the <strong><see cref="SharpDX.Direct3D12.Viewport"/></strong> structure for the <em>pViewports</em> array in a call to  <strong>RSSetViewports</strong> for feature levels 9_x, <strong>RSSetViewports</strong> uses DWORDs internally. Because of this behavior, when you use a negative top left corner for the viewport, the call to  <strong>RSSetViewports</strong> for feature levels 9_x fails. This failure occurs because <strong>RSSetViewports</strong> for 9_x casts the floating point values into unsigned integers without validation, which results in integer overflow.?	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::RSSetViewports']/*"/>	
        /// <msdn-id>dn903900</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::RSSetViewports([In] unsigned int NumViewports,[In, Buffer] const D3D12_VIEWPORT* pViewports)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::RSSetViewports</unmanaged-short>	
        public void SetViewports(int numViewports, SharpDX.Direct3D12.Viewport[] viewportsRef) {
            unsafe {
                fixed (void* viewportsRef_ = viewportsRef)
                    SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, numViewports, viewportsRef_,((void**)(*(void**)_nativePointer))[21]);		
            }
        }
        
        /// <summary>	
        /// <p> Bind an array of viewports to the rasterizer stage of the pipeline. </p>	
        /// </summary>	
        /// <param name="numViewports"><dd>  <p> Number of viewports to bind. The range of valid values is (0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE). </p> </dd></param>	
        /// <param name="viewportsRef"><dd>  <p> An array of <strong><see cref="SharpDX.Direct3D12.Viewport"/></strong> structures to bind to the device. </p> </dd></param>	
        /// <remarks>	
        /// <p> All viewports must be set atomically as one operation. Any viewports not defined by the call are disabled. </p><p> Which viewport to use is determined by the SV_ViewportArrayIndex semantic output by a geometry shader; if a geometry shader does not specify the semantic, Direct3D will use the first viewport in the array. </p><strong>Note</strong>?? Even though you specify float values to the members of the <strong><see cref="SharpDX.Direct3D12.Viewport"/></strong> structure for the <em>pViewports</em> array in a call to  <strong>RSSetViewports</strong> for feature levels 9_x, <strong>RSSetViewports</strong> uses DWORDs internally. Because of this behavior, when you use a negative top left corner for the viewport, the call to  <strong>RSSetViewports</strong> for feature levels 9_x fails. This failure occurs because <strong>RSSetViewports</strong> for 9_x casts the floating point values into unsigned integers without validation, which results in integer overflow.?	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::RSSetViewports']/*"/>	
        /// <msdn-id>dn903900</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::RSSetViewports([In] unsigned int NumViewports,[In, Buffer] const D3D12_VIEWPORT* pViewports)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::RSSetViewports</unmanaged-short>	
        private void SetViewports(int numViewports, System.IntPtr viewportsRef) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, numViewports, (void*)viewportsRef,((void**)(*(void**)_nativePointer))[21]);		
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="numRects">No documentation.</param>	
        /// <param name="rectsRef">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::RSSetScissorRects']/*"/>	
        /// <unmanaged>void ID3D12GraphicsCommandList::RSSetScissorRects([In] unsigned int NumRects,[In, Buffer] const RECT* pRects)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::RSSetScissorRects</unmanaged-short>	
        public void SetScissorRectangles(int numRects, SharpDX.Mathematics.Interop.RawRectangle[] rectsRef) {
            unsafe {
                fixed (void* rectsRef_ = rectsRef)
                    SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, numRects, rectsRef_,((void**)(*(void**)_nativePointer))[22]);		
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="numRects">No documentation.</param>	
        /// <param name="rectsRef">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::RSSetScissorRects']/*"/>	
        /// <unmanaged>void ID3D12GraphicsCommandList::RSSetScissorRects([In] unsigned int NumRects,[In, Buffer] const RECT* pRects)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::RSSetScissorRects</unmanaged-short>	
        private void SetScissorRectangles(int numRects, System.IntPtr rectsRef) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, numRects, (void*)rectsRef,((void**)(*(void**)_nativePointer))[22]);		
            }
        }
        
        /// <summary>	
        /// <p>Sets the blend factor that modulate values for a pixel shader, render target, or both.</p>	
        /// </summary>	
        /// <param name="blendFactor"><dd>  <p> Array of blend factors, one for each RGBA component. </p> </dd></param>	
        /// <remarks>	
        /// <p> If you created the blend-state object with <see cref="SharpDX.Direct3D11.BlendOption.BlendFactor"/> or <see cref="SharpDX.Direct3D11.BlendOption.InverseBlendFactor"/>, the blending stage uses the non-<c>null</c> array of blend factors. </p><p> If you didn't create the blend-state object with <see cref="SharpDX.Direct3D11.BlendOption.BlendFactor"/> or <see cref="SharpDX.Direct3D11.BlendOption.InverseBlendFactor"/>, the blending stage does not use the non-<c>null</c> array of blend factors; the runtime stores the blend factors. </p><p> If you pass <c>null</c>, the runtime uses or stores a blend factor equal to { 1, 1, 1, 1 }. </p><p> <see cref="SharpDX.Direct3D11.BlendOption.BlendFactor"/> and <see cref="SharpDX.Direct3D11.BlendOption.InverseBlendFactor"/> are <strong><see cref="SharpDX.Direct3D12.BlendOption"/></strong> enumeration constants. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::OMSetBlendFactor']/*"/>	
        /// <msdn-id>dn903886</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::OMSetBlendFactor([In, Optional] const SHARPDX_VECTOR4* BlendFactor)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::OMSetBlendFactor</unmanaged-short>	
        internal void SetBlendFactor(SharpDX.Mathematics.Interop.RawVector4? blendFactor) {
            unsafe {
                SharpDX.Mathematics.Interop.RawVector4 blendFactor_;
                if (blendFactor.HasValue)
                    blendFactor_ = blendFactor.Value;				
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (blendFactor.HasValue)?&blendFactor_:(void*)IntPtr.Zero,((void**)(*(void**)_nativePointer))[23]);		
            }
        }
        
        /// <summary>	
        /// <p>Sets the reference value for depth stencil tests.</p>	
        /// </summary>	
        /// <param name="stencilRef"><dd>  <p> Reference value to perform against when doing a depth-stencil test. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::OMSetStencilRef']/*"/>	
        /// <msdn-id>dn903887</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::OMSetStencilRef([In] unsigned int StencilRef)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::OMSetStencilRef</unmanaged-short>	
        internal void SetStencilReference(int stencilRef) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, stencilRef,((void**)(*(void**)_nativePointer))[24]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets all shaders and programs most of the fixed-function state of the graphics processing unit (GPU) pipeline. </p>	
        /// </summary>	
        /// <param name="pipelineStateRef"><dd>  <p> Pointer to the <strong><see cref="SharpDX.Direct3D12.PipelineState"/></strong> containing the pipeline state data. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetPipelineState']/*"/>	
        /// <msdn-id>dn903918</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetPipelineState([In] ID3D12PipelineState* pPipelineState)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetPipelineState</unmanaged-short>	
        internal void SetPipelineState(SharpDX.Direct3D12.PipelineState pipelineStateRef) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((pipelineStateRef == null)?IntPtr.Zero:pipelineStateRef.NativePointer),((void**)(*(void**)_nativePointer))[25]);		
            }
        }
        
        /// <summary>	
        /// <p> Notifies the driver that it needs to synchronize multiple accesses to resources. </p>	
        /// </summary>	
        /// <param name="numBarriers"><dd>  <p> The number of submitted barrier descriptions. </p> </dd></param>	
        /// <param name="barriersRef"><dd>  <p> Pointer to an array of barrier descriptions. </p> </dd></param>	
        /// <remarks>	
        /// <p>There are three types of barrier descriptions:</p><ul> <li> <strong><see cref="SharpDX.Direct3D12.ResourceTransitionBarrier"/></strong> -  Transition barriers  indicate that a set of subresources transition between different usages.  The caller must specify the <em>before</em> and <em>after</em> usages of the subresources.  The D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES flag is used to transition all subresources in a resource at the same time. </li> <li> <strong><see cref="SharpDX.Direct3D12.ResourceAliasingBarrier"/></strong> - Aliasing barriers indicate a transition between usages of two different resources which have mappings into the same heap.  The application can specify both the before and the after resource.  Note that one or both resources can be <c>null</c> (indicating that any tiled resource could cause aliasing). </li> <li> <strong><see cref="SharpDX.Direct3D12.ResourceUnorderedAccessViewBarrier"/></strong> - Unordered access view barriers indicate all UAV accesses (read or writes) to a particular resource must complete before any future UAV accesses (read or write) can begin.  The specified resource cannot be <c>null</c>.  It is not necessary to insert a UAV barrier between two draw or dispatch calls which only read a UAV.  Additionally, it is not necessary to insert a UAV barrier between two draw or dispatch calls which write to the same UAV if the application knows that it is safe to execute the UAV accesses in any order.  The resource can be <c>null</c> (indicating that any UAV access could require the barrier). </li> </ul><p> When <strong><see cref="SharpDX.Direct3D12.GraphicsCommandList.ResourceBarrier"/></strong> is passed an array of resource barrier descriptions, the API behaves as if it was called N times (1 for each array element), in the specified order. </p><p> For descriptions of the usage states a subresource can be in, see the <strong><see cref="SharpDX.Direct3D12.ResourceStates"/></strong> enumeration and the Using Resource Barriers to Synchronize Resource States in Direct3D 12 section. </p><p> A subresource can be in any state when <strong><see cref="SharpDX.Direct3D12.GraphicsCommandList.DiscardResource"/></strong> is called. </p><p> When a back buffer is presented, it must be in the <see cref="SharpDX.Direct3D12.ResourceStates.Present"/> state.  If <strong>Present</strong> is called on a resource which is not in the PRESENT state, a debug layer warning will be emitted. </p><p>The resource usage bits are group into two categories, read-only and read/write.</p><p> The following usage bits are read-only: </p><ul> <li><see cref="SharpDX.Direct3D12.ResourceStates.VertexAndConstantBuffer"/></li> <li><see cref="SharpDX.Direct3D12.ResourceStates.IndexBuffer"/></li> <li><see cref="SharpDX.Direct3D12.ResourceStates.NonPixelShaderResource"/></li> <li><see cref="SharpDX.Direct3D12.ResourceStates.PixelShaderResource"/></li> <li><see cref="SharpDX.Direct3D12.ResourceStates.IndirectArgument"/></li> <li><see cref="SharpDX.Direct3D12.ResourceStates.CopySource"/></li> <li><see cref="SharpDX.Direct3D12.ResourceStates.DepthRead"/></li> </ul><p>The following usage bits are read/write:</p><ul> <li><see cref="SharpDX.Direct3D12.ResourceStates.CopyDestination"/></li> <li><see cref="SharpDX.Direct3D12.ResourceStates.RenderTarget"/></li> <li><see cref="SharpDX.Direct3D12.ResourceStates.UnorderedAccess"/></li> <li><see cref="SharpDX.Direct3D12.ResourceStates.DepthWrite"/></li> <li>D3D12_RESOURCE_STATE_GENERATE_MIPS</li> <li><see cref="SharpDX.Direct3D12.ResourceStates.StreamOut"/></li> </ul><p> At most one write bit can be set. If any write bit is set, then no read bit may be set. If no write bit is set, then any number of read bits may be set.  </p><p> At any given time, a subresource is in exactly one  state (determined by a set of flags).  The application must ensure that the states are matched when making a sequence of <strong>ResourceBarrier</strong> calls. In other words, the before and after states in consecutive calls to <strong>ResourceBarrier</strong> must agree. </p><p>To transition all subresources within a resource, the application can set the subresource index to D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES, which implies that all subresources are changed.</p><p> For improved performance, applications should use split barriers (refer to Synchronization and Multi-Engine). Applications should also batch multiple transitions into a single call whenever possible. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::ResourceBarrier']/*"/>	
        /// <msdn-id>dn903898</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::ResourceBarrier([In] unsigned int NumBarriers,[In, Buffer] const void* pBarriers)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::ResourceBarrier</unmanaged-short>	
        private void ResourceBarrier(int numBarriers, System.IntPtr barriersRef) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, numBarriers, (void*)barriersRef,((void**)(*(void**)_nativePointer))[26]);		
            }
        }
        
        /// <summary>	
        /// <p> Executes a bundle. </p>	
        /// </summary>	
        /// <param name="commandListRef"><dd>  <p> Specifies the <strong><see cref="SharpDX.Direct3D12.GraphicsCommandList"/></strong> that determines the bundle to be executed. </p> </dd></param>	
        /// <remarks>	
        /// <p> Bundles inherit all state from the parent command list on which <strong>ExecuteBundle</strong> is called, except the pipeline state object and primitive topology. All of the state that is set in a bundle will affect the state of the parent command list. Note that <strong>ExecuteBundle</strong> is not a predicated operation. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::ExecuteBundle']/*"/>	
        /// <msdn-id>dn903882</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::ExecuteBundle([In] ID3D12GraphicsCommandList* pCommandList)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::ExecuteBundle</unmanaged-short>	
        public void ExecuteBundle(SharpDX.Direct3D12.GraphicsCommandList commandListRef) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((commandListRef == null)?IntPtr.Zero:commandListRef.NativePointer),((void**)(*(void**)_nativePointer))[27]);		
            }
        }
        
        /// <summary>	
        /// <p> Changes the currently bound descriptor heaps that are associated with a command list. </p>	
        /// </summary>	
        /// <param name="numDescriptorHeaps"><dd>  <p> Number of descriptor heaps to bind. </p> </dd></param>	
        /// <param name="descriptorHeapsOut"><dd>  <p> A reference to an array of <strong><see cref="SharpDX.Direct3D12.DescriptorHeap"/></strong> objects for the heaps to set on the command list. </p> </dd></param>	
        /// <remarks>	
        /// <p><strong>SetDescriptorHeaps</strong> can be called on a bundle, but the bundle descriptor heaps must match the calling command list descriptor heap. For more information on bundle restrictions, refer to Creating and Recording Command Lists and Bundles.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetDescriptorHeaps']/*"/>	
        /// <msdn-id>Dn903908</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetDescriptorHeaps([In] unsigned int NumDescriptorHeaps,[In, Buffer] const ID3D12DescriptorHeap** ppDescriptorHeaps)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetDescriptorHeaps</unmanaged-short>	
        public void SetDescriptorHeaps(int numDescriptorHeaps, SharpDX.Direct3D12.DescriptorHeap[] descriptorHeapsOut) {
            unsafe {
                IntPtr* descriptorHeapsOut_ = (IntPtr*)0;
                if ( descriptorHeapsOut != null ) {
                    IntPtr* descriptorHeapsOut__ = stackalloc IntPtr[descriptorHeapsOut.Length];
                    descriptorHeapsOut_ = descriptorHeapsOut__;
                    for (int i = 0; i < descriptorHeapsOut.Length; i++)                        
                        descriptorHeapsOut_[i] =  (descriptorHeapsOut[i] == null)? IntPtr.Zero : descriptorHeapsOut[i].NativePointer;
                }
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, numDescriptorHeaps, descriptorHeapsOut_,((void**)(*(void**)_nativePointer))[28]);		
            }
        }
        
        /// <summary>	
        /// <p> Changes the currently bound descriptor heaps that are associated with a command list. </p>	
        /// </summary>	
        /// <param name="numDescriptorHeaps"><dd>  <p> Number of descriptor heaps to bind. </p> </dd></param>	
        /// <param name="descriptorHeapsOut"><dd>  <p> A reference to an array of <strong><see cref="SharpDX.Direct3D12.DescriptorHeap"/></strong> objects for the heaps to set on the command list. </p> </dd></param>	
        /// <remarks>	
        /// <p><strong>SetDescriptorHeaps</strong> can be called on a bundle, but the bundle descriptor heaps must match the calling command list descriptor heap. For more information on bundle restrictions, refer to Creating and Recording Command Lists and Bundles.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetDescriptorHeaps']/*"/>	
        /// <msdn-id>Dn903908</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetDescriptorHeaps([In] unsigned int NumDescriptorHeaps,[In, Buffer] const ID3D12DescriptorHeap** ppDescriptorHeaps)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetDescriptorHeaps</unmanaged-short>	
        public void SetDescriptorHeaps(int numDescriptorHeaps, SharpDX.ComArray<SharpDX.Direct3D12.DescriptorHeap> descriptorHeapsOut) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, numDescriptorHeaps, (void*)((descriptorHeapsOut == null)?IntPtr.Zero:descriptorHeapsOut.NativePointer),((void**)(*(void**)_nativePointer))[28]);		
            }
        }
        
        /// <summary>	
        /// <p> Changes the currently bound descriptor heaps that are associated with a command list. </p>	
        /// </summary>	
        /// <param name="numDescriptorHeaps"><dd>  <p> Number of descriptor heaps to bind. </p> </dd></param>	
        /// <param name="descriptorHeapsOut"><dd>  <p> A reference to an array of <strong><see cref="SharpDX.Direct3D12.DescriptorHeap"/></strong> objects for the heaps to set on the command list. </p> </dd></param>	
        /// <remarks>	
        /// <p><strong>SetDescriptorHeaps</strong> can be called on a bundle, but the bundle descriptor heaps must match the calling command list descriptor heap. For more information on bundle restrictions, refer to Creating and Recording Command Lists and Bundles.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetDescriptorHeaps']/*"/>	
        /// <msdn-id>Dn903908</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetDescriptorHeaps([In] unsigned int NumDescriptorHeaps,[In, Buffer] const ID3D12DescriptorHeap** ppDescriptorHeaps)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetDescriptorHeaps</unmanaged-short>	
        private void SetDescriptorHeaps(int numDescriptorHeaps, System.IntPtr descriptorHeapsOut) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, numDescriptorHeaps, (void*)descriptorHeapsOut,((void**)(*(void**)_nativePointer))[28]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets the layout of the compute root signature. </p>	
        /// </summary>	
        /// <param name="rootSignatureRef"><dd>  <p> A reference to the <strong><see cref="SharpDX.Direct3D12.RootSignature"/></strong> object. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetComputeRootSignature']/*"/>	
        /// <msdn-id>dn903906</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetComputeRootSignature([In] ID3D12RootSignature* pRootSignature)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetComputeRootSignature</unmanaged-short>	
        public void SetComputeRootSignature(SharpDX.Direct3D12.RootSignature rootSignatureRef) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((rootSignatureRef == null)?IntPtr.Zero:rootSignatureRef.NativePointer),((void**)(*(void**)_nativePointer))[29]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets the layout of the graphics root signature. </p>	
        /// </summary>	
        /// <param name="rootSignatureRef"><dd>  <p> A reference to the <strong><see cref="SharpDX.Direct3D12.RootSignature"/></strong> object. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetGraphicsRootSignature']/*"/>	
        /// <msdn-id>dn903914</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetGraphicsRootSignature([In] ID3D12RootSignature* pRootSignature)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetGraphicsRootSignature</unmanaged-short>	
        public void SetGraphicsRootSignature(SharpDX.Direct3D12.RootSignature rootSignatureRef) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((rootSignatureRef == null)?IntPtr.Zero:rootSignatureRef.NativePointer),((void**)(*(void**)_nativePointer))[30]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets the compute descriptor table. </p>	
        /// </summary>	
        /// <param name="rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>	
        /// <param name="baseDescriptor"><dd>  <p> A GPU_descriptor_handle object for the base descriptor to set. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetComputeRootDescriptorTable']/*"/>	
        /// <msdn-id>dn903904</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetComputeRootDescriptorTable([In] unsigned int RootParameterIndex,[In] D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetComputeRootDescriptorTable</unmanaged-short>	
        public void SetComputeRootDescriptorTable(int rootParameterIndex, SharpDX.Direct3D12.GpuDescriptorHandle baseDescriptor) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid48(_nativePointer, rootParameterIndex, baseDescriptor,((void**)(*(void**)_nativePointer))[31]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets the graphics descriptor table. </p>	
        /// </summary>	
        /// <param name="rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>	
        /// <param name="baseDescriptor"><dd>  <p> A GPU_descriptor_handle object for the base descriptor to set. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetGraphicsRootDescriptorTable']/*"/>	
        /// <msdn-id>dn903912</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetGraphicsRootDescriptorTable([In] unsigned int RootParameterIndex,[In] D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetGraphicsRootDescriptorTable</unmanaged-short>	
        public void SetGraphicsRootDescriptorTable(int rootParameterIndex, SharpDX.Direct3D12.GpuDescriptorHandle baseDescriptor) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid48(_nativePointer, rootParameterIndex, baseDescriptor,((void**)(*(void**)_nativePointer))[32]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets a constant in the compute root signature. </p>	
        /// </summary>	
        /// <param name="rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>	
        /// <param name="srcData"><dd>  <p> The source data for the constant to set. </p> </dd></param>	
        /// <param name="destOffsetIn32BitValues"><dd>  <p> The offset, in 32-bit values, to set the constant in the root signature. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetComputeRoot32BitConstant']/*"/>	
        /// <msdn-id>dn903901</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetComputeRoot32BitConstant([In] unsigned int RootParameterIndex,[In] unsigned int SrcData,[In] unsigned int DestOffsetIn32BitValues)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetComputeRoot32BitConstant</unmanaged-short>	
        public void SetComputeRoot32BitConstant(int rootParameterIndex, int srcData, int destOffsetIn32BitValues) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, rootParameterIndex, srcData, destOffsetIn32BitValues,((void**)(*(void**)_nativePointer))[33]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets a constant in the graphics root signature. </p>	
        /// </summary>	
        /// <param name="rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>	
        /// <param name="srcData"><dd>  <p> The source data for the constant to set. </p> </dd></param>	
        /// <param name="destOffsetIn32BitValues"><dd>  <p> The offset, in 32-bit values, to set the constant in the root signature. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetGraphicsRoot32BitConstant']/*"/>	
        /// <msdn-id>dn903909</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetGraphicsRoot32BitConstant([In] unsigned int RootParameterIndex,[In] unsigned int SrcData,[In] unsigned int DestOffsetIn32BitValues)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetGraphicsRoot32BitConstant</unmanaged-short>	
        public void SetGraphicsRoot32BitConstant(int rootParameterIndex, int srcData, int destOffsetIn32BitValues) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, rootParameterIndex, srcData, destOffsetIn32BitValues,((void**)(*(void**)_nativePointer))[34]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets a group of constants in the compute root signature. </p>	
        /// </summary>	
        /// <param name="rootParameterIndex"><dd>  <p>The slot number for binding.</p> </dd></param>	
        /// <param name="num32BitValuesToSet"><dd>  <p>The number of constants to set in the root signature.</p> </dd></param>	
        /// <param name="srcDataRef"><dd>  <p>The source data for the group of constants to set.</p> </dd></param>	
        /// <param name="destOffsetIn32BitValues"><dd>  <p>The offset, in 32-bit values, to set the first constant of the group in the root signature.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetComputeRoot32BitConstants']/*"/>	
        /// <msdn-id>dn903902</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetComputeRoot32BitConstants([In] unsigned int RootParameterIndex,[In] unsigned int Num32BitValuesToSet,[In, Buffer] const void* pSrcData,[In] unsigned int DestOffsetIn32BitValues)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetComputeRoot32BitConstants</unmanaged-short>	
        public void SetComputeRoot32BitConstants(int rootParameterIndex, int num32BitValuesToSet, System.IntPtr srcDataRef, int destOffsetIn32BitValues) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, rootParameterIndex, num32BitValuesToSet, (void*)srcDataRef, destOffsetIn32BitValues,((void**)(*(void**)_nativePointer))[35]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets a group of constants in the graphics root signature. </p>	
        /// </summary>	
        /// <param name="rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>	
        /// <param name="num32BitValuesToSet"><dd>  <p> The number of constants to set in the root signature. </p> </dd></param>	
        /// <param name="srcDataRef"><dd>  <p> The source data for the group of constants to set. </p> </dd></param>	
        /// <param name="destOffsetIn32BitValues"><dd>  <p> The offset, in 32-bit values, to set the first constant of the group in the root signature. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetGraphicsRoot32BitConstants']/*"/>	
        /// <msdn-id>dn903910</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetGraphicsRoot32BitConstants([In] unsigned int RootParameterIndex,[In] unsigned int Num32BitValuesToSet,[In, Buffer] const void* pSrcData,[In] unsigned int DestOffsetIn32BitValues)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetGraphicsRoot32BitConstants</unmanaged-short>	
        public void SetGraphicsRoot32BitConstants(int rootParameterIndex, int num32BitValuesToSet, System.IntPtr srcDataRef, int destOffsetIn32BitValues) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, rootParameterIndex, num32BitValuesToSet, (void*)srcDataRef, destOffsetIn32BitValues,((void**)(*(void**)_nativePointer))[36]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets a CPU descriptor handle for the constant buffer in the compute root signature. </p>	
        /// </summary>	
        /// <param name="rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>	
        /// <param name="bufferLocation"><dd>  <p> Specifies the D3D12_GPU_VIRTUAL_ADDRESS of the constant buffer. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetComputeRootConstantBufferView']/*"/>	
        /// <msdn-id>dn903903</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetComputeRootConstantBufferView([In] unsigned int RootParameterIndex,[In] unsigned longlong BufferLocation)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetComputeRootConstantBufferView</unmanaged-short>	
        public void SetComputeRootConstantBufferView(int rootParameterIndex, long bufferLocation) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, rootParameterIndex, bufferLocation,((void**)(*(void**)_nativePointer))[37]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets a CPU descriptor handle for the constant buffer in the graphics root signature. </p>	
        /// </summary>	
        /// <param name="rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>	
        /// <param name="bufferLocation"><dd>  <p> The GPU virtual address of the constant buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetGraphicsRootConstantBufferView']/*"/>	
        /// <msdn-id>dn903911</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetGraphicsRootConstantBufferView([In] unsigned int RootParameterIndex,[In] unsigned longlong BufferLocation)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetGraphicsRootConstantBufferView</unmanaged-short>	
        public void SetGraphicsRootConstantBufferView(int rootParameterIndex, long bufferLocation) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, rootParameterIndex, bufferLocation,((void**)(*(void**)_nativePointer))[38]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets a CPU descriptor handle for the shader resource in the compute root signature. </p>	
        /// </summary>	
        /// <param name="rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>	
        /// <param name="bufferLocation"><dd>  <p> The GPU virtual address of the buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetComputeRootShaderResourceView']/*"/>	
        /// <msdn-id>dn903905</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetComputeRootShaderResourceView([In] unsigned int RootParameterIndex,[In] unsigned longlong BufferLocation)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetComputeRootShaderResourceView</unmanaged-short>	
        public void SetComputeRootShaderResourceView(int rootParameterIndex, long bufferLocation) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, rootParameterIndex, bufferLocation,((void**)(*(void**)_nativePointer))[39]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets a CPU descriptor handle for the shader resource in the graphics root signature. </p>	
        /// </summary>	
        /// <param name="rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>	
        /// <param name="bufferLocation"><dd>  <p> The GPU virtual address of the constant buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetGraphicsRootShaderResourceView']/*"/>	
        /// <msdn-id>dn903913</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetGraphicsRootShaderResourceView([In] unsigned int RootParameterIndex,[In] unsigned longlong BufferLocation)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetGraphicsRootShaderResourceView</unmanaged-short>	
        public void SetGraphicsRootShaderResourceView(int rootParameterIndex, long bufferLocation) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, rootParameterIndex, bufferLocation,((void**)(*(void**)_nativePointer))[40]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets a CPU descriptor handle for the unordered-access-view resource in the compute root signature. </p>	
        /// </summary>	
        /// <param name="rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>	
        /// <param name="bufferLocation"><dd>  <p> The GPU virtual address of the buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.   </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetComputeRootUnorderedAccessView']/*"/>	
        /// <msdn-id>dn903907</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetComputeRootUnorderedAccessView([In] unsigned int RootParameterIndex,[In] unsigned longlong BufferLocation)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetComputeRootUnorderedAccessView</unmanaged-short>	
        public void SetComputeRootUnorderedAccessView(int rootParameterIndex, long bufferLocation) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, rootParameterIndex, bufferLocation,((void**)(*(void**)_nativePointer))[41]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets a CPU descriptor handle for the unordered-access-view resource in the graphics root signature. </p>	
        /// </summary>	
        /// <param name="rootParameterIndex"><dd>  <p> The slot number for binding. </p> </dd></param>	
        /// <param name="bufferLocation"><dd>  <p> The GPU virtual address of the buffer. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetGraphicsRootUnorderedAccessView']/*"/>	
        /// <msdn-id>dn903915</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetGraphicsRootUnorderedAccessView([In] unsigned int RootParameterIndex,[In] unsigned longlong BufferLocation)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetGraphicsRootUnorderedAccessView</unmanaged-short>	
        public void SetGraphicsRootUnorderedAccessView(int rootParameterIndex, long bufferLocation) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, rootParameterIndex, bufferLocation,((void**)(*(void**)_nativePointer))[42]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets the view for the index buffer. </p>	
        /// </summary>	
        /// <param name="viewRef"><dd>  <p> The view specifies the index buffer's address, size, and <strong><see cref="SharpDX.DXGI.Format"/></strong>, as a reference to a <strong><see cref="SharpDX.Direct3D12.IndexBufferView"/></strong> structure. </p> </dd></param>	
        /// <remarks>	
        /// <p>Only one index buffer can be bound to the graphics pipeline at any one time.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::IASetIndexBuffer']/*"/>	
        /// <msdn-id>dn986882</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::IASetIndexBuffer([In, Optional] const D3D12_INDEX_BUFFER_VIEW* pView)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::IASetIndexBuffer</unmanaged-short>	
        public void SetIndexBuffer(SharpDX.Direct3D12.IndexBufferView? viewRef) {
            unsafe {
                SharpDX.Direct3D12.IndexBufferView viewRef_;
                if (viewRef.HasValue)
                    viewRef_ = viewRef.Value;				
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (viewRef.HasValue)?&viewRef_:(void*)IntPtr.Zero,((void**)(*(void**)_nativePointer))[43]);		
            }
        }
        
        /// <summary>	
        /// <p>Sets a CPU descriptor handle for the vertex buffers.</p>	
        /// </summary>	
        /// <param name="startSlot"><dd>  <p> Index into the device's zero-based array to begin setting vertex buffers. </p> </dd></param>	
        /// <param name="numViews"><dd>  <p> The number of views in the <em>pViews</em> array. </p> </dd></param>	
        /// <param name="viewsRef"><dd>  <p> Specifies the vertex buffer views in an array of <strong><see cref="SharpDX.Direct3D12.VertexBufferView"/></strong> structures. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::IASetVertexBuffers']/*"/>	
        /// <msdn-id>dn986883</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::IASetVertexBuffers([In] unsigned int StartSlot,[In] unsigned int NumViews,[In] const void* pViews)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::IASetVertexBuffers</unmanaged-short>	
        private void SetVertexBuffers(int startSlot, int numViews, System.IntPtr viewsRef) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, startSlot, numViews, (void*)viewsRef,((void**)(*(void**)_nativePointer))[44]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets the stream output buffer views. </p>	
        /// </summary>	
        /// <param name="startSlot"><dd>  <p> Index into the device's zero-based array to begin setting stream output buffers. </p> </dd></param>	
        /// <param name="numViews"><dd>  <p> The number of entries in the <em>pViews</em> array. </p> </dd></param>	
        /// <param name="viewsRef"><dd>  <p> Specifies an array of  <strong><see cref="SharpDX.Direct3D12.StreamOutputBufferView"/></strong> structures. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SOSetTargets']/*"/>	
        /// <msdn-id>dn986886</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SOSetTargets([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const D3D12_STREAM_OUTPUT_BUFFER_VIEW* pViews)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SOSetTargets</unmanaged-short>	
        public void SOSetTargets(int startSlot, int numViews, SharpDX.Direct3D12.StreamOutputBufferView[] viewsRef) {
            unsafe {
                SharpDX.Direct3D12.StreamOutputBufferView[] viewsRef__ = viewsRef;
                fixed (void* viewsRef_ = viewsRef__)
                    SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, startSlot, numViews, viewsRef_,((void**)(*(void**)_nativePointer))[45]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets CPU descriptor handles for the render targets and depth stencil. </p>	
        /// </summary>	
        /// <param name="numRenderTargetDescriptors"><dd>  <p> The number of entries in the <em>pRenderTargetDescriptors</em> array. </p> </dd></param>	
        /// <param name="renderTargetDescriptorsRef"><dd>  <p> Specifies an array of <strong><see cref="SharpDX.Direct3D12.CpuDescriptorHandle"/></strong> structures that describe the CPU descriptor handles that represents the start of the heap of render target descriptors. </p> </dd></param>	
        /// <param name="rTsSingleHandleToDescriptorRange"><dd>  <p><strong>True</strong> means the handle passed in is the reference to a contiguous range of <em>NumRenderTargetDescriptors</em> descriptors.  This case is useful if the set of descriptors to bind already happens to be contiguous in memory (so all that?s needed is a handle to the first one).  For example, if  <em>NumRenderTargetDescriptors</em> is 3 then the memory layout is taken as follows:</p><p>In this case the driver dereferences the handle and then increments the memory being pointed to.</p> <p><strong>False</strong> means that the handle is the first of an array of <em>NumRenderTargetDescriptors</em> handles.  The false case allows an application to bind a set of descriptors from different locations at once. Again assuming that <em>NumRenderTargetDescriptors</em> is 3, the memory layout is taken as follows:</p><p>In this case the driver dereferences three handles that are expected to be adjacent to each other in memory.</p> </dd></param>	
        /// <param name="depthStencilDescriptorRef"><dd>  <p> A reference to a <strong><see cref="SharpDX.Direct3D12.CpuDescriptorHandle"/></strong> structure that describes the CPU descriptor handle that represents the start of the heap that holds the depth stencil descriptor. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::OMSetRenderTargets']/*"/>	
        /// <msdn-id>dn986884</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::OMSetRenderTargets([In] unsigned int NumRenderTargetDescriptors,[In, Optional] const void* pRenderTargetDescriptors,[In] BOOL RTsSingleHandleToDescriptorRange,[In, Optional] const D3D12_CPU_DESCRIPTOR_HANDLE* pDepthStencilDescriptor)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::OMSetRenderTargets</unmanaged-short>	
        private void SetRenderTargets(int numRenderTargetDescriptors, System.IntPtr renderTargetDescriptorsRef, SharpDX.Mathematics.Interop.RawBool rTsSingleHandleToDescriptorRange, SharpDX.Direct3D12.CpuDescriptorHandle? depthStencilDescriptorRef) {
            unsafe {
                SharpDX.Direct3D12.CpuDescriptorHandle depthStencilDescriptorRef_;
                if (depthStencilDescriptorRef.HasValue)
                    depthStencilDescriptorRef_ = depthStencilDescriptorRef.Value;				
                SharpDX.Direct3D12.LocalInterop.Callivoid52(_nativePointer, numRenderTargetDescriptors, (void*)renderTargetDescriptorsRef, rTsSingleHandleToDescriptorRange, (depthStencilDescriptorRef.HasValue)?&depthStencilDescriptorRef_:(void*)IntPtr.Zero,((void**)(*(void**)_nativePointer))[46]);		
            }
        }
        
        /// <summary>	
        /// <p>Clears the depth-stencil resource.</p>	
        /// </summary>	
        /// <param name="depthStencilView"><dd>  <p> Describes the CPU descriptor handle that represents the start of the heap for the depth stencil to be cleared. </p> </dd></param>	
        /// <param name="clearFlags"><dd>  <p> A combination of <strong><see cref="SharpDX.Direct3D12.ClearFlags"/></strong> values that are combined by using a bitwise OR operation. The resulting value identifies the type of data to clear (depth buffer, stencil buffer, or both). </p> </dd></param>	
        /// <param name="depth"><dd>  <p> A value to clear the depth buffer with. This value will be clamped between 0 and 1. </p> </dd></param>	
        /// <param name="stencil"><dd>  <p> A value to clear the stencil buffer with. </p> </dd></param>	
        /// <param name="numRects"><dd>  <p> The number of rectangles in the array that the <em>pRects</em> parameter specifies. </p> </dd></param>	
        /// <param name="rectsRef"><dd>  <p> An array of <strong>D3D12_RECT</strong> structures for the rectangles in the resource view to clear. If <strong><c>null</c></strong>, <strong>ClearDepthStencilView</strong> clears the entire resource view. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::ClearDepthStencilView']/*"/>	
        /// <msdn-id>dn903840</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::ClearDepthStencilView([In] D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView,[In] D3D12_CLEAR_FLAGS ClearFlags,[In] float Depth,[In] unsigned char Stencil,[In] unsigned int NumRects,[In, Buffer] const RECT* pRects)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::ClearDepthStencilView</unmanaged-short>	
        public void ClearDepthStencilView(SharpDX.Direct3D12.CpuDescriptorHandle depthStencilView, SharpDX.Direct3D12.ClearFlags clearFlags, float depth, byte stencil, int numRects, SharpDX.Mathematics.Interop.RawRectangle[] rectsRef) {
            unsafe {
                fixed (void* rectsRef_ = rectsRef)
                    SharpDX.Direct3D12.LocalInterop.Callivoid53(_nativePointer, depthStencilView, unchecked((int)clearFlags), depth, stencil, numRects, rectsRef_,((void**)(*(void**)_nativePointer))[47]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets all the elements in a render target to one value. </p>	
        /// </summary>	
        /// <param name="renderTargetView"><dd>  <p> Specifies a <see cref="SharpDX.Direct3D12.CpuDescriptorHandle"/> structure that describes the CPU descriptor handle that represents the start of the heap for the render target to be cleared. </p> </dd></param>	
        /// <param name="colorRGBA"><dd>  <p> A 4-component array that represents the color to fill the render target with. </p> </dd></param>	
        /// <param name="numRects"><dd>  <p> The number of rectangles in the array that the <em>pRects</em> parameter specifies. </p> </dd></param>	
        /// <param name="rectsRef"><dd>  <p> An array of <strong>D3D12_RECT</strong> structures for the rectangles in the resource view to clear. If <strong><c>null</c></strong>, <strong>ClearRenderTargetView</strong> clears the entire resource view. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::ClearRenderTargetView']/*"/>	
        /// <msdn-id>dn903842</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::ClearRenderTargetView([In] D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView,[In] const SHARPDX_COLOR4* ColorRGBA,[In] unsigned int NumRects,[In, Buffer] const RECT* pRects)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::ClearRenderTargetView</unmanaged-short>	
        public void ClearRenderTargetView(SharpDX.Direct3D12.CpuDescriptorHandle renderTargetView, SharpDX.Mathematics.Interop.RawColor4 colorRGBA, int numRects, SharpDX.Mathematics.Interop.RawRectangle[] rectsRef) {
            unsafe {
                fixed (void* rectsRef_ = rectsRef)
                    SharpDX.Direct3D12.LocalInterop.Callivoid54(_nativePointer, renderTargetView, &colorRGBA, numRects, rectsRef_,((void**)(*(void**)_nativePointer))[48]);		
            }
        }
        
        /// <summary>	
        /// <p> Sets all the elements in a unordered-access view to the specified integer values. </p>	
        /// </summary>	
        /// <param name="viewGPUHandleInCurrentHeap"><dd>  <p> A <strong><see cref="SharpDX.Direct3D12.GpuDescriptorHandle"/></strong> structure that describes the GPU descriptor handle that represents the start of the heap for the unordered-access view to clear. </p> </dd></param>	
        /// <param name="viewCPUHandle"><dd>  <p> A <strong><see cref="SharpDX.Direct3D12.CpuDescriptorHandle"/></strong> structure that describes the CPU descriptor handle that represents the start of the heap for the render target to clear. </p> </dd></param>	
        /// <param name="resourceRef"><dd>  <p> A reference to the <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> interface that represents the unordered-access-view resource to clear. </p> </dd></param>	
        /// <param name="values"><dd>  <p> A 4-component array that containing the values to fill the unordered-access-view resource with. </p> </dd></param>	
        /// <param name="numRects"><dd>  <p> The number of rectangles in the array that the <em>pRects</em> parameter specifies. </p> </dd></param>	
        /// <param name="rectsRef"><dd>  <p> An array of <strong>D3D12_RECT</strong> structures for the rectangles in the resource view to clear. If <strong><c>null</c></strong>, <strong>ClearUnorderedAccessViewUint</strong> clears the entire resource view. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::ClearUnorderedAccessViewUint']/*"/>	
        /// <msdn-id>dn903853</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::ClearUnorderedAccessViewUint([In] D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,[In] D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,[In] ID3D12Resource* pResource,[In] const SHARPDX_INT4* Values,[In] unsigned int NumRects,[In, Buffer] const RECT* pRects)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::ClearUnorderedAccessViewUint</unmanaged-short>	
        public void ClearUnorderedAccessViewUint(SharpDX.Direct3D12.GpuDescriptorHandle viewGPUHandleInCurrentHeap, SharpDX.Direct3D12.CpuDescriptorHandle viewCPUHandle, SharpDX.Direct3D12.Resource resourceRef, SharpDX.Mathematics.Interop.RawInt4 values, int numRects, SharpDX.Mathematics.Interop.RawRectangle[] rectsRef) {
            unsafe {
                fixed (void* rectsRef_ = rectsRef)
                    SharpDX.Direct3D12.LocalInterop.Callivoid55(_nativePointer, viewGPUHandleInCurrentHeap, viewCPUHandle, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), &values, numRects, rectsRef_,((void**)(*(void**)_nativePointer))[49]);		
            }
        }
        
        /// <summary>	
        /// <p>Sets all the elements in a unordered access view to the specified float values.</p>	
        /// </summary>	
        /// <param name="viewGPUHandleInCurrentHeap"><dd>  <p> Describes the GPU descriptor handle that represents the start of the heap for the unordered-access view to clear. </p> </dd></param>	
        /// <param name="viewCPUHandle"><dd>  <p> Describes the CPU descriptor handle that represents the start of the heap for the render target to clear. </p> </dd></param>	
        /// <param name="resourceRef"><dd>  <p> A reference to the <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> interface that represents the unordered-access-view resource to clear. </p> </dd></param>	
        /// <param name="values"><dd>  <p> A 4-component array that containing the values to fill the unordered-access-view resource with. </p> </dd></param>	
        /// <param name="numRects"><dd>  <p> The number of rectangles in the array that the <em>pRects</em> parameter specifies. </p> </dd></param>	
        /// <param name="rectsRef"><dd>  <p> An array of <strong>D3D12_RECT</strong> structures for the rectangles in the resource view to clear. If <strong><c>null</c></strong>, <strong>ClearUnorderedAccessViewFloat</strong> clears the entire resource view. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::ClearUnorderedAccessViewFloat']/*"/>	
        /// <msdn-id>dn903849</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::ClearUnorderedAccessViewFloat([In] D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,[In] D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,[In] ID3D12Resource* pResource,[In] const SHARPDX_VECTOR4* Values,[In] unsigned int NumRects,[In, Buffer] const RECT* pRects)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::ClearUnorderedAccessViewFloat</unmanaged-short>	
        public void ClearUnorderedAccessViewFloat(SharpDX.Direct3D12.GpuDescriptorHandle viewGPUHandleInCurrentHeap, SharpDX.Direct3D12.CpuDescriptorHandle viewCPUHandle, SharpDX.Direct3D12.Resource resourceRef, SharpDX.Mathematics.Interop.RawVector4 values, int numRects, SharpDX.Mathematics.Interop.RawRectangle[] rectsRef) {
            unsafe {
                fixed (void* rectsRef_ = rectsRef)
                    SharpDX.Direct3D12.LocalInterop.Callivoid55(_nativePointer, viewGPUHandleInCurrentHeap, viewCPUHandle, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), &values, numRects, rectsRef_,((void**)(*(void**)_nativePointer))[50]);		
            }
        }
        
        /// <summary>	
        /// <p>Discards a resource.</p>	
        /// </summary>	
        /// <param name="resourceRef"><dd>  <p> A reference to the <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> interface for the resource to discard. The resource must have been created with usage <strong><see cref="SharpDX.Direct3D11.ResourceUsage.Default"/></strong> or <strong><see cref="SharpDX.Direct3D11.ResourceUsage.Dynamic"/></strong>, otherwise the runtime drops the call to <strong>DiscardResource</strong>; if the debug layer is enabled, the runtime returns an error message. </p> </dd></param>	
        /// <param name="regionRef"><dd>  <p> A reference to a <strong><see cref="SharpDX.Direct3D12.DiscardRegion"/></strong> structure that describes details for the discard-resource operation. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::DiscardResource']/*"/>	
        /// <msdn-id>dn903869</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::DiscardResource([In] ID3D12Resource* pResource,[In, Optional] const D3D12_DISCARD_REGION* pRegion)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::DiscardResource</unmanaged-short>	
        public void DiscardResource(SharpDX.Direct3D12.Resource resourceRef, SharpDX.Direct3D12.DiscardRegion? regionRef) {
            unsafe {
                SharpDX.Direct3D12.DiscardRegion regionRef_;
                if (regionRef.HasValue)
                    regionRef_ = regionRef.Value;				
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (regionRef.HasValue)?&regionRef_:(void*)IntPtr.Zero,((void**)(*(void**)_nativePointer))[51]);		
            }
        }
        
        /// <summary>	
        /// <p>Starts a query running.</p>	
        /// </summary>	
        /// <param name="queryHeapRef"><dd>  <p> Specifies the <strong><see cref="SharpDX.Direct3D12.QueryHeap"/></strong> containing the query. </p> </dd></param>	
        /// <param name="type"><dd>  <p> Specifies one member of <strong><see cref="SharpDX.Direct3D12.QueryType"/></strong>. </p> </dd></param>	
        /// <param name="index"><dd>  <p> Specifies the index of the query within the query heap. </p> </dd></param>	
        /// <remarks>	
        /// <p> In Direct3D 12, the usage of queries is more restricted than Direct3D 11.  The following scenarios are no longer supported: </p><ul> <li> A call to <strong>BeginQuery</strong> followed by another call to  <strong>BeginQuery</strong> without an intervening call to <strong>EndQuery</strong>. </li> <li> A call to <strong>EndQuery</strong> followed by <strong>EndQuery</strong> without an intervening call to <strong>BeginQuery</strong>. </li> </ul><p> Given these restrictions, there are 3 states that a query can be in: </p><ul> <li>Inactive (this is the initial state of all queries)</li> <li>Querying</li> <li>Predicating</li> </ul><p><strong>BeginQuery</strong> transitions a query from the inactive state to the querying state. <strong>EndQuery</strong> transitions a query from the querying state to the inactive state. <strong>SetPredication</strong> transitions the previous set query from the predicating state to the inactive state and transitions the newly set query from the inactive state to the predicating state. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::BeginQuery']/*"/>	
        /// <msdn-id>dn903838</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::BeginQuery([In] ID3D12QueryHeap* pQueryHeap,[In] D3D12_QUERY_TYPE Type,[In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::BeginQuery</unmanaged-short>	
        public void BeginQuery(SharpDX.Direct3D12.QueryHeap queryHeapRef, SharpDX.Direct3D12.QueryType type, int index) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((queryHeapRef == null)?IntPtr.Zero:queryHeapRef.NativePointer), unchecked((int)type), index,((void**)(*(void**)_nativePointer))[52]);		
            }
        }
        
        /// <summary>	
        /// <p> Ends a running query. </p>	
        /// </summary>	
        /// <param name="queryHeapRef"><dd>  <p> Specifies the <strong><see cref="SharpDX.Direct3D12.QueryHeap"/></strong> containing the query. </p> </dd></param>	
        /// <param name="type"><dd>  <p> Specifies one member of <strong><see cref="SharpDX.Direct3D12.QueryType"/></strong>. </p> </dd></param>	
        /// <param name="index"><dd>  <p> Specifies the index of the query in the query heap. </p> </dd></param>	
        /// <remarks>	
        /// <p> Refer to the remarks for <strong>BeginQuery</strong>, and to Queries. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::EndQuery']/*"/>	
        /// <msdn-id>dn903881</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::EndQuery([In] ID3D12QueryHeap* pQueryHeap,[In] D3D12_QUERY_TYPE Type,[In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::EndQuery</unmanaged-short>	
        public void EndQuery(SharpDX.Direct3D12.QueryHeap queryHeapRef, SharpDX.Direct3D12.QueryType type, int index) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((queryHeapRef == null)?IntPtr.Zero:queryHeapRef.NativePointer), unchecked((int)type), index,((void**)(*(void**)_nativePointer))[53]);		
            }
        }
        
        /// <summary>	
        /// <p> </p><p> Extracts data from a query. <strong>ResolveQueryData</strong> works with all heap types (default, upload, and readback).? </p>	
        /// </summary>	
        /// <param name="queryHeapRef"><dd>  <p> Specifies the  <strong><see cref="SharpDX.Direct3D12.QueryHeap"/></strong> containing the queries to resolve. </p> </dd></param>	
        /// <param name="type"><dd>  <p> Specifies the type of query, one member of <strong><see cref="SharpDX.Direct3D12.QueryType"/></strong>. </p> </dd></param>	
        /// <param name="startIndex"><dd>  <p> Specifies an index of the first query to resolve. </p> </dd></param>	
        /// <param name="numQueries"><dd>  <p> Specifies the number of queries to resolve. </p> </dd></param>	
        /// <param name="destinationBufferRef"><dd>  <p> Specifies an <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> destination buffer, which must be in the state <strong><see cref="SharpDX.Direct3D12.ResourceStates.CopyDestination"/></strong>. </p> </dd></param>	
        /// <param name="alignedDestinationBufferOffset"><dd>  <p> Specifies an alignment offset into the destination buffer. Must be a multiple of 8 bytes. </p> </dd></param>	
        /// <remarks>	
        /// <p><strong>ResolveQueryData</strong> performs a batched operation which writes query data into a destination buffer.  Query data is written contiguously to the destination buffer, and the parameter. </p><p> Binary occlusion queries write 64-bits per query.  The least significant bit is either 0 or 1.  The rest of the bits are 0. </p><p>The core runtime will validate the following:</p><ul> <li><em>StartIndex</em> and <em>NumQueries</em> are within range. </li> <li><em>AlignedDestinationBufferOffset</em> is a multiple of 8 bytes. </li> <li><em>DestinationBuffer</em> is a buffer. </li> <li> The written data will not overflow the output buffer. </li> <li> The query type must be supported by the command list type. </li> <li> The query type must be supported by the query heap. </li> </ul><p> The debug layer will issue a warning if the destination buffer is not in the <see cref="SharpDX.Direct3D12.ResourceStates.CopyDestination"/> state. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::ResolveQueryData']/*"/>	
        /// <msdn-id>dn903896</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::ResolveQueryData([In] ID3D12QueryHeap* pQueryHeap,[In] D3D12_QUERY_TYPE Type,[In] unsigned int StartIndex,[In] unsigned int NumQueries,[In] ID3D12Resource* pDestinationBuffer,[In] unsigned longlong AlignedDestinationBufferOffset)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::ResolveQueryData</unmanaged-short>	
        public void ResolveQueryData(SharpDX.Direct3D12.QueryHeap queryHeapRef, SharpDX.Direct3D12.QueryType type, int startIndex, int numQueries, SharpDX.Direct3D12.Resource destinationBufferRef, long alignedDestinationBufferOffset) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((queryHeapRef == null)?IntPtr.Zero:queryHeapRef.NativePointer), unchecked((int)type), startIndex, numQueries, (void*)((destinationBufferRef == null)?IntPtr.Zero:destinationBufferRef.NativePointer), alignedDestinationBufferOffset,((void**)(*(void**)_nativePointer))[54]);		
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="bufferRef">No documentation.</param>	
        /// <param name="alignedBufferOffset">No documentation.</param>	
        /// <param name="operation">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetPredication']/*"/>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetPredication([In, Optional] ID3D12Resource* pBuffer,[In] unsigned longlong AlignedBufferOffset,[In] D3D12_PREDICATION_OP Operation)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetPredication</unmanaged-short>	
        public void SetPredication(SharpDX.Direct3D12.Resource bufferRef, long alignedBufferOffset, SharpDX.Direct3D12.PredicationOperation operation) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((bufferRef == null)?IntPtr.Zero:bufferRef.NativePointer), alignedBufferOffset, unchecked((int)operation),((void**)(*(void**)_nativePointer))[55]);		
            }
        }
        
        /// <summary>	
        /// <p> For internal use only.</p>	
        /// </summary>	
        /// <param name="metadata"><dd>  <p> Internal. </p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>Internal.</p> </dd></param>	
        /// <param name="size"><dd>  <p> Internal.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::SetMarker']/*"/>	
        /// <msdn-id>dn986885</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::SetMarker([In] unsigned int Metadata,[In, Buffer, Optional] const void* pData,[In] unsigned int Size)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::SetMarker</unmanaged-short>	
        public void SetMarker(int metadata, System.IntPtr dataRef, int size) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, metadata, (void*)dataRef, size,((void**)(*(void**)_nativePointer))[56]);		
            }
        }
        
        /// <summary>	
        /// <p> For internal use only. </p>	
        /// </summary>	
        /// <param name="metadata"><dd>  <p> Internal. </p> </dd></param>	
        /// <param name="dataRef"><dd>  <p> Internal. </p> </dd></param>	
        /// <param name="size"><dd>  <p> Internal. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::BeginEvent']/*"/>	
        /// <msdn-id>dn986879</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::BeginEvent([In] unsigned int Metadata,[In, Buffer, Optional] const void* pData,[In] unsigned int Size)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::BeginEvent</unmanaged-short>	
        public void BeginEvent(int metadata, System.IntPtr dataRef, int size) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, metadata, (void*)dataRef, size,((void**)(*(void**)_nativePointer))[57]);		
            }
        }
        
        /// <summary>	
        /// <p>For internal use only. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::EndEvent']/*"/>	
        /// <msdn-id>dn903879</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::EndEvent()</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::EndEvent</unmanaged-short>	
        public void EndEvent() {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[58]);		
            }
        }
        
        /// <summary>	
        /// <p> Apps perform indirect draws/dispatches using the <strong>ExecuteIndirect</strong> method. </p>	
        /// </summary>	
        /// <param name="commandSignatureRef"><dd>  <p> Specifies a <strong><see cref="SharpDX.Direct3D12.CommandSignature"/></strong>. The data referenced by <em>pArgumentBuffer</em> will be interpreted depending on the contents of the command signature. Refer to Indirect Drawing for the APIs that are used to create a command signature. </p> </dd></param>	
        /// <param name="maxCommandCount"><dd>  <p>There are two ways that command counts can be specified:</p> <ul> <li> If <em>pCountBuffer</em> is not <c>null</c>, then <em>MaxCommandCount</em> specifies the maximum number of operations which will be performed.  The actual number of operations to be performed are defined by the minimum of this value, and a 32-bit unsigned integer contained in <em>pCountBuffer</em> (at the byte offset specified by <em>CountBufferOffset</em>). </li> <li> If <em>pCountBuffer</em> is <c>null</c>, the <em>MaxCommandCount</em> specifies the exact number of operations which will be performed. </li> </ul> </dd></param>	
        /// <param name="argumentBufferRef"><dd>  <p> Specifies one or more <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> objects, containing the command arguments. </p> </dd></param>	
        /// <param name="argumentBufferOffset"><dd>  <p> Specifies an offset into <em>pArgumentBuffer</em> to identify the first command argument. </p> </dd></param>	
        /// <param name="countBufferRef"><dd>  <p> Specifies a reference to a <strong><see cref="SharpDX.Direct3D12.Resource"/></strong>. </p> </dd></param>	
        /// <param name="countBufferOffset"><dd>  <p> Specifies a UINT64 that is the offset into <em>pCountBuffer</em>, identifying the argument count. </p> </dd></param>	
        /// <remarks>	
        /// <p>The semantics of this API are defined with the following pseudo-code:</p><p>Non-<c>null</c> pCountBuffer:</p><code>// Read draw count out of count buffer	
        /// UINT CommandCount = pCountBuffer-&gt;ReadUINT32(CountBufferOffset); CommandCount = min(CommandCount, MaxCommandCount) // Get reference to first Commanding argument	
        /// BYTE* Arguments = pArgumentBuffer-&gt;GetBase() + ArgumentBufferOffset; for(UINT CommandIndex = 0; CommandIndex &lt; CommandCount; CommandIndex++)	
        /// { // Interpret the data contained in *Arguments // according to the command signature pCommandSignature-&gt;Interpret(Arguments); Arguments += pCommandSignature -&gt;GetByteStride();	
        /// }	
        /// </code><p><c>null</c> pCountBuffer:</p><code>// Get reference to first Commanding argument	
        /// BYTE* Arguments = pArgumentBuffer-&gt;GetBase() + ArgumentBufferOffset; for(UINT CommandIndex = 0; CommandIndex &lt; MaxCommandCount; CommandIndex++)	
        /// { // Interpret the data contained in *Arguments // according to the command signature pCommandSignature-&gt;Interpret(Arguments); Arguments += pCommandSignature -&gt;GetByteStride();	
        /// }	
        /// </code><p>The debug layer will issue an error if either the count buffer or the argument buffer are not in the <see cref="SharpDX.Direct3D12.ResourceStates.IndirectArgument"/> state. The core runtime will validate:</p><ul> <li><em>CountBufferOffset</em> and <em>ArgumentBufferOffset</em> are 4-byte aligned </li> <li><em>pCountBuffer</em> and <em>pArgumentBuffer</em> are buffer resources (any heap type) </li> <li> The offset implied by <em>MaxCommandCount</em>, <em>ArgumentBufferOffset</em>, and the drawing program stride do not exceed the bounds of <em>pArgumentBuffer</em> (similarly for count buffer) </li> <li>The command list is a direct command list or a compute command list (not a copy or JPEG decode command list)</li> <li>The root signature of the command list matches the root signature of the command signature</li> </ul><p> The functionality of two APIs from earlier versions of Direct3D, <code>DrawInstancedIndirect</code> and <code>DrawIndexedInstancedIndirect</code>, are encompassed by  <strong>ExecuteIndirect</strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12GraphicsCommandList::ExecuteIndirect']/*"/>	
        /// <msdn-id>dn903884</msdn-id>	
        /// <unmanaged>void ID3D12GraphicsCommandList::ExecuteIndirect([In] ID3D12CommandSignature* pCommandSignature,[In] unsigned int MaxCommandCount,[In] ID3D12Resource* pArgumentBuffer,[In] unsigned longlong ArgumentBufferOffset,[In, Optional] ID3D12Resource* pCountBuffer,[In] unsigned longlong CountBufferOffset)</unmanaged>	
        /// <unmanaged-short>ID3D12GraphicsCommandList::ExecuteIndirect</unmanaged-short>	
        public void ExecuteIndirect(SharpDX.Direct3D12.CommandSignature commandSignatureRef, int maxCommandCount, SharpDX.Direct3D12.Resource argumentBufferRef, long argumentBufferOffset, SharpDX.Direct3D12.Resource countBufferRef, long countBufferOffset) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, (void*)((commandSignatureRef == null)?IntPtr.Zero:commandSignatureRef.NativePointer), maxCommandCount, (void*)((argumentBufferRef == null)?IntPtr.Zero:argumentBufferRef.NativePointer), argumentBufferOffset, (void*)((countBufferRef == null)?IntPtr.Zero:countBufferRef.NativePointer), countBufferOffset,((void**)(*(void**)_nativePointer))[59]);		
            }
        }
    }
    /// <summary>	
    /// <p>A heap  is an abstraction of contiguous memory allocation, used to manage physical memory. This heap can be used with <strong><see cref="SharpDX.Direct3D12.Resource"/></strong> objects to support placed resources or reserved resources.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Heap']/*"/>	
    /// <msdn-id>dn788687</msdn-id>	
    /// <unmanaged>ID3D12Heap</unmanaged>	
    /// <unmanaged-short>ID3D12Heap</unmanaged-short>	
    [Guid("6b3b2502-6e51-45b3-90ee-9884265e8df3")]
    public partial class Heap : SharpDX.Direct3D12.Pageable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.Heap"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Heap(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.Heap"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.Heap(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.Heap(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the heap description.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Heap::GetDesc']/*"/>	
        /// <msdn-id>dn788689</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>D3D12_HEAP_DESC ID3D12Heap::GetDesc()</unmanaged>
        public SharpDX.Direct3D12.HeapDescription Description {
                get { return GetDescription(); }
        }
        
        /// <summary>	
        /// <p>Gets the heap description.</p>	
        /// </summary>	
        /// <returns><p>Returns the <strong><see cref="SharpDX.Direct3D12.HeapDescription"/></strong> structure that describes the heap.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Heap::GetDesc']/*"/>	
        /// <msdn-id>dn788689</msdn-id>	
        /// <unmanaged>D3D12_HEAP_DESC ID3D12Heap::GetDesc()</unmanaged>	
        /// <unmanaged-short>ID3D12Heap::GetDesc</unmanaged-short>	
        internal SharpDX.Direct3D12.HeapDescription GetDescription() {
            unsafe {
                SharpDX.Direct3D12.HeapDescription __result__;
                SharpDX.Direct3D12.LocalInterop.CallivoidPtr(_nativePointer,(void*)&__result__,((void**)(*(void**)_nativePointer))[8]);		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p> An information-queue interface stores, retrieves, and filters debug messages. The queue consists of a message queue, an optional storage filter stack, and a optional retrieval filter stack. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is obtained by querying it from the <strong><see cref="SharpDX.Direct3D12.Device"/></strong> using <code>IUnknown::QueryInterface</code>.  </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue']/*"/>	
    /// <msdn-id>dn950163</msdn-id>	
    /// <unmanaged>ID3D12InfoQueue</unmanaged>	
    /// <unmanaged-short>ID3D12InfoQueue</unmanaged-short>	
    [Guid("0742a90b-c387-483f-b946-30a7e4e61458")]
    public partial class InfoQueue : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.InfoQueue"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public InfoQueue(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.InfoQueue"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.InfoQueue(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.InfoQueue(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get or sets the maximum number of messages that can be added to the message queue. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetMessageCountLimit']/*"/>	
        /// <msdn-id>dn950175</msdn-id>	
        /// <unmanaged>GetMessageCountLimit / SetMessageCountLimit</unmanaged>	
        /// <unmanaged-short>GetMessageCountLimit</unmanaged-short>	
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetMessageCountLimit()</unmanaged>
        public long MessageCountLimit {
                get { return GetMessageCountLimit(); }
                set { SetMessageCountLimit(value); }
        }
        
        /// <summary>	
        /// <p> Get the number of messages that were allowed to pass through a storage filter. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetNumMessagesAllowedByStorageFilter']/*"/>	
        /// <msdn-id>dn950177</msdn-id>	
        /// <unmanaged>GetNumMessagesAllowedByStorageFilter</unmanaged>	
        /// <unmanaged-short>GetNumMessagesAllowedByStorageFilter</unmanaged-short>	
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetNumMessagesAllowedByStorageFilter()</unmanaged>
        public long NumMessagesAllowedByStorageFilter {
                get { return GetNumMessagesAllowedByStorageFilter(); }
        }
        
        /// <summary>	
        /// <p>Get the number of messages that were denied passage through a storage filter. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetNumMessagesDeniedByStorageFilter']/*"/>	
        /// <msdn-id>dn950178</msdn-id>	
        /// <unmanaged>GetNumMessagesDeniedByStorageFilter</unmanaged>	
        /// <unmanaged-short>GetNumMessagesDeniedByStorageFilter</unmanaged-short>	
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetNumMessagesDeniedByStorageFilter()</unmanaged>
        public long NumMessagesDeniedByStorageFilter {
                get { return GetNumMessagesDeniedByStorageFilter(); }
        }
        
        /// <summary>	
        /// <p> Get the number of messages currently stored in the message queue. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetNumStoredMessages']/*"/>	
        /// <msdn-id>dn950180</msdn-id>	
        /// <unmanaged>GetNumStoredMessages</unmanaged>	
        /// <unmanaged-short>GetNumStoredMessages</unmanaged-short>	
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetNumStoredMessages()</unmanaged>
        public long NumStoredMessages {
                get { return GetNumStoredMessages(); }
        }
        
        /// <summary>	
        /// <p> Get the number of messages that are able to pass through a retrieval filter. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetNumStoredMessagesAllowedByRetrievalFilter']/*"/>	
        /// <msdn-id>dn950181</msdn-id>	
        /// <unmanaged>GetNumStoredMessagesAllowedByRetrievalFilter</unmanaged>	
        /// <unmanaged-short>GetNumStoredMessagesAllowedByRetrievalFilter</unmanaged-short>	
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetNumStoredMessagesAllowedByRetrievalFilter()</unmanaged>
        public long NumStoredMessagesAllowedByRetrievalFilter {
                get { return GetNumStoredMessagesAllowedByRetrievalFilter(); }
        }
        
        /// <summary>	
        /// <p> Get the number of messages that were discarded due to the message count limit. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Get and set the message count limit with <strong>GetMessageCountLimit</strong> and <strong>SetMessageCountLimit</strong>, respectively. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetNumMessagesDiscardedByMessageCountLimit']/*"/>	
        /// <msdn-id>dn950179</msdn-id>	
        /// <unmanaged>GetNumMessagesDiscardedByMessageCountLimit</unmanaged>	
        /// <unmanaged-short>GetNumMessagesDiscardedByMessageCountLimit</unmanaged-short>	
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetNumMessagesDiscardedByMessageCountLimit()</unmanaged>
        public long NumMessagesDiscardedByMessageCountLimit {
                get { return GetNumMessagesDiscardedByMessageCountLimit(); }
        }
        
        /// <summary>	
        /// <p> Get the size of the storage-filter stack in bytes. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetStorageFilterStackSize']/*"/>	
        /// <msdn-id>dn950185</msdn-id>	
        /// <unmanaged>GetStorageFilterStackSize</unmanaged>	
        /// <unmanaged-short>GetStorageFilterStackSize</unmanaged-short>	
        /// <unmanaged>unsigned int ID3D12InfoQueue::GetStorageFilterStackSize()</unmanaged>
        public int StorageFilterStackSize {
                get { return GetStorageFilterStackSize(); }
        }
        
        /// <summary>	
        /// <p> Get the size of the retrieval-filter stack in bytes. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetRetrievalFilterStackSize']/*"/>	
        /// <msdn-id>dn950183</msdn-id>	
        /// <unmanaged>GetRetrievalFilterStackSize</unmanaged>	
        /// <unmanaged-short>GetRetrievalFilterStackSize</unmanaged-short>	
        /// <unmanaged>unsigned int ID3D12InfoQueue::GetRetrievalFilterStackSize()</unmanaged>
        public int RetrievalFilterStackSize {
                get { return GetRetrievalFilterStackSize(); }
        }
        
        /// <summary>	
        /// <p>Get or sets a boolean that determines if debug output is on or off. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetMuteDebugOutput']/*"/>	
        /// <msdn-id>dn950176</msdn-id>	
        /// <unmanaged>GetMuteDebugOutput / SetMuteDebugOutput</unmanaged>	
        /// <unmanaged-short>GetMuteDebugOutput</unmanaged-short>	
        /// <unmanaged>BOOL ID3D12InfoQueue::GetMuteDebugOutput()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool MuteDebugOutput {
                get { return GetMuteDebugOutput(); }
                set { SetMuteDebugOutput(value); }
        }
        
        /// <summary>	
        /// <p> Set the maximum number of messages that can be added to the message queue. </p>	
        /// </summary>	
        /// <param name="messageCountLimit"><dd>  <p> Maximum number of messages that can be added to the message queue. -1 means no limit. When the number of messages in the message queue has reached the maximum limit, new messages coming in will push old messages out. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::SetMessageCountLimit']/*"/>	
        /// <msdn-id>dn950198</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::SetMessageCountLimit([In] unsigned longlong MessageCountLimit)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::SetMessageCountLimit</unmanaged-short>	
        internal void SetMessageCountLimit(long messageCountLimit) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, messageCountLimit,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Clear all messages from the message queue. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::ClearStoredMessages']/*"/>	
        /// <msdn-id>dn950170</msdn-id>	
        /// <unmanaged>void ID3D12InfoQueue::ClearStoredMessages()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::ClearStoredMessages</unmanaged-short>	
        public void ClearStoredMessages() {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
            }
        }
        
        /// <summary>	
        /// <p> Get a message from the message queue. </p>	
        /// </summary>	
        /// <param name="messageIndex"><dd>  <p>Index into message queue after an optional retrieval filter has been applied. This can be between 0 and the number of messages in the message queue that pass through the retrieval filter (which can be obtained with <strong>GetNumStoredMessagesAllowedByRetrievalFilter</strong>). 0 is the message at the front of the message queue. </p> </dd></param>	
        /// <param name="messageRef"><dd>  <p> Returned message.</p> </dd></param>	
        /// <param name="messageByteLengthRef"><dd>  <p>Size of <em>pMessage</em> in bytes. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <remarks>	
        /// <p>This method does not remove any messages from the message queue. </p><p>This method gets messages from the message queue after an optional retrieval filter has been applied. </p><p>Applications should call this method twice to retrieve a message - first to obtain the size of the message and second to get the message. Here is a typical example: </p><code> // Get the size of the message	
        /// <see cref="SharpDX.PointerSize"/> messageLength = 0;	
        /// <see cref="SharpDX.Result"/> hr = pInfoQueue-&gt;GetMessage(0, <c>null</c>, &amp;messageLength); // Allocate space and get the message	
        /// <see cref="SharpDX.Direct3D12.Message"/> * pMessage = (<see cref="SharpDX.Direct3D12.Message"/>*)malloc(messageLength);	
        /// hr = pInfoQueue-&gt;GetMessage(0, pMessage, &amp;messageLength); 	
        /// </code>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetMessageW']/*"/>	
        /// <msdn-id>dn950174</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::GetMessageW([In] unsigned longlong MessageIndex,[In] void* pMessage,[InOut] SIZE_T* pMessageByteLength)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::GetMessageW</unmanaged-short>	
        internal void GetMessage(long messageIndex, System.IntPtr messageRef, ref SharpDX.PointerSize messageByteLengthRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* messageByteLengthRef_ = &messageByteLengthRef)
                    __result__= 
    				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, messageIndex, (void*)messageRef, messageByteLengthRef_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Get the number of messages that were allowed to pass through a storage filter. </p>	
        /// </summary>	
        /// <returns><p> Number of messages allowed by a storage filter. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetNumMessagesAllowedByStorageFilter']/*"/>	
        /// <msdn-id>dn950177</msdn-id>	
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetNumMessagesAllowedByStorageFilter()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::GetNumMessagesAllowedByStorageFilter</unmanaged-short>	
        internal long GetNumMessagesAllowedByStorageFilter() {
            unsafe {
                long __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Callilong(_nativePointer,((void**)(*(void**)_nativePointer))[6]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get the number of messages that were denied passage through a storage filter. </p>	
        /// </summary>	
        /// <returns><p> Number of messages denied by a storage filter. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetNumMessagesDeniedByStorageFilter']/*"/>	
        /// <msdn-id>dn950178</msdn-id>	
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetNumMessagesDeniedByStorageFilter()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::GetNumMessagesDeniedByStorageFilter</unmanaged-short>	
        internal long GetNumMessagesDeniedByStorageFilter() {
            unsafe {
                long __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Callilong(_nativePointer,((void**)(*(void**)_nativePointer))[7]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Get the number of messages currently stored in the message queue. </p>	
        /// </summary>	
        /// <returns><p> Number of messages currently stored in the message queue. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetNumStoredMessages']/*"/>	
        /// <msdn-id>dn950180</msdn-id>	
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetNumStoredMessages()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::GetNumStoredMessages</unmanaged-short>	
        internal long GetNumStoredMessages() {
            unsafe {
                long __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Callilong(_nativePointer,((void**)(*(void**)_nativePointer))[8]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Get the number of messages that are able to pass through a retrieval filter. </p>	
        /// </summary>	
        /// <returns><p>Number of messages allowed by a retrieval filter. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetNumStoredMessagesAllowedByRetrievalFilter']/*"/>	
        /// <msdn-id>dn950181</msdn-id>	
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetNumStoredMessagesAllowedByRetrievalFilter()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::GetNumStoredMessagesAllowedByRetrievalFilter</unmanaged-short>	
        internal long GetNumStoredMessagesAllowedByRetrievalFilter() {
            unsafe {
                long __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Callilong(_nativePointer,((void**)(*(void**)_nativePointer))[9]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Get the number of messages that were discarded due to the message count limit. </p>	
        /// </summary>	
        /// <returns><p> Number of messages discarded. </p></returns>	
        /// <remarks>	
        /// <p>Get and set the message count limit with <strong>GetMessageCountLimit</strong> and <strong>SetMessageCountLimit</strong>, respectively. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetNumMessagesDiscardedByMessageCountLimit']/*"/>	
        /// <msdn-id>dn950179</msdn-id>	
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetNumMessagesDiscardedByMessageCountLimit()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::GetNumMessagesDiscardedByMessageCountLimit</unmanaged-short>	
        internal long GetNumMessagesDiscardedByMessageCountLimit() {
            unsafe {
                long __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Callilong(_nativePointer,((void**)(*(void**)_nativePointer))[10]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Get the maximum number of messages that can be added to the message queue. </p>	
        /// </summary>	
        /// <returns><p> Maximum number of messages that can be added to the queue. -1 means no limit. When the number of messages in the message queue has reached the maximum limit, new messages coming in will push old messages out. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetMessageCountLimit']/*"/>	
        /// <msdn-id>dn950175</msdn-id>	
        /// <unmanaged>unsigned longlong ID3D12InfoQueue::GetMessageCountLimit()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::GetMessageCountLimit</unmanaged-short>	
        internal long GetMessageCountLimit() {
            unsafe {
                long __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Callilong(_nativePointer,((void**)(*(void**)_nativePointer))[11]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Add storage filters to the top of the storage-filter stack. </p>	
        /// </summary>	
        /// <param name="filterRef"><dd>  <p> Array of storage filters.</p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::AddStorageFilterEntries']/*"/>	
        /// <msdn-id>dn950167</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::AddStorageFilterEntries([In] D3D12_INFO_QUEUE_FILTER* pFilter)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::AddStorageFilterEntries</unmanaged-short>	
        public void AddStorageFilterEntries(SharpDX.Direct3D12.InfoQueueFilter filterRef) {
            unsafe {
                var filterRef_ = new SharpDX.Direct3D12.InfoQueueFilter.__Native();
                filterRef.__MarshalTo(ref filterRef_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, &filterRef_,((void**)(*(void**)_nativePointer))[12]);		
                filterRef.__MarshalFree(ref filterRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Get the storage filter at the top of the storage-filter stack. </p>	
        /// </summary>	
        /// <param name="filterRef"><dd>  <p> Storage filter at the top of the storage-filter stack. </p> </dd></param>	
        /// <param name="filterByteLengthRef"><dd>  <p> Size of the storage filter in bytes. If <em>pFilter</em> is <c>null</c>, the size of the storage filter will be output to this parameter. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetStorageFilter']/*"/>	
        /// <msdn-id>dn950184</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::GetStorageFilter([In] void* pFilter,[InOut] SIZE_T* pFilterByteLength)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::GetStorageFilter</unmanaged-short>	
        internal void GetStorageFilter(System.IntPtr filterRef, ref SharpDX.PointerSize filterByteLengthRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* filterByteLengthRef_ = &filterByteLengthRef)
                    __result__= 
    				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, (void*)filterRef, filterByteLengthRef_,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Remove a storage filter from the top of the storage-filter stack. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::ClearStorageFilter']/*"/>	
        /// <msdn-id>dn950169</msdn-id>	
        /// <unmanaged>void ID3D12InfoQueue::ClearStorageFilter()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::ClearStorageFilter</unmanaged-short>	
        public void ClearStorageFilter() {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[14]);		
            }
        }
        
        /// <summary>	
        /// <p> Push an empty storage filter onto the storage-filter stack. </p>	
        /// </summary>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <remarks>	
        /// <p>An empty storage filter allows all messages to pass through. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::PushEmptyStorageFilter']/*"/>	
        /// <msdn-id>dn950191</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::PushEmptyStorageFilter()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::PushEmptyStorageFilter</unmanaged-short>	
        public void PushEmptyStorageFilter() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Push a copy of storage filter currently on the top of the storage-filter stack onto the storage-filter stack. </p>	
        /// </summary>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::PushCopyOfStorageFilter']/*"/>	
        /// <msdn-id>dn950189</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::PushCopyOfStorageFilter()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::PushCopyOfStorageFilter</unmanaged-short>	
        public void PushCopyOfStorageFilter() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Push a storage filter onto the storage-filter stack. </p>	
        /// </summary>	
        /// <param name="filterRef"><dd>  <p> Pointer to a storage filter.</p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::PushStorageFilter']/*"/>	
        /// <msdn-id>dn950193</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::PushStorageFilter([In] D3D12_INFO_QUEUE_FILTER* pFilter)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::PushStorageFilter</unmanaged-short>	
        public void PushStorageFilter(SharpDX.Direct3D12.InfoQueueFilter filterRef) {
            unsafe {
                var filterRef_ = new SharpDX.Direct3D12.InfoQueueFilter.__Native();
                filterRef.__MarshalTo(ref filterRef_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, &filterRef_,((void**)(*(void**)_nativePointer))[17]);		
                filterRef.__MarshalFree(ref filterRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Pop a storage filter from the top of the storage-filter stack. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::PopStorageFilter']/*"/>	
        /// <msdn-id>dn950187</msdn-id>	
        /// <unmanaged>void ID3D12InfoQueue::PopStorageFilter()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::PopStorageFilter</unmanaged-short>	
        public void PopStorageFilter() {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[18]);		
            }
        }
        
        /// <summary>	
        /// <p> Get the size of the storage-filter stack in bytes. </p>	
        /// </summary>	
        /// <returns><p> Size of the storage-filter stack in bytes. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetStorageFilterStackSize']/*"/>	
        /// <msdn-id>dn950185</msdn-id>	
        /// <unmanaged>unsigned int ID3D12InfoQueue::GetStorageFilterStackSize()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::GetStorageFilterStackSize</unmanaged-short>	
        internal int GetStorageFilterStackSize() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[19]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Add storage filters to the top of the retrieval-filter stack. </p>	
        /// </summary>	
        /// <param name="filterRef"><dd>  <p>Array of retrieval filters. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <remarks>	
        /// <p>The following code example shows how to use this method: </p><code> <see cref="SharpDX.Direct3D12.MessageCategory"/> cats[] = { ..., ..., ... };	
        /// <see cref="SharpDX.Direct3D12.MessageSeverity"/> sevs[] = { ..., ..., ... };	
        /// UINT ids[] = { ..., ..., ... }; <see cref="SharpDX.Direct3D12.InfoQueueFilter"/> filter;	
        /// memset( &amp;filter, 0, sizeof(filter) ); // To set the type of messages to allow, 	
        /// // set filter.AllowList as follows:	
        /// filter.AllowList.NumCategories = sizeof(cats / sizeof(<see cref="SharpDX.Direct3D12.MessageCategory"/>)); 	
        /// filter.AllowList.pCategoryList = cats;	
        /// filter.AllowList.NumSeverities = sizeof(sevs / sizeof(<see cref="SharpDX.Direct3D12.MessageSeverity"/>)); 	
        /// filter.AllowList.pSeverityList = sevs;	
        /// filter.AllowList.NumIDs = sizeof(ids) / sizeof(UINT);	
        /// filter.AllowList.pIDList = ids; // To set the type of messages to deny, set filter.DenyList 	
        /// // similarly to the preceding filter.AllowList. // The following single call sets all of the preceding information.	
        /// hr = infoQueue-&gt;AddRetrievalFilterEntries( &amp;filter ); </code>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::AddRetrievalFilterEntries']/*"/>	
        /// <msdn-id>dn950166</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::AddRetrievalFilterEntries([In] D3D12_INFO_QUEUE_FILTER* pFilter)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::AddRetrievalFilterEntries</unmanaged-short>	
        public void AddRetrievalFilterEntries(SharpDX.Direct3D12.InfoQueueFilter filterRef) {
            unsafe {
                var filterRef_ = new SharpDX.Direct3D12.InfoQueueFilter.__Native();
                filterRef.__MarshalTo(ref filterRef_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, &filterRef_,((void**)(*(void**)_nativePointer))[20]);		
                filterRef.__MarshalFree(ref filterRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Get the retrieval filter at the top of the retrieval-filter stack. </p>	
        /// </summary>	
        /// <param name="filterRef"><dd>  <p> Retrieval filter at the top of the retrieval-filter stack. </p> </dd></param>	
        /// <param name="filterByteLengthRef"><dd>  <p> Size of the retrieval filter in bytes. If <em>pFilter</em> is <c>null</c>, the size of the retrieval filter will be output to this parameter. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetRetrievalFilter']/*"/>	
        /// <msdn-id>dn950182</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::GetRetrievalFilter([In] void* pFilter,[InOut] SIZE_T* pFilterByteLength)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::GetRetrievalFilter</unmanaged-short>	
        internal void GetRetrievalFilter(System.IntPtr filterRef, ref SharpDX.PointerSize filterByteLengthRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* filterByteLengthRef_ = &filterByteLengthRef)
                    __result__= 
    				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, (void*)filterRef, filterByteLengthRef_,((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Remove a retrieval filter from the top of the retrieval-filter stack. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::ClearRetrievalFilter']/*"/>	
        /// <msdn-id>dn950168</msdn-id>	
        /// <unmanaged>void ID3D12InfoQueue::ClearRetrievalFilter()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::ClearRetrievalFilter</unmanaged-short>	
        public void ClearRetrievalFilter() {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[22]);		
            }
        }
        
        /// <summary>	
        /// <p> Push an empty retrieval filter onto the retrieval-filter stack. </p>	
        /// </summary>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <remarks>	
        /// <p>An empty retrieval filter allows all messages to pass through. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::PushEmptyRetrievalFilter']/*"/>	
        /// <msdn-id>dn950190</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::PushEmptyRetrievalFilter()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::PushEmptyRetrievalFilter</unmanaged-short>	
        public void PushEmptyRetrievalFilter() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[23]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Push a copy of retrieval filter currently on the top of the retrieval-filter stack onto the retrieval-filter stack. </p>	
        /// </summary>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::PushCopyOfRetrievalFilter']/*"/>	
        /// <msdn-id>dn950188</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::PushCopyOfRetrievalFilter()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::PushCopyOfRetrievalFilter</unmanaged-short>	
        public void PushCopyOfRetrievalFilter() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[24]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="filterRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::PushRetrievalFilter']/*"/>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::PushRetrievalFilter([In] D3D12_INFO_QUEUE_FILTER* pFilter)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::PushRetrievalFilter</unmanaged-short>	
        public void PushRetrievalFilter(SharpDX.Direct3D12.InfoQueueFilter filterRef) {
            unsafe {
                var filterRef_ = new SharpDX.Direct3D12.InfoQueueFilter.__Native();
                filterRef.__MarshalTo(ref filterRef_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, &filterRef_,((void**)(*(void**)_nativePointer))[25]);		
                filterRef.__MarshalFree(ref filterRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Pop a retrieval filter from the top of the retrieval-filter stack. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::PopRetrievalFilter']/*"/>	
        /// <msdn-id>dn950186</msdn-id>	
        /// <unmanaged>void ID3D12InfoQueue::PopRetrievalFilter()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::PopRetrievalFilter</unmanaged-short>	
        public void PopRetrievalFilter() {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[26]);		
            }
        }
        
        /// <summary>	
        /// <p> Get the size of the retrieval-filter stack in bytes. </p>	
        /// </summary>	
        /// <returns><p> Size of the retrieval-filter stack in bytes. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetRetrievalFilterStackSize']/*"/>	
        /// <msdn-id>dn950183</msdn-id>	
        /// <unmanaged>unsigned int ID3D12InfoQueue::GetRetrievalFilterStackSize()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::GetRetrievalFilterStackSize</unmanaged-short>	
        internal int GetRetrievalFilterStackSize() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[27]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Adds a debug message to the message queue and sends that message to debug output. </p>	
        /// </summary>	
        /// <param name="category"><dd>  <p> Category of a message. </p> </dd></param>	
        /// <param name="severity"><dd>  <p> Severity of a message. </p> </dd></param>	
        /// <param name="id"><dd>  <p> Unique identifier of a message. </p> </dd></param>	
        /// <param name="descriptionRef"><dd>  <p> User-defined message. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <remarks>	
        /// <p>This method is used by the runtime's internal mechanisms to add debug messages to the message queue and send them to debug output. For applications to add their own custom messages to the message queue and send them to debug output, call <strong><see cref="SharpDX.Direct3D12.InfoQueue.AddApplicationMessage"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::AddMessage']/*"/>	
        /// <msdn-id>dn950165</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::AddMessage([In] D3D12_MESSAGE_CATEGORY Category,[In] D3D12_MESSAGE_SEVERITY Severity,[In] D3D12_MESSAGE_ID ID,[In] const char* pDescription)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::AddMessage</unmanaged-short>	
        public void AddMessage(SharpDX.Direct3D12.MessageCategory category, SharpDX.Direct3D12.MessageSeverity severity, SharpDX.Direct3D12.MessageId id, string descriptionRef) {
            unsafe {
                IntPtr descriptionRef_ = Utilities.StringToHGlobalAnsi(descriptionRef);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, unchecked((int)category), unchecked((int)severity), unchecked((int)id), (void*)descriptionRef_,((void**)(*(void**)_nativePointer))[28]);		
                Marshal.FreeHGlobal(descriptionRef_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Adds a user-defined message to the message queue and sends that message to debug output. </p>	
        /// </summary>	
        /// <param name="severity"><dd>  <p> Severity of a message.</p> </dd></param>	
        /// <param name="descriptionRef"><dd>  <p> Specifies the message string. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::AddApplicationMessage']/*"/>	
        /// <msdn-id>dn950164</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::AddApplicationMessage([In] D3D12_MESSAGE_SEVERITY Severity,[In] const char* pDescription)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::AddApplicationMessage</unmanaged-short>	
        public void AddApplicationMessage(SharpDX.Direct3D12.MessageSeverity severity, string descriptionRef) {
            unsafe {
                IntPtr descriptionRef_ = Utilities.StringToHGlobalAnsi(descriptionRef);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, unchecked((int)severity), (void*)descriptionRef_,((void**)(*(void**)_nativePointer))[29]);		
                Marshal.FreeHGlobal(descriptionRef_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Set a message category to break on when a message with that category passes through the storage filter. </p>	
        /// </summary>	
        /// <param name="category"><dd>  <p> Message category to break on. </p> </dd></param>	
        /// <param name="bEnable"><dd>  <p> Turns this breaking condition on or off (true for on, false for off). </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::SetBreakOnCategory']/*"/>	
        /// <msdn-id>dn950195</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::SetBreakOnCategory([In] D3D12_MESSAGE_CATEGORY Category,[In] BOOL bEnable)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::SetBreakOnCategory</unmanaged-short>	
        public void SetBreakOnCategory(SharpDX.Direct3D12.MessageCategory category, SharpDX.Mathematics.Interop.RawBool bEnable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint66(_nativePointer, unchecked((int)category), bEnable,((void**)(*(void**)_nativePointer))[30]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Set a message severity level to break on when a message with that severity level passes through the storage filter. </p>	
        /// </summary>	
        /// <param name="severity"><dd>  <p> A message severity level to break on. </p> </dd></param>	
        /// <param name="bEnable"><dd>  <p> Turns this breaking condition on or off (true for on, false for off). </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::SetBreakOnSeverity']/*"/>	
        /// <msdn-id>dn950197</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::SetBreakOnSeverity([In] D3D12_MESSAGE_SEVERITY Severity,[In] BOOL bEnable)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::SetBreakOnSeverity</unmanaged-short>	
        public void SetBreakOnSeverity(SharpDX.Direct3D12.MessageSeverity severity, SharpDX.Mathematics.Interop.RawBool bEnable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint66(_nativePointer, unchecked((int)severity), bEnable,((void**)(*(void**)_nativePointer))[31]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Set a message identifier to break on when a message with that identifier passes through the storage filter. </p>	
        /// </summary>	
        /// <param name="id"><dd>  <p> Message identifier to break on. </p> </dd></param>	
        /// <param name="bEnable"><dd>  <p> Turns this breaking condition on or off (true for on, false for off). </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes.  </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::SetBreakOnID']/*"/>	
        /// <msdn-id>dn950196</msdn-id>	
        /// <unmanaged>HRESULT ID3D12InfoQueue::SetBreakOnID([In] D3D12_MESSAGE_ID ID,[In] BOOL bEnable)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::SetBreakOnID</unmanaged-short>	
        public void SetBreakOnID(SharpDX.Direct3D12.MessageId id, SharpDX.Mathematics.Interop.RawBool bEnable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint66(_nativePointer, unchecked((int)id), bEnable,((void**)(*(void**)_nativePointer))[32]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Get a message category to break on when a message with that category passes through the storage filter. </p>	
        /// </summary>	
        /// <param name="category"><dd>  <p> Message category to break on. </p> </dd></param>	
        /// <returns><p> Whether this breaking condition is turned on or off (true for on, false for off). </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetBreakOnCategory']/*"/>	
        /// <msdn-id>dn950171</msdn-id>	
        /// <unmanaged>BOOL ID3D12InfoQueue::GetBreakOnCategory([In] D3D12_MESSAGE_CATEGORY Category)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::GetBreakOnCategory</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool GetBreakOnCategory(SharpDX.Direct3D12.MessageCategory category) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, unchecked((int)category),((void**)(*(void**)_nativePointer))[33]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a message severity level to break on when a message with that severity level passes through the storage filter. </p>	
        /// </summary>	
        /// <param name="severity"><dd>  <p> Message severity level to break on.</p> </dd></param>	
        /// <returns><p> Whether this breaking condition is turned on or off (true for on, false for off). </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetBreakOnSeverity']/*"/>	
        /// <msdn-id>dn950173</msdn-id>	
        /// <unmanaged>BOOL ID3D12InfoQueue::GetBreakOnSeverity([In] D3D12_MESSAGE_SEVERITY Severity)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::GetBreakOnSeverity</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool GetBreakOnSeverity(SharpDX.Direct3D12.MessageSeverity severity) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, unchecked((int)severity),((void**)(*(void**)_nativePointer))[34]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Get a message identifier to break on when a message with that identifier passes through the storage filter. </p>	
        /// </summary>	
        /// <param name="id"><dd>  <p> Message identifier to break on. </p> </dd></param>	
        /// <returns><p> Whether this breaking condition is turned on or off (true for on, false for off). </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetBreakOnID']/*"/>	
        /// <msdn-id>dn950172</msdn-id>	
        /// <unmanaged>BOOL ID3D12InfoQueue::GetBreakOnID([In] D3D12_MESSAGE_ID ID)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::GetBreakOnID</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool GetBreakOnID(SharpDX.Direct3D12.MessageId id) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, unchecked((int)id),((void**)(*(void**)_nativePointer))[35]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Set a boolean that turns the debug output on or off. </p>	
        /// </summary>	
        /// <param name="bMute"><dd>  <p> Disable/Enable the debug output (true to disable or mute the output, false to enable the output). </p> </dd></param>	
        /// <remarks>	
        /// <p>This will stop messages that pass the storage filter from being printed out in the debug output, however those messages will still be added to the message queue. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::SetMuteDebugOutput']/*"/>	
        /// <msdn-id>dn950199</msdn-id>	
        /// <unmanaged>void ID3D12InfoQueue::SetMuteDebugOutput([In] BOOL bMute)</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::SetMuteDebugOutput</unmanaged-short>	
        internal void SetMuteDebugOutput(SharpDX.Mathematics.Interop.RawBool bMute) {
            unsafe {
                SharpDX.Direct3D12.LocalInterop.Callivoid68(_nativePointer, bMute,((void**)(*(void**)_nativePointer))[36]);		
            }
        }
        
        /// <summary>	
        /// <p> Get a boolean that determines if debug output is on or off. </p>	
        /// </summary>	
        /// <returns><p> Whether the debug output is on or off (true for on, false for off). </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12InfoQueue::GetMuteDebugOutput']/*"/>	
        /// <msdn-id>dn950176</msdn-id>	
        /// <unmanaged>BOOL ID3D12InfoQueue::GetMuteDebugOutput()</unmanaged>	
        /// <unmanaged-short>ID3D12InfoQueue::GetMuteDebugOutput</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool GetMuteDebugOutput() {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer,((void**)(*(void**)_nativePointer))[37]);		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p> Associates a name with the device object. This name is for use in debug diagnostics and tools. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p> This method takes UNICODE names. The older Direct3D 11 debug object naming system through <strong><see cref="SharpDX.Direct3D12.Object.SetPrivateData"/></strong> with <strong><see cref="SharpDX.Direct3D.CommonGuid.DebugObjectName"/></strong> used ASCII. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Object']/*"/>	
    /// <msdn-id>dn788701</msdn-id>	
    /// <unmanaged>ID3D12Object</unmanaged>	
    /// <unmanaged-short>ID3D12Object</unmanaged-short>	
    [Guid("c4fec28f-7966-4e95-9f94-f431cb56c3b8")]
    public partial class Object : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.Object"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Object(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.Object"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.Object(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.Object(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Associates a name with the device object. This name is for use in debug diagnostics and tools. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p> This method takes UNICODE names. The older Direct3D 11 debug object naming system through <strong><see cref="SharpDX.Direct3D12.Object.SetPrivateData"/></strong> with <strong><see cref="SharpDX.Direct3D.CommonGuid.DebugObjectName"/></strong> used ASCII. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Object::SetName']/*"/>	
        /// <msdn-id>dn788701</msdn-id>	
        /// <unmanaged>SetName</unmanaged>	
        /// <unmanaged-short>SetName</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D12Object::SetName([In] const wchar_t* Name)</unmanaged>
        public string Name {
                set { SetName(value); }
        }
        
        /// <summary>	
        /// <p>Gets application-defined data from a device object.</p>	
        /// </summary>	
        /// <param name="guid"><dd>  <p> The <strong><see cref="System.Guid"/></strong> that is associated with the data. </p> </dd></param>	
        /// <param name="dataSizeRef"><dd>  <p> A reference to a variable that on input contains the size, in bytes, of the buffer that <em>pData</em> points to, and on output contains the size, in bytes, of the amount of data that <strong>GetPrivateData</strong> retrieved. </p> </dd></param>	
        /// <param name="dataRef"><dd>  <p> A reference to a memory block that receives the data from the device object if <em>pDataSize</em> points to a value that specifies a buffer large enough to hold the data. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Object::GetPrivateData']/*"/>	
        /// <msdn-id>dn788700</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Object::GetPrivateData([In] const GUID&amp; guid,[InOut] unsigned int* pDataSize,[Out, Buffer, Optional] void* pData)</unmanaged>	
        /// <unmanaged-short>ID3D12Object::GetPrivateData</unmanaged-short>	
        public SharpDX.Result GetPrivateData(System.Guid guid, ref int dataSizeRef, System.IntPtr dataRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataSizeRef_ = &dataSizeRef)
                    __result__= 
    				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, &guid, dataSizeRef_, (void*)dataRef,((void**)(*(void**)_nativePointer))[3]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> Associates a name with the device object. This name is for use in debug diagnostics and tools. </p>	
        /// </summary>	
        /// <param name="guid"><dd>  <p> A <strong><c>null</c></strong>-terminated <strong>UNICODE</strong> string that contains the name to associate with the device object. </p> </dd></param>	
        /// <param name="dataSize">No documentation.</param>	
        /// <param name="dataRef">No documentation.</param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p> This method takes UNICODE names. The older Direct3D 11 debug object naming system through <strong><see cref="SharpDX.Direct3D12.Object.SetPrivateData"/></strong> with <strong><see cref="SharpDX.Direct3D.CommonGuid.DebugObjectName"/></strong> used ASCII. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Object::SetPrivateData']/*"/>	
        /// <msdn-id>dn788701</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Object::SetPrivateData([In] const GUID&amp; guid,[In] unsigned int DataSize,[In, Buffer, Optional] const void* pData)</unmanaged>	
        /// <unmanaged-short>ID3D12Object::SetPrivateData</unmanaged-short>	
        public void SetPrivateData(System.Guid guid, int dataSize, System.IntPtr dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, &guid, dataSize, (void*)dataRef,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Associates an <strong><see cref="SharpDX.ComObject"/></strong>-derived interface with the device object and associates that interface with an application-defined <strong><see cref="System.Guid"/></strong>. </p>	
        /// </summary>	
        /// <param name="guid">No documentation.</param>	
        /// <param name="dataRef">No documentation.</param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Object::SetPrivateDataInterface']/*"/>	
        /// <msdn-id>dn788703</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Object::SetPrivateDataInterface([In] const GUID&amp; guid,[In, Optional] const IUnknown* pData)</unmanaged>	
        /// <unmanaged-short>ID3D12Object::SetPrivateDataInterface</unmanaged-short>	
        public void SetPrivateDataInterface(System.Guid guid, SharpDX.ComObject dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, &guid, (void*)((dataRef == null)?IntPtr.Zero:dataRef.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Associates a name with the device object. This name is for use in debug diagnostics and tools. </p>	
        /// </summary>	
        /// <param name="name"><dd>  <p> A <strong><c>null</c></strong>-terminated <strong>UNICODE</strong> string that contains the name to associate with the device object. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p> This method takes UNICODE names. The older Direct3D 11 debug object naming system through <strong><see cref="SharpDX.Direct3D12.Object.SetPrivateData"/></strong> with <strong><see cref="SharpDX.Direct3D.CommonGuid.DebugObjectName"/></strong> used ASCII. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Object::SetName']/*"/>	
        /// <msdn-id>dn788701</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Object::SetName([In] const wchar_t* Name)</unmanaged>	
        /// <unmanaged-short>ID3D12Object::SetName</unmanaged-short>	
        internal void SetName(string name) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalUni(name);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, (void*)name_,((void**)(*(void**)_nativePointer))[6]);		
                Marshal.FreeHGlobal(name_ );
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>An interface from which many other core interfaces inherit from. It indicates that the object type encapsulates some amount of GPU-accessible memory; but does not strongly indicate whether the application can manipulate the object's residency. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>For more details, refer to Memory Management in Direct3D 12 and the <strong>MakeResident</strong> method reference.	
    /// </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Pageable']/*"/>	
    /// <msdn-id>dn788704</msdn-id>	
    /// <unmanaged>ID3D12Pageable</unmanaged>	
    /// <unmanaged-short>ID3D12Pageable</unmanaged-short>	
    [Guid("63ee58fb-1268-4835-86da-f008ce62f0d6")]
    public partial class Pageable : SharpDX.Direct3D12.DeviceChild {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.Pageable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Pageable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.Pageable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.Pageable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.Pageable(nativePointer);
		}
        
    }
    /// <summary>	
    /// <p>Represents the state of all currently set shaders as well as certain fixed function state objects.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Use <strong><see cref="SharpDX.Direct3D12.Device.CreateGraphicsPipelineState"/></strong> or  <strong><see cref="SharpDX.Direct3D12.Device.CreateComputePipelineState"/></strong> to create a pipeline state object (PSO). </p><p>A pipeline state object corresponds to a significant portion of the state of the graphics processing unit (GPU).  This state includes all currently set shaders and certain fixed function state objects.  The only way to change states contained within the pipeline object is to change the currently bound pipeline object.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12PipelineState']/*"/>	
    /// <msdn-id>dn788705</msdn-id>	
    /// <unmanaged>ID3D12PipelineState</unmanaged>	
    /// <unmanaged-short>ID3D12PipelineState</unmanaged-short>	
    [Guid("765a30f3-f624-4c6f-a828-ace948622445")]
    public partial class PipelineState : SharpDX.Direct3D12.Pageable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.PipelineState"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PipelineState(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.PipelineState"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.PipelineState(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.PipelineState(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Gets the cached blob representing the pipeline state. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Refer to the remarks for <strong><see cref="SharpDX.Direct3D12.CachedPipelineState"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12PipelineState::GetCachedBlob']/*"/>	
        /// <msdn-id>dn914413</msdn-id>	
        /// <unmanaged>GetCachedBlob</unmanaged>	
        /// <unmanaged-short>GetCachedBlob</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D12PipelineState::GetCachedBlob([Out] ID3D10Blob** ppBlob)</unmanaged>
        public SharpDX.Direct3D.Blob CachedBlob {
                get { SharpDX.Direct3D.Blob __output__; GetCachedBlob(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p> Gets the cached blob representing the pipeline state. </p>	
        /// </summary>	
        /// <param name="blobOut"><dd>  <p> After this method returns, points to the cached blob representing the pipeline state. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p>Refer to the remarks for <strong><see cref="SharpDX.Direct3D12.CachedPipelineState"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12PipelineState::GetCachedBlob']/*"/>	
        /// <msdn-id>dn914413</msdn-id>	
        /// <unmanaged>HRESULT ID3D12PipelineState::GetCachedBlob([Out] ID3D10Blob** ppBlob)</unmanaged>	
        /// <unmanaged-short>ID3D12PipelineState::GetCachedBlob</unmanaged-short>	
        internal void GetCachedBlob(out SharpDX.Direct3D.Blob blobOut) {
            unsafe {
                IntPtr blobOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, &blobOut_,((void**)(*(void**)_nativePointer))[8]);		
                blobOut= (blobOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(blobOut_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Manages a query heap. A query heap holds an array of queries, referenced by indexes.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>For more information, refer to Queries.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12QueryHeap']/*"/>	
    /// <msdn-id>dn891447</msdn-id>	
    /// <unmanaged>ID3D12QueryHeap</unmanaged>	
    /// <unmanaged-short>ID3D12QueryHeap</unmanaged-short>	
    [Guid("0d9658ae-ed45-469e-a61d-970ec583cab4")]
    public partial class QueryHeap : SharpDX.Direct3D12.Pageable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.QueryHeap"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public QueryHeap(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.QueryHeap"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.QueryHeap(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.QueryHeap(nativePointer);
		}
        
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Resource']/*"/>	
    /// <unmanaged>ID3D12Resource</unmanaged>	
    /// <unmanaged-short>ID3D12Resource</unmanaged-short>	
    [Guid("696442be-a72e-4059-bc79-5b5c98040fad")]
    public partial class Resource : SharpDX.Direct3D12.Pageable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.Resource"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Resource(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.Resource"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.Resource(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.Resource(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the resource description.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Resource::GetDesc']/*"/>	
        /// <msdn-id>dn788710</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>D3D12_RESOURCE_DESC ID3D12Resource::GetDesc()</unmanaged>
        public SharpDX.Direct3D12.ResourceDescription Description {
                get { return GetDescription(); }
        }
        
        /// <summary>	
        /// <p> This method returns the GPU virtual address of the resource. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p> For more information on the use of GPU virtual addresses, refer to Indirect Drawing.  </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Resource::GetGPUVirtualAddress']/*"/>	
        /// <msdn-id>dn903923</msdn-id>	
        /// <unmanaged>GetGPUVirtualAddress</unmanaged>	
        /// <unmanaged-short>GetGPUVirtualAddress</unmanaged-short>	
        /// <unmanaged>unsigned longlong ID3D12Resource::GetGPUVirtualAddress()</unmanaged>
        public long GPUVirtualAddress {
                get { return GetGPUVirtualAddress(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="subresource">No documentation.</param>	
        /// <param name="readRangeRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Resource::Map']/*"/>	
        /// <unmanaged>HRESULT ID3D12Resource::Map([In] unsigned int Subresource,[In, Optional] const D3D12_RANGE* pReadRange,[Out] void** ppData)</unmanaged>	
        /// <unmanaged-short>ID3D12Resource::Map</unmanaged-short>	
        public System.IntPtr Map(int subresource, SharpDX.Direct3D12.Range? readRangeRef = null) {
            unsafe {
                SharpDX.Direct3D12.Range readRangeRef_;
                if (readRangeRef.HasValue)
                    readRangeRef_ = readRangeRef.Value;				
                System.IntPtr dataOut;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, subresource, (readRangeRef.HasValue)?&readRangeRef_:(void*)IntPtr.Zero, &dataOut,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
                return dataOut;
            }
        }
        
        /// <summary>	
        /// <p>Invalidates the CPU reference to the specified subresource in the resource. <strong>Unmap</strong> also flushes the CPU cache, when necessary, so that GPU reads to this address reflect any modifications made by the CPU.	
        /// </p>	
        /// </summary>	
        /// <param name="subresource"><dd>  <p>Specifies the index of the subresource.</p> </dd></param>	
        /// <param name="writtenRangeRef"><dd>  <p>A reference to a <strong><see cref="SharpDX.Direct3D12.Range"/></strong> structure that describes the range of memory to unmap.</p> <p>This indicates the region the CPU might have modified, and the coordinates are subresource-relative. A null reference indicates the entire subresource might have been modified by the CPU. It is valid to specify the CPU didn't write any data by passing a range where <strong>End</strong> is less than or equal to <strong>Begin</strong>.</p> </dd></param>	
        /// <remarks>	
        /// <p>Refer to the extensive Remarks and Examples for the <strong>Map</strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Resource::Unmap']/*"/>	
        /// <msdn-id>dn788713</msdn-id>	
        /// <unmanaged>void ID3D12Resource::Unmap([In] unsigned int Subresource,[In, Optional] const D3D12_RANGE* pWrittenRange)</unmanaged>	
        /// <unmanaged-short>ID3D12Resource::Unmap</unmanaged-short>	
        public void Unmap(int subresource, SharpDX.Direct3D12.Range? writtenRangeRef = null) {
            unsafe {
                SharpDX.Direct3D12.Range writtenRangeRef_;
                if (writtenRangeRef.HasValue)
                    writtenRangeRef_ = writtenRangeRef.Value;				
                SharpDX.Direct3D12.LocalInterop.Callivoid(_nativePointer, subresource, (writtenRangeRef.HasValue)?&writtenRangeRef_:(void*)IntPtr.Zero,((void**)(*(void**)_nativePointer))[9]);		
            }
        }
        
        /// <summary>	
        /// <p>Gets the resource description.</p>	
        /// </summary>	
        /// <returns><p>A Direct3D 12 resource description structure.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Resource::GetDesc']/*"/>	
        /// <msdn-id>dn788710</msdn-id>	
        /// <unmanaged>D3D12_RESOURCE_DESC ID3D12Resource::GetDesc()</unmanaged>	
        /// <unmanaged-short>ID3D12Resource::GetDesc</unmanaged-short>	
        internal SharpDX.Direct3D12.ResourceDescription GetDescription() {
            unsafe {
                SharpDX.Direct3D12.ResourceDescription __result__;
                SharpDX.Direct3D12.LocalInterop.CallivoidPtr(_nativePointer,(void*)&__result__,((void**)(*(void**)_nativePointer))[10]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p> This method returns the GPU virtual address of the resource. </p>	
        /// </summary>	
        /// <returns><p> This method returns the GPU virtual address. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd synonym of UINT64. </p></returns>	
        /// <remarks>	
        /// <p> For more information on the use of GPU virtual addresses, refer to Indirect Drawing.  </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Resource::GetGPUVirtualAddress']/*"/>	
        /// <msdn-id>dn903923</msdn-id>	
        /// <unmanaged>unsigned longlong ID3D12Resource::GetGPUVirtualAddress()</unmanaged>	
        /// <unmanaged-short>ID3D12Resource::GetGPUVirtualAddress</unmanaged-short>	
        internal long GetGPUVirtualAddress() {
            unsafe {
                long __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Callilong(_nativePointer,((void**)(*(void**)_nativePointer))[11]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Uses the CPU to copy data into a subresource, enabling the CPU to modify the contents of most textures with undefined layouts.</p>	
        /// </summary>	
        /// <param name="dstSubresource"><dd>  <p> Specifies the index of the subresource. </p> </dd></param>	
        /// <param name="dstBoxRef"><dd>  <p> A reference to a box that defines the portion of the destination subresource to copy the resource data into. If <c>null</c>, the data is written to the destination subresource with no offset. The dimensions of the source must fit the destination (see <strong><see cref="SharpDX.Direct3D12.ResourceRegion"/></strong>). </p> <p> An empty box results in a no-op. A box is empty if the top value is greater than or equal to the bottom value, or the left value is greater than or equal to the right value,  or the front value is greater than or equal to the back value. When the box is empty, this method doesn't perform any operation. </p> </dd></param>	
        /// <param name="srcDataRef"><dd>  <p> A reference to the source data in memory. </p> </dd></param>	
        /// <param name="srcRowPitch"><dd>  <p>The distance from one row of source data to the next row. </p> </dd></param>	
        /// <param name="srcDepthPitch"><dd>  <p> The distance from one depth slice of source data to the next. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p>The resource should first be mapped using <strong>Map</strong>. Textures must be in the <strong><see cref="SharpDX.Direct3D12.ResourceStates.Common"/></strong> state for CPU access through <strong>WriteToSubresource</strong> and <strong>ReadFromSubresource</strong> to be legal; but buffers do not.</p><p> For efficiency, ensure the bounds and alignment of the extents within the box are ( 64 / [bytes per pixel] ) pixels horizontally. Vertical bounds and alignment should be 2 rows, except when 1-byte-per-pixel formats are used, in which case 4 rows are recommended. Single depth slices per call are handled efficiently. It is recommended but not necessary to provide references and strides which are 128-byte aligned. </p><p> When writing to sub mipmap levels, it is recommended to use larger width and heights than described above. This is because small mipmap levels may actually be stored within a larger block of memory, with an opaque amount of offsetting which can interfere with alignment to cache lines. </p><p><strong>WriteToSubresource</strong> and <strong>ReadFromSubresource</strong> enable near zero-copy optimizations for UMA adapters, but can prohibitively impair the efficiency of discrete/ NUMA adapters as the texture data cannot reside in local video memory. Typical applications should stick to discrete-friendly upload techniques, unless they recognize the adapter architecture is UMA. For more details on uploading, refer to <strong>CopyTextureRegion</strong>, and for more details on UMA, refer to <strong><see cref="SharpDX.Direct3D12.FeatureDataArchitecture"/></strong>. </p><p>On UMA systems, this routine can be used to minimize the cost of memory copying through the loop optimization known as loop tiling. By breaking up the upload into chucks that comfortably fit in the CPU cache, the effective bandwidth between the CPU and main memory more closely achieves theoretical maximums.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Resource::WriteToSubresource']/*"/>	
        /// <msdn-id>dn914416</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Resource::WriteToSubresource([In] unsigned int DstSubresource,[In, Optional] const D3D12_BOX* pDstBox,[In] const void* pSrcData,[In] unsigned int SrcRowPitch,[In] unsigned int SrcDepthPitch)</unmanaged>	
        /// <unmanaged-short>ID3D12Resource::WriteToSubresource</unmanaged-short>	
        public void WriteToSubresource(int dstSubresource, SharpDX.Direct3D12.ResourceRegion? dstBoxRef, System.IntPtr srcDataRef, int srcRowPitch, int srcDepthPitch) {
            unsafe {
                SharpDX.Direct3D12.ResourceRegion dstBoxRef_;
                if (dstBoxRef.HasValue)
                    dstBoxRef_ = dstBoxRef.Value;				
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, dstSubresource, (dstBoxRef.HasValue)?&dstBoxRef_:(void*)IntPtr.Zero, (void*)srcDataRef, srcRowPitch, srcDepthPitch,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Uses the CPU to copy data from a subresource, enabling the CPU to read the contents of most textures with undefined layouts. </p>	
        /// </summary>	
        /// <param name="dstDataRef"><dd>  <p> A reference to the destination data in memory. </p> </dd></param>	
        /// <param name="dstRowPitch"><dd>  <p> The distance from one row of destination data to the next row. </p> </dd></param>	
        /// <param name="dstDepthPitch"><dd>  <p> The distance from one depth slice of destination data to the next. </p> </dd></param>	
        /// <param name="srcSubresource"><dd>  <p> Specifies the index of the subresource to read from. </p> </dd></param>	
        /// <param name="srcBoxRef"><dd>  <p> A reference to a box that defines the portion of the destination subresource to copy the resource data from. If <c>null</c>, the data is read from the destination subresource with no offset. The dimensions of the destination must fit the destination (see <strong><see cref="SharpDX.Direct3D12.ResourceRegion"/></strong>). </p> <p> An empty box results in a no-op. A box is empty if the top value is greater than or equal to the bottom value, or the left value is greater than or equal to the right value, or the front value is greater than or equal to the back value. When the box is empty, this method doesn't perform any operation. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p> See the Remarks section for <strong>WriteToSubresource</strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Resource::ReadFromSubresource']/*"/>	
        /// <msdn-id>dn914415</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Resource::ReadFromSubresource([Out] void* pDstData,[In] unsigned int DstRowPitch,[In] unsigned int DstDepthPitch,[In] unsigned int SrcSubresource,[In, Optional] const D3D12_BOX* pSrcBox)</unmanaged>	
        /// <unmanaged-short>ID3D12Resource::ReadFromSubresource</unmanaged-short>	
        public void ReadFromSubresource(out System.IntPtr dstDataRef, int dstRowPitch, int dstDepthPitch, int srcSubresource, SharpDX.Direct3D12.ResourceRegion? srcBoxRef) {
            unsafe {
                SharpDX.Direct3D12.ResourceRegion srcBoxRef_;
                if (srcBoxRef.HasValue)
                    srcBoxRef_ = srcBoxRef.Value;				
                SharpDX.Result __result__;
                fixed (void* dstDataRef_ = &dstDataRef)
                    __result__= 
    				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, dstDataRef_, dstRowPitch, dstDepthPitch, srcSubresource, (srcBoxRef.HasValue)?&srcBoxRef_:(void*)IntPtr.Zero,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Retrieves the properties of the resource heap, for placed and committed resources. </p>	
        /// </summary>	
        /// <param name="heapPropertiesRef"><dd>  <p> Pointer to a <strong><see cref="SharpDX.Direct3D12.HeapProperties"/></strong> structure, that on successful completion of the method will contain the resource heap properties. </p> </dd></param>	
        /// <param name="heapFlagsRef"><dd>  <p> Specifies a <strong><see cref="SharpDX.Direct3D12.HeapFlags"/></strong> variable, that on successful completion of the method will contain any miscellaneous heap flags. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. If the resource was created as reserved, E_INVALIDARG is returned. </p></returns>	
        /// <remarks>	
        /// <p> This method only works on placed and committed resources, not on reserved resources. If the resource was created as reserved, E_INVALIDARG is returned. The pages could be mapped to none, one, or more heaps. </p><p> For more information, refer to Memory Management in Direct3D 12. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12Resource::GetHeapProperties']/*"/>	
        /// <msdn-id>dn914414</msdn-id>	
        /// <unmanaged>HRESULT ID3D12Resource::GetHeapProperties([Out, Optional] D3D12_HEAP_PROPERTIES* pHeapProperties,[Out, Optional] D3D12_HEAP_FLAGS* pHeapFlags)</unmanaged>	
        /// <unmanaged-short>ID3D12Resource::GetHeapProperties</unmanaged-short>	
        public void GetHeapProperties(out SharpDX.Direct3D12.HeapProperties heapPropertiesRef, out SharpDX.Direct3D12.HeapFlags heapFlagsRef) {
            unsafe {
                heapPropertiesRef = new SharpDX.Direct3D12.HeapProperties();
                SharpDX.Result __result__;
                fixed (void* heapPropertiesRef_ = &heapPropertiesRef)
                    fixed (void* heapFlagsRef_ = &heapFlagsRef)
                        __result__= 
        				SharpDX.Direct3D12.LocalInterop.Calliint(_nativePointer, heapPropertiesRef_, heapFlagsRef_,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The root signature defines what resources are bound to the graphics pipeline. A root signature is configured by the app and links command lists to the resources the shaders require. Currently, there is one graphics and one compute root signature per app.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12RootSignature']/*"/>	
    /// <msdn-id>dn788714</msdn-id>	
    /// <unmanaged>ID3D12RootSignature</unmanaged>	
    /// <unmanaged-short>ID3D12RootSignature</unmanaged-short>	
    [Guid("c54a6b66-72df-4ee8-8be5-a946a1429214")]
    public partial class RootSignature : SharpDX.Direct3D12.DeviceChild {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.RootSignature"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RootSignature(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.RootSignature"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.RootSignature(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.RootSignature(nativePointer);
		}
        
    }
    /// <summary>	
    /// <p>Contains a method to  return the deserialized  <strong><see cref="SharpDX.Direct3D12.RootSignatureDescription"/></strong> data structure, of a serialized root signature. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12RootSignatureDeserializer']/*"/>	
    /// <msdn-id>dn899192</msdn-id>	
    /// <unmanaged>ID3D12RootSignatureDeserializer</unmanaged>	
    /// <unmanaged-short>ID3D12RootSignatureDeserializer</unmanaged-short>	
    [Guid("34AB647B-3CC8-46AC-841B-C0965645C046")]
    public partial class RootSignatureDeserializer : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D12.RootSignatureDeserializer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RootSignatureDeserializer(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D12.RootSignatureDeserializer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D12.RootSignatureDeserializer(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D12.RootSignatureDeserializer(nativePointer);
		}
        
        
        /// <summary>	
        /// <p> Gets the layout of the root signature. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12RootSignatureDeserializer::GetRootSignatureDesc']/*"/>	
        /// <msdn-id>dn986887</msdn-id>	
        /// <unmanaged>GetRootSignatureDesc</unmanaged>	
        /// <unmanaged-short>GetRootSignatureDesc</unmanaged-short>	
        /// <unmanaged>const D3D12_ROOT_SIGNATURE_DESC* ID3D12RootSignatureDeserializer::GetRootSignatureDesc()</unmanaged>
        public SharpDX.Direct3D12.RootSignatureDescription RootSignatureDescription {
                get { return GetRootSignatureDescription(); }
        }
        
        /// <summary>	
        /// <p> Gets the layout of the root signature. </p>	
        /// </summary>	
        /// <returns><p> Returns a reference to a <strong><see cref="SharpDX.Direct3D12.RootSignatureDescription"/></strong> structure that describes the layout of the root signature. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D12RootSignatureDeserializer::GetRootSignatureDesc']/*"/>	
        /// <msdn-id>dn986887</msdn-id>	
        /// <unmanaged>const D3D12_ROOT_SIGNATURE_DESC* ID3D12RootSignatureDeserializer::GetRootSignatureDesc()</unmanaged>	
        /// <unmanaged-short>ID3D12RootSignatureDeserializer::GetRootSignatureDesc</unmanaged-short>	
        internal SharpDX.Direct3D12.RootSignatureDescription GetRootSignatureDescription() {
            unsafe {
                SharpDX.Direct3D12.RootSignatureDescription __result__;
                __result__= 
				SharpDX.Direct3D12.LocalInterop.CalliSharpDXDirect3D12RootSignatureDescription(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                return __result__;
            }
        }
    }
}
