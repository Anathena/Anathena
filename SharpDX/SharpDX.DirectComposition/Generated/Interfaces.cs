// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.DirectComposition namespace.
//     This code was generated by a tool.
//     Date : 6/25/2016 10:38:13 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.DirectComposition {

// Disable warning : XML comment is not placed on a valid language element
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
    /// <summary>	
    /// <p>Sets an element of the transform matrix of the effect.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAffineTransform2DEffect']/*"/>	
    /// <msdn-id>dn919697</msdn-id>	
    /// <unmanaged>IDCompositionAffineTransform2DEffect</unmanaged>	
    /// <unmanaged-short>IDCompositionAffineTransform2DEffect</unmanaged-short>	
    [Guid("0B74B9E8-CDD6-492F-BBBC-5ED32157026D")]
    public partial class AffineTransform2DEffect : SharpDX.DirectComposition.FilterEffect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.AffineTransform2DEffect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public AffineTransform2DEffect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.AffineTransform2DEffect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.AffineTransform2DEffect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.AffineTransform2DEffect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the interpolation mode of the effect.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAffineTransform2DEffect::SetInterpolationMode']/*"/>	
        /// <msdn-id>dn919692</msdn-id>	
        /// <unmanaged>SetInterpolationMode</unmanaged>	
        /// <unmanaged-short>SetInterpolationMode</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetInterpolationMode([In] D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE interpolationMode)</unmanaged>
        public SharpDX.Direct2D1.AffineTransform2DInterpolationMode InterpolationMode {
                set { SetInterpolationMode(value); }
        }
        
        /// <summary>	
        /// <p>Sets the border mode to use with the effect.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAffineTransform2DEffect::SetBorderMode']/*"/>	
        /// <msdn-id>dn919691</msdn-id>	
        /// <unmanaged>SetBorderMode</unmanaged>	
        /// <unmanaged-short>SetBorderMode</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetBorderMode([In] D2D1_BORDER_MODE borderMode)</unmanaged>
        public SharpDX.Direct2D1.BorderMode BorderMode {
                set { SetBorderMode(value); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAffineTransform2DEffect::SetTransformMatrix']/*"/>	
        /// <unmanaged>SetTransformMatrix</unmanaged>	
        /// <unmanaged-short>SetTransformMatrix</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetTransformMatrix([In] const D2D_MATRIX_3X2_F& transformMatrix)</unmanaged>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 TransformMatrix {
                set { SetTransformMatrix(ref value); }
        }
        
        /// <summary>	
        /// <p>Sets the sharpness of the effect.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAffineTransform2DEffect::SetSharpness']/*"/>	
        /// <msdn-id>dn919694</msdn-id>	
        /// <unmanaged>SetSharpness</unmanaged>	
        /// <unmanaged-short>SetSharpness</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetSharpness([In] float sharpness)</unmanaged>
        public float Sharpness {
                set { SetSharpness(value); }
        }
        
        /// <summary>	
        /// <p>Sets the interpolation mode of the effect.</p>	
        /// </summary>	
        /// <param name="interpolationMode"><dd>  <p>Specifies the interpolation mode of the effect.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAffineTransform2DEffect::SetInterpolationMode']/*"/>	
        /// <msdn-id>dn919692</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetInterpolationMode([In] D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE interpolationMode)</unmanaged>	
        /// <unmanaged-short>IDCompositionAffineTransform2DEffect::SetInterpolationMode</unmanaged-short>	
        internal void SetInterpolationMode(SharpDX.Direct2D1.AffineTransform2DInterpolationMode interpolationMode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, unchecked((int)interpolationMode),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the border mode to use with the effect.</p>	
        /// </summary>	
        /// <param name="borderMode"><dd>  <p>Specifies the border mode to use with the effect.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAffineTransform2DEffect::SetBorderMode']/*"/>	
        /// <msdn-id>dn919691</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetBorderMode([In] D2D1_BORDER_MODE borderMode)</unmanaged>	
        /// <unmanaged-short>IDCompositionAffineTransform2DEffect::SetBorderMode</unmanaged-short>	
        internal void SetBorderMode(SharpDX.Direct2D1.BorderMode borderMode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, unchecked((int)borderMode),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="transformMatrix">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAffineTransform2DEffect::SetTransformMatrix']/*"/>	
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetTransformMatrix([In] const D2D_MATRIX_3X2_F&amp; transformMatrix)</unmanaged>	
        /// <unmanaged-short>IDCompositionAffineTransform2DEffect::SetTransformMatrix</unmanaged-short>	
        internal void SetTransformMatrix(ref SharpDX.Mathematics.Interop.RawMatrix3x2 transformMatrix) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* transformMatrix_ = &transformMatrix)
                    __result__= 
    				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, transformMatrix_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an element of the transform matrix of the effect.</p>	
        /// </summary>	
        /// <param name="row"><dd>  <p>The row of the element.</p> </dd></param>	
        /// <param name="column"><dd>  <p>The columen of the element.</p> </dd></param>	
        /// <param name="animation"><dd>  <p>An animation that represents how the element value changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAffineTransform2DEffect::SetTransformMatrixElement']/*"/>	
        /// <msdn-id>dn919697</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetTransformMatrixElement([In] int row,[In] int column,[In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionAffineTransform2DEffect::SetTransformMatrixElement</unmanaged-short>	
        public void SetTransformMatrixElement(int row, int column, SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, row, column, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an element of the transform matrix of the effect.</p>	
        /// </summary>	
        /// <param name="row"><dd>  <p>The row of the element.</p> </dd></param>	
        /// <param name="column"><dd>  <p>The columen of the element.</p> </dd></param>	
        /// <param name="value"><dd>  <p>An animation that represents how the element value changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAffineTransform2DEffect::SetTransformMatrixElement']/*"/>	
        /// <msdn-id>dn919697</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetTransformMatrixElement([In] int row,[In] int column,[In] float value)</unmanaged>	
        /// <unmanaged-short>IDCompositionAffineTransform2DEffect::SetTransformMatrixElement</unmanaged-short>	
        public void SetTransformMatrixElement(int row, int column, float value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, row, column, value,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the sharpness of the effect.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the sharpness value changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAffineTransform2DEffect::SetSharpness']/*"/>	
        /// <msdn-id>dn919694</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetSharpness([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionAffineTransform2DEffect::SetSharpness</unmanaged-short>	
        public void SetSharpness(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the sharpness of the effect.</p>	
        /// </summary>	
        /// <param name="sharpness"><dd>  <p>An animation that represents how the sharpness value changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAffineTransform2DEffect::SetSharpness']/*"/>	
        /// <msdn-id>dn919694</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionAffineTransform2DEffect::SetSharpness([In] float sharpness)</unmanaged>	
        /// <unmanaged-short>IDCompositionAffineTransform2DEffect::SetSharpness</unmanaged-short>	
        internal void SetSharpness(float sharpness) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, sharpness,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Adds a cubic polynomial segment to the animation function.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A cubic segment transitions time along a cubic polynomial.  For a given time input (t), the output value is given by the following equation. </p><p><em>x</em>(<em>t</em>) = <em>at</em>3 + <em>bt</em>2 + <em>ct</em> + <em>d</em></p><p>This method fails if any of the parameters are NaN, positive infinity, or negative infinity.</p><p>Because animation segments must be added in increasing order, this method fails if the <em>beginOffset</em> parameter is less than or equal to the <em>beginOffset</em> parameter of the previous segment, if any.</p><p>This animation segment remains in effect until the begin time of the next segment in the animation function. If the animation function contains no more segments, this segment remains in effect indefinitely. </p><p>If all coefficients except <em>constantCoefficient</em> are zero, the value of this segment remains constant over time, and the animation does not cause a recomposition for the duration of the segment.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAnimation']/*"/>	
    /// <msdn-id>hh437385</msdn-id>	
    /// <unmanaged>IDCompositionAnimation</unmanaged>	
    /// <unmanaged-short>IDCompositionAnimation</unmanaged-short>	
    [Guid("CBFD91D9-51B2-45e4-B3DE-D19CCFB863C5")]
    public partial class Animation : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.Animation"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Animation(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.Animation"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.Animation(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.Animation(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the absolute time at which the animation function starts.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>By default, an animation function starts when the first frame of the animation takes effect. For example, if an application creates a simple animation function with a single primitive at offset zero, associates the animation with some property,  and then calls the <strong><see cref="SharpDX.DirectComposition.Device.Commit"/></strong> method, the first frame that includes the commit samples the animation at offset zero for the first primitive. This implies that the actual default start time of all animations varies depending on the time between when the application creates the animation and calls <strong>Commit</strong>, to the time it takes the composition engine to pick up the committed changes. The application can use the <strong>SetAbsoluteBeginTime</strong> method to exercise finer control over the starting time of an animation. </p><p>This method does not control when animations take effect; it only affects how animations are sampled after they start. If the application specifies the exact time of the next frame as the absolute begin time, the result is the same as not calling this method at all. If the specified begin time is different from the time of the next frame, the result is one of following: </p><ul> <li>If the specified time is later than the next frame time, the animation start is delayed until the specified begin time.</li> <li>If the specified time is earlier than the next frame time, the beginning of the animation is dropped and sampling starts into the animation function.	
        /// </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAnimation::SetAbsoluteBeginTime']/*"/>	
        /// <msdn-id>hh437390</msdn-id>	
        /// <unmanaged>SetAbsoluteBeginTime</unmanaged>	
        /// <unmanaged-short>SetAbsoluteBeginTime</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionAnimation::SetAbsoluteBeginTime([In] LARGE_INTEGER beginTime)</unmanaged>
        public long AbsoluteBeginTime {
                set { SetAbsoluteBeginTime(value); }
        }
        
        /// <summary>	
        /// <p>Resets the animation function so that it contains no segments.</p>	
        /// </summary>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method returns the animation function to a clean state, as when the animation was first constructed. After this method is called, the next segment to be added becomes the first segment of the animation function. Because it is the first segment, it can have any non-negative beginning offset.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAnimation::Reset']/*"/>	
        /// <msdn-id>hh437389</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionAnimation::Reset()</unmanaged>	
        /// <unmanaged-short>IDCompositionAnimation::Reset</unmanaged-short>	
        public void Reset() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the absolute time at which the animation function starts.</p>	
        /// </summary>	
        /// <param name="beginTime"><dd>  <p>The starting time for this animation.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>By default, an animation function starts when the first frame of the animation takes effect. For example, if an application creates a simple animation function with a single primitive at offset zero, associates the animation with some property,  and then calls the <strong><see cref="SharpDX.DirectComposition.Device.Commit"/></strong> method, the first frame that includes the commit samples the animation at offset zero for the first primitive. This implies that the actual default start time of all animations varies depending on the time between when the application creates the animation and calls <strong>Commit</strong>, to the time it takes the composition engine to pick up the committed changes. The application can use the <strong>SetAbsoluteBeginTime</strong> method to exercise finer control over the starting time of an animation. </p><p>This method does not control when animations take effect; it only affects how animations are sampled after they start. If the application specifies the exact time of the next frame as the absolute begin time, the result is the same as not calling this method at all. If the specified begin time is different from the time of the next frame, the result is one of following: </p><ul> <li>If the specified time is later than the next frame time, the animation start is delayed until the specified begin time.</li> <li>If the specified time is earlier than the next frame time, the beginning of the animation is dropped and sampling starts into the animation function.	
        /// </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAnimation::SetAbsoluteBeginTime']/*"/>	
        /// <msdn-id>hh437390</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionAnimation::SetAbsoluteBeginTime([In] LARGE_INTEGER beginTime)</unmanaged>	
        /// <unmanaged-short>IDCompositionAnimation::SetAbsoluteBeginTime</unmanaged-short>	
        internal void SetAbsoluteBeginTime(long beginTime) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, beginTime,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds a cubic polynomial segment to the animation function.</p>	
        /// </summary>	
        /// <param name="beginOffset"><dd>  <p>The offset, in seconds, from the beginning of the animation function to the point when this segment should take effect.</p> </dd></param>	
        /// <param name="constantCoefficient"><dd>  <p>The constant coefficient of the polynomial.</p> </dd></param>	
        /// <param name="linearCoefficient"><dd>  <p>The linear coefficient of the polynomial.</p> </dd></param>	
        /// <param name="quadraticCoefficient"><dd>  <p>The quadratic coefficient of the polynomial.</p> </dd></param>	
        /// <param name="cubicCoefficient"><dd>  <p>The cubic coefficient of the polynomial.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A cubic segment transitions time along a cubic polynomial.  For a given time input (t), the output value is given by the following equation. </p><p><em>x</em>(<em>t</em>) = <em>at</em>3 + <em>bt</em>2 + <em>ct</em> + <em>d</em></p><p>This method fails if any of the parameters are NaN, positive infinity, or negative infinity.</p><p>Because animation segments must be added in increasing order, this method fails if the <em>beginOffset</em> parameter is less than or equal to the <em>beginOffset</em> parameter of the previous segment, if any.</p><p>This animation segment remains in effect until the begin time of the next segment in the animation function. If the animation function contains no more segments, this segment remains in effect indefinitely. </p><p>If all coefficients except <em>constantCoefficient</em> are zero, the value of this segment remains constant over time, and the animation does not cause a recomposition for the duration of the segment.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAnimation::AddCubic']/*"/>	
        /// <msdn-id>hh437385</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionAnimation::AddCubic([In] double beginOffset,[In] float constantCoefficient,[In] float linearCoefficient,[In] float quadraticCoefficient,[In] float cubicCoefficient)</unmanaged>	
        /// <unmanaged-short>IDCompositionAnimation::AddCubic</unmanaged-short>	
        public void AddCubic(double beginOffset, float constantCoefficient, float linearCoefficient, float quadraticCoefficient, float cubicCoefficient) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, beginOffset, constantCoefficient, linearCoefficient, quadraticCoefficient, cubicCoefficient,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds a sinusoidal segment to the animation function.</p>	
        /// </summary>	
        /// <param name="beginOffset"><dd>  <p>The offset, in seconds, from the beginning of the animation function to the point when this segment should take effect. </p> </dd></param>	
        /// <param name="bias"><dd>  <p>A constant that is added to the sinusoidal.</p> </dd></param>	
        /// <param name="amplitude"><dd>  <p>A scale factor that is applied to the sinusoidal.</p> </dd></param>	
        /// <param name="frequency"><dd>  <p>A scale factor that is applied to the time offset, in Hertz.</p> </dd></param>	
        /// <param name="phase"><dd>  <p>A constant that is added to the time offset, in degrees.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if any of the parameters are NaN, positive infinity, or negative infinity, or if the <em>beginOffset</em> parameter is negative. </p><p>Because animation segments must be added in increasing order, this method fails if the <em>beginOffset</em> parameter is less than or equal to the <em>beginOffset</em> parameter of the previous segment, if any.</p><p>This animation segment remains in effect until the begin time of the next segment in the animation function. If the animation function contains no more segments, this segment remains in effect indefinitely. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAnimation::AddSinusoidal']/*"/>	
        /// <msdn-id>hh437387</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionAnimation::AddSinusoidal([In] double beginOffset,[In] float bias,[In] float amplitude,[In] float frequency,[In] float phase)</unmanaged>	
        /// <unmanaged-short>IDCompositionAnimation::AddSinusoidal</unmanaged-short>	
        public void AddSinusoidal(double beginOffset, float bias, float amplitude, float frequency, float phase) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, beginOffset, bias, amplitude, frequency, phase,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds a repeat segment that causes the specified portion of an animation function to be repeated.</p>	
        /// </summary>	
        /// <param name="beginOffset"><dd>  <p>The offset, in seconds, from the beginning of the animation to the point at which the repeat should begin.</p> </dd></param>	
        /// <param name="durationToRepeat"><dd>  <p>The duration, in seconds, of a portion of the animation immediately preceding the begin time that is specified by <em>beginOffset</em>.  This is the portion that will be repeated.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if any of the parameters are NaN, positive infinity, or negative infinity.</p><p>Because animation segments must be added in increasing order, this method fails if the <em>beginOffset</em> parameter is less than or equal to the <em>beginOffset</em> parameter of the previous segment. This method also fails if this is the first segment to be added to the animation function.</p><p>This animation segment remains in effect until the begin time of the next segment. If the animation function contains no more segments, this segment remains in effect indefinitely.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAnimation::AddRepeat']/*"/>	
        /// <msdn-id>hh437386</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionAnimation::AddRepeat([In] double beginOffset,[In] double durationToRepeat)</unmanaged>	
        /// <unmanaged-short>IDCompositionAnimation::AddRepeat</unmanaged-short>	
        public void AddRepeat(double beginOffset, double durationToRepeat) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, beginOffset, durationToRepeat,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds an end segment that marks the end of an animation function.  </p>	
        /// </summary>	
        /// <param name="endOffset"><dd>  <p>The offset, in seconds, from the beginning of the animation function to the point when the function ends.</p> </dd></param>	
        /// <param name="endValue"><dd>  <p>The final value of the animation.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>When the specified offset is reached, the property or properties affected by this animation are set to the specified final value, and then the animation stops. If no end segment is added, the final segment of the animation function runs indefinitely. Calling this method is semantically identical to making the last segment of the animation function a cubic polynomial where the cubic, quadratic, and linear coefficients are all zeros, and the constant coefficient is the desired final value.</p><p>Because animation segments must be added in increasing order, this method fails if the <em>endOffset</em> parameter is less than or equal to the <em>beginOffset</em> parameter of the previous segment. This method also fails if this is the first segment to be added to the animation function.</p><p>After this method is called, all methods on this animation object fail except the <strong><see cref="SharpDX.DirectComposition.Animation.Reset"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionAnimation::End']/*"/>	
        /// <msdn-id>hh437388</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionAnimation::End([In] double endOffset,[In] float endValue)</unmanaged>	
        /// <unmanaged-short>IDCompositionAnimation::End</unmanaged-short>	
        public void End(double endOffset, float endValue) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, endOffset, endValue,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The arithmetic composite effect is used to combine 2 images using a weighted sum of pixels from the input images.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect']/*"/>	
    /// <msdn-id>dn919698</msdn-id>	
    /// <unmanaged>IDCompositionArithmeticCompositeEffect</unmanaged>	
    /// <unmanaged-short>IDCompositionArithmeticCompositeEffect</unmanaged-short>	
    [Guid("3B67DFA8-E3DD-4E61-B640-46C2F3D739DC")]
    public partial class ArithmeticCompositeEffect : SharpDX.DirectComposition.FilterEffect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.ArithmeticCompositeEffect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ArithmeticCompositeEffect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.ArithmeticCompositeEffect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.ArithmeticCompositeEffect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.ArithmeticCompositeEffect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the coefficients for the equation used to composite the two input images.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetCoefficients']/*"/>	
        /// <msdn-id>dn919708</msdn-id>	
        /// <unmanaged>SetCoefficients</unmanaged>	
        /// <unmanaged-short>SetCoefficients</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficients([In] const D2D_VECTOR_4F& coefficients)</unmanaged>
        public SharpDX.Mathematics.Interop.RawVector4 Coefficients {
                set { SetCoefficients(value); }
        }
        
        /// <summary>	
        /// <p>Specifies whether to clamp color values before the effect passes the values to the next effect in the graph.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetClampOutput']/*"/>	
        /// <msdn-id>dn919699</msdn-id>	
        /// <unmanaged>SetClampOutput</unmanaged>	
        /// <unmanaged-short>SetClampOutput</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetClampOutput([In] BOOL clampoutput)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool ClampOutput {
                set { SetClampOutput(value); }
        }
        
        /// <summary>	
        /// <p>Sets the first coefficient for the equation used to composite the two input images.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetCoefficient1']/*"/>	
        /// <msdn-id>dn919700</msdn-id>	
        /// <unmanaged>SetCoefficient1</unmanaged>	
        /// <unmanaged-short>SetCoefficient1</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient1([In] float Coeffcient1)</unmanaged>
        public float Coefficient1 {
                set { SetCoefficient1(value); }
        }
        
        /// <summary>	
        /// <p>Sets the second coefficient for the equation used to composite the two input images.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetCoefficient2']/*"/>	
        /// <msdn-id>dn919702</msdn-id>	
        /// <unmanaged>SetCoefficient2</unmanaged>	
        /// <unmanaged-short>SetCoefficient2</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient2([In] float Coefficient2)</unmanaged>
        public float Coefficient2 {
                set { SetCoefficient2(value); }
        }
        
        /// <summary>	
        /// <p>Sets the third coefficient for the equation used to composite the two input images.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetCoefficient3']/*"/>	
        /// <msdn-id>dn919705</msdn-id>	
        /// <unmanaged>SetCoefficient3</unmanaged>	
        /// <unmanaged-short>SetCoefficient3</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient3([In] float Coefficient3)</unmanaged>
        public float Coefficient3 {
                set { SetCoefficient3(value); }
        }
        
        /// <summary>	
        /// <p>Sets the fourth coefficient for the equation used to composite the two input images.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetCoefficient4']/*"/>	
        /// <msdn-id>dn919706</msdn-id>	
        /// <unmanaged>SetCoefficient4</unmanaged>	
        /// <unmanaged-short>SetCoefficient4</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient4([In] float Coefficient4)</unmanaged>
        public float Coefficient4 {
                set { SetCoefficient4(value); }
        }
        
        /// <summary>	
        /// <p>Sets the coefficients for the equation used to composite the two input images.</p>	
        /// </summary>	
        /// <param name="coefficients"><dd>  <p>The coefficients for the equation used to composite the two input images.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetCoefficients']/*"/>	
        /// <msdn-id>dn919708</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficients([In] const D2D_VECTOR_4F&amp; coefficients)</unmanaged>	
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficients</unmanaged-short>	
        internal void SetCoefficients(SharpDX.Mathematics.Interop.RawVector4 coefficients) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &coefficients,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies whether to clamp color values before the effect passes the values to the next effect in the graph.</p>	
        /// </summary>	
        /// <param name="clampoutput"><dd>  <p>A boolean value indicating whether to clamp the color values.  A value of TRUE causes color values to be clamped between 0 and 1.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetClampOutput']/*"/>	
        /// <msdn-id>dn919699</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetClampOutput([In] BOOL clampoutput)</unmanaged>	
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetClampOutput</unmanaged-short>	
        internal void SetClampOutput(SharpDX.Mathematics.Interop.RawBool clampoutput) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint9(_nativePointer, clampoutput,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the first coefficient for the equation used to composite the two input images.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Specifies the first coefficient for the equation used to composite the two input images.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetCoefficient1']/*"/>	
        /// <msdn-id>dn919700</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient1([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient1</unmanaged-short>	
        public void SetCoefficient1(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the first coefficient for the equation used to composite the two input images.</p>	
        /// </summary>	
        /// <param name="coeffcient1"><dd>  <p>Specifies the first coefficient for the equation used to composite the two input images.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetCoefficient1']/*"/>	
        /// <msdn-id>dn919700</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient1([In] float Coeffcient1)</unmanaged>	
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient1</unmanaged-short>	
        internal void SetCoefficient1(float coeffcient1) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, coeffcient1,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the second coefficient for the equation used to composite the two input images.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The second coefficient for the equation used to composite the two input images.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetCoefficient2']/*"/>	
        /// <msdn-id>dn919702</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient2([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient2</unmanaged-short>	
        public void SetCoefficient2(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the second coefficient for the equation used to composite the two input images.</p>	
        /// </summary>	
        /// <param name="coefficient2"><dd>  <p>The second coefficient for the equation used to composite the two input images.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetCoefficient2']/*"/>	
        /// <msdn-id>dn919702</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient2([In] float Coefficient2)</unmanaged>	
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient2</unmanaged-short>	
        internal void SetCoefficient2(float coefficient2) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, coefficient2,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the third coefficient for the equation used to composite the two input images.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the value of the third coefficient changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetCoefficient3']/*"/>	
        /// <msdn-id>dn919705</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient3([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient3</unmanaged-short>	
        public void SetCoefficient3(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the third coefficient for the equation used to composite the two input images.</p>	
        /// </summary>	
        /// <param name="coefficient3"><dd>  <p>An animation that represents how the value of the third coefficient changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetCoefficient3']/*"/>	
        /// <msdn-id>dn919705</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient3([In] float Coefficient3)</unmanaged>	
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient3</unmanaged-short>	
        internal void SetCoefficient3(float coefficient3) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, coefficient3,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the fourth coefficient for the equation used to composite the two input images.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The fourth coefficient for the equation used to composite the two input images.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetCoefficient4']/*"/>	
        /// <msdn-id>dn919706</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient4([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient4</unmanaged-short>	
        public void SetCoefficient4(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the fourth coefficient for the equation used to composite the two input images.</p>	
        /// </summary>	
        /// <param name="coefficient4"><dd>  <p>The fourth coefficient for the equation used to composite the two input images.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionArithmeticCompositeEffect::SetCoefficient4']/*"/>	
        /// <msdn-id>dn919706</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionArithmeticCompositeEffect::SetCoefficient4([In] float Coefficient4)</unmanaged>	
        /// <unmanaged-short>IDCompositionArithmeticCompositeEffect::SetCoefficient4</unmanaged-short>	
        internal void SetCoefficient4(float coefficient4) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, coefficient4,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> The Blend Effect is used to combine 2 images. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBlendEffect']/*"/>	
    /// <msdn-id>dn919709</msdn-id>	
    /// <unmanaged>IDCompositionBlendEffect</unmanaged>	
    /// <unmanaged-short>IDCompositionBlendEffect</unmanaged-short>	
    [Guid("33ECDC0A-578A-4A11-9C14-0CB90517F9C5")]
    public partial class BlendEffect : SharpDX.DirectComposition.FilterEffect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.BlendEffect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BlendEffect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.BlendEffect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.BlendEffect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.BlendEffect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the blend mode to use when the blend effect combines the two images.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBlendEffect::SetMode']/*"/>	
        /// <msdn-id>dn919710</msdn-id>	
        /// <unmanaged>SetMode</unmanaged>	
        /// <unmanaged-short>SetMode</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionBlendEffect::SetMode([In] D2D1_BLEND_MODE mode)</unmanaged>
        public SharpDX.Direct2D1.BlendMode Mode {
                set { SetMode(value); }
        }
        
        /// <summary>	
        /// <p>Sets the blend mode to use when the blend effect combines the two images.</p>	
        /// </summary>	
        /// <param name="mode"><dd>  <p>The blend mode to use when the blend effect combines the two images.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBlendEffect::SetMode']/*"/>	
        /// <msdn-id>dn919710</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionBlendEffect::SetMode([In] D2D1_BLEND_MODE mode)</unmanaged>	
        /// <unmanaged-short>IDCompositionBlendEffect::SetMode</unmanaged-short>	
        internal void SetMode(SharpDX.Direct2D1.BlendMode mode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, unchecked((int)mode),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The brightness effect controls the brightness of the image.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect']/*"/>	
    /// <msdn-id>dn919711</msdn-id>	
    /// <unmanaged>IDCompositionBrightnessEffect</unmanaged>	
    /// <unmanaged-short>IDCompositionBrightnessEffect</unmanaged-short>	
    [Guid("6027496E-CB3A-49AB-934F-D798DA4F7DA6")]
    public partial class BrightnessEffect : SharpDX.DirectComposition.FilterEffect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.BrightnessEffect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BrightnessEffect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.BrightnessEffect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.BrightnessEffect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.BrightnessEffect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the upper portion of the brightness transfer curve. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetWhitePoint']/*"/>	
        /// <msdn-id>dn919717</msdn-id>	
        /// <unmanaged>SetWhitePoint</unmanaged>	
        /// <unmanaged-short>SetWhitePoint</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetWhitePoint([In] const D2D_VECTOR_2F& whitePoint)</unmanaged>
        public SharpDX.Mathematics.Interop.RawVector2 WhitePoint {
                set { SetWhitePoint(value); }
        }
        
        /// <summary>	
        /// <p>Specifies the lower portion of the brightness transfer curve for the brightness effect.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetBlackPoint']/*"/>	
        /// <msdn-id>dn919712</msdn-id>	
        /// <unmanaged>SetBlackPoint</unmanaged>	
        /// <unmanaged-short>SetBlackPoint</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetBlackPoint([In] const D2D_VECTOR_2F& blackPoint)</unmanaged>
        public SharpDX.Mathematics.Interop.RawVector2 BlackPoint {
                set { SetBlackPoint(value); }
        }
        
        /// <summary>	
        /// <p>Sets the x value of the white point.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetWhitePointX']/*"/>	
        /// <msdn-id>dn919719</msdn-id>	
        /// <unmanaged>SetWhitePointX</unmanaged>	
        /// <unmanaged-short>SetWhitePointX</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetWhitePointX([In] float whitePointX)</unmanaged>
        public float WhitePointX {
                set { SetWhitePointX(value); }
        }
        
        /// <summary>	
        /// Sets the y value of the white point.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetWhitePointY']/*"/>	
        /// <msdn-id>dn905287</msdn-id>	
        /// <unmanaged>SetWhitePointY</unmanaged>	
        /// <unmanaged-short>SetWhitePointY</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetWhitePointY([In] float whitePointY)</unmanaged>
        public float WhitePointY {
                set { SetWhitePointY(value); }
        }
        
        /// <summary>	
        /// <p>Sets the x value of the black point.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetBlackPointX']/*"/>	
        /// <msdn-id>dn919714</msdn-id>	
        /// <unmanaged>SetBlackPointX</unmanaged>	
        /// <unmanaged-short>SetBlackPointX</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetBlackPointX([In] float blackPointX)</unmanaged>
        public float BlackPointX {
                set { SetBlackPointX(value); }
        }
        
        /// <summary>	
        /// <p>Sets the y value of the black point.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetBlackPointY']/*"/>	
        /// <msdn-id>dn919716</msdn-id>	
        /// <unmanaged>SetBlackPointY</unmanaged>	
        /// <unmanaged-short>SetBlackPointY</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetBlackPointY([In] float blackPointY)</unmanaged>
        public float BlackPointY {
                set { SetBlackPointY(value); }
        }
        
        /// <summary>	
        /// <p>Sets the upper portion of the brightness transfer curve. </p>	
        /// </summary>	
        /// <param name="whitePoint"><dd>  <p>The upper portion of the brightness transfer curve. The white point adjusts the appearance of the brighter portions of the image. This vector is for both the x value and the y value, in that order. Each of the values must be between 0 and 1, inclusive.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetWhitePoint']/*"/>	
        /// <msdn-id>dn919717</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetWhitePoint([In] const D2D_VECTOR_2F&amp; whitePoint)</unmanaged>	
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetWhitePoint</unmanaged-short>	
        internal void SetWhitePoint(SharpDX.Mathematics.Interop.RawVector2 whitePoint) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &whitePoint,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies the lower portion of the brightness transfer curve for the brightness effect.</p>	
        /// </summary>	
        /// <param name="blackPoint"><dd>  <p>The lower portion of the brightness transfer curve. The black point adjusts the appearance of the darker portions of the image. The vector is for both the x value and the y value, in that order. Each of the values must be between 0 and 1, inclusive.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetBlackPoint']/*"/>	
        /// <msdn-id>dn919712</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetBlackPoint([In] const D2D_VECTOR_2F&amp; blackPoint)</unmanaged>	
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetBlackPoint</unmanaged-short>	
        internal void SetBlackPoint(SharpDX.Mathematics.Interop.RawVector2 blackPoint) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &blackPoint,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the x value of the white point.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the x value of the white point changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetWhitePointX']/*"/>	
        /// <msdn-id>dn919719</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetWhitePointX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetWhitePointX</unmanaged-short>	
        public void SetWhitePointX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the x value of the white point.</p>	
        /// </summary>	
        /// <param name="whitePointX"><dd>  <p>An animation that represents how the x value of the white point changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetWhitePointX']/*"/>	
        /// <msdn-id>dn919719</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetWhitePointX([In] float whitePointX)</unmanaged>	
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetWhitePointX</unmanaged-short>	
        internal void SetWhitePointX(float whitePointX) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, whitePointX,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// Sets the y value of the white point.	
        /// </summary>	
        /// <param name="animation">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetWhitePointY']/*"/>	
        /// <msdn-id>dn905287</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetWhitePointY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetWhitePointY</unmanaged-short>	
        public void SetWhitePointY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// Sets the y value of the white point.	
        /// </summary>	
        /// <param name="whitePointY">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetWhitePointY']/*"/>	
        /// <msdn-id>dn905287</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetWhitePointY([In] float whitePointY)</unmanaged>	
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetWhitePointY</unmanaged-short>	
        internal void SetWhitePointY(float whitePointY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, whitePointY,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the x value of the black point.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the x value of the black point changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetBlackPointX']/*"/>	
        /// <msdn-id>dn919714</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetBlackPointX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetBlackPointX</unmanaged-short>	
        public void SetBlackPointX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the x value of the black point.</p>	
        /// </summary>	
        /// <param name="blackPointX"><dd>  <p>An animation that represents how the x value of the black point changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetBlackPointX']/*"/>	
        /// <msdn-id>dn919714</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetBlackPointX([In] float blackPointX)</unmanaged>	
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetBlackPointX</unmanaged-short>	
        internal void SetBlackPointX(float blackPointX) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, blackPointX,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the y value of the black point.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the y value of the black point changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetBlackPointY']/*"/>	
        /// <msdn-id>dn919716</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetBlackPointY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetBlackPointY</unmanaged-short>	
        public void SetBlackPointY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the y value of the black point.</p>	
        /// </summary>	
        /// <param name="blackPointY"><dd>  <p>An animation that represents how the y value of the black point changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionBrightnessEffect::SetBlackPointY']/*"/>	
        /// <msdn-id>dn919716</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionBrightnessEffect::SetBlackPointY([In] float blackPointY)</unmanaged>	
        /// <unmanaged-short>IDCompositionBrightnessEffect::SetBlackPointY</unmanaged-short>	
        internal void SetBlackPointY(float blackPointY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, blackPointY,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a clip object that is used to restrict the rendering of a visual subtree to a rectangular area. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionClip']/*"/>	
    /// <msdn-id>hh437391</msdn-id>	
    /// <unmanaged>IDCompositionClip</unmanaged>	
    /// <unmanaged-short>IDCompositionClip</unmanaged-short>	
    [Guid("64AC3703-9D3F-45ec-A109-7CAC0E7A13A7")]
    public partial class Clip : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.Clip"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Clip(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.Clip"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.Clip(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.Clip(nativePointer);
		}
        
    }
    /// <summary>	
    /// <p>The color matrix effect alters the RGBA values of a bitmap.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionColorMatrixEffect']/*"/>	
    /// <msdn-id>dn919722</msdn-id>	
    /// <unmanaged>IDCompositionColorMatrixEffect</unmanaged>	
    /// <unmanaged-short>IDCompositionColorMatrixEffect</unmanaged-short>	
    [Guid("C1170A22-3CE2-4966-90D4-55408BFC84C4")]
    public partial class ColorMatrixEffect : SharpDX.DirectComposition.FilterEffect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.ColorMatrixEffect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ColorMatrixEffect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.ColorMatrixEffect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.ColorMatrixEffect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.ColorMatrixEffect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the matrix used by the effect to multiply the RGBA values of the image.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionColorMatrixEffect::SetMatrix']/*"/>	
        /// <msdn-id>dn919725</msdn-id>	
        /// <unmanaged>SetMatrix</unmanaged>	
        /// <unmanaged-short>SetMatrix</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionColorMatrixEffect::SetMatrix([In] const D2D_MATRIX_5X4_F& matrix)</unmanaged>
        public SharpDX.Mathematics.Interop.RawMatrix5x4 Matrix {
                set { SetMatrix(ref value); }
        }
        
        /// <summary>	
        /// <p>Sets the alpha mode of the output for the color matrix effect.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionColorMatrixEffect::SetAlphaMode']/*"/>	
        /// <msdn-id>dn919723</msdn-id>	
        /// <unmanaged>SetAlphaMode</unmanaged>	
        /// <unmanaged-short>SetAlphaMode</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionColorMatrixEffect::SetAlphaMode([In] D2D1_COLORMATRIX_ALPHA_MODE mode)</unmanaged>
        public SharpDX.Direct2D1.ColorMatrixAlphaMode AlphaMode {
                set { SetAlphaMode(value); }
        }
        
        /// <summary>	
        /// <p>Specifies whether the effect clamps color values to between 0 and 1 before the effects passes the values to the next effect in the chain.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionColorMatrixEffect::SetClampOutput']/*"/>	
        /// <msdn-id>dn919724</msdn-id>	
        /// <unmanaged>SetClampOutput</unmanaged>	
        /// <unmanaged-short>SetClampOutput</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionColorMatrixEffect::SetClampOutput([In] BOOL clamp)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool ClampOutput {
                set { SetClampOutput(value); }
        }
        
        /// <summary>	
        /// <p>Sets the matrix used by the effect to multiply the RGBA values of the image.</p>	
        /// </summary>	
        /// <param name="matrix"><dd>  <p>The matrix used by the effect to multiply the RGBA values of the image. The matrix is column major and is applied as shown in the following equation: </p></dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionColorMatrixEffect::SetMatrix']/*"/>	
        /// <msdn-id>dn919725</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionColorMatrixEffect::SetMatrix([In] const D2D_MATRIX_5X4_F&amp; matrix)</unmanaged>	
        /// <unmanaged-short>IDCompositionColorMatrixEffect::SetMatrix</unmanaged-short>	
        internal void SetMatrix(ref SharpDX.Mathematics.Interop.RawMatrix5x4 matrix) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* matrix_ = &matrix)
                    __result__= 
    				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, matrix_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an element of the color matrix.</p>	
        /// </summary>	
        /// <param name="row"><dd>  <p>The row of the element.</p> </dd></param>	
        /// <param name="column"><dd>  <p>The column of the element.</p> </dd></param>	
        /// <param name="animation"><dd>  <p>The new value of the element.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionColorMatrixEffect::SetMatrixElement']/*"/>	
        /// <msdn-id>dn919726</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionColorMatrixEffect::SetMatrixElement([In] int row,[In] int column,[In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionColorMatrixEffect::SetMatrixElement</unmanaged-short>	
        public void SetMatrixElement(int row, int column, SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, row, column, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an element of the color matrix.</p>	
        /// </summary>	
        /// <param name="row"><dd>  <p>The row of the element.</p> </dd></param>	
        /// <param name="column"><dd>  <p>The column of the element.</p> </dd></param>	
        /// <param name="value"><dd>  <p>The new value of the element.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionColorMatrixEffect::SetMatrixElement']/*"/>	
        /// <msdn-id>dn919726</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionColorMatrixEffect::SetMatrixElement([In] int row,[In] int column,[In] float value)</unmanaged>	
        /// <unmanaged-short>IDCompositionColorMatrixEffect::SetMatrixElement</unmanaged-short>	
        public void SetMatrixElement(int row, int column, float value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, row, column, value,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the alpha mode of the output for the color matrix effect.</p>	
        /// </summary>	
        /// <param name="mode"><dd>  <p>The alpha mode of the output for the color matrix effect.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionColorMatrixEffect::SetAlphaMode']/*"/>	
        /// <msdn-id>dn919723</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionColorMatrixEffect::SetAlphaMode([In] D2D1_COLORMATRIX_ALPHA_MODE mode)</unmanaged>	
        /// <unmanaged-short>IDCompositionColorMatrixEffect::SetAlphaMode</unmanaged-short>	
        internal void SetAlphaMode(SharpDX.Direct2D1.ColorMatrixAlphaMode mode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, unchecked((int)mode),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies whether the effect clamps color values to between 0 and 1 before the effects passes the values to the next effect in the chain.</p>	
        /// </summary>	
        /// <param name="clamp"><dd>  <p>A boolean value indicating whether the effect clamps color values to between 0 and 1 before the effects passes the values to the next effect in the chain.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionColorMatrixEffect::SetClampOutput']/*"/>	
        /// <msdn-id>dn919724</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionColorMatrixEffect::SetClampOutput([In] BOOL clamp)</unmanaged>	
        /// <unmanaged-short>IDCompositionColorMatrixEffect::SetClampOutput</unmanaged-short>	
        internal void SetClampOutput(SharpDX.Mathematics.Interop.RawBool clamp) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint9(_nativePointer, clamp,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> The composite effect is used to combine 2 or more images. This effect has 13 different composite modes. The composite effect accepts 2 or more inputs. When you specify 2 images, destination is the first input (index 0) and the source is the second input (index 1).  If you specify more than 2 inputs, the images are composited starting with the first input and the second and so on. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionCompositeEffect']/*"/>	
    /// <msdn-id>dn919728</msdn-id>	
    /// <unmanaged>IDCompositionCompositeEffect</unmanaged>	
    /// <unmanaged-short>IDCompositionCompositeEffect</unmanaged-short>	
    [Guid("576616C0-A231-494D-A38D-00FD5EC4DB46")]
    public partial class CompositeEffect : SharpDX.DirectComposition.FilterEffect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.CompositeEffect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CompositeEffect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.CompositeEffect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.CompositeEffect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.CompositeEffect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the mode for the composite effect.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionCompositeEffect::SetMode']/*"/>	
        /// <msdn-id>dn919729</msdn-id>	
        /// <unmanaged>SetMode</unmanaged>	
        /// <unmanaged-short>SetMode</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionCompositeEffect::SetMode([In] D2D1_COMPOSITE_MODE mode)</unmanaged>
        public SharpDX.Direct2D1.CompositeMode Mode {
                set { SetMode(value); }
        }
        
        /// <summary>	
        /// <p>Sets the mode for the composite effect.</p>	
        /// </summary>	
        /// <param name="mode"><dd>  <p>The mode for the composite effect.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionCompositeEffect::SetMode']/*"/>	
        /// <msdn-id>dn919729</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionCompositeEffect::SetMode([In] D2D1_COMPOSITE_MODE mode)</unmanaged>	
        /// <unmanaged-short>IDCompositionCompositeEffect::SetMode</unmanaged-short>	
        internal void SetMode(SharpDX.Direct2D1.CompositeMode mode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, unchecked((int)mode),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>An application must use the <see cref="SharpDX.DirectComposition.DesktopDevice"/> interface in order to use DirectComposition in a Win32 desktop application. This interface allows the application to connect a visual tree to a window and to host layered child windows for composition</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDesktopDevice']/*"/>	
    /// <msdn-id>dn280350</msdn-id>	
    /// <unmanaged>IDCompositionDesktopDevice</unmanaged>	
    /// <unmanaged-short>IDCompositionDesktopDevice</unmanaged-short>	
    [Guid("5F4633FE-1E08-4CB8-8C75-CE24333F5602")]
    public partial class DesktopDevice : SharpDX.DirectComposition.Device2 {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.DesktopDevice"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DesktopDevice(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.DesktopDevice"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.DesktopDevice(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.DesktopDevice(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Creates a composition target object that is bound to the window that is represented by the specified window handle.</p>	
        /// </summary>	
        /// <param name="hwnd"><dd> <p>The window to which the composition target object should be bound. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <param name="topmost"><dd> <p>TRUE if the visual tree should be displayed on top of the children of the window specified by the hwnd parameter; otherwise, the visual tree is displayed behind the children.</p> </dd></param>	
        /// <returns><dd> <p>The new composition target object. This parameter must not be <c>null</c>.</p> </dd></returns>	
        /// <remarks>	
        /// <p>A DirectComposition visual tree must be bound to a window before anything can be displayed on screen. The window can be a top-level window or a child window. In either case, the window can be a layered window, but in all cases the window must belong to the calling process. If the window belongs to a different process, this method returns DCOMPOSITION_ERROR_ACCESS_DENIED.</p><p>When DirectComposition content is composed to the window, the content is always composed on top of whatever is drawn directly to that window through the device context returned by the <strong>GetDC</strong> function, or by calls to DirectX Present methods. However, because window clipping rules apply to DirectComposition content, if the window has child windows, those child windows may clip the visual tree. The topmost parameter determines whether child windows clip the visual tree.</p><p>Conceptually, each window consists of four layers:</p><ol> <li>The contents drawn directly to the window handle (this is the bottommost layer).</li> <li>An optional DirectComposition visual tree.</li> <li>The contents of all child windows, if any.</li> <li>Another optional DirectComposition visual tree (this is the topmost layer).</li> </ol><p>All four layers are clipped to the window?s visible region.</p><p>At most, only two composition targets can be created for each window in the system, one topmost and one not topmost. If a composition target is already bound to the specified window at the specified layer, this method fails. When a composition target object is destroyed, the layer it composed is available for use by a new composition target object.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDesktopDevice::CreateTargetForHwnd']/*"/>	
        /// <msdn-id>dn280353</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDesktopDevice::CreateTargetForHwnd([In] HWND hwnd,[In] BOOL topmost,[Out] IDCompositionTarget** target)</unmanaged>	
        /// <unmanaged-short>IDCompositionDesktopDevice::CreateTargetForHwnd</unmanaged-short>	
        internal SharpDX.DirectComposition.Target CreateTargetForHwnd(System.IntPtr hwnd, SharpDX.Mathematics.Interop.RawBool topmost) {
            unsafe {
                SharpDX.DirectComposition.Target target;
                IntPtr target_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint12(_nativePointer, (void*)hwnd, topmost, &target_,((void**)(*(void**)_nativePointer))[24]);		
                target= (target_ == IntPtr.Zero)?null:new SharpDX.DirectComposition.Target(target_);	
                __result__.CheckError();
                return target;
            }
        }
        
        /// <summary>	
        /// <p>Creates a new composition surface object that wraps an existing composition surface.</p>	
        /// </summary>	
        /// <param name="handle"><dd> <p>The handle of an existing composition surface that was created by a call to the <strong><see cref="SharpDX.DirectComposition.DComp.CreateSurfaceHandle"/></strong> function.</p> </dd></param>	
        /// <returns><dd> <p>The new composition surface object. This parameter must not be <c>null</c>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDesktopDevice::CreateSurfaceFromHandle']/*"/>	
        /// <msdn-id>dn280351</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDesktopDevice::CreateSurfaceFromHandle([In] void* handle,[Out] IUnknown** surface)</unmanaged>	
        /// <unmanaged-short>IDCompositionDesktopDevice::CreateSurfaceFromHandle</unmanaged-short>	
        public SharpDX.ComObject CreateSurfaceFromHandle(System.IntPtr handle) {
            unsafe {
                SharpDX.ComObject surface;
                IntPtr surface_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)handle, &surface_,((void**)(*(void**)_nativePointer))[25]);		
                surface= (surface_ == IntPtr.Zero)?null:new SharpDX.ComObject(surface_);	
                __result__.CheckError();
                return surface;
            }
        }
        
        /// <summary>	
        /// <p>Creates a wrapper object that represents the rasterization of a layered window, and that can be associated with a visual for composition.</p>	
        /// </summary>	
        /// <param name="hwnd"><dd> <p>The handle of the layered window for which to create a wrapper. A layered window is created by specifying WS_EX_LAYERED when creating the window with the <strong>CreateWindowEx</strong> function or by setting WS_EX_LAYERED via <strong>SetWindowLong</strong> after the window has been created.</p> </dd></param>	
        /// <returns><dd> <p>The new composition surface object. This parameter must not be <c>null</c>.</p> </dd></returns>	
        /// <remarks>	
        /// <p>You can use the surface reference in calls to the <see cref="SharpDX.DirectComposition.Visual.SetContent"/> method to set the content of one or more visuals. After setting the content, the visuals compose the contents of the specified layered window as long as the window is layered. If the window is unlayered, the window content disappears from the output of the composition tree. If the window is later re-layered, the window content reappears as long as it is still associated with a visual. If the window is resized, the affected visuals are re-composed. </p><p>The contents of the window are not cached beyond the life of the window. That is, if the window is destroyed, the affected visuals stop composing the window. </p><p>If the window is moved off-screen or resized to zero, the system stops composing the content of those visuals. You should use the <strong>DwmSetWindowAttribute</strong> function with the DWMWA_CLOAK flag to "cloak" the layered child window when you need to hide the original window while allowing the system to continue to compose the content of the visuals.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDesktopDevice::CreateSurfaceFromHwnd']/*"/>	
        /// <msdn-id>dn280352</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDesktopDevice::CreateSurfaceFromHwnd([In] HWND hwnd,[Out] IUnknown** surface)</unmanaged>	
        /// <unmanaged-short>IDCompositionDesktopDevice::CreateSurfaceFromHwnd</unmanaged-short>	
        public SharpDX.ComObject CreateSurfaceFromHwnd(System.IntPtr hwnd) {
            unsafe {
                SharpDX.ComObject surface;
                IntPtr surface_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)hwnd, &surface_,((void**)(*(void**)_nativePointer))[26]);		
                surface= (surface_ == IntPtr.Zero)?null:new SharpDX.ComObject(surface_);	
                __result__.CheckError();
                return surface;
            }
        }
    }
    /// <summary>	
    /// <p>Serves as a factory for all other Microsoft DirectComposition objects and provides methods to control transactional composition.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice']/*"/>	
    /// <msdn-id>hh437392</msdn-id>	
    /// <unmanaged>IDCompositionDevice</unmanaged>	
    /// <unmanaged-short>IDCompositionDevice</unmanaged-short>	
    [Guid("C37EA93A-E7AA-450D-B16F-9746CB0407F3")]
    public partial class Device : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.Device"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Device(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.Device"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.Device(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.Device(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves information from the composition engine about composition times and the frame rate.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method retrieves timing information about the composition engine that an application can use to synchronize the rasterization of bitmaps with independent animations.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::GetFrameStatistics']/*"/>	
        /// <msdn-id>hh437415</msdn-id>	
        /// <unmanaged>GetFrameStatistics</unmanaged>	
        /// <unmanaged-short>GetFrameStatistics</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionDevice::GetFrameStatistics([Out] DCOMPOSITION_FRAME_STATISTICS* statistics)</unmanaged>
        public SharpDX.DirectComposition.FrameStatistics FrameStatistics {
                get { SharpDX.DirectComposition.FrameStatistics __output__; GetFrameStatistics(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Commits all DirectComposition commands that are pending on this device.</p>	
        /// </summary>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Calls to DirectComposition methods are always batched and executed atomically as a single transaction. Calls take effect only when <strong><see cref="SharpDX.DirectComposition.Device.Commit"/></strong> is called, at which time all pending method calls for a device are executed at once. </p><p>An application that uses multiple devices must call <strong>Commit</strong> for each device separately. However, because the composition engine processes the calls individually, the batch of commands might not take effect at the same time. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::Commit']/*"/>	
        /// <msdn-id>hh437393</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::Commit()</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::Commit</unmanaged-short>	
        public void Commit() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Waits for the composition engine to finish processing the previous call to the <strong><see cref="SharpDX.DirectComposition.Device.Commit"/></strong> method. </p>	
        /// </summary>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::WaitForCommitCompletion']/*"/>	
        /// <msdn-id>hh920928</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::WaitForCommitCompletion()</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::WaitForCommitCompletion</unmanaged-short>	
        public void WaitForCommitCompletion() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves information from the composition engine about composition times and the frame rate.</p>	
        /// </summary>	
        /// <param name="statistics"><dd>  <p>A structure that receives composition times and frame rate information.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method retrieves timing information about the composition engine that an application can use to synchronize the rasterization of bitmaps with independent animations.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::GetFrameStatistics']/*"/>	
        /// <msdn-id>hh437415</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::GetFrameStatistics([Out] DCOMPOSITION_FRAME_STATISTICS* statistics)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::GetFrameStatistics</unmanaged-short>	
        internal void GetFrameStatistics(out SharpDX.DirectComposition.FrameStatistics statistics) {
            unsafe {
                statistics = new SharpDX.DirectComposition.FrameStatistics();
                SharpDX.Result __result__;
                fixed (void* statistics_ = &statistics)
                    __result__= 
    				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, statistics_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a composition target object that is bound to the window that is represented by the specified window handle (<strong><see cref="System.IntPtr"/></strong>).</p>	
        /// </summary>	
        /// <param name="hwnd">No documentation.</param>	
        /// <param name="topmost">No documentation.</param>	
        /// <param name="target">No documentation.</param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A Microsoft DirectComposition visual tree must be bound to a window before anything can be displayed on screen. The window can be a top-level window or a child window. In either case, the window can be a layered window, but in all cases the window must belong to the calling process. If the window belongs to a different process, this method returns <strong>DCOMPOSITION_ERROR_ACCESS_DENIED</strong>. </p><p>When DirectComposition content is composed to the window, the content is always composed on top of whatever is drawn directly to that window through the device context (<strong><see cref="System.IntPtr"/></strong>) returned by the <strong>GetDC</strong> function, or by calls to Microsoft DirectX <strong>Present</strong> methods. However, because window clipping rules apply to DirectComposition content, if the window has child windows, those child windows may clip the visual tree. The <em>topmost</em> parameter determines whether child windows clip the visual tree. </p><p> Conceptually, each window consists of four layers:</p><ol> <li>The contents drawn directly to the window handle (this is the bottommost layer).</li> <li>An optional DirectComposition visual tree.</li> <li>The contents of all child windows, if any.</li> <li>Another optional DirectComposition visual tree (this is the topmost layer).</li> </ol><p>All four layers are clipped to the window's visible region.</p><p>At most, only two composition targets can be created for each window in the system, one topmost and one not topmost. If a composition target is already bound to the specified window at the specified layer, this method fails. When a composition target object is destroyed, the layer it composed is available for use by a new composition target object.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateTargetForHwnd']/*"/>	
        /// <msdn-id>hh437396</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTargetForHwnd([In] HWND hwnd,[In] BOOL topmost,[Out] IDCompositionTarget** target)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateTargetForHwnd</unmanaged-short>	
        internal void CreateTargetForHwnd(System.IntPtr hwnd, SharpDX.Mathematics.Interop.RawBool topmost, out SharpDX.DirectComposition.Target target) {
            unsafe {
                IntPtr target_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint12(_nativePointer, (void*)hwnd, topmost, &target_,((void**)(*(void**)_nativePointer))[6]);		
                target= (target_ == IntPtr.Zero)?null:new SharpDX.DirectComposition.Target(target_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new visual object.</p>	
        /// </summary>	
        /// <param name="visual"><dd>  <p>The new visual object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new visual object has a static value of zero for the OffsetX and OffsetY properties, and <c>null</c> for the Transform, Clip, and Content properties. Initially, the visual  does not cause the contents of a window to change. The visual must be added as a child of another visual, or as the root of a composition target, before it can affect the appearance of a window.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateVisual']/*"/>	
        /// <msdn-id>hh437414</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateVisual([Out, Fast] IDCompositionVisual** visual)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateVisual</unmanaged-short>	
        internal void CreateVisual(SharpDX.DirectComposition.Visual visual) {
            unsafe {
                IntPtr visual_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &visual_,((void**)(*(void**)_nativePointer))[7]);		
                ((SharpDX.DirectComposition.Visual)visual).NativePointer = visual_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an updateable surface object that can be associated with one or more visuals for composition.</p>	
        /// </summary>	
        /// <param name="width"><dd>  <p>The width of the surface, in pixels.</p> </dd></param>	
        /// <param name="height"><dd>  <p>The height of the surface, in pixels.</p> </dd></param>	
        /// <param name="pixelFormat"><dd>  <p>The pixel format of the surface.</p> </dd></param>	
        /// <param name="alphaMode"><dd>  <p>The format of the alpha channel, if an alpha channel is included in the pixel format. It can be one of the following values:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.DXGI.AlphaMode.Unspecified"/></strong></dt> </dl> </td><td> <p>The alpha channel is not specified. This value has the same effect as <strong><see cref="SharpDX.DXGI.AlphaMode.Ignore"/></strong>.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.DXGI.AlphaMode.Premultiplied"/></strong></dt> </dl> </td><td> <p>The color channels contain values that are premultiplied with the alpha channel.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.DXGI.AlphaMode.Ignore"/></strong></dt> </dl> </td><td> <p>The alpha channel should be ignored and the bitmap should be rendered opaquely.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="surface"><dd>  <p>The newly created surface object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A Microsoft DirectComposition surface is a rectangular array of pixels that can be associated with a visual for composition. </p><p>A newly created surface object is in an uninitialized state. While it is uninitialized, the surface has no effect on the composition of the visual tree. It behaves exactly like a surface that has  100% transparent pixels. </p><p>To initialize the surface with pixel data, use the <strong><see cref="SharpDX.DirectComposition.Surface.BeginDraw"/></strong> method. The first call to this method must cover the entire surface area to provide an initial value for every pixel. Subsequent calls may specify smaller sub-rectangles of the surface to update. </p><p>DirectComposition surfaces support the following pixel formats: </p><ul> <li><strong><see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm"/></strong></li> <li><strong><see cref="SharpDX.DXGI.Format.R8G8B8A8_UNorm"/></strong></li> <li><strong><see cref="SharpDX.DXGI.Format.R16G16B16A16_Float"/></strong></li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateSurface']/*"/>	
        /// <msdn-id>hh437405</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateSurface([In] unsigned int width,[In] unsigned int height,[In] DXGI_FORMAT pixelFormat,[In] DXGI_ALPHA_MODE alphaMode,[Out, Fast] IDCompositionSurface** surface)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateSurface</unmanaged-short>	
        internal void CreateSurface(int width, int height, SharpDX.DXGI.Format pixelFormat, SharpDX.DXGI.AlphaMode alphaMode, SharpDX.DirectComposition.Surface surface) {
            unsafe {
                IntPtr surface_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, width, height, unchecked((int)pixelFormat), unchecked((int)alphaMode), &surface_,((void**)(*(void**)_nativePointer))[8]);		
                ((SharpDX.DirectComposition.Surface)surface).NativePointer = surface_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a sparsely populated surface that can be associated with one or more visuals for composition.</p>	
        /// </summary>	
        /// <param name="initialWidth"><dd>  <p>The width of the surface, in pixels. The maximum width is 16,777,216 pixels.</p> </dd></param>	
        /// <param name="initialHeight"><dd>  <p>The height of the surface, in pixels. The maximum height is 16,777,216 pixels.</p> </dd></param>	
        /// <param name="pixelFormat"><dd>  <p>The pixel format of the surface.</p> </dd></param>	
        /// <param name="alphaMode"><dd>  <p>The meaning of the alpha channel, if the pixel format contains an alpha channel. It can be one of the following values:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.DXGI.AlphaMode.Unspecified"/></strong></dt> </dl> </td><td> <p>The alpha channel is not specified. This value has the same effect as <strong><see cref="SharpDX.DXGI.AlphaMode.Ignore"/></strong>.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.DXGI.AlphaMode.Premultiplied"/></strong></dt> </dl> </td><td> <p>The color channels contain values that are premultiplied with the alpha channel.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.DXGI.AlphaMode.Ignore"/></strong></dt> </dl> </td><td> <p>The alpha channel should be ignored and the bitmap should be rendered opaquely.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="virtualSurface"><dd>  <p>The newly created surface object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A Microsoft DirectComposition sparse surface is a logical object that behaves like a rectangular array of pixels that can be associated with a visual for composition. The surface is not necessarily backed by any physical video or system memory for every one of its pixels. The application can realize or virtualize parts of the logical surface at different times. </p><p>A newly created surface object is in an uninitialized state. While it is uninitialized, the surface has no effect on the composition of the visual tree. It behaves exactly like a surface that is initialized with 100% transparent pixels. </p><p>To initialize the surface with pixel data, use the <strong><see cref="SharpDX.DirectComposition.Surface.BeginDraw"/></strong> method. This method not only provides pixels for the surface, but it also allocates actual storage space for those pixels. The memory allocation persists until the application returns some of the memory to the system. The application can free part or all of the allocated memory by calling the <strong>IDComposition::VirtualSurfaceTrim</strong> method. </p><p>DirectComposition surfaces support the following pixel formats:</p><ul> <li><strong><see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm"/></strong></li> <li><strong><see cref="SharpDX.DXGI.Format.R8G8B8A8_UNorm"/></strong></li> <li><strong><see cref="SharpDX.DXGI.Format.R16G16B16A16_Float"/></strong></li> </ul><p>This method fails if <em>initialWidth</em> or <em>initialHeight</em> exceeds 16,777,216 pixels. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateVirtualSurface']/*"/>	
        /// <msdn-id>hh437413</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateVirtualSurface([In] unsigned int initialWidth,[In] unsigned int initialHeight,[In] DXGI_FORMAT pixelFormat,[In] DXGI_ALPHA_MODE alphaMode,[Out, Fast] IDCompositionVirtualSurface** virtualSurface)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateVirtualSurface</unmanaged-short>	
        internal void CreateVirtualSurface(int initialWidth, int initialHeight, SharpDX.DXGI.Format pixelFormat, SharpDX.DXGI.AlphaMode alphaMode, SharpDX.DirectComposition.VirtualSurface virtualSurface) {
            unsafe {
                IntPtr virtualSurface_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, initialWidth, initialHeight, unchecked((int)pixelFormat), unchecked((int)alphaMode), &virtualSurface_,((void**)(*(void**)_nativePointer))[9]);		
                ((SharpDX.DirectComposition.VirtualSurface)virtualSurface).NativePointer = virtualSurface_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new composition surface object that wraps an existing composition surface.</p>	
        /// </summary>	
        /// <param name="handle"><dd>  <p>The handle of an existing composition surface that was created by a call to the <strong><see cref="SharpDX.DirectComposition.DComp.CreateSurfaceHandle"/></strong> function.</p> </dd></param>	
        /// <param name="surface"><dd>  <p>The new composition surface object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method enables an application to use a shared composition surface in a composition tree. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateSurfaceFromHandle']/*"/>	
        /// <msdn-id>hh437406</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateSurfaceFromHandle([In] void* handle,[Out] IUnknown** surface)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateSurfaceFromHandle</unmanaged-short>	
        internal void CreateSurfaceFromHandle(System.IntPtr handle, out SharpDX.ComObject surface) {
            unsafe {
                IntPtr surface_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)handle, &surface_,((void**)(*(void**)_nativePointer))[10]);		
                surface= (surface_ == IntPtr.Zero)?null:new SharpDX.ComObject(surface_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a wrapper object that represents the rasterization of a layered window, and that can be associated with a visual for composition.</p>	
        /// </summary>	
        /// <param name="hwnd"><dd>  <p>The handle of the layered window for which to create a  wrapper. A layered window is created by specifying <strong>WS_EX_LAYERED</strong> when creating the window with the <strong>CreateWindowEx</strong> function or by setting <strong>WS_EX_LAYERED</strong> via <strong>SetWindowLong</strong> after the window has been created.</p> </dd></param>	
        /// <param name="surface"><dd>  <p>The new composition surface object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>You can use the <em>surface</em> reference in calls to the <strong><see cref="SharpDX.DirectComposition.Visual.SetContent"/></strong> method to set the content of one or more visuals. After setting the content, the visuals compose the contents of the specified layered window as long as the window is layered. If the window is unlayered, the window content disappears from the output of the composition tree. If the window is later re-layered, the window content reappears as long as it is still associated with a visual. If the window is resized, the affected visuals are re-composed. </p><p>The contents of the window are not cached beyond the life of the window. That is, if the window is destroyed, the affected visuals stop composing the window.	
        /// </p><p>If the window is moved off-screen or resized to zero, the system stops composing the content of visuals. You should use the <strong>DwmSetWindowAttribute</strong> function with the <strong>DWMWA_CLOAK</strong> flag to "cloak" the layered child window when you need to hide the original window while allowing the system to continue to compose the content of the visuals. For more information, see How to animate the bitmap of a layered child window and DirectComposition layered child window sample.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateSurfaceFromHwnd']/*"/>	
        /// <msdn-id>hh437407</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateSurfaceFromHwnd([In] HWND hwnd,[Out] IUnknown** surface)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateSurfaceFromHwnd</unmanaged-short>	
        internal void CreateSurfaceFromHwnd(System.IntPtr hwnd, out SharpDX.ComObject surface) {
            unsafe {
                IntPtr surface_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)hwnd, &surface_,((void**)(*(void**)_nativePointer))[11]);		
                surface= (surface_ == IntPtr.Zero)?null:new SharpDX.ComObject(surface_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D translation transform object.</p>	
        /// </summary>	
        /// <param name="translateTransform"><dd>  <p>The new 2D translation transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new 2D translation transform object has a static value of zero for the OffsetX and OffsetY properties.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateTranslateTransform']/*"/>	
        /// <msdn-id>hh437411</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTranslateTransform([Out, Fast] IDCompositionTranslateTransform** translateTransform)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateTranslateTransform</unmanaged-short>	
        internal void CreateTranslateTransform(SharpDX.DirectComposition.TranslateTransform translateTransform) {
            unsafe {
                IntPtr translateTransform_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &translateTransform_,((void**)(*(void**)_nativePointer))[12]);		
                ((SharpDX.DirectComposition.TranslateTransform)translateTransform).NativePointer = translateTransform_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D scale transform object.</p>	
        /// </summary>	
        /// <param name="scaleTransform"><dd>  <p>The new 2D scale transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new 2D scale transform object has a static value of zero for the ScaleX, ScaleY, CenterX, and CenterY properties.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateScaleTransform']/*"/>	
        /// <msdn-id>hh437402</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateScaleTransform([Out, Fast] IDCompositionScaleTransform** scaleTransform)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateScaleTransform</unmanaged-short>	
        internal void CreateScaleTransform(SharpDX.DirectComposition.ScaleTransform scaleTransform) {
            unsafe {
                IntPtr scaleTransform_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &scaleTransform_,((void**)(*(void**)_nativePointer))[13]);		
                ((SharpDX.DirectComposition.ScaleTransform)scaleTransform).NativePointer = scaleTransform_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D rotation transform object.</p>	
        /// </summary>	
        /// <param name="rotateTransform"><dd>  <p>The new rotation transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new 2D rotation transform object has a static value of zero for the Angle, CenterX, and CenterY properties.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateRotateTransform']/*"/>	
        /// <msdn-id>hh437400</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateRotateTransform([Out, Fast] IDCompositionRotateTransform** rotateTransform)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateRotateTransform</unmanaged-short>	
        internal void CreateRotateTransform(SharpDX.DirectComposition.RotateTransform rotateTransform) {
            unsafe {
                IntPtr rotateTransform_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &rotateTransform_,((void**)(*(void**)_nativePointer))[14]);		
                ((SharpDX.DirectComposition.RotateTransform)rotateTransform).NativePointer = rotateTransform_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D skew transform object.</p>	
        /// </summary>	
        /// <param name="skewTransform"><dd>  <p>The new 2D skew transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new 2D skew transform object has a static value of zero for the AngleX, AngleY, CenterX, and CenterY properties.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateSkewTransform']/*"/>	
        /// <msdn-id>hh437404</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateSkewTransform([Out, Fast] IDCompositionSkewTransform** skewTransform)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateSkewTransform</unmanaged-short>	
        internal void CreateSkewTransform(SharpDX.DirectComposition.SkewTransform skewTransform) {
            unsafe {
                IntPtr skewTransform_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &skewTransform_,((void**)(*(void**)_nativePointer))[15]);		
                ((SharpDX.DirectComposition.SkewTransform)skewTransform).NativePointer = skewTransform_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D 3-by-2 matrix transform object.</p>	
        /// </summary>	
        /// <param name="matrixTransform"><dd>  <p>The new matrix transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new matrix transform object has the identity matrix as its initial value. The identity matrix is the 3x2 matrix with ones on the main diagonal and zeros elsewhere, as shown in the following illustration. </p><p></p><p>When an identity transform is applied to an object, it does not change the position, shape, or size of the object. It is similar to the way that multiplying a number by one does not change the number. Any transform other than the identity transform will modify the position, shape, and/or size of objects.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateMatrixTransform']/*"/>	
        /// <msdn-id>hh437397</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateMatrixTransform([Out, Fast] IDCompositionMatrixTransform** matrixTransform)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateMatrixTransform</unmanaged-short>	
        internal void CreateMatrixTransform(SharpDX.DirectComposition.MatrixTransform matrixTransform) {
            unsafe {
                IntPtr matrixTransform_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &matrixTransform_,((void**)(*(void**)_nativePointer))[16]);		
                ((SharpDX.DirectComposition.MatrixTransform)matrixTransform).NativePointer = matrixTransform_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D transform group object that holds an array of 2D transform objects.</p>	
        /// </summary>	
        /// <param name="transforms"><dd>  <p>An array of 2D transform objects that make up this transform group.</p> </dd></param>	
        /// <param name="elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>	
        /// <param name="transformGroup"><dd>  <p>The new transform group object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The array entries in a transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateTransformGroup']/*"/>	
        /// <msdn-id>hh437410</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTransformGroup([In, Buffer] IDCompositionTransform** transforms,[In] unsigned int elements,[Out, Fast] IDCompositionTransform** transformGroup)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateTransformGroup</unmanaged-short>	
        internal void CreateTransformGroup(SharpDX.DirectComposition.Transform[] transforms, int elements, SharpDX.DirectComposition.Transform transformGroup) {
            unsafe {
                IntPtr* transforms_ = (IntPtr*)0;
                if ( transforms != null ) {
                    IntPtr* transforms__ = stackalloc IntPtr[transforms.Length];
                    transforms_ = transforms__;
                    for (int i = 0; i < transforms.Length; i++)                        
                        transforms_[i] =  (transforms[i] == null)? IntPtr.Zero : transforms[i].NativePointer;
                }
                IntPtr transformGroup_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, transforms_, elements, &transformGroup_,((void**)(*(void**)_nativePointer))[17]);		
                ((SharpDX.DirectComposition.Transform)transformGroup).NativePointer = transformGroup_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D transform group object that holds an array of 2D transform objects.</p>	
        /// </summary>	
        /// <param name="transforms"><dd>  <p>An array of 2D transform objects that make up this transform group.</p> </dd></param>	
        /// <param name="elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>	
        /// <param name="transformGroup"><dd>  <p>The new transform group object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The array entries in a transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateTransformGroup']/*"/>	
        /// <msdn-id>hh437410</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTransformGroup([In, Buffer] IDCompositionTransform** transforms,[In] unsigned int elements,[Out, Fast] IDCompositionTransform** transformGroup)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateTransformGroup</unmanaged-short>	
        internal void CreateTransformGroup(SharpDX.ComArray<SharpDX.DirectComposition.Transform> transforms, int elements, SharpDX.DirectComposition.Transform transformGroup) {
            unsafe {
                IntPtr transformGroup_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((transforms == null)?IntPtr.Zero:transforms.NativePointer), elements, &transformGroup_,((void**)(*(void**)_nativePointer))[17]);		
                ((SharpDX.DirectComposition.Transform)transformGroup).NativePointer = transformGroup_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D transform group object that holds an array of 2D transform objects.</p>	
        /// </summary>	
        /// <param name="transforms"><dd>  <p>An array of 2D transform objects that make up this transform group.</p> </dd></param>	
        /// <param name="elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>	
        /// <param name="transformGroup"><dd>  <p>The new transform group object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The array entries in a transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateTransformGroup']/*"/>	
        /// <msdn-id>hh437410</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTransformGroup([In, Buffer] IDCompositionTransform** transforms,[In] unsigned int elements,[Out, Fast] IDCompositionTransform** transformGroup)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateTransformGroup</unmanaged-short>	
        private void CreateTransformGroup(System.IntPtr transforms, int elements, System.IntPtr transformGroup) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)transforms, elements, (void*)transformGroup,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 3D translation transform object.</p>	
        /// </summary>	
        /// <param name="translateTransform3D"><dd>  <p>The new 3D translation transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>A newly created 3D translation transform has a static value of 0 for the OffsetX, OffsetY, and OffsetZ properties. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateTranslateTransform3D']/*"/>	
        /// <msdn-id>hh437412</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTranslateTransform3D([Out, Fast] IDCompositionTranslateTransform3D** translateTransform3D)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateTranslateTransform3D</unmanaged-short>	
        internal void CreateTranslateTransform3D(SharpDX.DirectComposition.TranslateTransform3D translateTransform3D) {
            unsafe {
                IntPtr translateTransform3D_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &translateTransform3D_,((void**)(*(void**)_nativePointer))[18]);		
                ((SharpDX.DirectComposition.TranslateTransform3D)translateTransform3D).NativePointer = translateTransform3D_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 3D scale transform object.</p>	
        /// </summary>	
        /// <param name="scaleTransform3D"><dd>  <p>The new 3D scale transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new 3D scale transform object has a static value of 1.0 for the ScaleX, ScaleY, and ScaleZ properties.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateScaleTransform3D']/*"/>	
        /// <msdn-id>hh437403</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateScaleTransform3D([Out, Fast] IDCompositionScaleTransform3D** scaleTransform3D)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateScaleTransform3D</unmanaged-short>	
        internal void CreateScaleTransform3D(SharpDX.DirectComposition.ScaleTransform3D scaleTransform3D) {
            unsafe {
                IntPtr scaleTransform3D_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &scaleTransform3D_,((void**)(*(void**)_nativePointer))[19]);		
                ((SharpDX.DirectComposition.ScaleTransform3D)scaleTransform3D).NativePointer = scaleTransform3D_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 3D rotation transform object.</p>	
        /// </summary>	
        /// <param name="rotateTransform3D"><dd>  <p>The new 3D rotation transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new 3D rotation transform object has a default static value of zero for the Angle, CenterX, CenterY, AxisX, and AxisY properties, and a default static value of 1.0 for the AxisZ property.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateRotateTransform3D']/*"/>	
        /// <msdn-id>hh437401</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateRotateTransform3D([Out, Fast] IDCompositionRotateTransform3D** rotateTransform3D)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateRotateTransform3D</unmanaged-short>	
        internal void CreateRotateTransform3D(SharpDX.DirectComposition.RotateTransform3D rotateTransform3D) {
            unsafe {
                IntPtr rotateTransform3D_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &rotateTransform3D_,((void**)(*(void**)_nativePointer))[20]);		
                ((SharpDX.DirectComposition.RotateTransform3D)rotateTransform3D).NativePointer = rotateTransform3D_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 3D 4-by-4 matrix transform object.</p>	
        /// </summary>	
        /// <param name="matrixTransform3D"><dd>  <p>The new 3D matrix transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The new 3D matrix transform has the identity matrix as its value. The identity matrix is the 4-by-4 matrix with ones on the main diagonal and zeros elsewhere, as shown in the following illustration. </p><p></p><p>When an identity transform is applied to an object, it does not change the position, shape, or size of the object. It is similar to the way that multiplying a number by one does not change the number. Any transform other than the identity transform will modify the position, shape, and/or size of objects.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateMatrixTransform3D']/*"/>	
        /// <msdn-id>hh437398</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateMatrixTransform3D([Out, Fast] IDCompositionMatrixTransform3D** matrixTransform3D)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateMatrixTransform3D</unmanaged-short>	
        internal void CreateMatrixTransform3D(SharpDX.DirectComposition.MatrixTransform3D matrixTransform3D) {
            unsafe {
                IntPtr matrixTransform3D_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &matrixTransform3D_,((void**)(*(void**)_nativePointer))[21]);		
                ((SharpDX.DirectComposition.MatrixTransform3D)matrixTransform3D).NativePointer = matrixTransform3D_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 3D transform group object that holds an array of 3D transform objects.</p>	
        /// </summary>	
        /// <param name="transforms3D"><dd>  <p>An array of 3D transform objects that make up this transform group.</p> </dd></param>	
        /// <param name="elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>	
        /// <param name="transform3DGroup"><dd>  <p>The new 3D transform group object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The array entries in a 3D transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateTransform3DGroup']/*"/>	
        /// <msdn-id>hh437409</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTransform3DGroup([In, Buffer] IDCompositionTransform3D** transforms3D,[In] unsigned int elements,[Out, Fast] IDCompositionTransform3D** transform3DGroup)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateTransform3DGroup</unmanaged-short>	
        internal void CreateTransform3DGroup(SharpDX.DirectComposition.Transform3D[] transforms3D, int elements, SharpDX.DirectComposition.Transform3D transform3DGroup) {
            unsafe {
                IntPtr* transforms3D_ = (IntPtr*)0;
                if ( transforms3D != null ) {
                    IntPtr* transforms3D__ = stackalloc IntPtr[transforms3D.Length];
                    transforms3D_ = transforms3D__;
                    for (int i = 0; i < transforms3D.Length; i++)                        
                        transforms3D_[i] =  (transforms3D[i] == null)? IntPtr.Zero : transforms3D[i].NativePointer;
                }
                IntPtr transform3DGroup_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, transforms3D_, elements, &transform3DGroup_,((void**)(*(void**)_nativePointer))[22]);		
                ((SharpDX.DirectComposition.Transform3D)transform3DGroup).NativePointer = transform3DGroup_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 3D transform group object that holds an array of 3D transform objects.</p>	
        /// </summary>	
        /// <param name="transforms3D"><dd>  <p>An array of 3D transform objects that make up this transform group.</p> </dd></param>	
        /// <param name="elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>	
        /// <param name="transform3DGroup"><dd>  <p>The new 3D transform group object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The array entries in a 3D transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateTransform3DGroup']/*"/>	
        /// <msdn-id>hh437409</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTransform3DGroup([In, Buffer] IDCompositionTransform3D** transforms3D,[In] unsigned int elements,[Out, Fast] IDCompositionTransform3D** transform3DGroup)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateTransform3DGroup</unmanaged-short>	
        internal void CreateTransform3DGroup(SharpDX.ComArray<SharpDX.DirectComposition.Transform3D> transforms3D, int elements, SharpDX.DirectComposition.Transform3D transform3DGroup) {
            unsafe {
                IntPtr transform3DGroup_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((transforms3D == null)?IntPtr.Zero:transforms3D.NativePointer), elements, &transform3DGroup_,((void**)(*(void**)_nativePointer))[22]);		
                ((SharpDX.DirectComposition.Transform3D)transform3DGroup).NativePointer = transform3DGroup_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 3D transform group object that holds an array of 3D transform objects.</p>	
        /// </summary>	
        /// <param name="transforms3D"><dd>  <p>An array of 3D transform objects that make up this transform group.</p> </dd></param>	
        /// <param name="elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>	
        /// <param name="transform3DGroup"><dd>  <p>The new 3D transform group object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The array entries in a 3D transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateTransform3DGroup']/*"/>	
        /// <msdn-id>hh437409</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateTransform3DGroup([In, Buffer] IDCompositionTransform3D** transforms3D,[In] unsigned int elements,[Out, Fast] IDCompositionTransform3D** transform3DGroup)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateTransform3DGroup</unmanaged-short>	
        private void CreateTransform3DGroup(System.IntPtr transforms3D, int elements, System.IntPtr transform3DGroup) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)transforms3D, elements, (void*)transform3DGroup,((void**)(*(void**)_nativePointer))[22]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an object that represents multiple effects to be applied to a visual subtree.</p>	
        /// </summary>	
        /// <param name="effectGroup"><dd>  <p>The new effect group object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>An effect group enables an application to apply multiple effects to a single visual subtree. </p><p>A new effect group has a default opacity value of 1.0 and no 3D transformations.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateEffectGroup']/*"/>	
        /// <msdn-id>hh437395</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateEffectGroup([Out, Fast] IDCompositionEffectGroup** effectGroup)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateEffectGroup</unmanaged-short>	
        internal void CreateEffectGroup(SharpDX.DirectComposition.EffectGroup effectGroup) {
            unsafe {
                IntPtr effectGroup_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &effectGroup_,((void**)(*(void**)_nativePointer))[23]);		
                ((SharpDX.DirectComposition.EffectGroup)effectGroup).NativePointer = effectGroup_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a clip object that can be used to restrict the rendering of  a visual subtree to a rectangular area.</p>	
        /// </summary>	
        /// <param name="clip"><dd>  <p>The new clip object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A newly created clip object has a static value of ?FLT_MAX for the left and top properties, and a static value of ?FLT_MAX for the right and bottom properties, effectively making it a no-op clip object.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateRectangleClip']/*"/>	
        /// <msdn-id>hh437399</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateRectangleClip([Out, Fast] IDCompositionRectangleClip** clip)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateRectangleClip</unmanaged-short>	
        internal void CreateRectangleClip(SharpDX.DirectComposition.RectangleClip clip) {
            unsafe {
                IntPtr clip_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &clip_,((void**)(*(void**)_nativePointer))[24]);		
                ((SharpDX.DirectComposition.RectangleClip)clip).NativePointer = clip_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an animation object that is used to animate one or more scalar properties of one or more Microsoft DirectComposition objects. </p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new animation object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A number of DirectComposition object properties can have an animation object as the value of the property. When a property has an animation object as its value, DirectComposition redraws the visual at the refresh rate to reflect the changing value of the property that is being animated.</p><p>A newly created animation object does not have any animation segments associated with it. An application must use the methods of the <strong><see cref="SharpDX.DirectComposition.Animation"/></strong> interface to build an animation function before setting the animation object as the property of another DirectComposition object.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CreateAnimation']/*"/>	
        /// <msdn-id>hh437394</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CreateAnimation([Out, Fast] IDCompositionAnimation** animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CreateAnimation</unmanaged-short>	
        internal void CreateAnimation(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                IntPtr animation_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &animation_,((void**)(*(void**)_nativePointer))[25]);		
                ((SharpDX.DirectComposition.Animation)animation).NativePointer = animation_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Determines whether the DirectComposition device object is still valid.</p>	
        /// </summary>	
        /// <param name="fValidRef"><dd> <p>TRUE if the  DirectComposition device object is still valid; otherwise <see cref="SharpDX.Result.False"/>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> If the Microsoft DirectX Graphics Infrastructure (DXGI) device is lost, the DirectComposition device associated with the DXGI device is also lost. When it detects a lost device, DirectComposition sends the <strong>WM_PAINT</strong> message to all windows that are composing DirectComposition content using the lost device. An application should call <strong>CheckDeviceState</strong> in response to each  <strong>WM_PAINT</strong> message to ensure that the DirectComposition device object is still valid. The application must take steps to recover content if the device object becomes invalid. Steps include creating new DXGI and DirectComposition devices, and recreating all content. (It?s not possible to create just a new DXGI device and associate it with the existing DirectComposition device.)  The system ensures that the device object remains valid between <strong>WM_PAINT</strong> messages. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice::CheckDeviceState']/*"/>	
        /// <msdn-id>Hh707428</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice::CheckDeviceState([Out] BOOL* pfValid)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice::CheckDeviceState</unmanaged-short>	
        public void CheckDeviceState(out SharpDX.Mathematics.Interop.RawBool fValidRef) {
            unsafe {
                fValidRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fValidRef_ = &fValidRef)
                    __result__= 
    				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, fValidRef_,((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Serves as a factory for all other Microsoft DirectComposition objects and provides methods to control transactional composition.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2']/*"/>	
    /// <msdn-id>dn280354</msdn-id>	
    /// <unmanaged>IDCompositionDevice2</unmanaged>	
    /// <unmanaged-short>IDCompositionDevice2</unmanaged-short>	
    [Guid("75F6468D-1B8E-447C-9BC6-75FEA80B5B25")]
    public partial class Device2 : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.Device2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Device2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.Device2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.Device2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.Device2(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves information from the composition engine about composition times and the frame rate.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method retrieves timing information about the composition engine that an application can use to synchronize the rasterization of bitmaps with independent animations.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::GetFrameStatistics']/*"/>	
        /// <msdn-id>dn280375</msdn-id>	
        /// <unmanaged>GetFrameStatistics</unmanaged>	
        /// <unmanaged-short>GetFrameStatistics</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionDevice2::GetFrameStatistics([Out] DCOMPOSITION_FRAME_STATISTICS* statistics)</unmanaged>
        public SharpDX.DirectComposition.FrameStatistics FrameStatistics {
                get { SharpDX.DirectComposition.FrameStatistics __output__; GetFrameStatistics(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Commits all DirectComposition commands that are pending on this device.</p>	
        /// </summary>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See  DirectComposition Error Codes for a  list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Calls to DirectComposition methods are always batched and executed atomically as  a single transaction. Calls take effect only when  <strong><see cref="SharpDX.DirectComposition.Device2.Commit"/></strong> is  called, at which time all pending method calls for a device are executed at once.</p><p>An application that uses multiple devices must call  <strong>Commit</strong> for each device separately.  However, because the composition engine processes the calls individually, the batch of commands might not take  effect at the same time.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::Commit']/*"/>	
        /// <msdn-id>dn280355</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::Commit()</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::Commit</unmanaged-short>	
        public void Commit() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Waits for the composition engine to finish processing the previous call to the <strong><see cref="SharpDX.DirectComposition.Device2.Commit"/></strong> method. </p>	
        /// </summary>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::WaitForCommitCompletion']/*"/>	
        /// <msdn-id>dn280376</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::WaitForCommitCompletion()</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::WaitForCommitCompletion</unmanaged-short>	
        public void WaitForCommitCompletion() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves information from the composition engine about composition times and the frame rate.</p>	
        /// </summary>	
        /// <param name="statistics"><dd>  <p>A structure that receives composition times and frame rate information.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method retrieves timing information about the composition engine that an application can use to synchronize the rasterization of bitmaps with independent animations.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::GetFrameStatistics']/*"/>	
        /// <msdn-id>dn280375</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::GetFrameStatistics([Out] DCOMPOSITION_FRAME_STATISTICS* statistics)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::GetFrameStatistics</unmanaged-short>	
        internal void GetFrameStatistics(out SharpDX.DirectComposition.FrameStatistics statistics) {
            unsafe {
                statistics = new SharpDX.DirectComposition.FrameStatistics();
                SharpDX.Result __result__;
                fixed (void* statistics_ = &statistics)
                    __result__= 
    				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, statistics_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new visual object.</p>	
        /// </summary>	
        /// <param name="visual"><dd>  <p>The new visual object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new visual object has a static value of zero for the OffsetX and OffsetY properties, and <c>null</c> for the Transform, Clip, and Content properties. Initially, the visual  does not cause the contents of a window to change. The visual must be added as a child of another visual, or as the root of a composition target, before it can affect the appearance of a window.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateVisual']/*"/>	
        /// <msdn-id>dn280373</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateVisual([Out, Fast] IDCompositionVisual2** visual)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateVisual</unmanaged-short>	
        internal void CreateVisual(SharpDX.DirectComposition.Visual2 visual) {
            unsafe {
                IntPtr visual_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &visual_,((void**)(*(void**)_nativePointer))[6]);		
                ((SharpDX.DirectComposition.Visual2)visual).NativePointer = visual_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a Microsoft DirectComposition surface factory object, which can be used to create other DirectComposition surface or virtual surface objects</p>	
        /// </summary>	
        /// <param name="renderingDevice"><dd> <p>A reference to a DirectX device to be used to create DirectComposition surface objects. Must be a reference to an object implementing the <strong><see cref="SharpDX.DXGI.Device"/></strong> or <strong><see cref="SharpDX.Direct2D1.Device"/></strong> interfaces. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <param name="surfaceFactory"><dd> <p>The newly created surface factory object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A surface factory allows an application to simultaneously use more than one single DXGI or Direct2D device with DirectComposition. Each surface factory has a permanent association with one DXGI or Direct2D device, but a DirectComposition device may have any number of surface factories. </p><p>Each surface factory manages resources independently from the others. In particular, DirectComposition pools surface allocations to mitigate surface allocation and deallocation costs. This pool is done on a per-surface factory basis. </p><p>If the <strong><see cref="SharpDX.DirectComposition.DComp.CreateDevice2"/></strong> function is called with a non-<c>null</c> <em>renderingDevice</em> parameter, the returned DirectComposition device object has an implicit surface factory under the covers associated with the given rendering device. This implicit surface factory is used to service the <strong><see cref="SharpDX.DirectComposition.Device.CreateSurface"/></strong>, <strong><see cref="SharpDX.DirectComposition.Device.CreateVirtualSurface"/></strong>, <strong><see cref="SharpDX.DirectComposition.Device2.CreateSurface"/></strong> and <strong><see cref="SharpDX.DirectComposition.Device2.CreateVirtualSurface"/></strong> methods. </p><p>A surface object remains alive as long as any of the surfaces or virtual surfaces that it created remain alive, either directly because the application holds a direct reference, or indirectly because one or more such surfaces are associated with one or more visual objects.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateSurfaceFactory']/*"/>	
        /// <msdn-id>dn280367</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateSurfaceFactory([In] IUnknown* renderingDevice,[Out, Fast] IDCompositionSurfaceFactory** surfaceFactory)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateSurfaceFactory</unmanaged-short>	
        internal void CreateSurfaceFactory(SharpDX.ComObject renderingDevice, SharpDX.DirectComposition.SurfaceFactory surfaceFactory) {
            unsafe {
                IntPtr surfaceFactory_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((renderingDevice == null)?IntPtr.Zero:renderingDevice.NativePointer), &surfaceFactory_,((void**)(*(void**)_nativePointer))[7]);		
                ((SharpDX.DirectComposition.SurfaceFactory)surfaceFactory).NativePointer = surfaceFactory_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an updateable surface object that can be associated with one or more visuals for composition.</p>	
        /// </summary>	
        /// <param name="width"><dd>  <p>The width of the surface, in pixels. Constrained by the feature level of the rendering device that was passed in at the time the DirectComposition device was created. </p> </dd></param>	
        /// <param name="height"><dd>  <p>The height of the surface, in pixels. Constrained by the feature level of the rendering device that was passed in at the time the DirectComposition device was created.</p> </dd></param>	
        /// <param name="pixelFormat"><dd>  <p>The pixel format of the surface.</p> </dd></param>	
        /// <param name="alphaMode"><dd>  <p>The format of the alpha channel, if an alpha channel is included in the pixel format. It can be one of the following values:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.DXGI.AlphaMode.Unspecified"/></strong></dt> </dl> </td><td> <p>The alpha channel is not specified. This value has the same effect as <strong><see cref="SharpDX.DXGI.AlphaMode.Ignore"/></strong>.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.DXGI.AlphaMode.Premultiplied"/></strong></dt> </dl> </td><td> <p>The color channels contain values that are premultiplied with the alpha channel.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.DXGI.AlphaMode.Ignore"/></strong></dt> </dl> </td><td> <p>The alpha channel should be ignored and the bitmap should be rendered opaquely.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="surface"><dd>  <p>The newly created surface object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A Microsoft DirectComposition surface is a rectangular array of pixels that can be associated with a visual for composition. </p><p>A newly created surface object is in an uninitialized state. While it is uninitialized, the surface has no effect on the composition of the visual tree. It behaves exactly like a surface that has  100% transparent pixels. </p><p>To initialize the surface with pixel data, use the <strong><see cref="SharpDX.DirectComposition.Surface.BeginDraw"/></strong> and <strong><see cref="SharpDX.DirectComposition.Surface.EndDraw"/></strong> methods. The first call to this method must cover the entire surface area to provide an initial value for every pixel. Subsequent calls may specify smaller sub-rectangles of the surface to update. </p><p>DirectComposition surfaces support the following pixel formats: </p><ul> <li><strong><see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm"/></strong></li> <li><strong><see cref="SharpDX.DXGI.Format.R8G8B8A8_UNorm"/></strong></li> <li><strong><see cref="SharpDX.DXGI.Format.R16G16B16A16_Float"/></strong></li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateSurface']/*"/>	
        /// <msdn-id>dn280366</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateSurface([In] unsigned int width,[In] unsigned int height,[In] DXGI_FORMAT pixelFormat,[In] DXGI_ALPHA_MODE alphaMode,[Out, Fast] IDCompositionSurface** surface)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateSurface</unmanaged-short>	
        internal void CreateSurface(int width, int height, SharpDX.DXGI.Format pixelFormat, SharpDX.DXGI.AlphaMode alphaMode, SharpDX.DirectComposition.Surface surface) {
            unsafe {
                IntPtr surface_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, width, height, unchecked((int)pixelFormat), unchecked((int)alphaMode), &surface_,((void**)(*(void**)_nativePointer))[8]);		
                ((SharpDX.DirectComposition.Surface)surface).NativePointer = surface_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a sparsely populated surface that can be associated with one or more visuals for composition.</p>	
        /// </summary>	
        /// <param name="initialWidth"><dd>  <p>The width of the surface, in pixels. The maximum width is 16,777,216 pixels.</p> </dd></param>	
        /// <param name="initialHeight"><dd>  <p>The height of the surface, in pixels. The maximum height is 16,777,216 pixels.</p> </dd></param>	
        /// <param name="pixelFormat"><dd>  <p>The pixel format of the surface.</p> </dd></param>	
        /// <param name="alphaMode"><dd>  <p>The meaning of the alpha channel, if the pixel format contains an alpha channel. It can be one of the following values:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.DXGI.AlphaMode.Unspecified"/></strong></dt> </dl> </td><td> <p>The alpha channel is not specified. This value has the same effect as <strong><see cref="SharpDX.DXGI.AlphaMode.Ignore"/></strong>.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.DXGI.AlphaMode.Premultiplied"/></strong></dt> </dl> </td><td> <p>The color channels contain values that are premultiplied with the alpha channel.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.DXGI.AlphaMode.Ignore"/></strong></dt> </dl> </td><td> <p>The alpha channel should be ignored and the bitmap should be rendered opaquely.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="virtualSurface"><dd>  <p>The newly created surface object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A Microsoft DirectComposition sparse surface is a logical object that behaves like a rectangular array of pixels that can be associated with a visual for composition. The surface is not necessarily backed by any physical video or system memory for every one of its pixels. The application can realize or virtualize parts of the logical surface at different times. </p><p>A newly created surface object is in an uninitialized state. While it is uninitialized, the surface has no effect on the composition of the visual tree. It behaves exactly like a surface that is initialized with 100% transparent pixels. </p><p>To initialize the surface with pixel data, use the <strong><see cref="SharpDX.DirectComposition.Surface.BeginDraw"/></strong> and <strong><see cref="SharpDX.DirectComposition.Surface.EndDraw"/></strong> methods. This method not only provides pixels for the surface, but it also allocates actual storage space for those pixels. The memory allocation persists until the application returns some of the memory to the system. The application can free part or all of the allocated memory by calling the <strong><see cref="SharpDX.DirectComposition.VirtualSurface.Trim"/></strong> method.</p><p>DirectComposition surfaces support the following pixel formats:</p><ul> <li><strong><see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm"/></strong></li> <li><strong><see cref="SharpDX.DXGI.Format.R8G8B8A8_UNorm"/></strong></li> <li><strong><see cref="SharpDX.DXGI.Format.R16G16B16A16_Float"/></strong></li> </ul><p>This method fails if <em>initialWidth</em> or <em>initialHeight</em> exceeds 16,777,216 pixels. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateVirtualSurface']/*"/>	
        /// <msdn-id>dn280372</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateVirtualSurface([In] unsigned int initialWidth,[In] unsigned int initialHeight,[In] DXGI_FORMAT pixelFormat,[In] DXGI_ALPHA_MODE alphaMode,[Out, Fast] IDCompositionVirtualSurface** virtualSurface)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateVirtualSurface</unmanaged-short>	
        internal void CreateVirtualSurface(int initialWidth, int initialHeight, SharpDX.DXGI.Format pixelFormat, SharpDX.DXGI.AlphaMode alphaMode, SharpDX.DirectComposition.VirtualSurface virtualSurface) {
            unsafe {
                IntPtr virtualSurface_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, initialWidth, initialHeight, unchecked((int)pixelFormat), unchecked((int)alphaMode), &virtualSurface_,((void**)(*(void**)_nativePointer))[9]);		
                ((SharpDX.DirectComposition.VirtualSurface)virtualSurface).NativePointer = virtualSurface_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D translation transform object.</p>	
        /// </summary>	
        /// <param name="translateTransform"><dd>  <p>The new 2D translation transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new 2D translation transform object has a static value of zero for the OffsetX and OffsetY properties.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateTranslateTransform']/*"/>	
        /// <msdn-id>dn280370</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTranslateTransform([Out, Fast] IDCompositionTranslateTransform** translateTransform)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateTranslateTransform</unmanaged-short>	
        internal void CreateTranslateTransform(SharpDX.DirectComposition.TranslateTransform translateTransform) {
            unsafe {
                IntPtr translateTransform_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &translateTransform_,((void**)(*(void**)_nativePointer))[10]);		
                ((SharpDX.DirectComposition.TranslateTransform)translateTransform).NativePointer = translateTransform_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D scale transform object.</p>	
        /// </summary>	
        /// <param name="scaleTransform"><dd>  <p>The new 2D scale transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new 2D scale transform object has a static value of zero for the ScaleX, ScaleY, CenterX, and CenterY properties.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateScaleTransform']/*"/>	
        /// <msdn-id>dn280363</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateScaleTransform([Out, Fast] IDCompositionScaleTransform** scaleTransform)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateScaleTransform</unmanaged-short>	
        internal void CreateScaleTransform(SharpDX.DirectComposition.ScaleTransform scaleTransform) {
            unsafe {
                IntPtr scaleTransform_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &scaleTransform_,((void**)(*(void**)_nativePointer))[11]);		
                ((SharpDX.DirectComposition.ScaleTransform)scaleTransform).NativePointer = scaleTransform_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D rotation transform object.</p>	
        /// </summary>	
        /// <param name="rotateTransform"><dd>  <p>The new rotation transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new 2D rotation transform object has a static value of zero for the Angle, CenterX, and CenterY properties.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateRotateTransform']/*"/>	
        /// <msdn-id>dn280361</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateRotateTransform([Out, Fast] IDCompositionRotateTransform** rotateTransform)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateRotateTransform</unmanaged-short>	
        internal void CreateRotateTransform(SharpDX.DirectComposition.RotateTransform rotateTransform) {
            unsafe {
                IntPtr rotateTransform_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &rotateTransform_,((void**)(*(void**)_nativePointer))[12]);		
                ((SharpDX.DirectComposition.RotateTransform)rotateTransform).NativePointer = rotateTransform_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D skew transform object.</p>	
        /// </summary>	
        /// <param name="skewTransform"><dd>  <p>The new 2D skew transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new 2D skew transform object has a static value of zero for the AngleX, AngleY, CenterX, and CenterY properties.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateSkewTransform']/*"/>	
        /// <msdn-id>dn280365</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateSkewTransform([Out, Fast] IDCompositionSkewTransform** skewTransform)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateSkewTransform</unmanaged-short>	
        internal void CreateSkewTransform(SharpDX.DirectComposition.SkewTransform skewTransform) {
            unsafe {
                IntPtr skewTransform_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &skewTransform_,((void**)(*(void**)_nativePointer))[13]);		
                ((SharpDX.DirectComposition.SkewTransform)skewTransform).NativePointer = skewTransform_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D 3-by-2 matrix transform object.</p>	
        /// </summary>	
        /// <param name="matrixTransform"><dd>  <p>The new matrix transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new matrix transform object has the identity matrix as its initial value. The identity matrix is the 3x2 matrix with ones on the main diagonal and zeros elsewhere, as shown in the following illustration. </p><p></p><p>When an identity transform is applied to an object, it does not change the position, shape, or size of the object. It is similar to the way that multiplying a number by one does not change the number. Any transform other than the identity transform will modify the position, shape, and/or size of objects.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateMatrixTransform']/*"/>	
        /// <msdn-id>dn280358</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateMatrixTransform([Out, Fast] IDCompositionMatrixTransform** matrixTransform)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateMatrixTransform</unmanaged-short>	
        internal void CreateMatrixTransform(SharpDX.DirectComposition.MatrixTransform matrixTransform) {
            unsafe {
                IntPtr matrixTransform_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &matrixTransform_,((void**)(*(void**)_nativePointer))[14]);		
                ((SharpDX.DirectComposition.MatrixTransform)matrixTransform).NativePointer = matrixTransform_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D transform group object that holds an array of 2D transform objects.</p>	
        /// </summary>	
        /// <param name="transforms"><dd>  <p>An array of 2D transform objects that make up this transform group.</p> </dd></param>	
        /// <param name="elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>	
        /// <param name="transformGroup"><dd>  <p>The new transform group object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The array entries in a transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateTransformGroup']/*"/>	
        /// <msdn-id>dn280369</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTransformGroup([In, Buffer] IDCompositionTransform** transforms,[In] unsigned int elements,[Out, Fast] IDCompositionTransform** transformGroup)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateTransformGroup</unmanaged-short>	
        internal void CreateTransformGroup(SharpDX.DirectComposition.Transform[] transforms, int elements, SharpDX.DirectComposition.Transform transformGroup) {
            unsafe {
                IntPtr* transforms_ = (IntPtr*)0;
                if ( transforms != null ) {
                    IntPtr* transforms__ = stackalloc IntPtr[transforms.Length];
                    transforms_ = transforms__;
                    for (int i = 0; i < transforms.Length; i++)                        
                        transforms_[i] =  (transforms[i] == null)? IntPtr.Zero : transforms[i].NativePointer;
                }
                IntPtr transformGroup_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, transforms_, elements, &transformGroup_,((void**)(*(void**)_nativePointer))[15]);		
                ((SharpDX.DirectComposition.Transform)transformGroup).NativePointer = transformGroup_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D transform group object that holds an array of 2D transform objects.</p>	
        /// </summary>	
        /// <param name="transforms"><dd>  <p>An array of 2D transform objects that make up this transform group.</p> </dd></param>	
        /// <param name="elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>	
        /// <param name="transformGroup"><dd>  <p>The new transform group object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The array entries in a transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateTransformGroup']/*"/>	
        /// <msdn-id>dn280369</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTransformGroup([In, Buffer] IDCompositionTransform** transforms,[In] unsigned int elements,[Out, Fast] IDCompositionTransform** transformGroup)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateTransformGroup</unmanaged-short>	
        internal void CreateTransformGroup(SharpDX.ComArray<SharpDX.DirectComposition.Transform> transforms, int elements, SharpDX.DirectComposition.Transform transformGroup) {
            unsafe {
                IntPtr transformGroup_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((transforms == null)?IntPtr.Zero:transforms.NativePointer), elements, &transformGroup_,((void**)(*(void**)_nativePointer))[15]);		
                ((SharpDX.DirectComposition.Transform)transformGroup).NativePointer = transformGroup_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 2D transform group object that holds an array of 2D transform objects.</p>	
        /// </summary>	
        /// <param name="transforms"><dd>  <p>An array of 2D transform objects that make up this transform group.</p> </dd></param>	
        /// <param name="elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>	
        /// <param name="transformGroup"><dd>  <p>The new transform group object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The array entries in a transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateTransformGroup']/*"/>	
        /// <msdn-id>dn280369</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTransformGroup([In, Buffer] IDCompositionTransform** transforms,[In] unsigned int elements,[Out, Fast] IDCompositionTransform** transformGroup)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateTransformGroup</unmanaged-short>	
        private void CreateTransformGroup(System.IntPtr transforms, int elements, System.IntPtr transformGroup) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)transforms, elements, (void*)transformGroup,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 3D translation transform object.</p>	
        /// </summary>	
        /// <param name="translateTransform3D"><dd>  <p>The new 3D translation transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>A newly created 3D translation transform has a static value of 0 for the OffsetX, OffsetY, and OffsetZ properties. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateTranslateTransform3D']/*"/>	
        /// <msdn-id>dn280371</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTranslateTransform3D([Out, Fast] IDCompositionTranslateTransform3D** translateTransform3D)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateTranslateTransform3D</unmanaged-short>	
        internal void CreateTranslateTransform3D(SharpDX.DirectComposition.TranslateTransform3D translateTransform3D) {
            unsafe {
                IntPtr translateTransform3D_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &translateTransform3D_,((void**)(*(void**)_nativePointer))[16]);		
                ((SharpDX.DirectComposition.TranslateTransform3D)translateTransform3D).NativePointer = translateTransform3D_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 3D scale transform object.</p>	
        /// </summary>	
        /// <param name="scaleTransform3D"><dd>  <p>The new 3D scale transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new 3D scale transform object has a static value of 1.0 for the ScaleX, ScaleY, and ScaleZ properties.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateScaleTransform3D']/*"/>	
        /// <msdn-id>dn280364</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateScaleTransform3D([Out, Fast] IDCompositionScaleTransform3D** scaleTransform3D)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateScaleTransform3D</unmanaged-short>	
        internal void CreateScaleTransform3D(SharpDX.DirectComposition.ScaleTransform3D scaleTransform3D) {
            unsafe {
                IntPtr scaleTransform3D_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &scaleTransform3D_,((void**)(*(void**)_nativePointer))[17]);		
                ((SharpDX.DirectComposition.ScaleTransform3D)scaleTransform3D).NativePointer = scaleTransform3D_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 3D rotation transform object.</p>	
        /// </summary>	
        /// <param name="rotateTransform3D"><dd>  <p>The new 3D rotation transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A new 3D rotation transform object has a default static value of zero for the Angle, CenterX, CenterY, CenterZ, AxisX, and AxisY properties, and a default static value of 1.0 for the AxisZ property.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateRotateTransform3D']/*"/>	
        /// <msdn-id>dn280362</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateRotateTransform3D([Out, Fast] IDCompositionRotateTransform3D** rotateTransform3D)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateRotateTransform3D</unmanaged-short>	
        internal void CreateRotateTransform3D(SharpDX.DirectComposition.RotateTransform3D rotateTransform3D) {
            unsafe {
                IntPtr rotateTransform3D_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &rotateTransform3D_,((void**)(*(void**)_nativePointer))[18]);		
                ((SharpDX.DirectComposition.RotateTransform3D)rotateTransform3D).NativePointer = rotateTransform3D_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 3D 4-by-4 matrix transform object.</p>	
        /// </summary>	
        /// <param name="matrixTransform3D"><dd>  <p>The new 3D matrix transform object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The new 3D matrix transform has the identity matrix as its value. The identity matrix is the 4-by-4 matrix with ones on the main diagonal and zeros elsewhere, as shown in the following illustration. </p><p></p><p>When an identity transform is applied to an object, it does not change the position, shape, or size of the object. It is similar to the way that multiplying a number by one does not change the number. Any transform other than the identity transform will modify the position, shape, and/or size of objects.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateMatrixTransform3D']/*"/>	
        /// <msdn-id>dn280359</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateMatrixTransform3D([Out, Fast] IDCompositionMatrixTransform3D** matrixTransform3D)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateMatrixTransform3D</unmanaged-short>	
        internal void CreateMatrixTransform3D(SharpDX.DirectComposition.MatrixTransform3D matrixTransform3D) {
            unsafe {
                IntPtr matrixTransform3D_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &matrixTransform3D_,((void**)(*(void**)_nativePointer))[19]);		
                ((SharpDX.DirectComposition.MatrixTransform3D)matrixTransform3D).NativePointer = matrixTransform3D_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 3D transform group object that holds an array of 3D transform objects.</p>	
        /// </summary>	
        /// <param name="transforms3D"><dd>  <p>An array of 3D transform objects that make up this transform group.</p> </dd></param>	
        /// <param name="elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>	
        /// <param name="transform3DGroup"><dd>  <p>The new 3D transform group object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The array entries in a 3D transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateTransform3DGroup']/*"/>	
        /// <msdn-id>dn280368</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTransform3DGroup([In, Buffer] IDCompositionTransform3D** transforms3D,[In] unsigned int elements,[Out, Fast] IDCompositionTransform3D** transform3DGroup)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateTransform3DGroup</unmanaged-short>	
        internal void CreateTransform3DGroup(SharpDX.DirectComposition.Transform3D[] transforms3D, int elements, SharpDX.DirectComposition.Transform3D transform3DGroup) {
            unsafe {
                IntPtr* transforms3D_ = (IntPtr*)0;
                if ( transforms3D != null ) {
                    IntPtr* transforms3D__ = stackalloc IntPtr[transforms3D.Length];
                    transforms3D_ = transforms3D__;
                    for (int i = 0; i < transforms3D.Length; i++)                        
                        transforms3D_[i] =  (transforms3D[i] == null)? IntPtr.Zero : transforms3D[i].NativePointer;
                }
                IntPtr transform3DGroup_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, transforms3D_, elements, &transform3DGroup_,((void**)(*(void**)_nativePointer))[20]);		
                ((SharpDX.DirectComposition.Transform3D)transform3DGroup).NativePointer = transform3DGroup_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 3D transform group object that holds an array of 3D transform objects.</p>	
        /// </summary>	
        /// <param name="transforms3D"><dd>  <p>An array of 3D transform objects that make up this transform group.</p> </dd></param>	
        /// <param name="elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>	
        /// <param name="transform3DGroup"><dd>  <p>The new 3D transform group object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The array entries in a 3D transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateTransform3DGroup']/*"/>	
        /// <msdn-id>dn280368</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTransform3DGroup([In, Buffer] IDCompositionTransform3D** transforms3D,[In] unsigned int elements,[Out, Fast] IDCompositionTransform3D** transform3DGroup)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateTransform3DGroup</unmanaged-short>	
        internal void CreateTransform3DGroup(SharpDX.ComArray<SharpDX.DirectComposition.Transform3D> transforms3D, int elements, SharpDX.DirectComposition.Transform3D transform3DGroup) {
            unsafe {
                IntPtr transform3DGroup_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((transforms3D == null)?IntPtr.Zero:transforms3D.NativePointer), elements, &transform3DGroup_,((void**)(*(void**)_nativePointer))[20]);		
                ((SharpDX.DirectComposition.Transform3D)transform3DGroup).NativePointer = transform3DGroup_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a 3D transform group object that holds an array of 3D transform objects.</p>	
        /// </summary>	
        /// <param name="transforms3D"><dd>  <p>An array of 3D transform objects that make up this transform group.</p> </dd></param>	
        /// <param name="elements"><dd>  <p>The number of elements in the <em>transforms</em> array.</p> </dd></param>	
        /// <param name="transform3DGroup"><dd>  <p>The new 3D transform group object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The array entries in a 3D transform group cannot be changed. However, each transform in the array can be modified through its own property setting methods. If a transform in the array is modified, the change is reflected in the computed matrix of the transform group.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateTransform3DGroup']/*"/>	
        /// <msdn-id>dn280368</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateTransform3DGroup([In, Buffer] IDCompositionTransform3D** transforms3D,[In] unsigned int elements,[Out, Fast] IDCompositionTransform3D** transform3DGroup)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateTransform3DGroup</unmanaged-short>	
        private void CreateTransform3DGroup(System.IntPtr transforms3D, int elements, System.IntPtr transform3DGroup) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)transforms3D, elements, (void*)transform3DGroup,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an object that represents multiple effects to be applied to a visual subtree.</p>	
        /// </summary>	
        /// <param name="effectGroup"><dd>  <p>The new effect group object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>An effect group enables an application to apply multiple effects to a single visual subtree. </p><p>A new effect group has a default opacity value of 1.0 and no 3D transformations.</p><p>To set the opacity and transform values, use the corresponding methods on the <strong><see cref="SharpDX.DirectComposition.EffectGroup"/></strong> that was created.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateEffectGroup']/*"/>	
        /// <msdn-id>dn280357</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateEffectGroup([Out, Fast] IDCompositionEffectGroup** effectGroup)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateEffectGroup</unmanaged-short>	
        internal void CreateEffectGroup(SharpDX.DirectComposition.EffectGroup effectGroup) {
            unsafe {
                IntPtr effectGroup_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &effectGroup_,((void**)(*(void**)_nativePointer))[21]);		
                ((SharpDX.DirectComposition.EffectGroup)effectGroup).NativePointer = effectGroup_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a clip object that can be used to restrict the rendering of  a visual subtree to a rectangular area.</p>	
        /// </summary>	
        /// <param name="clip"><dd>  <p>The new clip object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A newly created clip object has a static value of FLT_MAX for the left and top properties, and a static value of ?FLT_MAX for the right and bottom properties, effectively making it a no-op clip object.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateRectangleClip']/*"/>	
        /// <msdn-id>dn280360</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateRectangleClip([Out, Fast] IDCompositionRectangleClip** clip)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateRectangleClip</unmanaged-short>	
        internal void CreateRectangleClip(SharpDX.DirectComposition.RectangleClip clip) {
            unsafe {
                IntPtr clip_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &clip_,((void**)(*(void**)_nativePointer))[22]);		
                ((SharpDX.DirectComposition.RectangleClip)clip).NativePointer = clip_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an animation object that is used to animate one or more scalar properties of one or more Microsoft DirectComposition objects. </p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new animation object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A number of DirectComposition object properties can have an animation object as the value of the property. When a property has an animation object as its value, DirectComposition redraws the visual at the refresh rate to reflect the changing value of the property that is being animated.</p><p>A newly created animation object does not have any animation segments associated with it. An application must use the methods of the <strong><see cref="SharpDX.DirectComposition.Animation"/></strong> interface to build an animation function before setting the animation object as the property of another DirectComposition object.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice2::CreateAnimation']/*"/>	
        /// <msdn-id>dn280356</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice2::CreateAnimation([Out, Fast] IDCompositionAnimation** animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice2::CreateAnimation</unmanaged-short>	
        internal void CreateAnimation(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                IntPtr animation_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &animation_,((void**)(*(void**)_nativePointer))[23]);		
                ((SharpDX.DirectComposition.Animation)animation).NativePointer = animation_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Serves as a factory for all other Microsoft DirectComposition objects and provides methods to control transactional composition. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice3']/*"/>	
    /// <msdn-id>dn904488</msdn-id>	
    /// <unmanaged>IDCompositionDevice3</unmanaged>	
    /// <unmanaged-short>IDCompositionDevice3</unmanaged-short>	
    [Guid("0987CB06-F916-48BF-8D35-CE7641781BD9")]
    public partial class Device3 : SharpDX.DirectComposition.Device2 {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.Device3"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Device3(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.Device3"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.Device3(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.Device3(nativePointer);
		}
        
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="gaussianBlurEffect">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice3::CreateGaussianBlurEffect']/*"/>	
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateGaussianBlurEffect([Out] IDCompositionGaussianBlurEffect** gaussianBlurEffect)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice3::CreateGaussianBlurEffect</unmanaged-short>	
        public void CreateGaussianBlurEffect(out SharpDX.DirectComposition.GaussianBlurEffect gaussianBlurEffect) {
            unsafe {
                IntPtr gaussianBlurEffect_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &gaussianBlurEffect_,((void**)(*(void**)_nativePointer))[24]);		
                gaussianBlurEffect= (gaussianBlurEffect_ == IntPtr.Zero)?null:new SharpDX.DirectComposition.GaussianBlurEffect(gaussianBlurEffect_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates an instance of <strong><see cref="SharpDX.DirectComposition.BrightnessEffect"/></strong>. </p>	
        /// </summary>	
        /// <param name="brightnessEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice3::CreateBrightnessEffect']/*"/>	
        /// <msdn-id>dn950130</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateBrightnessEffect([Out] IDCompositionBrightnessEffect** brightnessEffect)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice3::CreateBrightnessEffect</unmanaged-short>	
        public void CreateBrightnessEffect(out SharpDX.DirectComposition.BrightnessEffect brightnessEffect) {
            unsafe {
                IntPtr brightnessEffect_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &brightnessEffect_,((void**)(*(void**)_nativePointer))[25]);		
                brightnessEffect= (brightnessEffect_ == IntPtr.Zero)?null:new SharpDX.DirectComposition.BrightnessEffect(brightnessEffect_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an instance of <strong><see cref="SharpDX.DirectComposition.ColorMatrixEffect"/></strong>.</p>	
        /// </summary>	
        /// <param name="colorMatrixEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice3::CreateColorMatrixEffect']/*"/>	
        /// <msdn-id>dn950131</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateColorMatrixEffect([Out] IDCompositionColorMatrixEffect** colorMatrixEffect)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice3::CreateColorMatrixEffect</unmanaged-short>	
        public void CreateColorMatrixEffect(out SharpDX.DirectComposition.ColorMatrixEffect colorMatrixEffect) {
            unsafe {
                IntPtr colorMatrixEffect_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &colorMatrixEffect_,((void**)(*(void**)_nativePointer))[26]);		
                colorMatrixEffect= (colorMatrixEffect_ == IntPtr.Zero)?null:new SharpDX.DirectComposition.ColorMatrixEffect(colorMatrixEffect_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates an instance of <strong><see cref="SharpDX.DirectComposition.ShadowEffect"/></strong>. </p>	
        /// </summary>	
        /// <param name="shadowEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice3::CreateShadowEffect']/*"/>	
        /// <msdn-id>dn950138</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateShadowEffect([Out] IDCompositionShadowEffect** shadowEffect)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice3::CreateShadowEffect</unmanaged-short>	
        public void CreateShadowEffect(out SharpDX.DirectComposition.ShadowEffect shadowEffect) {
            unsafe {
                IntPtr shadowEffect_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &shadowEffect_,((void**)(*(void**)_nativePointer))[27]);		
                shadowEffect= (shadowEffect_ == IntPtr.Zero)?null:new SharpDX.DirectComposition.ShadowEffect(shadowEffect_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates an instance of <strong><see cref="SharpDX.DirectComposition.HueRotationEffect"/></strong>. </p>	
        /// </summary>	
        /// <param name="hueRotationEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice3::CreateHueRotationEffect']/*"/>	
        /// <msdn-id>dn950135</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateHueRotationEffect([Out] IDCompositionHueRotationEffect** hueRotationEffect)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice3::CreateHueRotationEffect</unmanaged-short>	
        public void CreateHueRotationEffect(out SharpDX.DirectComposition.HueRotationEffect hueRotationEffect) {
            unsafe {
                IntPtr hueRotationEffect_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &hueRotationEffect_,((void**)(*(void**)_nativePointer))[28]);		
                hueRotationEffect= (hueRotationEffect_ == IntPtr.Zero)?null:new SharpDX.DirectComposition.HueRotationEffect(hueRotationEffect_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates an instance of <strong><see cref="SharpDX.DirectComposition.SaturationEffect"/></strong>. </p>	
        /// </summary>	
        /// <param name="saturationEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice3::CreateSaturationEffect']/*"/>	
        /// <msdn-id>dn950137</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateSaturationEffect([Out] IDCompositionSaturationEffect** saturationEffect)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice3::CreateSaturationEffect</unmanaged-short>	
        public void CreateSaturationEffect(out SharpDX.DirectComposition.SaturationEffect saturationEffect) {
            unsafe {
                IntPtr saturationEffect_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &saturationEffect_,((void**)(*(void**)_nativePointer))[29]);		
                saturationEffect= (saturationEffect_ == IntPtr.Zero)?null:new SharpDX.DirectComposition.SaturationEffect(saturationEffect_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates an instance of <strong><see cref="SharpDX.DirectComposition.TurbulenceEffect"/></strong>. </p>	
        /// </summary>	
        /// <param name="turbulenceEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice3::CreateTurbulenceEffect']/*"/>	
        /// <msdn-id>dn950140</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateTurbulenceEffect([Out] IDCompositionTurbulenceEffect** turbulenceEffect)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice3::CreateTurbulenceEffect</unmanaged-short>	
        public void CreateTurbulenceEffect(out SharpDX.DirectComposition.TurbulenceEffect turbulenceEffect) {
            unsafe {
                IntPtr turbulenceEffect_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &turbulenceEffect_,((void**)(*(void**)_nativePointer))[30]);		
                turbulenceEffect= (turbulenceEffect_ == IntPtr.Zero)?null:new SharpDX.DirectComposition.TurbulenceEffect(turbulenceEffect_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="linearTransferEffect">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice3::CreateLinearTransferEffect']/*"/>	
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateLinearTransferEffect([Out] IDCompositionLinearTransferEffect** linearTransferEffect)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice3::CreateLinearTransferEffect</unmanaged-short>	
        public void CreateLinearTransferEffect(out SharpDX.DirectComposition.LinearTransferEffect linearTransferEffect) {
            unsafe {
                IntPtr linearTransferEffect_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &linearTransferEffect_,((void**)(*(void**)_nativePointer))[31]);		
                linearTransferEffect= (linearTransferEffect_ == IntPtr.Zero)?null:new SharpDX.DirectComposition.LinearTransferEffect(linearTransferEffect_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates an instance of <strong><see cref="SharpDX.DirectComposition.TableTransferEffect"/></strong>. </p>	
        /// </summary>	
        /// <param name="tableTransferEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice3::CreateTableTransferEffect']/*"/>	
        /// <msdn-id>dn950139</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateTableTransferEffect([Out] IDCompositionTableTransferEffect** tableTransferEffect)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice3::CreateTableTransferEffect</unmanaged-short>	
        public void CreateTableTransferEffect(out SharpDX.DirectComposition.TableTransferEffect tableTransferEffect) {
            unsafe {
                IntPtr tableTransferEffect_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &tableTransferEffect_,((void**)(*(void**)_nativePointer))[32]);		
                tableTransferEffect= (tableTransferEffect_ == IntPtr.Zero)?null:new SharpDX.DirectComposition.TableTransferEffect(tableTransferEffect_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p> Creates an instance of <strong><see cref="SharpDX.DirectComposition.CompositeEffect"/></strong>. </p>	
        /// </summary>	
        /// <param name="compositeEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice3::CreateCompositeEffect']/*"/>	
        /// <msdn-id>dn950132</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateCompositeEffect([Out] IDCompositionCompositeEffect** compositeEffect)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice3::CreateCompositeEffect</unmanaged-short>	
        public void CreateCompositeEffect(out SharpDX.DirectComposition.CompositeEffect compositeEffect) {
            unsafe {
                IntPtr compositeEffect_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &compositeEffect_,((void**)(*(void**)_nativePointer))[33]);		
                compositeEffect= (compositeEffect_ == IntPtr.Zero)?null:new SharpDX.DirectComposition.CompositeEffect(compositeEffect_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an instance of <strong><see cref="SharpDX.DirectComposition.BlendEffect"/></strong>.</p>	
        /// </summary>	
        /// <param name="blendEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice3::CreateBlendEffect']/*"/>	
        /// <msdn-id>dn950129</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateBlendEffect([Out] IDCompositionBlendEffect** blendEffect)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice3::CreateBlendEffect</unmanaged-short>	
        public void CreateBlendEffect(out SharpDX.DirectComposition.BlendEffect blendEffect) {
            unsafe {
                IntPtr blendEffect_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &blendEffect_,((void**)(*(void**)_nativePointer))[34]);		
                blendEffect= (blendEffect_ == IntPtr.Zero)?null:new SharpDX.DirectComposition.BlendEffect(blendEffect_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an instance of <strong><see cref="SharpDX.DirectComposition.ArithmeticCompositeEffect"/></strong>.</p>	
        /// </summary>	
        /// <param name="arithmeticCompositeEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice3::CreateArithmeticCompositeEffect']/*"/>	
        /// <msdn-id>dn950128</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateArithmeticCompositeEffect([Out] IDCompositionArithmeticCompositeEffect** arithmeticCompositeEffect)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice3::CreateArithmeticCompositeEffect</unmanaged-short>	
        public void CreateArithmeticCompositeEffect(out SharpDX.DirectComposition.ArithmeticCompositeEffect arithmeticCompositeEffect) {
            unsafe {
                IntPtr arithmeticCompositeEffect_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &arithmeticCompositeEffect_,((void**)(*(void**)_nativePointer))[35]);		
                arithmeticCompositeEffect= (arithmeticCompositeEffect_ == IntPtr.Zero)?null:new SharpDX.DirectComposition.ArithmeticCompositeEffect(arithmeticCompositeEffect_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an instance of <strong><see cref="SharpDX.DirectComposition.AffineTransform2DEffect"/></strong>.</p>	
        /// </summary>	
        /// <param name="affineTransform2dEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDevice3::CreateAffineTransform2DEffect']/*"/>	
        /// <msdn-id>dn950127</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDevice3::CreateAffineTransform2DEffect([Out] IDCompositionAffineTransform2DEffect** affineTransform2dEffect)</unmanaged>	
        /// <unmanaged-short>IDCompositionDevice3::CreateAffineTransform2DEffect</unmanaged-short>	
        public void CreateAffineTransform2DEffect(out SharpDX.DirectComposition.AffineTransform2DEffect affineTransform2dEffect) {
            unsafe {
                IntPtr affineTransform2dEffect_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &affineTransform2dEffect_,((void**)(*(void**)_nativePointer))[36]);		
                affineTransform2dEffect= (affineTransform2dEffect_ == IntPtr.Zero)?null:new SharpDX.DirectComposition.AffineTransform2DEffect(affineTransform2dEffect_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides access to rendering features that help with application debugging and performance tuning. This interface can be queried from the DirectComposition device interface.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDeviceDebug']/*"/>	
    /// <msdn-id>dn280378</msdn-id>	
    /// <unmanaged>IDCompositionDeviceDebug</unmanaged>	
    /// <unmanaged-short>IDCompositionDeviceDebug</unmanaged-short>	
    [Guid("A1A3C64A-224F-4A81-9773-4F03A89D3C6C")]
    public partial class DeviceDebug : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.DeviceDebug"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DeviceDebug(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.DeviceDebug"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.DeviceDebug(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.DeviceDebug(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Enables display of performance debugging counters.</p>	
        /// </summary>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Performance counters are displayed on the top-right corner of the screen. From left to right, Microsoft DirectComposition displays the following information: </p><ul> <li>The composition engine frame rate, in frames per second, averaged over the last 60 composition frames</li> <li>The overall CPU usage of the composition thread, in milliseconds	
        /// </li> </ul><p>The DirectComposition composition engine operates on the entire desktop all at once, so the performance counters measure the total cost of desktop composition, not just the cost of any one particular application. If the application occupies the entire screen, however, it is reasonable to assume that all of the composition cost is due to that one application.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDeviceDebug::EnableDebugCounters']/*"/>	
        /// <msdn-id>dn280380</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDeviceDebug::EnableDebugCounters()</unmanaged>	
        /// <unmanaged-short>IDCompositionDeviceDebug::EnableDebugCounters</unmanaged-short>	
        public void EnableDebugCounters() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Disables display of performance debugging counters.</p>	
        /// </summary>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Microsoft DirectComposition keeps a count of how many DirectComposition devices have performance counters enabled, for the entire desktop session. If the count is non-zero, the performance counters are displayed. Therefore, disabling the counters may not make them go away if another device is also requesting display of the counters.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionDeviceDebug::DisableDebugCounters']/*"/>	
        /// <msdn-id>dn280379</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionDeviceDebug::DisableDebugCounters()</unmanaged>	
        /// <unmanaged-short>IDCompositionDeviceDebug::DisableDebugCounters</unmanaged-short>	
        public void DisableDebugCounters() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a bitmap effect that modifies the rasterization of a visual's subtree. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong><see cref="SharpDX.DirectComposition.Effect"/></strong> is an abstract interface that represents a bitmap effect. An effect applies to the entire visual subtree rooted at the visual that the effect is associated with. An effect object can be associated with multiple visuals. When an effect object is modified, all affected visuals are recomposed to reflect the change. </p><p>More than one effect can be simultaneously applied to a visual by using the <strong><see cref="SharpDX.DirectComposition.EffectGroup"/></strong> interface.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionEffect']/*"/>	
    /// <msdn-id>hh437417</msdn-id>	
    /// <unmanaged>IDCompositionEffect</unmanaged>	
    /// <unmanaged-short>IDCompositionEffect</unmanaged-short>	
    [Guid("EC81B08F-BFCB-4e8d-B193-A915587999E8")]
    public partial class Effect : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.Effect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Effect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.Effect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.Effect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.Effect(nativePointer);
		}
        
    }
    /// <summary>	
    /// <p>Represents a group of bitmap effects that are applied together to modify the rasterization of a visual's subtree. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionEffectGroup']/*"/>	
    /// <msdn-id>hh437418</msdn-id>	
    /// <unmanaged>IDCompositionEffectGroup</unmanaged>	
    /// <unmanaged-short>IDCompositionEffectGroup</unmanaged-short>	
    [Guid("A7929A74-E6B2-4bd6-8B95-4040119CA34D")]
    public partial class EffectGroup : SharpDX.DirectComposition.Effect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.EffectGroup"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectGroup(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.EffectGroup"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.EffectGroup(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.EffectGroup(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the 3D transformation effect object that modifies the rasterization of the visuals that this effect group is applied to.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method fails if <em>transform3D</em> is an invalid reference, or if the reference was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as this effect group. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method. </p><p>If the <em>transform3D</em> parameter is <c>null</c>, the effect group does not apply any perspective transformations to the visuals. Setting the transform to <c>null</c> is equivalent to setting the transform to an <strong><see cref="SharpDX.DirectComposition.MatrixTransform3D"/></strong> object where the specified matrix is the identity matrix. However, an application should use a <c>null</c> transform whenever possible because it is slightly faster.  </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionEffectGroup::SetTransform3D']/*"/>	
        /// <msdn-id>hh437423</msdn-id>	
        /// <unmanaged>SetTransform3D</unmanaged>	
        /// <unmanaged-short>SetTransform3D</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionEffectGroup::SetTransform3D([In, Optional] IDCompositionTransform3D* transform3D)</unmanaged>
        public SharpDX.DirectComposition.Transform3D Transform3D {
                set { SetTransform3D(value); }
        }
        
        /// <summary>	
        /// <p>Animates the value of the Opacity property. </p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the value of the Opacity property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Opacity property unless this method is called again. If the Opacity property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected compostion effect group. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionEffectGroup::SetOpacity']/*"/>	
        /// <msdn-id>hh437421</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionEffectGroup::SetOpacity([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionEffectGroup::SetOpacity</unmanaged-short>	
        public void SetOpacity(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the Opacity property. </p>	
        /// </summary>	
        /// <param name="opacity"><dd>  <p>An animation that represents how the value of the Opacity property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Opacity property unless this method is called again. If the Opacity property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected compostion effect group. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionEffectGroup::SetOpacity']/*"/>	
        /// <msdn-id>hh437421</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionEffectGroup::SetOpacity([In] float opacity)</unmanaged>	
        /// <unmanaged-short>IDCompositionEffectGroup::SetOpacity</unmanaged-short>	
        public void SetOpacity(float opacity) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, opacity,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the 3D transformation effect object that modifies the rasterization of the visuals that this effect group is applied to.</p>	
        /// </summary>	
        /// <param name="transform3D"><dd>  <p>Pointer to an <strong><see cref="SharpDX.DirectComposition.Transform3D"/></strong> interface or one of its derived interfaces. This parameter can be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if <em>transform3D</em> is an invalid reference, or if the reference was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as this effect group. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method. </p><p>If the <em>transform3D</em> parameter is <c>null</c>, the effect group does not apply any perspective transformations to the visuals. Setting the transform to <c>null</c> is equivalent to setting the transform to an <strong><see cref="SharpDX.DirectComposition.MatrixTransform3D"/></strong> object where the specified matrix is the identity matrix. However, an application should use a <c>null</c> transform whenever possible because it is slightly faster.  </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionEffectGroup::SetTransform3D']/*"/>	
        /// <msdn-id>hh437423</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionEffectGroup::SetTransform3D([In, Optional] IDCompositionTransform3D* transform3D)</unmanaged>	
        /// <unmanaged-short>IDCompositionEffectGroup::SetTransform3D</unmanaged-short>	
        internal void SetTransform3D(SharpDX.DirectComposition.Transform3D transform3D) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((transform3D == null)?IntPtr.Zero:transform3D.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a filter effect.</p><p><see cref="SharpDX.DirectComposition.FilterEffect"/> exposes a subset of Direct2D's image effects through Direction Composition for use in CSS filters in the browser platform.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionFilterEffect']/*"/>	
    /// <msdn-id>dn919730</msdn-id>	
    /// <unmanaged>IDCompositionFilterEffect</unmanaged>	
    /// <unmanaged-short>IDCompositionFilterEffect</unmanaged-short>	
    [Guid("30C421D5-8CB2-4E9F-B133-37BE270D4AC2")]
    public partial class FilterEffect : SharpDX.DirectComposition.Effect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.FilterEffect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FilterEffect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.FilterEffect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.FilterEffect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.FilterEffect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Represents a filter effect.</p><p><see cref="SharpDX.DirectComposition.FilterEffect"/> exposes a subset of Direct2D's image effects through Direction Composition for use in CSS filters in the browser platform.</p>	
        /// </summary>	
        /// <param name="index">No documentation.</param>	
        /// <param name="input">No documentation.</param>	
        /// <param name="flags">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionFilterEffect::SetInput']/*"/>	
        /// <msdn-id>dn919730</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionFilterEffect::SetInput([In] unsigned int index,[In, Optional] IUnknown* input,[In] unsigned int flags)</unmanaged>	
        /// <unmanaged-short>IDCompositionFilterEffect::SetInput</unmanaged-short>	
        public void SetInput(int index, SharpDX.ComObject input, int flags) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, index, (void*)((input == null)?IntPtr.Zero:input.NativePointer), flags,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p></p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionGaussianBlurEffect']/*"/>	
    /// <msdn-id>dn919734</msdn-id>	
    /// <unmanaged>IDCompositionGaussianBlurEffect</unmanaged>	
    /// <unmanaged-short>IDCompositionGaussianBlurEffect</unmanaged-short>	
    [Guid("45D4D0B7-1BD4-454E-8894-2BFA68443033")]
    public partial class GaussianBlurEffect : SharpDX.DirectComposition.FilterEffect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.GaussianBlurEffect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public GaussianBlurEffect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.GaussianBlurEffect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.GaussianBlurEffect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.GaussianBlurEffect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the amount of blur to be applied to the image.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionGaussianBlurEffect::SetStandardDeviation']/*"/>	
        /// <msdn-id>dn919736</msdn-id>	
        /// <unmanaged>SetStandardDeviation</unmanaged>	
        /// <unmanaged-short>SetStandardDeviation</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionGaussianBlurEffect::SetStandardDeviation([In] float amount)</unmanaged>
        public float StandardDeviation {
                set { SetStandardDeviation(value); }
        }
        
        /// <summary>	
        /// <p>Sets the mode used to calculate the border of the image.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionGaussianBlurEffect::SetBorderMode']/*"/>	
        /// <msdn-id>dn919735</msdn-id>	
        /// <unmanaged>SetBorderMode</unmanaged>	
        /// <unmanaged-short>SetBorderMode</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionGaussianBlurEffect::SetBorderMode([In] D2D1_BORDER_MODE mode)</unmanaged>
        public SharpDX.Direct2D1.BorderMode BorderMode {
                set { SetBorderMode(value); }
        }
        
        /// <summary>	
        /// <p>Sets the amount of blur to be applied to the image.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p> The amount of blur to be applied to the image. You can compute the blur radius of the kernel by multiplying the standard deviation by 3. The units of both the standard deviation and blur radius are DIPs. A value of zero DIPs disables this effect entirely. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionGaussianBlurEffect::SetStandardDeviation']/*"/>	
        /// <msdn-id>dn919736</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionGaussianBlurEffect::SetStandardDeviation([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionGaussianBlurEffect::SetStandardDeviation</unmanaged-short>	
        public void SetStandardDeviation(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the amount of blur to be applied to the image.</p>	
        /// </summary>	
        /// <param name="amount"><dd>  <p> The amount of blur to be applied to the image. You can compute the blur radius of the kernel by multiplying the standard deviation by 3. The units of both the standard deviation and blur radius are DIPs. A value of zero DIPs disables this effect entirely. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionGaussianBlurEffect::SetStandardDeviation']/*"/>	
        /// <msdn-id>dn919736</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionGaussianBlurEffect::SetStandardDeviation([In] float amount)</unmanaged>	
        /// <unmanaged-short>IDCompositionGaussianBlurEffect::SetStandardDeviation</unmanaged-short>	
        internal void SetStandardDeviation(float amount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, amount,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the mode used to calculate the border of the image.</p>	
        /// </summary>	
        /// <param name="mode"><dd>  <p>The mode used to calculate the border of the image.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionGaussianBlurEffect::SetBorderMode']/*"/>	
        /// <msdn-id>dn919735</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionGaussianBlurEffect::SetBorderMode([In] D2D1_BORDER_MODE mode)</unmanaged>	
        /// <unmanaged-short>IDCompositionGaussianBlurEffect::SetBorderMode</unmanaged-short>	
        internal void SetBorderMode(SharpDX.Direct2D1.BorderMode mode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, unchecked((int)mode),((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> The hue rotate effect alters the hue of an image by applying a color matrix based on the rotation angle. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionHueRotationEffect']/*"/>	
    /// <msdn-id>dn919738</msdn-id>	
    /// <unmanaged>IDCompositionHueRotationEffect</unmanaged>	
    /// <unmanaged-short>IDCompositionHueRotationEffect</unmanaged-short>	
    [Guid("6DB9F920-0770-4781-B0C6-381912F9D167")]
    public partial class HueRotationEffect : SharpDX.DirectComposition.FilterEffect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.HueRotationEffect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public HueRotationEffect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.HueRotationEffect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.HueRotationEffect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.HueRotationEffect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the angle to rotate the hue.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionHueRotationEffect::SetAngle']/*"/>	
        /// <msdn-id>dn919739</msdn-id>	
        /// <unmanaged>SetAngle</unmanaged>	
        /// <unmanaged-short>SetAngle</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionHueRotationEffect::SetAngle([In] float amountDegrees)</unmanaged>
        public float Angle {
                set { SetAngle(value); }
        }
        
        /// <summary>	
        /// <p>Sets the angle to rotate the hue.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The angle to rotate the hue. The effect calculates a color matrix based on the rotation angle (?) according to the following matrix equations: </p></dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionHueRotationEffect::SetAngle']/*"/>	
        /// <msdn-id>dn919739</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionHueRotationEffect::SetAngle([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionHueRotationEffect::SetAngle</unmanaged-short>	
        public void SetAngle(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the angle to rotate the hue.</p>	
        /// </summary>	
        /// <param name="amountDegrees"><dd>  <p>The angle to rotate the hue. The effect calculates a color matrix based on the rotation angle (?) according to the following matrix equations: </p></dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionHueRotationEffect::SetAngle']/*"/>	
        /// <msdn-id>dn919739</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionHueRotationEffect::SetAngle([In] float amountDegrees)</unmanaged>	
        /// <unmanaged-short>IDCompositionHueRotationEffect::SetAngle</unmanaged-short>	
        internal void SetAngle(float amountDegrees) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, amountDegrees,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> The linear transfer effect is used to map the color intensities of an image using a linear function created from a list of values you provide for each channel. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect']/*"/>	
    /// <msdn-id>dn919741</msdn-id>	
    /// <unmanaged>IDCompositionLinearTransferEffect</unmanaged>	
    /// <unmanaged-short>IDCompositionLinearTransferEffect</unmanaged-short>	
    [Guid("4305EE5B-C4A0-4C88-9385-67124E017683")]
    public partial class LinearTransferEffect : SharpDX.DirectComposition.FilterEffect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.LinearTransferEffect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public LinearTransferEffect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.LinearTransferEffect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.LinearTransferEffect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.LinearTransferEffect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the Y-intercept of the linear function for the red channel.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetRedYIntercept']/*"/>	
        /// <msdn-id>dn919762</msdn-id>	
        /// <unmanaged>SetRedYIntercept</unmanaged>	
        /// <unmanaged-short>SetRedYIntercept</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetRedYIntercept([In] float redYIntercept)</unmanaged>
        public float RedYIntercept {
                set { SetRedYIntercept(value); }
        }
        
        /// <summary>	
        /// <p>Sets the slope of the linear function for the red channel.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetRedSlope']/*"/>	
        /// <msdn-id>dn919760</msdn-id>	
        /// <unmanaged>SetRedSlope</unmanaged>	
        /// <unmanaged-short>SetRedSlope</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetRedSlope([In] float redSlope)</unmanaged>
        public float RedSlope {
                set { SetRedSlope(value); }
        }
        
        /// <summary>	
        /// <p>Specifies whether to apply the transfer function to the red channel.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetRedDisable']/*"/>	
        /// <msdn-id>dn919758</msdn-id>	
        /// <unmanaged>SetRedDisable</unmanaged>	
        /// <unmanaged-short>SetRedDisable</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetRedDisable([In] BOOL redDisable)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool RedDisable {
                set { SetRedDisable(value); }
        }
        
        /// <summary>	
        /// <p>Sets the Y-intercept of the linear function for the green channel.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetGreenYIntercept']/*"/>	
        /// <msdn-id>dn919757</msdn-id>	
        /// <unmanaged>SetGreenYIntercept</unmanaged>	
        /// <unmanaged-short>SetGreenYIntercept</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetGreenYIntercept([In] float greenYIntercept)</unmanaged>
        public float GreenYIntercept {
                set { SetGreenYIntercept(value); }
        }
        
        /// <summary>	
        /// <p>Sets the slope of the linear function for the green channel.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetGreenSlope']/*"/>	
        /// <msdn-id>dn919755</msdn-id>	
        /// <unmanaged>SetGreenSlope</unmanaged>	
        /// <unmanaged-short>SetGreenSlope</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetGreenSlope([In] float greenSlope)</unmanaged>
        public float GreenSlope {
                set { SetGreenSlope(value); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetGreenDisable']/*"/>	
        /// <unmanaged>SetGreenDisable</unmanaged>	
        /// <unmanaged-short>SetGreenDisable</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetGreenDisable([In] BOOL greenDisable)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool GreenDisable {
                set { SetGreenDisable(value); }
        }
        
        /// <summary>	
        /// <p>Sets the Y-intercept of the linear function for the blue channel. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetBlueYIntercept']/*"/>	
        /// <msdn-id>dn919751</msdn-id>	
        /// <unmanaged>SetBlueYIntercept</unmanaged>	
        /// <unmanaged-short>SetBlueYIntercept</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetBlueYIntercept([In] float blueYIntercept)</unmanaged>
        public float BlueYIntercept {
                set { SetBlueYIntercept(value); }
        }
        
        /// <summary>	
        /// <p>Sets the slope of the linear function for the blue channel.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetBlueSlope']/*"/>	
        /// <msdn-id>dn919749</msdn-id>	
        /// <unmanaged>SetBlueSlope</unmanaged>	
        /// <unmanaged-short>SetBlueSlope</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetBlueSlope([In] float blueSlope)</unmanaged>
        public float BlueSlope {
                set { SetBlueSlope(value); }
        }
        
        /// <summary>	
        /// <p>Specifies whether to apply the transfer function to the blue channel.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetBlueDisable']/*"/>	
        /// <msdn-id>dn919747</msdn-id>	
        /// <unmanaged>SetBlueDisable</unmanaged>	
        /// <unmanaged-short>SetBlueDisable</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetBlueDisable([In] BOOL blueDisable)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool BlueDisable {
                set { SetBlueDisable(value); }
        }
        
        /// <summary>	
        /// <p>Sets the Y-intercept of the linear function for the Alpha channel.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetAlphaYIntercept']/*"/>	
        /// <msdn-id>dn919746</msdn-id>	
        /// <unmanaged>SetAlphaYIntercept</unmanaged>	
        /// <unmanaged-short>SetAlphaYIntercept</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetAlphaYIntercept([In] float alphaYIntercept)</unmanaged>
        public float AlphaYIntercept {
                set { SetAlphaYIntercept(value); }
        }
        
        /// <summary>	
        /// <p>Sets the slope of the linear function for the alpha channel.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetAlphaSlope']/*"/>	
        /// <msdn-id>dn919744</msdn-id>	
        /// <unmanaged>SetAlphaSlope</unmanaged>	
        /// <unmanaged-short>SetAlphaSlope</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetAlphaSlope([In] float alphaSlope)</unmanaged>
        public float AlphaSlope {
                set { SetAlphaSlope(value); }
        }
        
        /// <summary>	
        /// <p>Specifies whether to apply the transfer function to the alpha channel.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetAlphaDisable']/*"/>	
        /// <msdn-id>dn919742</msdn-id>	
        /// <unmanaged>SetAlphaDisable</unmanaged>	
        /// <unmanaged-short>SetAlphaDisable</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetAlphaDisable([In] BOOL alphaDisable)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool AlphaDisable {
                set { SetAlphaDisable(value); }
        }
        
        /// <summary>	
        /// <p>Specifies whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetClampOutput']/*"/>	
        /// <msdn-id>dn919752</msdn-id>	
        /// <unmanaged>SetClampOutput</unmanaged>	
        /// <unmanaged-short>SetClampOutput</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetClampOutput([In] BOOL clampOutput)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool ClampOutput {
                set { SetClampOutput(value); }
        }
        
        /// <summary>	
        /// <p>Sets the Y-intercept of the linear function for the red channel.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the Y-intercept of the linear function for the red channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetRedYIntercept']/*"/>	
        /// <msdn-id>dn919762</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetRedYIntercept([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetRedYIntercept</unmanaged-short>	
        public void SetRedYIntercept(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the Y-intercept of the linear function for the red channel.</p>	
        /// </summary>	
        /// <param name="redYIntercept"><dd>  <p>An animation that represents how the Y-intercept of the linear function for the red channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetRedYIntercept']/*"/>	
        /// <msdn-id>dn919762</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetRedYIntercept([In] float redYIntercept)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetRedYIntercept</unmanaged-short>	
        internal void SetRedYIntercept(float redYIntercept) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, redYIntercept,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the slope of the linear function for the red channel.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the slope of the linear function for the red channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetRedSlope']/*"/>	
        /// <msdn-id>dn919760</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetRedSlope([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetRedSlope</unmanaged-short>	
        public void SetRedSlope(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the slope of the linear function for the red channel.</p>	
        /// </summary>	
        /// <param name="redSlope"><dd>  <p>An animation that represents how the slope of the linear function for the red channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetRedSlope']/*"/>	
        /// <msdn-id>dn919760</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetRedSlope([In] float redSlope)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetRedSlope</unmanaged-short>	
        internal void SetRedSlope(float redSlope) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, redSlope,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies whether to apply the transfer function to the red channel.</p>	
        /// </summary>	
        /// <param name="redDisable"><dd>  <p> A boolean value that specifies whether to apply the transfer function to the red channel. If you set this to TRUE the effect does not apply the transfer function to the red channel. If you set this to <see cref="SharpDX.Result.False"/> the effect applies the RedLinearTransfer function to the red channel. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetRedDisable']/*"/>	
        /// <msdn-id>dn919758</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetRedDisable([In] BOOL redDisable)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetRedDisable</unmanaged-short>	
        internal void SetRedDisable(SharpDX.Mathematics.Interop.RawBool redDisable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint9(_nativePointer, redDisable,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the Y-intercept of the linear function for the green channel.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the Y-intercept of the linear function for the green channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetGreenYIntercept']/*"/>	
        /// <msdn-id>dn919757</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetGreenYIntercept([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetGreenYIntercept</unmanaged-short>	
        public void SetGreenYIntercept(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the Y-intercept of the linear function for the green channel.</p>	
        /// </summary>	
        /// <param name="greenYIntercept"><dd>  <p>An animation that represents how the Y-intercept of the linear function for the green channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetGreenYIntercept']/*"/>	
        /// <msdn-id>dn919757</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetGreenYIntercept([In] float greenYIntercept)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetGreenYIntercept</unmanaged-short>	
        internal void SetGreenYIntercept(float greenYIntercept) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, greenYIntercept,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the slope of the linear function for the green channel.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the slope of the linear function for the green channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetGreenSlope']/*"/>	
        /// <msdn-id>dn919755</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetGreenSlope([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetGreenSlope</unmanaged-short>	
        public void SetGreenSlope(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the slope of the linear function for the green channel.</p>	
        /// </summary>	
        /// <param name="greenSlope"><dd>  <p>An animation that represents how the slope of the linear function for the green channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetGreenSlope']/*"/>	
        /// <msdn-id>dn919755</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetGreenSlope([In] float greenSlope)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetGreenSlope</unmanaged-short>	
        internal void SetGreenSlope(float greenSlope) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, greenSlope,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="greenDisable">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetGreenDisable']/*"/>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetGreenDisable([In] BOOL greenDisable)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetGreenDisable</unmanaged-short>	
        internal void SetGreenDisable(SharpDX.Mathematics.Interop.RawBool greenDisable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint9(_nativePointer, greenDisable,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the Y-intercept of the linear function for the blue channel. </p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the Y-intercept of the linear function for the blue channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetBlueYIntercept']/*"/>	
        /// <msdn-id>dn919751</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetBlueYIntercept([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetBlueYIntercept</unmanaged-short>	
        public void SetBlueYIntercept(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the Y-intercept of the linear function for the blue channel. </p>	
        /// </summary>	
        /// <param name="blueYIntercept"><dd>  <p>An animation that represents how the Y-intercept of the linear function for the blue channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetBlueYIntercept']/*"/>	
        /// <msdn-id>dn919751</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetBlueYIntercept([In] float blueYIntercept)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetBlueYIntercept</unmanaged-short>	
        internal void SetBlueYIntercept(float blueYIntercept) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, blueYIntercept,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the slope of the linear function for the blue channel.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the slope of the linear function for the blue channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetBlueSlope']/*"/>	
        /// <msdn-id>dn919749</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetBlueSlope([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetBlueSlope</unmanaged-short>	
        public void SetBlueSlope(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the slope of the linear function for the blue channel.</p>	
        /// </summary>	
        /// <param name="blueSlope"><dd>  <p>An animation that represents how the slope of the linear function for the blue channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetBlueSlope']/*"/>	
        /// <msdn-id>dn919749</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetBlueSlope([In] float blueSlope)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetBlueSlope</unmanaged-short>	
        internal void SetBlueSlope(float blueSlope) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, blueSlope,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies whether to apply the transfer function to the blue channel.</p>	
        /// </summary>	
        /// <param name="blueDisable"><dd>  <p> A boolean value that specifies whether to apply the transfer function to the blue channel. If you set this to TRUE the effect does not apply the transfer function to the blue channel. If you set this to <see cref="SharpDX.Result.False"/> it applies the BlueLinearTransfer function to the blue channel. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetBlueDisable']/*"/>	
        /// <msdn-id>dn919747</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetBlueDisable([In] BOOL blueDisable)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetBlueDisable</unmanaged-short>	
        internal void SetBlueDisable(SharpDX.Mathematics.Interop.RawBool blueDisable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint9(_nativePointer, blueDisable,((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the Y-intercept of the linear function for the Alpha channel.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the the Y-intercept of the linear function for the alpha channel. changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetAlphaYIntercept']/*"/>	
        /// <msdn-id>dn919746</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetAlphaYIntercept([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetAlphaYIntercept</unmanaged-short>	
        public void SetAlphaYIntercept(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the Y-intercept of the linear function for the Alpha channel.</p>	
        /// </summary>	
        /// <param name="alphaYIntercept"><dd>  <p>An animation that represents how the the Y-intercept of the linear function for the alpha channel. changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetAlphaYIntercept']/*"/>	
        /// <msdn-id>dn919746</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetAlphaYIntercept([In] float alphaYIntercept)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetAlphaYIntercept</unmanaged-short>	
        internal void SetAlphaYIntercept(float alphaYIntercept) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, alphaYIntercept,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the slope of the linear function for the alpha channel.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the slope of the linear function for the alpha channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetAlphaSlope']/*"/>	
        /// <msdn-id>dn919744</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetAlphaSlope([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetAlphaSlope</unmanaged-short>	
        public void SetAlphaSlope(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the slope of the linear function for the alpha channel.</p>	
        /// </summary>	
        /// <param name="alphaSlope"><dd>  <p>An animation that represents how the slope of the linear function for the alpha channel changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetAlphaSlope']/*"/>	
        /// <msdn-id>dn919744</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetAlphaSlope([In] float alphaSlope)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetAlphaSlope</unmanaged-short>	
        internal void SetAlphaSlope(float alphaSlope) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, alphaSlope,((void**)(*(void**)_nativePointer))[22]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies whether to apply the transfer function to the alpha channel.</p>	
        /// </summary>	
        /// <param name="alphaDisable"><dd>  <p> A boolean value that specifies whether to apply the transfer function to the alpha channel. If you set this to TRUE the effect does not apply the transfer function to the Alpha channel. If you set this to <see cref="SharpDX.Result.False"/> it applies the AlphaLinearTransfer function to the Alpha channel. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetAlphaDisable']/*"/>	
        /// <msdn-id>dn919742</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetAlphaDisable([In] BOOL alphaDisable)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetAlphaDisable</unmanaged-short>	
        internal void SetAlphaDisable(SharpDX.Mathematics.Interop.RawBool alphaDisable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint9(_nativePointer, alphaDisable,((void**)(*(void**)_nativePointer))[23]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph.</p>	
        /// </summary>	
        /// <param name="clampOutput"><dd>  <p> A boolean value that specifies whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph. If you set this to TRUE the effect will clamp the values. If you set this to <see cref="SharpDX.Result.False"/>, the effect will not clamp the color values, but other effects and the output surface may clamp the values if they are not of high enough precision. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionLinearTransferEffect::SetClampOutput']/*"/>	
        /// <msdn-id>dn919752</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionLinearTransferEffect::SetClampOutput([In] BOOL clampOutput)</unmanaged>	
        /// <unmanaged-short>IDCompositionLinearTransferEffect::SetClampOutput</unmanaged-short>	
        internal void SetClampOutput(SharpDX.Mathematics.Interop.RawBool clampOutput) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint9(_nativePointer, clampOutput,((void**)(*(void**)_nativePointer))[24]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents an arbitrary affine 2D transformation defined by a 3-by-2 matrix.</p><p></p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionMatrixTransform']/*"/>	
    /// <msdn-id>hh437424</msdn-id>	
    /// <unmanaged>IDCompositionMatrixTransform</unmanaged>	
    /// <unmanaged-short>IDCompositionMatrixTransform</unmanaged-short>	
    [Guid("16CDFF07-C503-419c-83F2-0965C7AF1FA6")]
    public partial class MatrixTransform : SharpDX.DirectComposition.Transform {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.MatrixTransform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MatrixTransform(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.MatrixTransform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.MatrixTransform(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.MatrixTransform(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Changes all values of the matrix of this 2D transform.</p>	
        /// </summary>	
        /// <param name="matrix"><dd>  <p>The new matrix for this 2D transform.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if any of the matrix values are NaN, positive infinity, or negative infinity.</p><p>If any of the matrix elements were previously animated, this method removes the animations and sets the elements to the specified static value.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionMatrixTransform::SetMatrix']/*"/>	
        /// <msdn-id>hh437430</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionMatrixTransform::SetMatrix([In] const D2D_MATRIX_3X2_F&amp; matrix)</unmanaged>	
        /// <unmanaged-short>IDCompositionMatrixTransform::SetMatrix</unmanaged-short>	
        public void SetMatrix(ref SharpDX.Mathematics.Interop.RawMatrix3x2 matrix) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* matrix_ = &matrix)
                    __result__= 
    				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, matrix_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// Changes or animates the value of one element of the matrix of this 2D transform.	
        /// </summary>	
        /// <param name="row">No documentation.</param>	
        /// <param name="column">No documentation.</param>	
        /// <param name="animation">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionMatrixTransform::SetMatrixElement']/*"/>	
        /// <msdn-id>hh437433</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionMatrixTransform::SetMatrixElement([In] int row,[In] int column,[In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionMatrixTransform::SetMatrixElement</unmanaged-short>	
        public void SetMatrixElement(int row, int column, SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, row, column, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// Changes or animates the value of one element of the matrix of this 2D transform.	
        /// </summary>	
        /// <param name="row">No documentation.</param>	
        /// <param name="column">No documentation.</param>	
        /// <param name="value">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionMatrixTransform::SetMatrixElement']/*"/>	
        /// <msdn-id>hh437433</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionMatrixTransform::SetMatrixElement([In] int row,[In] int column,[In] float value)</unmanaged>	
        /// <unmanaged-short>IDCompositionMatrixTransform::SetMatrixElement</unmanaged-short>	
        public void SetMatrixElement(int row, int column, float value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, row, column, value,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents an arbitrary 3D transformation defined by a 4-by-4 matrix.</p><p></p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A 3D matrix transform represents the following 4-by-4 matrix:</p><p></p><p> The application can set any of the values in the first three columns. Note that the fourth column is padded to allow for matrix concatenation. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionMatrixTransform3D']/*"/>	
    /// <msdn-id>hh437425</msdn-id>	
    /// <unmanaged>IDCompositionMatrixTransform3D</unmanaged>	
    /// <unmanaged-short>IDCompositionMatrixTransform3D</unmanaged-short>	
    [Guid("4B3363F0-643B-41b7-B6E0-CCF22D34467C")]
    public partial class MatrixTransform3D : SharpDX.DirectComposition.Transform3D {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.MatrixTransform3D"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MatrixTransform3D(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.MatrixTransform3D"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.MatrixTransform3D(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.MatrixTransform3D(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Changes all values of the matrix of this 3D transformation effect.</p>	
        /// </summary>	
        /// <param name="matrix"><dd>  <p>The new matrix for this 3D transformation effect.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if any of the matrix values are NaN, positive infinity, or negative infinity.</p><p>If any of the matrix elements were previously animated, this method removes the animations and sets the elements to the specified static value.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionMatrixTransform3D::SetMatrix']/*"/>	
        /// <msdn-id>hh437426</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionMatrixTransform3D::SetMatrix([In] const D3DMATRIX&amp; matrix)</unmanaged>	
        /// <unmanaged-short>IDCompositionMatrixTransform3D::SetMatrix</unmanaged-short>	
        public void SetMatrix(ref SharpDX.Mathematics.Interop.RawMatrix matrix) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* matrix_ = &matrix)
                    __result__= 
    				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, matrix_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of one element of the matrix of this 3D transform.</p>	
        /// </summary>	
        /// <param name="row"><dd>  <p>The row index of the element to change. This value must be between 0 and 3, inclusive.</p> </dd></param>	
        /// <param name="column"><dd>  <p>The column index of the element to change. This value must be between 0 and 3, inclusive.</p> </dd></param>	
        /// <param name="animation"><dd>  <p>An animation that represents how the value of the specified element changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the specified element unless this method is called again. If the specified element was previously animated, calling this method replaces the previous animation with the new animation.</p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected transform. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionMatrixTransform3D::SetMatrixElement']/*"/>	
        /// <msdn-id>hh437428</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionMatrixTransform3D::SetMatrixElement([In] int row,[In] int column,[In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionMatrixTransform3D::SetMatrixElement</unmanaged-short>	
        public void SetMatrixElement(int row, int column, SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, row, column, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of one element of the matrix of this 3D transform.</p>	
        /// </summary>	
        /// <param name="row"><dd>  <p>The row index of the element to change. This value must be between 0 and 3, inclusive.</p> </dd></param>	
        /// <param name="column"><dd>  <p>The column index of the element to change. This value must be between 0 and 3, inclusive.</p> </dd></param>	
        /// <param name="value"><dd>  <p>An animation that represents how the value of the specified element changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the specified element unless this method is called again. If the specified element was previously animated, calling this method replaces the previous animation with the new animation.</p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected transform. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionMatrixTransform3D::SetMatrixElement']/*"/>	
        /// <msdn-id>hh437428</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionMatrixTransform3D::SetMatrixElement([In] int row,[In] int column,[In] float value)</unmanaged>	
        /// <unmanaged-short>IDCompositionMatrixTransform3D::SetMatrixElement</unmanaged-short>	
        public void SetMatrixElement(int row, int column, float value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, row, column, value,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a clip object that restricts the rendering of a visual subtree to the specified rectangular region. Optionally, the clip object may have rounded corners specified.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip']/*"/>	
    /// <msdn-id>hh437434</msdn-id>	
    /// <unmanaged>IDCompositionRectangleClip</unmanaged>	
    /// <unmanaged-short>IDCompositionRectangleClip</unmanaged-short>	
    [Guid("9842AD7D-D9CF-4908-AED7-48B51DA5E7C2")]
    public partial class RectangleClip : SharpDX.DirectComposition.Clip {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.RectangleClip"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RectangleClip(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.RectangleClip"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.RectangleClip(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.RectangleClip(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Changes the value of the Left property of a clip rectangle. The Left property specifies the x-coordinate of the upper-left corner of the clip rectangle.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new value of the Left property, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>left</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the Left property was previously animated, this method removes the animation and sets the Left property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetLeft']/*"/>	
        /// <msdn-id>hh448899</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetLeft([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetLeft</unmanaged-short>	
        public void SetLeft(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the Left property of a clip rectangle. The Left property specifies the x-coordinate of the upper-left corner of the clip rectangle.</p>	
        /// </summary>	
        /// <param name="left"><dd>  <p>The new value of the Left property, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>left</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the Left property was previously animated, this method removes the animation and sets the Left property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetLeft']/*"/>	
        /// <msdn-id>hh448899</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetLeft([In] float left)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetLeft</unmanaged-short>	
        public void SetLeft(float left) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, left,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the Top property of a clip rectangle. The Top property specifies the y-coordinate of the upper-left corner of the clip rectangle.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new value of the Top property, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>top</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the Top property was previously animated, this method removes the animation and sets the Top property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetTop']/*"/>	
        /// <msdn-id>hh448921</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTop([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetTop</unmanaged-short>	
        public void SetTop(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the Top property of a clip rectangle. The Top property specifies the y-coordinate of the upper-left corner of the clip rectangle.</p>	
        /// </summary>	
        /// <param name="top"><dd>  <p>The new value of the Top property, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>top</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the Top property was previously animated, this method removes the animation and sets the Top property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetTop']/*"/>	
        /// <msdn-id>hh448921</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTop([In] float top)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetTop</unmanaged-short>	
        public void SetTop(float top) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, top,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the Right property of a clip rectangle. The Right property specifies the x-coordinate of the lower-right corner of the clip rectangle.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation object that determines how the value of the Right property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Right property unless this method is called again. If the Right  property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetRight']/*"/>	
        /// <msdn-id>hh448907</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetRight([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetRight</unmanaged-short>	
        public void SetRight(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the Right property of a clip rectangle. The Right property specifies the x-coordinate of the lower-right corner of the clip rectangle.</p>	
        /// </summary>	
        /// <param name="right"><dd>  <p>An animation object that determines how the value of the Right property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Right property unless this method is called again. If the Right  property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetRight']/*"/>	
        /// <msdn-id>hh448907</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetRight([In] float right)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetRight</unmanaged-short>	
        public void SetRight(float right) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, right,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the Bottom property of a clip object. The Bottom property specifies the y-coordinate of the lower-right corner of the clip rectangle. </p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new value of the Bottom property, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>bottom</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the Bottom property was previously animated, this method removes the animation and sets the Bottom property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetBottom']/*"/>	
        /// <msdn-id>hh448860</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottom([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottom</unmanaged-short>	
        public void SetBottom(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the Bottom property of a clip object. The Bottom property specifies the y-coordinate of the lower-right corner of the clip rectangle. </p>	
        /// </summary>	
        /// <param name="bottom"><dd>  <p>The new value of the Bottom property, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>bottom</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the Bottom property was previously animated, this method removes the animation and sets the Bottom property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetBottom']/*"/>	
        /// <msdn-id>hh448860</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottom([In] float bottom)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottom</unmanaged-short>	
        public void SetBottom(float bottom) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, bottom,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the TopLeftRadiusX property of this clip. The TopLeftRadiusX property  specifies the x radius of the ellipse that rounds the top-left corner of the clip.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation object that determines how the value of the x radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the x radius unless this method is called again. If the x radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetTopLeftRadiusX']/*"/>	
        /// <msdn-id>hh448911</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopLeftRadiusX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopLeftRadiusX</unmanaged-short>	
        public void SetTopLeftRadiusX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the TopLeftRadiusX property of this clip. The TopLeftRadiusX property  specifies the x radius of the ellipse that rounds the top-left corner of the clip.</p>	
        /// </summary>	
        /// <param name="radius"><dd>  <p>An animation object that determines how the value of the x radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the x radius unless this method is called again. If the x radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetTopLeftRadiusX']/*"/>	
        /// <msdn-id>hh448911</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopLeftRadiusX([In] float radius)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopLeftRadiusX</unmanaged-short>	
        public void SetTopLeftRadiusX(float radius) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, radius,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the TopLeftRadiusY property of this clip. The TopLeftRadiusY property  specifies the y radius of the ellipse that rounds the top-left corner of the clip.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation object that determines how the value of the y radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the y radius unless this method is called again. If the y radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetTopLeftRadiusY']/*"/>	
        /// <msdn-id>hh448914</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopLeftRadiusY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopLeftRadiusY</unmanaged-short>	
        public void SetTopLeftRadiusY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the TopLeftRadiusY property of this clip. The TopLeftRadiusY property  specifies the y radius of the ellipse that rounds the top-left corner of the clip.</p>	
        /// </summary>	
        /// <param name="radius"><dd>  <p>An animation object that determines how the value of the y radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the y radius unless this method is called again. If the y radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetTopLeftRadiusY']/*"/>	
        /// <msdn-id>hh448914</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopLeftRadiusY([In] float radius)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopLeftRadiusY</unmanaged-short>	
        public void SetTopLeftRadiusY(float radius) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, radius,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the TopRightRadiusX property of this clip. The TopRightRadiusX property  specifies the x radius of the ellipse that rounds the top-right corner of the clip.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation object that determines how the value of the x radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the x radius unless this method is called again. If the x radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetTopRightRadiusX']/*"/>	
        /// <msdn-id>hh448917</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopRightRadiusX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopRightRadiusX</unmanaged-short>	
        public void SetTopRightRadiusX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the TopRightRadiusX property of this clip. The TopRightRadiusX property  specifies the x radius of the ellipse that rounds the top-right corner of the clip.</p>	
        /// </summary>	
        /// <param name="radius"><dd>  <p>An animation object that determines how the value of the x radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the x radius unless this method is called again. If the x radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetTopRightRadiusX']/*"/>	
        /// <msdn-id>hh448917</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopRightRadiusX([In] float radius)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopRightRadiusX</unmanaged-short>	
        public void SetTopRightRadiusX(float radius) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, radius,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the TopRightRadiusY property of this clip. The TopRightRadiusY property  specifies the y radius of the ellipse that rounds the top-right corner of the clip.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation object that determines how the value of the y radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the y radius unless this method is called again. If the y radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetTopRightRadiusY']/*"/>	
        /// <msdn-id>hh448920</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopRightRadiusY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopRightRadiusY</unmanaged-short>	
        public void SetTopRightRadiusY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the TopRightRadiusY property of this clip. The TopRightRadiusY property  specifies the y radius of the ellipse that rounds the top-right corner of the clip.</p>	
        /// </summary>	
        /// <param name="radius"><dd>  <p>An animation object that determines how the value of the y radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the y radius unless this method is called again. If the y radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetTopRightRadiusY']/*"/>	
        /// <msdn-id>hh448920</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetTopRightRadiusY([In] float radius)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetTopRightRadiusY</unmanaged-short>	
        public void SetTopRightRadiusY(float radius) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, radius,((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the BottomLeftRadiusX property of this clip. The BottomLeftRadiusX property  specifies the x radius of the ellipse that rounds the lower-left corner of the clip.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation object that determines how the value of the x radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the x radius unless this method is called again. If the x radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetBottomLeftRadiusX']/*"/>	
        /// <msdn-id>hh437438</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomLeftRadiusX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomLeftRadiusX</unmanaged-short>	
        public void SetBottomLeftRadiusX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the BottomLeftRadiusX property of this clip. The BottomLeftRadiusX property  specifies the x radius of the ellipse that rounds the lower-left corner of the clip.</p>	
        /// </summary>	
        /// <param name="radius"><dd>  <p>An animation object that determines how the value of the x radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the x radius unless this method is called again. If the x radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetBottomLeftRadiusX']/*"/>	
        /// <msdn-id>hh437438</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomLeftRadiusX([In] float radius)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomLeftRadiusX</unmanaged-short>	
        public void SetBottomLeftRadiusX(float radius) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, radius,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the BottomLeftRadiusY property of this clip. The BottomLeftRadiusY property  specifies the y radius of the ellipse that rounds the lower-left corner of the clip.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation object that determines how the value of the y radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the y radius unless this method is called again. If the y radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetBottomLeftRadiusY']/*"/>	
        /// <msdn-id>hh437445</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomLeftRadiusY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomLeftRadiusY</unmanaged-short>	
        public void SetBottomLeftRadiusY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the BottomLeftRadiusY property of this clip. The BottomLeftRadiusY property  specifies the y radius of the ellipse that rounds the lower-left corner of the clip.</p>	
        /// </summary>	
        /// <param name="radius"><dd>  <p>An animation object that determines how the value of the y radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the y radius unless this method is called again. If the y radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetBottomLeftRadiusY']/*"/>	
        /// <msdn-id>hh437445</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomLeftRadiusY([In] float radius)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomLeftRadiusY</unmanaged-short>	
        public void SetBottomLeftRadiusY(float radius) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, radius,((void**)(*(void**)_nativePointer))[22]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the BottomRightRadiusX property of this clip. The BottomRightRadiusX property  specifies the x radius of the ellipse that rounds the lower-right corner of the clip.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation object that determines how the value of the x radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the x radius unless this method is called again. If the x radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetBottomRightRadiusX']/*"/>	
        /// <msdn-id>hh448853</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomRightRadiusX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomRightRadiusX</unmanaged-short>	
        public void SetBottomRightRadiusX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[23]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the BottomRightRadiusX property of this clip. The BottomRightRadiusX property  specifies the x radius of the ellipse that rounds the lower-right corner of the clip.</p>	
        /// </summary>	
        /// <param name="radius"><dd>  <p>An animation object that determines how the value of the x radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the x radius unless this method is called again. If the x radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetBottomRightRadiusX']/*"/>	
        /// <msdn-id>hh448853</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomRightRadiusX([In] float radius)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomRightRadiusX</unmanaged-short>	
        public void SetBottomRightRadiusX(float radius) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, radius,((void**)(*(void**)_nativePointer))[24]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the BottomRightRadiusY property of this clip. The BottomRightRadiusY property  specifies the y radius of the ellipse that rounds the lower-right corner of the clip.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation object that determines how the value of the y radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the y radius unless this method is called again. If the y radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetBottomRightRadiusY']/*"/>	
        /// <msdn-id>hh448858</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomRightRadiusY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomRightRadiusY</unmanaged-short>	
        public void SetBottomRightRadiusY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[25]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the BottomRightRadiusY property of this clip. The BottomRightRadiusY property  specifies the y radius of the ellipse that rounds the lower-right corner of the clip.</p>	
        /// </summary>	
        /// <param name="radius"><dd>  <p>An animation object that determines how the value of the y radius changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the y radius unless this method is called again. If the y radius was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRectangleClip::SetBottomRightRadiusY']/*"/>	
        /// <msdn-id>hh448858</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRectangleClip::SetBottomRightRadiusY([In] float radius)</unmanaged>	
        /// <unmanaged-short>IDCompositionRectangleClip::SetBottomRightRadiusY</unmanaged-short>	
        public void SetBottomRightRadiusY(float radius) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, radius,((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a 2D transformation that affects the rotation of a visual around the z-axis. The coordinate system is rotated around the specified center point. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A rotate transform represents the following 3-by-3 matrix:</p><p></p><p>The effect is to rotate the coordinate system clockwise or counter-clockwise, and to apply the corresponding translation such that the center point does not move.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform']/*"/>	
    /// <msdn-id>hh448924</msdn-id>	
    /// <unmanaged>IDCompositionRotateTransform</unmanaged>	
    /// <unmanaged-short>IDCompositionRotateTransform</unmanaged-short>	
    [Guid("641ED83C-AE96-46c5-90DC-32774CC5C6D5")]
    public partial class RotateTransform : SharpDX.DirectComposition.Transform {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.RotateTransform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RotateTransform(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.RotateTransform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.RotateTransform(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.RotateTransform(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Animates the value of the Angle property of a 2D rotation transform. The Angle property specifies the rotation angle.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation object that determines how the value of the Angle property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Angle property unless this method is called again. If the Angle property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform::SetAngle']/*"/>	
        /// <msdn-id>hh448974</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform::SetAngle([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform::SetAngle</unmanaged-short>	
        public void SetAngle(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the Angle property of a 2D rotation transform. The Angle property specifies the rotation angle.</p>	
        /// </summary>	
        /// <param name="angle"><dd>  <p>An animation object that determines how the value of the Angle property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Angle property unless this method is called again. If the Angle property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform::SetAngle']/*"/>	
        /// <msdn-id>hh448974</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform::SetAngle([In] float angle)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform::SetAngle</unmanaged-short>	
        public void SetAngle(float angle) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, angle,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterX property of a 2D rotation transform. The CenterX property specifies the x-coordinate of the point about which the rotation is performed.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new x-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterX property was previously animated, this method removes the animation and sets the CenterX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform::SetCenterX']/*"/>	
        /// <msdn-id>hh448978</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform::SetCenterX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform::SetCenterX</unmanaged-short>	
        public void SetCenterX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterX property of a 2D rotation transform. The CenterX property specifies the x-coordinate of the point about which the rotation is performed.</p>	
        /// </summary>	
        /// <param name="centerX"><dd>  <p>The new x-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterX property was previously animated, this method removes the animation and sets the CenterX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform::SetCenterX']/*"/>	
        /// <msdn-id>hh448978</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform::SetCenterX([In] float centerX)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform::SetCenterX</unmanaged-short>	
        public void SetCenterX(float centerX) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, centerX,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterY property of a 2D rotation transform. The CenterY property specifies the y-coordinate of the point about which the rotation is performed.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new y-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterY property was previously animated, this method removes the animation and sets the CenterY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform::SetCenterY']/*"/>	
        /// <msdn-id>hh448984</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform::SetCenterY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform::SetCenterY</unmanaged-short>	
        public void SetCenterY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterY property of a 2D rotation transform. The CenterY property specifies the y-coordinate of the point about which the rotation is performed.</p>	
        /// </summary>	
        /// <param name="centerY"><dd>  <p>The new y-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterY property was previously animated, this method removes the animation and sets the CenterY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform::SetCenterY']/*"/>	
        /// <msdn-id>hh448984</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform::SetCenterY([In] float centerY)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform::SetCenterY</unmanaged-short>	
        public void SetCenterY(float centerY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, centerY,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a 3D transformation that affects the rotation of a visual along an arbitrary axis in 3D space. The coordinate system is rotated around the specified center point. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A 3D rotate transform represents the following 4-by-4 matrix:</p><p></p><p>where the <em>offsetX</em>, <em>offsetY</em>, and <em>offsetZ</em> values of the matrix are the following: </p><p></p><p>The effect is to rotate the coordinate system clockwise or counter-clockwise around the specified axis, and to apply the corresponding translation such that the center point does not move.</p><p>A new 3D rotation transform object has a default static value of zero for the Angle, CenterX, CenterY, AxisX, and AxisY properties, and a default static value of 1.0 for the AxisZ property.</p><p>When setting the axis to a non-default value, you should always set all three axis properties (AxisX, AxisY, and AxisZ).</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform3D']/*"/>	
    /// <msdn-id>hh448927</msdn-id>	
    /// <unmanaged>IDCompositionRotateTransform3D</unmanaged>	
    /// <unmanaged-short>IDCompositionRotateTransform3D</unmanaged-short>	
    [Guid("D8F5B23F-D429-4a91-B55A-D2F45FD75B18")]
    public partial class RotateTransform3D : SharpDX.DirectComposition.Transform3D {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.RotateTransform3D"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RotateTransform3D(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.RotateTransform3D"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.RotateTransform3D(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.RotateTransform3D(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Animates the value of the Angle property of a 3D rotation transform. The Angle property specifies the rotation angle. The default value is zero.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation object that determines how the value of the Angle property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Angle property unless this method is called again. If the Angle property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected 3D transform. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform3D::SetAngle']/*"/>	
        /// <msdn-id>hh448931</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAngle([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAngle</unmanaged-short>	
        public void SetAngle(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the Angle property of a 3D rotation transform. The Angle property specifies the rotation angle. The default value is zero.</p>	
        /// </summary>	
        /// <param name="angle"><dd>  <p>An animation object that determines how the value of the Angle property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the Angle property unless this method is called again. If the Angle property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected 3D transform. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform3D::SetAngle']/*"/>	
        /// <msdn-id>hh448931</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAngle([In] float angle)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAngle</unmanaged-short>	
        public void SetAngle(float angle) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, angle,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the AxisX property of a 3D rotation transform. The AxisX property specifies the x-coordinate for the axis vector of rotation. The default value is zero.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new x-coordinate for the axis vector of rotation. </p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>When setting the axis to a non-default value, you should always set all three axis properties (AxisX, AxisY, and AxisZ).</p><p>This method fails if the <em>axisX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the AxisX property was previously animated, this method removes the animation and sets the AxisX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform3D::SetAxisX']/*"/>	
        /// <msdn-id>hh448935</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAxisX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAxisX</unmanaged-short>	
        public void SetAxisX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the AxisX property of a 3D rotation transform. The AxisX property specifies the x-coordinate for the axis vector of rotation. The default value is zero.</p>	
        /// </summary>	
        /// <param name="axisX"><dd>  <p>The new x-coordinate for the axis vector of rotation. </p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>When setting the axis to a non-default value, you should always set all three axis properties (AxisX, AxisY, and AxisZ).</p><p>This method fails if the <em>axisX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the AxisX property was previously animated, this method removes the animation and sets the AxisX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform3D::SetAxisX']/*"/>	
        /// <msdn-id>hh448935</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAxisX([In] float axisX)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAxisX</unmanaged-short>	
        public void SetAxisX(float axisX) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, axisX,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the AxisY property of a 3D rotation transform. The AxisY property specifies the y-coordinate for the axis vector of rotation.  The default value is zero.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new y-coordinate for the axis vector of rotation. </p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>When setting the axis to a non-default value, you should always set all three axis properties (AxisX, AxisY, and AxisZ).</p><p>This method fails if the <em>axisY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the AxisY property was previously animated, this method removes the animation and sets the AxisY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform3D::SetAxisY']/*"/>	
        /// <msdn-id>hh448941</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAxisY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAxisY</unmanaged-short>	
        public void SetAxisY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the AxisY property of a 3D rotation transform. The AxisY property specifies the y-coordinate for the axis vector of rotation.  The default value is zero.</p>	
        /// </summary>	
        /// <param name="axisY"><dd>  <p>The new y-coordinate for the axis vector of rotation. </p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>When setting the axis to a non-default value, you should always set all three axis properties (AxisX, AxisY, and AxisZ).</p><p>This method fails if the <em>axisY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the AxisY property was previously animated, this method removes the animation and sets the AxisY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform3D::SetAxisY']/*"/>	
        /// <msdn-id>hh448941</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAxisY([In] float axisY)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAxisY</unmanaged-short>	
        public void SetAxisY(float axisY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, axisY,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the AxisZ property of a 3D rotation transform. The AxisZ property specifies the z-coordinate for the axis vector of rotation. The default value is 1.0.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new z-coordinate for the axis vector of rotation. </p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>When setting the axis to a non-default value, you should always set all three axis properties (AxisX, AxisY, and AxisZ).</p><p>This method fails if the <em>axisZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the AxisZ property was previously animated, this method removes the animation and sets the AxisX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform3D::SetAxisZ']/*"/>	
        /// <msdn-id>hh448947</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAxisZ([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAxisZ</unmanaged-short>	
        public void SetAxisZ(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the AxisZ property of a 3D rotation transform. The AxisZ property specifies the z-coordinate for the axis vector of rotation. The default value is 1.0.</p>	
        /// </summary>	
        /// <param name="axisZ"><dd>  <p>The new z-coordinate for the axis vector of rotation. </p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>When setting the axis to a non-default value, you should always set all three axis properties (AxisX, AxisY, and AxisZ).</p><p>This method fails if the <em>axisZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the AxisZ property was previously animated, this method removes the animation and sets the AxisX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform3D::SetAxisZ']/*"/>	
        /// <msdn-id>hh448947</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetAxisZ([In] float axisZ)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetAxisZ</unmanaged-short>	
        public void SetAxisZ(float axisZ) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, axisZ,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the CenterX property of a 3D rotation transform. The CenterX property specifies the x-coordinate of the point about which the rotation is performed. The default value is zero.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation object that determines how the value of the CenterX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the CenterX property unless this method is called again. If the CenterX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform3D::SetCenterX']/*"/>	
        /// <msdn-id>hh448955</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetCenterX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetCenterX</unmanaged-short>	
        public void SetCenterX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the CenterX property of a 3D rotation transform. The CenterX property specifies the x-coordinate of the point about which the rotation is performed. The default value is zero.</p>	
        /// </summary>	
        /// <param name="centerX"><dd>  <p>An animation object that determines how the value of the CenterX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the CenterX property unless this method is called again. If the CenterX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform3D::SetCenterX']/*"/>	
        /// <msdn-id>hh448955</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetCenterX([In] float centerX)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetCenterX</unmanaged-short>	
        public void SetCenterX(float centerX) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, centerX,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterY property of a 3D rotation transform. The CenterY property specifies the y-coordinate of the point about which the rotation is performed. The default value is zero.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new y-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterY property was previously animated, this method removes the animation and sets the CenterY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform3D::SetCenterY']/*"/>	
        /// <msdn-id>hh448959</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetCenterY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetCenterY</unmanaged-short>	
        public void SetCenterY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterY property of a 3D rotation transform. The CenterY property specifies the y-coordinate of the point about which the rotation is performed. The default value is zero.</p>	
        /// </summary>	
        /// <param name="centerY"><dd>  <p>The new y-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterY property was previously animated, this method removes the animation and sets the CenterY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform3D::SetCenterY']/*"/>	
        /// <msdn-id>hh448959</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetCenterY([In] float centerY)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetCenterY</unmanaged-short>	
        public void SetCenterY(float centerY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, centerY,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterZ property of a 3D rotation transform. The CenterZ property specifies the z-coordinate of the point about which the rotation is performed. The default value is zero.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new z-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterZ property was previously animated, this method removes the animation and sets the CenterZ property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform3D::SetCenterZ']/*"/>	
        /// <msdn-id>hh448965</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetCenterZ([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetCenterZ</unmanaged-short>	
        public void SetCenterZ(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterZ property of a 3D rotation transform. The CenterZ property specifies the z-coordinate of the point about which the rotation is performed. The default value is zero.</p>	
        /// </summary>	
        /// <param name="centerZ"><dd>  <p>The new z-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterZ property was previously animated, this method removes the animation and sets the CenterZ property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionRotateTransform3D::SetCenterZ']/*"/>	
        /// <msdn-id>hh448965</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionRotateTransform3D::SetCenterZ([In] float centerZ)</unmanaged>	
        /// <unmanaged-short>IDCompositionRotateTransform3D::SetCenterZ</unmanaged-short>	
        public void SetCenterZ(float centerZ) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, centerZ,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> This effect is used to alter the saturation of an image. The saturation effect is a specialization of the?color matrix?effect. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSaturationEffect']/*"/>	
    /// <msdn-id>dn919763</msdn-id>	
    /// <unmanaged>IDCompositionSaturationEffect</unmanaged>	
    /// <unmanaged-short>IDCompositionSaturationEffect</unmanaged-short>	
    [Guid("A08DEBDA-3258-4FA4-9F16-9174D3FE93B1")]
    public partial class SaturationEffect : SharpDX.DirectComposition.FilterEffect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.SaturationEffect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SaturationEffect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.SaturationEffect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.SaturationEffect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.SaturationEffect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the saturation of the image.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSaturationEffect::SetSaturation']/*"/>	
        /// <msdn-id>dn919765</msdn-id>	
        /// <unmanaged>SetSaturation</unmanaged>	
        /// <unmanaged-short>SetSaturation</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionSaturationEffect::SetSaturation([In] float ratio)</unmanaged>
        public float Saturation {
                set { SetSaturation(value); }
        }
        
        /// <summary>	
        /// <p>Sets the saturation of the image.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the saturation of the image changes over time. This parameter must not be <c>null</c>. You can set the saturation to a value between 0 and 1. If you set it to 1 the output image is fully saturated. If you set it to 0 the output image is monochrome. The saturation value is unitless. The effect calculates a color matrix based on the saturation value (s in the equation here) using the following equation: </p></dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSaturationEffect::SetSaturation']/*"/>	
        /// <msdn-id>dn919765</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSaturationEffect::SetSaturation([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionSaturationEffect::SetSaturation</unmanaged-short>	
        public void SetSaturation(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the saturation of the image.</p>	
        /// </summary>	
        /// <param name="ratio"><dd>  <p>An animation that represents how the saturation of the image changes over time. This parameter must not be <c>null</c>. You can set the saturation to a value between 0 and 1. If you set it to 1 the output image is fully saturated. If you set it to 0 the output image is monochrome. The saturation value is unitless. The effect calculates a color matrix based on the saturation value (s in the equation here) using the following equation: </p></dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSaturationEffect::SetSaturation']/*"/>	
        /// <msdn-id>dn919765</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSaturationEffect::SetSaturation([In] float ratio)</unmanaged>	
        /// <unmanaged-short>IDCompositionSaturationEffect::SetSaturation</unmanaged-short>	
        internal void SetSaturation(float ratio) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, ratio,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a 2D transformation that affects the scale of a visual along the x-axis and y-axis. The coordinate system is scaled from the specified center point. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A scale transform represents the following 3-by-3 matrix:</p><p></p><p>The effect is to scale the coordinate system up or down and apply the corresponding translation such that the center point does not move.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform']/*"/>	
    /// <msdn-id>hh448990</msdn-id>	
    /// <unmanaged>IDCompositionScaleTransform</unmanaged>	
    /// <unmanaged-short>IDCompositionScaleTransform</unmanaged-short>	
    [Guid("71FDE914-40EF-45ef-BD51-68B037C339F9")]
    public partial class ScaleTransform : SharpDX.DirectComposition.Transform {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.ScaleTransform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ScaleTransform(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.ScaleTransform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.ScaleTransform(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.ScaleTransform(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Animates the value of the ScaleX property of a 2D scale transform. The ScaleX property specifies the scale factor along the x-axis.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation object that determines how the value of the ScaleX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the ScaleX property unless this method is called again. If the ScaleX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform::SetScaleX']/*"/>	
        /// <msdn-id>hh449046</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetScaleX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform::SetScaleX</unmanaged-short>	
        public void SetScaleX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the ScaleX property of a 2D scale transform. The ScaleX property specifies the scale factor along the x-axis.</p>	
        /// </summary>	
        /// <param name="scaleX"><dd>  <p>An animation object that determines how the value of the ScaleX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the ScaleX property unless this method is called again. If the ScaleX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform::SetScaleX']/*"/>	
        /// <msdn-id>hh449046</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetScaleX([In] float scaleX)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform::SetScaleX</unmanaged-short>	
        public void SetScaleX(float scaleX) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, scaleX,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the ScaleY property of a 2D scale transform. The ScaleY property specifies the scale factor along the y-axis.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new y-axis scale factor.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>scaleY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the ScaleY property was previously animated, this method removes the animation and sets the ScaleY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform::SetScaleY']/*"/>	
        /// <msdn-id>hh449050</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetScaleY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform::SetScaleY</unmanaged-short>	
        public void SetScaleY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the ScaleY property of a 2D scale transform. The ScaleY property specifies the scale factor along the y-axis.</p>	
        /// </summary>	
        /// <param name="scaleY"><dd>  <p>The new y-axis scale factor.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>scaleY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the ScaleY property was previously animated, this method removes the animation and sets the ScaleY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform::SetScaleY']/*"/>	
        /// <msdn-id>hh449050</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetScaleY([In] float scaleY)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform::SetScaleY</unmanaged-short>	
        public void SetScaleY(float scaleY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, scaleY,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterX property of a 2D scale transform.   The CenterX property specifies the x-coordinate of the point about which scaling is performed. </p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new x-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterX property was previously animated, this method removes the animation and sets the CenterX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform::SetCenterX']/*"/>	
        /// <msdn-id>hh449032</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetCenterX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform::SetCenterX</unmanaged-short>	
        public void SetCenterX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterX property of a 2D scale transform.   The CenterX property specifies the x-coordinate of the point about which scaling is performed. </p>	
        /// </summary>	
        /// <param name="centerX"><dd>  <p>The new x-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterX property was previously animated, this method removes the animation and sets the CenterX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform::SetCenterX']/*"/>	
        /// <msdn-id>hh449032</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetCenterX([In] float centerX)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform::SetCenterX</unmanaged-short>	
        public void SetCenterX(float centerX) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, centerX,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterY property of a 2D scale transform. The CenterY property specifies the y-coordinate of the point about which scaling is performed. </p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new y-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterY property was previously animated, this method removes the animation and sets the CenterY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform::SetCenterY']/*"/>	
        /// <msdn-id>hh449038</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetCenterY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform::SetCenterY</unmanaged-short>	
        public void SetCenterY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterY property of a 2D scale transform. The CenterY property specifies the y-coordinate of the point about which scaling is performed. </p>	
        /// </summary>	
        /// <param name="centerY"><dd>  <p>The new y-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterY property was previously animated, this method removes the animation and sets the CenterY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform::SetCenterY']/*"/>	
        /// <msdn-id>hh449038</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform::SetCenterY([In] float centerY)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform::SetCenterY</unmanaged-short>	
        public void SetCenterY(float centerY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, centerY,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a 3D transformation effect that affects the scale of a visual along the x-axis, y-axis, and z-axis. The coordinate system is scaled from the specified center point. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A 3D scale transform represents the following 4-by-4 matrix:</p><p></p><p>The effect is to scale the blending of the visual's subtree up or down, and apply the corresponding translation such that the center point does not move.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform3D']/*"/>	
    /// <msdn-id>hh448992</msdn-id>	
    /// <unmanaged>IDCompositionScaleTransform3D</unmanaged>	
    /// <unmanaged-short>IDCompositionScaleTransform3D</unmanaged-short>	
    [Guid("2A9E9EAD-364B-4b15-A7C4-A1997F78B389")]
    public partial class ScaleTransform3D : SharpDX.DirectComposition.Transform3D {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.ScaleTransform3D"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ScaleTransform3D(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.ScaleTransform3D"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.ScaleTransform3D(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.ScaleTransform3D(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Changes the value of the ScaleX property of a 3D scale transform. The ScaleX property specifies the scale factor along the x-axis.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new x-axis scale factor.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>scaleX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the ScaleX property was previously animated, this method removes the animation and sets the ScaleX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform3D::SetScaleX']/*"/>	
        /// <msdn-id>hh449014</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetScaleX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetScaleX</unmanaged-short>	
        public void SetScaleX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the ScaleX property of a 3D scale transform. The ScaleX property specifies the scale factor along the x-axis.</p>	
        /// </summary>	
        /// <param name="scaleX"><dd>  <p>The new x-axis scale factor.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>scaleX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the ScaleX property was previously animated, this method removes the animation and sets the ScaleX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform3D::SetScaleX']/*"/>	
        /// <msdn-id>hh449014</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetScaleX([In] float scaleX)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetScaleX</unmanaged-short>	
        public void SetScaleX(float scaleX) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, scaleX,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the ScaleY property of a 3D scale transform. The ScaleY property specifies the scale factor along the y-axis.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new y-axis scale factor.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>scaleY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the ScaleY property was previously animated, this method removes the animation and sets the ScaleY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform3D::SetScaleY']/*"/>	
        /// <msdn-id>hh449020</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetScaleY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetScaleY</unmanaged-short>	
        public void SetScaleY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the ScaleY property of a 3D scale transform. The ScaleY property specifies the scale factor along the y-axis.</p>	
        /// </summary>	
        /// <param name="scaleY"><dd>  <p>The new y-axis scale factor.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>scaleY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the ScaleY property was previously animated, this method removes the animation and sets the ScaleY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform3D::SetScaleY']/*"/>	
        /// <msdn-id>hh449020</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetScaleY([In] float scaleY)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetScaleY</unmanaged-short>	
        public void SetScaleY(float scaleY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, scaleY,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the ScaleZ property of a 3D scale transform. The ScaleZ property specifies the scale factor along the z-axis.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new z-axis scale factor.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>scaleZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the ScaleZ property was previously animated, this method removes the animation and sets the ScaleZ property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform3D::SetScaleZ']/*"/>	
        /// <msdn-id>hh449026</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetScaleZ([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetScaleZ</unmanaged-short>	
        public void SetScaleZ(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the ScaleZ property of a 3D scale transform. The ScaleZ property specifies the scale factor along the z-axis.</p>	
        /// </summary>	
        /// <param name="scaleZ"><dd>  <p>The new z-axis scale factor.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>scaleZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the ScaleZ property was previously animated, this method removes the animation and sets the ScaleZ property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform3D::SetScaleZ']/*"/>	
        /// <msdn-id>hh449026</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetScaleZ([In] float scaleZ)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetScaleZ</unmanaged-short>	
        public void SetScaleZ(float scaleZ) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, scaleZ,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterX property of a 3D scale transform.   The CenterX property specifies the x-coordinate of the point about which scaling is performed. </p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new x-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterX property was previously animated, this method removes the animation and sets the CenterX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform3D::SetCenterX']/*"/>	
        /// <msdn-id>hh448994</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetCenterX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetCenterX</unmanaged-short>	
        public void SetCenterX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterX property of a 3D scale transform.   The CenterX property specifies the x-coordinate of the point about which scaling is performed. </p>	
        /// </summary>	
        /// <param name="centerX"><dd>  <p>The new x-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterX property was previously animated, this method removes the animation and sets the CenterX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform3D::SetCenterX']/*"/>	
        /// <msdn-id>hh448994</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetCenterX([In] float centerX)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetCenterX</unmanaged-short>	
        public void SetCenterX(float centerX) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, centerX,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterY property of a 3D scale transform.   The CenterY property specifies the y-coordinate of the point about which scaling is performed. </p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new y-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterY property was previously animated, this method removes the animation and sets the CenterY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform3D::SetCenterY']/*"/>	
        /// <msdn-id>hh449002</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetCenterY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetCenterY</unmanaged-short>	
        public void SetCenterY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterY property of a 3D scale transform.   The CenterY property specifies the y-coordinate of the point about which scaling is performed. </p>	
        /// </summary>	
        /// <param name="centerY"><dd>  <p>The new y-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterY property was previously animated, this method removes the animation and sets the CenterY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform3D::SetCenterY']/*"/>	
        /// <msdn-id>hh449002</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetCenterY([In] float centerY)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetCenterY</unmanaged-short>	
        public void SetCenterY(float centerY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, centerY,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterZ property of a 3D scale transform.   The CenterZ property specifies the z-coordinate of the point about which scaling is performed. </p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new z-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterZ property was previously animated, this method removes the animation and sets the CenterZ property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform3D::SetCenterZ']/*"/>	
        /// <msdn-id>hh449008</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetCenterZ([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetCenterZ</unmanaged-short>	
        public void SetCenterZ(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterZ property of a 3D scale transform.   The CenterZ property specifies the z-coordinate of the point about which scaling is performed. </p>	
        /// </summary>	
        /// <param name="centerZ"><dd>  <p>The new z-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterZ property was previously animated, this method removes the animation and sets the CenterZ property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionScaleTransform3D::SetCenterZ']/*"/>	
        /// <msdn-id>hh449008</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionScaleTransform3D::SetCenterZ([In] float centerZ)</unmanaged>	
        /// <unmanaged-short>IDCompositionScaleTransform3D::SetCenterZ</unmanaged-short>	
        public void SetCenterZ(float centerZ) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, centerZ,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> The shadow effect is used to generate a shadow from the alpha channel of an image. The shadow is more opaque for higher alpha values and more transparent for lower alpha values. You can set the amount of blur and the color of the shadow. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect']/*"/>	
    /// <msdn-id>dn919766</msdn-id>	
    /// <unmanaged>IDCompositionShadowEffect</unmanaged>	
    /// <unmanaged-short>IDCompositionShadowEffect</unmanaged-short>	
    [Guid("4AD18AC0-CFD2-4C2F-BB62-96E54FDB6879")]
    public partial class ShadowEffect : SharpDX.DirectComposition.FilterEffect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.ShadowEffect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ShadowEffect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.ShadowEffect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.ShadowEffect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.ShadowEffect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the amount of blur to be applied to the alpha channel of the image.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetStandardDeviation']/*"/>	
        /// <msdn-id>dn919782</msdn-id>	
        /// <unmanaged>SetStandardDeviation</unmanaged>	
        /// <unmanaged-short>SetStandardDeviation</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetStandardDeviation([In] float amount)</unmanaged>
        public float StandardDeviation {
                set { SetStandardDeviation(value); }
        }
        
        /// <summary>	
        /// <p>Sets color of the shadow.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetColor']/*"/>	
        /// <msdn-id>dn919771</msdn-id>	
        /// <unmanaged>SetColor</unmanaged>	
        /// <unmanaged-short>SetColor</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetColor([In] const D2D_VECTOR_4F& color)</unmanaged>
        public SharpDX.Mathematics.Interop.RawVector4 Color {
                set { SetColor(value); }
        }
        
        /// <summary>	
        /// <p>Sets the red value for the color of the shadow.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetRed']/*"/>	
        /// <msdn-id>dn919774</msdn-id>	
        /// <unmanaged>SetRed</unmanaged>	
        /// <unmanaged-short>SetRed</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetRed([In] float amount)</unmanaged>
        public float Red {
                set { SetRed(value); }
        }
        
        /// <summary>	
        /// <p>Sets the green value for the color of the shadow.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetGreen']/*"/>	
        /// <msdn-id>dn919773</msdn-id>	
        /// <unmanaged>SetGreen</unmanaged>	
        /// <unmanaged-short>SetGreen</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetGreen([In] float amount)</unmanaged>
        public float Green {
                set { SetGreen(value); }
        }
        
        /// <summary>	
        /// <p>Sets the blue value for the color of the shadow.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetBlue']/*"/>	
        /// <msdn-id>dn919769</msdn-id>	
        /// <unmanaged>SetBlue</unmanaged>	
        /// <unmanaged-short>SetBlue</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetBlue([In] float amount)</unmanaged>
        public float Blue {
                set { SetBlue(value); }
        }
        
        /// <summary>	
        /// <p>Sets the alpha value for the effect.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetAlpha']/*"/>	
        /// <msdn-id>dn919767</msdn-id>	
        /// <unmanaged>SetAlpha</unmanaged>	
        /// <unmanaged-short>SetAlpha</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetAlpha([In] float amount)</unmanaged>
        public float Alpha {
                set { SetAlpha(value); }
        }
        
        /// <summary>	
        /// <p>Sets the amount of blur to be applied to the alpha channel of the image.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the amount of blur to be applied to the alpha channel of the image changes over time.  You can compute the blur radius of the kernel by multiplying the standard deviation by 3. The units of both the standard deviation and blur radius are DIPs.           This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetStandardDeviation']/*"/>	
        /// <msdn-id>dn919782</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetStandardDeviation([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionShadowEffect::SetStandardDeviation</unmanaged-short>	
        public void SetStandardDeviation(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the amount of blur to be applied to the alpha channel of the image.</p>	
        /// </summary>	
        /// <param name="amount"><dd>  <p>An animation that represents how the amount of blur to be applied to the alpha channel of the image changes over time.  You can compute the blur radius of the kernel by multiplying the standard deviation by 3. The units of both the standard deviation and blur radius are DIPs.           This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetStandardDeviation']/*"/>	
        /// <msdn-id>dn919782</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetStandardDeviation([In] float amount)</unmanaged>	
        /// <unmanaged-short>IDCompositionShadowEffect::SetStandardDeviation</unmanaged-short>	
        internal void SetStandardDeviation(float amount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, amount,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets color of the shadow.</p>	
        /// </summary>	
        /// <param name="color"><dd>  <p>The color of the shadow.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetColor']/*"/>	
        /// <msdn-id>dn919771</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetColor([In] const D2D_VECTOR_4F&amp; color)</unmanaged>	
        /// <unmanaged-short>IDCompositionShadowEffect::SetColor</unmanaged-short>	
        internal void SetColor(SharpDX.Mathematics.Interop.RawVector4 color) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &color,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the red value for the color of the shadow.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The red value for the color of the shadow.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetRed']/*"/>	
        /// <msdn-id>dn919774</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetRed([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionShadowEffect::SetRed</unmanaged-short>	
        public void SetRed(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the red value for the color of the shadow.</p>	
        /// </summary>	
        /// <param name="amount"><dd>  <p>The red value for the color of the shadow.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetRed']/*"/>	
        /// <msdn-id>dn919774</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetRed([In] float amount)</unmanaged>	
        /// <unmanaged-short>IDCompositionShadowEffect::SetRed</unmanaged-short>	
        internal void SetRed(float amount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, amount,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the green value for the color of the shadow.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation that represents how the green value for the color of the shadow changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetGreen']/*"/>	
        /// <msdn-id>dn919773</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetGreen([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionShadowEffect::SetGreen</unmanaged-short>	
        public void SetGreen(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the green value for the color of the shadow.</p>	
        /// </summary>	
        /// <param name="amount"><dd>  <p>An animation that represents how the green value for the color of the shadow changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetGreen']/*"/>	
        /// <msdn-id>dn919773</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetGreen([In] float amount)</unmanaged>	
        /// <unmanaged-short>IDCompositionShadowEffect::SetGreen</unmanaged-short>	
        internal void SetGreen(float amount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, amount,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the blue value for the color of the shadow.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The blue value for the color of the shadow.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetBlue']/*"/>	
        /// <msdn-id>dn919769</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetBlue([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionShadowEffect::SetBlue</unmanaged-short>	
        public void SetBlue(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the blue value for the color of the shadow.</p>	
        /// </summary>	
        /// <param name="amount"><dd>  <p>The blue value for the color of the shadow.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetBlue']/*"/>	
        /// <msdn-id>dn919769</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetBlue([In] float amount)</unmanaged>	
        /// <unmanaged-short>IDCompositionShadowEffect::SetBlue</unmanaged-short>	
        internal void SetBlue(float amount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, amount,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the alpha value for the effect.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The alpha value for the effect.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetAlpha']/*"/>	
        /// <msdn-id>dn919767</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetAlpha([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionShadowEffect::SetAlpha</unmanaged-short>	
        public void SetAlpha(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the alpha value for the effect.</p>	
        /// </summary>	
        /// <param name="amount"><dd>  <p>The alpha value for the effect.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionShadowEffect::SetAlpha']/*"/>	
        /// <msdn-id>dn919767</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionShadowEffect::SetAlpha([In] float amount)</unmanaged>	
        /// <unmanaged-short>IDCompositionShadowEffect::SetAlpha</unmanaged-short>	
        internal void SetAlpha(float amount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, amount,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a 2D transformation that affects the skew of a visual along the x-axis and y-axis. The coordinate system is skewed around the specified center point. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A skew transform represents the following 3-by-3 matrix: </p><p></p><p>The effect is to slant the coordinate system along the x-axis and y-axis such that a rectangle becomes a parallelogram, and to apply the corresponding translation such that the center point does not move.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSkewTransform']/*"/>	
    /// <msdn-id>hh449057</msdn-id>	
    /// <unmanaged>IDCompositionSkewTransform</unmanaged>	
    /// <unmanaged-short>IDCompositionSkewTransform</unmanaged-short>	
    [Guid("E57AA735-DCDB-4c72-9C61-0591F58889EE")]
    public partial class SkewTransform : SharpDX.DirectComposition.Transform {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.SkewTransform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SkewTransform(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.SkewTransform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.SkewTransform(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.SkewTransform(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Animates the value of the AngleX property of a 2D skew transform. The AngleX property specifies the skew angle along the x-axis.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation object that represents how the value of the AngleX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the AngleX property unless this method is called again. If the AngleX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSkewTransform::SetAngleX']/*"/>	
        /// <msdn-id>hh449061</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetAngleX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionSkewTransform::SetAngleX</unmanaged-short>	
        public void SetAngleX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the AngleX property of a 2D skew transform. The AngleX property specifies the skew angle along the x-axis.</p>	
        /// </summary>	
        /// <param name="angleX"><dd>  <p>An animation object that represents how the value of the AngleX property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the AngleX property unless this method is called again. If the AngleX property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSkewTransform::SetAngleX']/*"/>	
        /// <msdn-id>hh449061</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetAngleX([In] float angleX)</unmanaged>	
        /// <unmanaged-short>IDCompositionSkewTransform::SetAngleX</unmanaged-short>	
        public void SetAngleX(float angleX) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, angleX,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the AngleY property of a 2D skew transform. The AngleY property specifies the skew angle along the y-axis.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>An animation object that represents how the value of the AngleY property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the AngleY property unless this method is called again. If the AngleY property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSkewTransform::SetAngleY']/*"/>	
        /// <msdn-id>hh449067</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetAngleY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionSkewTransform::SetAngleY</unmanaged-short>	
        public void SetAngleY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the value of the AngleY property of a 2D skew transform. The AngleY property specifies the skew angle along the y-axis.</p>	
        /// </summary>	
        /// <param name="angleY"><dd>  <p>An animation object that represents how the value of the AngleY property changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the AngleY property unless this method is called again. If the AngleY property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSkewTransform::SetAngleY']/*"/>	
        /// <msdn-id>hh449067</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetAngleY([In] float angleY)</unmanaged>	
        /// <unmanaged-short>IDCompositionSkewTransform::SetAngleY</unmanaged-short>	
        public void SetAngleY(float angleY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, angleY,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterX property of a 2D skew transform. The CenterX property specifies the x-coordinate of the point about which the skew is performed.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new x-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterX property was previously animated, this method removes the animation and sets the CenterX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSkewTransform::SetCenterX']/*"/>	
        /// <msdn-id>hh449071</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetCenterX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionSkewTransform::SetCenterX</unmanaged-short>	
        public void SetCenterX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterX property of a 2D skew transform. The CenterX property specifies the x-coordinate of the point about which the skew is performed.</p>	
        /// </summary>	
        /// <param name="centerX"><dd>  <p>The new x-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterX property was previously animated, this method removes the animation and sets the CenterX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSkewTransform::SetCenterX']/*"/>	
        /// <msdn-id>hh449071</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetCenterX([In] float centerX)</unmanaged>	
        /// <unmanaged-short>IDCompositionSkewTransform::SetCenterX</unmanaged-short>	
        public void SetCenterX(float centerX) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, centerX,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterY property of a 2D skew transform. The CenterY property specifies the y-coordinate of the point about which the skew is performed.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new y-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterY property was previously animated, this method removes the animation and sets the CenterY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSkewTransform::SetCenterY']/*"/>	
        /// <msdn-id>hh449077</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetCenterY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionSkewTransform::SetCenterY</unmanaged-short>	
        public void SetCenterY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the CenterY property of a 2D skew transform. The CenterY property specifies the y-coordinate of the point about which the skew is performed.</p>	
        /// </summary>	
        /// <param name="centerY"><dd>  <p>The new y-coordinate of the center point.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>centerY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the CenterY property was previously animated, this method removes the animation and sets the CenterY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSkewTransform::SetCenterY']/*"/>	
        /// <msdn-id>hh449077</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSkewTransform::SetCenterY([In] float centerY)</unmanaged>	
        /// <unmanaged-short>IDCompositionSkewTransform::SetCenterY</unmanaged-short>	
        public void SetCenterY(float centerY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, centerY,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a physical bitmap that can be associated with a visual for composition in a visual tree.  This interface can also be used to update the bitmap contents. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSurface']/*"/>	
    /// <msdn-id>hh449083</msdn-id>	
    /// <unmanaged>IDCompositionSurface</unmanaged>	
    /// <unmanaged-short>IDCompositionSurface</unmanaged-short>	
    [Guid("BB8A4953-2C99-4F5A-96F5-4819027FA3AC")]
    public partial class Surface : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.Surface"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Surface(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.Surface"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.Surface(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.Surface(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Initiates drawing on this Microsoft DirectComposition surface object. The update rectangle must be within the boundaries of the surface; otherwise, this method fails. </p>	
        /// </summary>	
        /// <param name="updateRect"><dd>  <p>The rectangle to be updated. If this parameter is <c>null</c>, the entire bitmap is updated.</p> </dd></param>	
        /// <param name="iid"><dd>  <p>The identifier of the interface to retrieve.</p> </dd></param>	
        /// <param name="updateObject"><dd>  <p>Receives an interface reference of the type specified in the <em>iid</em> parameter.   This parameter must not be <c>null</c>.</p> <p><strong>Note</strong>??In Windows?8, this parameter was <em>surface</em>.</p> </dd></param>	
        /// <param name="updateOffset"><dd>  <p>The offset into the surface where the application should draw updated content. This offset will reference the upper left corner of the update rectangle.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p>This method enables an application to incrementally update the contents of a DirectComposition surface object. The application must use the following sequence: </p><ol> <li>Call <strong>BeginDraw</strong> to initiate the incremental update.</li> <li>Use the retrieved surface as a render target and draw the updated contents at the retrieved offset.</li> <li>Call the <strong><see cref="SharpDX.DirectComposition.Surface.EndDraw"/></strong> method to finish the update.</li> </ol><p>The update object returned by this method is either a Direct2D device context or a DXGI surface, depending on the value of the <em>iid</em> parameter and on how the DirectComposition surface object was created. If the <em>iid</em> parameter is __uuidof(<see cref="SharpDX.Direct2D1.DeviceContext"/>), then the returned object is a Direct2D device context that already has the DirectComposition surface selected as a render target. Otherwise, it is a DXGI surface which the application may use as a render target. In either case, the returned object is associated with the Direct2D or DXGI device passed by the application to the <see cref="SharpDX.DirectComposition.DComp.CreateDevice2"/> function or the <strong><see cref="SharpDX.DirectComposition.Device2.CreateSurfaceFactory"/></strong> method. </p><p>The <em>iid</em> parameter may only be __uuidof(<see cref="SharpDX.Direct2D1.DeviceContext"/>) if the DirectComposition surface object was created from a DirectComposition device or surface factory that was, itself, created with an associated Direct2D device. In particular, the application must have called either the <see cref="SharpDX.DirectComposition.DComp.CreateDevice2"/> function or the <strong><see cref="SharpDX.DirectComposition.Device2.CreateSurfaceFactory"/></strong> method with a Direct2D device as the <em>renderingDevice</em> parameter. If the DirectComposition surface was created via a surface factory that was not associated with a Direct2D device, or if it was created directly via the <see cref="SharpDX.DirectComposition.Device2"/> interface and the device was not directly associated with a Direct2D device, then passing __uuidof(<see cref="SharpDX.Direct2D1.DeviceContext"/>) as the iid parameter causes this method to return E_INVALIDARG. </p><p>If the application successfully retrieves a Direct2D device context as the update object, then the application should not call either the ID2D1DeviceContext::BeginDraw or ID2D1DeviceContext::EndDraw methods on the returned Direct2D device context.	
        /// </p><p>The retrieved offset is not necessarily the same as the top-left corner of the requested update rectangle. The application must transform its rendering primitives to draw within a rectangle of the same width and height as the input rectangle, but at the given offset. The application should not draw outside of this rectangle. </p><p>If the <em>updateRectangle</em> parameter is <c>null</c>, the entire surface is updated. In that case, because the retrieved offset still might not be (0,0), the application still needs to transform its rendering primitives accordingly. </p><p>If the surface is not a virtual surface, then the first time the application calls this method for a particular non-virtual surface, the update rectangle must cover the entire surface, either by specifying the full surface in the requested update rectangle, or by specifying <c>null</c> as the <em>updateRectangle</em> parameter. For virtual surfaces, the first call may be any sub-rectangle of the surface. </p><p>Because each call to this method might retrieve a different object in the <em>updateObject</em> surface, the application should not cache the retrieved surface reference. The application should release the retrieved reference as soon as it finishes drawing. </p><p>The retrieved surface rectangle does not contain the previous contents of the bitmap. The application must update every pixel in the update rectangle, either by first clearing the render target, or by issuing enough rendering primitives to fully cover the update rectangle. Because the initial contents of the update surface are undefined, failing to update every pixel leads to undefined behavior. </p><p>Only one DirectComposition surface can be updated at a time. An application must suspend drawing on one surface before beginning or resuming to draw on another surface. If the application calls <strong>BeginDraw</strong> twice, either for the same surface or for another surface belonging to the same DirectComposition device, without an intervening call to <strong><see cref="SharpDX.DirectComposition.Surface.EndDraw"/></strong>, the second call fails. If the application calls <strong><see cref="SharpDX.DirectComposition.Device2.Commit"/></strong> without calling <strong>EndDraw</strong>, the update remains pending. The update takes effect only after the application calls <strong>EndDraw</strong> and then  calls the <strong><see cref="SharpDX.DirectComposition.Device2.Commit"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSurface::BeginDraw']/*"/>	
        /// <msdn-id>hh449100</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSurface::BeginDraw([In, Optional] const RECT* updateRect,[In] const GUID&amp; iid,[Out] void** updateObject,[Out] POINT* updateOffset)</unmanaged>	
        /// <unmanaged-short>IDCompositionSurface::BeginDraw</unmanaged-short>	
        public void BeginDraw(SharpDX.Mathematics.Interop.RawRectangle? updateRect, System.Guid iid, out System.IntPtr updateObject, out SharpDX.Mathematics.Interop.RawPoint updateOffset) {
            unsafe {
                SharpDX.Mathematics.Interop.RawRectangle updateRect_;
                if (updateRect.HasValue)
                    updateRect_ = updateRect.Value;				
                updateOffset = new SharpDX.Mathematics.Interop.RawPoint();
                SharpDX.Result __result__;
                fixed (void* updateObject_ = &updateObject)
                    fixed (void* updateOffset_ = &updateOffset)
                        __result__= 
        				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (updateRect.HasValue)?&updateRect_:(void*)IntPtr.Zero, &iid, updateObject_, updateOffset_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Marks the end of drawing on this Microsoft DirectComposition surface object.</p>	
        /// </summary>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code, which can include <see cref="SharpDX.DirectComposition.ResultCode.SurfaceNotBeingRendered"/>. </p></returns>	
        /// <remarks>	
        /// <p>This method completes an update that was begun by a previous call to the <strong><see cref="SharpDX.DirectComposition.Surface.BeginDraw"/></strong> method. After this method returns, the application can start another update on the same surface object or on a different one. </p><p>If the application calls <strong><see cref="SharpDX.DirectComposition.Device2.Commit"/></strong> before calling <strong><see cref="SharpDX.DirectComposition.Surface.EndDraw"/></strong> for a surface with a pending update, that update is not processed by that Commit call. The update only takes effect on screen after the application calls <strong><see cref="SharpDX.DirectComposition.Surface.EndDraw"/></strong> followed by the <see cref="SharpDX.DirectComposition.Device2.Commit"/> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSurface::EndDraw']/*"/>	
        /// <msdn-id>hh449102</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSurface::EndDraw()</unmanaged>	
        /// <unmanaged-short>IDCompositionSurface::EndDraw</unmanaged-short>	
        public void EndDraw() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Suspends the drawing on this Microsoft DirectComposition surface object.</p>	
        /// </summary>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code, which can include <see cref="SharpDX.DirectComposition.ResultCode.SurfaceBeingRendered"/> and <see cref="SharpDX.DirectComposition.ResultCode.SurfaceNotBeingRendered"/>. </p></returns>	
        /// <remarks>	
        /// <p>Because only one surface can be open for drawing at a time, calling <strong>SuspendDraw</strong> allows the user to call <strong><see cref="SharpDX.DirectComposition.Surface.BeginDraw"/></strong> on a different surface. Drawing to this surface can be resumed by calling <strong><see cref="SharpDX.DirectComposition.Surface.ResumeDraw"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSurface::SuspendDraw']/*"/>	
        /// <msdn-id>hh449106</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSurface::SuspendDraw()</unmanaged>	
        /// <unmanaged-short>IDCompositionSurface::SuspendDraw</unmanaged-short>	
        public void SuspendDraw() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Resumes drawing on this Microsoft DirectComposition surface object.</p>	
        /// </summary>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code, which can include <see cref="SharpDX.DirectComposition.ResultCode.SurfaceBeingRendered"/> and <see cref="SharpDX.DirectComposition.ResultCode.SurfaceNotBeingRendered"/>. </p></returns>	
        /// <remarks>	
        /// <p> This method allows the surface update to continue unless there are other surfaces that have active, unsuspended draws.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSurface::ResumeDraw']/*"/>	
        /// <msdn-id>hh449104</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSurface::ResumeDraw()</unmanaged>	
        /// <unmanaged-short>IDCompositionSurface::ResumeDraw</unmanaged-short>	
        public void ResumeDraw() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Scrolls a rectangular area of a Microsoft DirectComposition logical surface.</p>	
        /// </summary>	
        /// <param name="scrollRect"><dd> <p>The rectangular area of the surface to be scrolled, relative to the upper-left corner of the surface. If this parameter is <c>null</c>, the entire surface is scrolled.</p> </dd></param>	
        /// <param name="clipRect"><dd> <p>The <em>clipRect</em> clips the destination (<em>scrollRect</em> after offset) of the scroll.The only bitmap content that will be scrolled are those that remain inside the clip rectangle after the scroll is completed.</p> </dd></param>	
        /// <param name="offsetX"><dd> <p>The amount of horizontal scrolling, in pixels. Use positive values to scroll right, and negative values to scroll left.</p> </dd></param>	
        /// <param name="offsetY"><dd> <p>The amount of vertical scrolling, in pixels. Use positive values to scroll down, and negative values to scroll up.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method allows an application to blt/copy a sub-rectangle of a DirectComposition surface object. This avoids re-rendering content that is already available.   </p><p>The <em>scrollRect</em> rectangle must be contained in the boundaries of the surface.  If the <em>scrollRect</em> rectangle goes outside the bounds of the surface, this method fails. </p><p>The bits copied by the scroll operation (source) are defined by the intersection of the <em>scrollRect</em> and <em>clipRect</em> rectangles.  </p><p>The bits shown on the screen (destination) are defined by the intersection of the offset source rectangle and <em>clipRect</em>. </p><p>Scroll operations can only be called before calling <strong>BeginDraw</strong> or after calling <strong>EndDraw</strong>.  Suspended or resumed surfaces are not candidates for scrolling because they are still being updated. </p><p>The application is responsible for ensuring that the scrollable area for an <strong><see cref="SharpDX.DirectComposition.VirtualSurface"/></strong> is limited to valid pixels. The behavior for invalid pixels in the <em>scrollRect</em> is undefined.  </p><p>Virtual surface sub-rectangular areas that were discarded by a trim or a resize operation can't be scrolled even if the trim or resize is applied in the same batch.  <strong>Trim</strong> and <strong>Resize</strong> are applied immediately. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSurface::Scroll']/*"/>	
        /// <msdn-id>Hh707486</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSurface::Scroll([In, Optional] const RECT* scrollRect,[In, Optional] const RECT* clipRect,[In] int offsetX,[In] int offsetY)</unmanaged>	
        /// <unmanaged-short>IDCompositionSurface::Scroll</unmanaged-short>	
        public void Scroll(SharpDX.Mathematics.Interop.RawRectangle? scrollRect, SharpDX.Mathematics.Interop.RawRectangle? clipRect, int offsetX, int offsetY) {
            unsafe {
                SharpDX.Mathematics.Interop.RawRectangle scrollRect_;
                if (scrollRect.HasValue)
                    scrollRect_ = scrollRect.Value;				
                SharpDX.Mathematics.Interop.RawRectangle clipRect_;
                if (clipRect.HasValue)
                    clipRect_ = clipRect.Value;				
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (scrollRect.HasValue)?&scrollRect_:(void*)IntPtr.Zero, (clipRect.HasValue)?&clipRect_:(void*)IntPtr.Zero, offsetX, offsetY,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Creates surface and virtual surface objects associated with an application-provided rendering device.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSurfaceFactory']/*"/>	
    /// <msdn-id>dn280423</msdn-id>	
    /// <unmanaged>IDCompositionSurfaceFactory</unmanaged>	
    /// <unmanaged-short>IDCompositionSurfaceFactory</unmanaged-short>	
    [Guid("E334BC12-3937-4E02-85EB-FCF4EB30D2C8")]
    public partial class SurfaceFactory : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.SurfaceFactory"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SurfaceFactory(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.SurfaceFactory"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.SurfaceFactory(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.SurfaceFactory(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Creates a surface object that can be associated with one or more visuals for composition.</p>	
        /// </summary>	
        /// <param name="width"><dd> <p>The width of the surface, in pixels.</p> </dd></param>	
        /// <param name="height"><dd> <p>The height of the surface, in pixels.</p> </dd></param>	
        /// <param name="pixelFormat"><dd> <p>The pixel format of the surface.</p> </dd></param>	
        /// <param name="alphaMode"><dd> <p>The format of the alpha channel, if an alpha channel is included in the pixel format. This can be one of <see cref="SharpDX.DXGI.AlphaMode.Premultiplied"/> or <see cref="SharpDX.DXGI.AlphaMode.Ignore"/>. It can also be <see cref="SharpDX.DXGI.AlphaMode.Unspecified"/>, which is interpreted as <see cref="SharpDX.DXGI.AlphaMode.Ignore"/>.</p> </dd></param>	
        /// <param name="surface"><dd> <p> The newly created surface object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A Microsoft DirectComposition surface is a rectangular array of pixels that can be associated with a visual for composition.  A newly created surface object is in an uninitialized state. While it is uninitialized, the surface has no effect on the composition of the visual tree. It behaves exactly like a surface that has 100% transparent pixels.  </p><p>To initialize the surface with pixel data, use the <strong><see cref="SharpDX.DirectComposition.Surface.BeginDraw"/></strong> method. The first call to this method must cover the entire surface area to provide an initial value for every pixel. Subsequent calls may specify smaller sub-rectangles of the surface to update. </p><p>This method will fail if either the width or height exceed the max texture size. If your scenario requires dimensions beyond the max texture size, use <strong>CreateVirtualSurface</strong> method.</p><p>DirectComposition surfaces support the following pixel formats:	
        /// </p><ul> <li><see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm"/>	
        /// </li> <li><see cref="SharpDX.DXGI.Format.R8G8B8A8_UNorm"/> </li> <li><see cref="SharpDX.DXGI.Format.R16G16B16A16_Float"/></li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSurfaceFactory::CreateSurface']/*"/>	
        /// <msdn-id>dn280424</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSurfaceFactory::CreateSurface([In] unsigned int width,[In] unsigned int height,[In] DXGI_FORMAT pixelFormat,[In] DXGI_ALPHA_MODE alphaMode,[Out, Fast] IDCompositionSurface** surface)</unmanaged>	
        /// <unmanaged-short>IDCompositionSurfaceFactory::CreateSurface</unmanaged-short>	
        internal void CreateSurface(int width, int height, SharpDX.DXGI.Format pixelFormat, SharpDX.DXGI.AlphaMode alphaMode, SharpDX.DirectComposition.Surface surface) {
            unsafe {
                IntPtr surface_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, width, height, unchecked((int)pixelFormat), unchecked((int)alphaMode), &surface_,((void**)(*(void**)_nativePointer))[3]);		
                ((SharpDX.DirectComposition.Surface)surface).NativePointer = surface_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a sparsely populated surface that can be associated with one or more visuals for composition.</p>	
        /// </summary>	
        /// <param name="initialWidth"><dd> <p>The width of the surface, in pixels. The maximum width is 16,777,216 pixels.</p> </dd></param>	
        /// <param name="initialHeight"><dd> <p>The height of the surface, in pixels.The maximum height is 16,777,216 pixels.</p> </dd></param>	
        /// <param name="pixelFormat"><dd> <p>The pixel format of the surface.</p> </dd></param>	
        /// <param name="alphaMode"><dd> <p>The format of the alpha channel, if an alpha channel is included in the pixel format. This can be one of <see cref="SharpDX.DXGI.AlphaMode.Premultiplied"/> or <see cref="SharpDX.DXGI.AlphaMode.Ignore"/>. It can also be <see cref="SharpDX.DXGI.AlphaMode.Unspecified"/>, which is interpreted as <see cref="SharpDX.DXGI.AlphaMode.Ignore"/>.</p> </dd></param>	
        /// <param name="virtualSurface"><dd> <p> The newly created virtual surface object. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A newly created virtual surface object is in an uninitialized state. While it is uninitialized, the surface has no effect on the composition of the visual tree. It behaves exactly like a surface that is initialized with 100% transparent pixels.  </p><p>To initialize the surface with pixel data, use the <strong><see cref="SharpDX.DirectComposition.Surface.BeginDraw"/></strong> method. This method not only provides pixels for the surface, but it also allocates actual storage space for those pixels. The memory allocation persists until the application returns some of the memory to the system. The application can free part or all of the allocated memory by calling the <strong><see cref="SharpDX.DirectComposition.VirtualSurface.Trim"/></strong> or <strong><see cref="SharpDX.DirectComposition.VirtualSurface.Resize"/></strong> method.</p><p>Microsoft DirectComposition surfaces support the following pixel formats:	
        /// </p><ul> <li><see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm"/>	
        /// </li> <li><see cref="SharpDX.DXGI.Format.R8G8B8A8_UNorm"/> </li> <li><see cref="SharpDX.DXGI.Format.R16G16B16A16_Float"/></li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionSurfaceFactory::CreateVirtualSurface']/*"/>	
        /// <msdn-id>dn280425</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionSurfaceFactory::CreateVirtualSurface([In] unsigned int initialWidth,[In] unsigned int initialHeight,[In] DXGI_FORMAT pixelFormat,[In] DXGI_ALPHA_MODE alphaMode,[Out, Fast] IDCompositionVirtualSurface** virtualSurface)</unmanaged>	
        /// <unmanaged-short>IDCompositionSurfaceFactory::CreateVirtualSurface</unmanaged-short>	
        internal void CreateVirtualSurface(int initialWidth, int initialHeight, SharpDX.DXGI.Format pixelFormat, SharpDX.DXGI.AlphaMode alphaMode, SharpDX.DirectComposition.VirtualSurface virtualSurface) {
            unsafe {
                IntPtr virtualSurface_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, initialWidth, initialHeight, unchecked((int)pixelFormat), unchecked((int)alphaMode), &virtualSurface_,((void**)(*(void**)_nativePointer))[4]);		
                ((SharpDX.DirectComposition.VirtualSurface)virtualSurface).NativePointer = virtualSurface_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The table transfer effect is used to map the color intensities of an image using a transfer function created from interpolating a list of values you provide.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect']/*"/>	
    /// <msdn-id>dn919783</msdn-id>	
    /// <unmanaged>IDCompositionTableTransferEffect</unmanaged>	
    /// <unmanaged-short>IDCompositionTableTransferEffect</unmanaged-short>	
    [Guid("9B7E82E2-69C5-4EB4-A5F5-A7033F5132CD")]
    public partial class TableTransferEffect : SharpDX.DirectComposition.FilterEffect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.TableTransferEffect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TableTransferEffect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.TableTransferEffect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.TableTransferEffect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.TableTransferEffect(nativePointer);
		}
        
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetRedDisable']/*"/>	
        /// <unmanaged>SetRedDisable</unmanaged>	
        /// <unmanaged-short>SetRedDisable</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetRedDisable([In] BOOL redDisable)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool RedDisable {
                set { SetRedDisable(value); }
        }
        
        /// <summary>	
        /// <p>Specifies whether to apply the transfer function to the green channel.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetGreenDisable']/*"/>	
        /// <msdn-id>dn919793</msdn-id>	
        /// <unmanaged>SetGreenDisable</unmanaged>	
        /// <unmanaged-short>SetGreenDisable</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetGreenDisable([In] BOOL greenDisable)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool GreenDisable {
                set { SetGreenDisable(value); }
        }
        
        /// <summary>	
        /// <p>Specifies whether to apply the transfer function to the blue channel.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetBlueDisable']/*"/>	
        /// <msdn-id>dn919788</msdn-id>	
        /// <unmanaged>SetBlueDisable</unmanaged>	
        /// <unmanaged-short>SetBlueDisable</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetBlueDisable([In] BOOL blueDisable)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool BlueDisable {
                set { SetBlueDisable(value); }
        }
        
        /// <summary>	
        /// <p>Specifies whether to apply the transfer function to the Alpha channel.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetAlphaDisable']/*"/>	
        /// <msdn-id>dn919784</msdn-id>	
        /// <unmanaged>SetAlphaDisable</unmanaged>	
        /// <unmanaged-short>SetAlphaDisable</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetAlphaDisable([In] BOOL alphaDisable)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool AlphaDisable {
                set { SetAlphaDisable(value); }
        }
        
        /// <summary>	
        /// <p>Specifies whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetClampOutput']/*"/>	
        /// <msdn-id>dn919792</msdn-id>	
        /// <unmanaged>SetClampOutput</unmanaged>	
        /// <unmanaged-short>SetClampOutput</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetClampOutput([In] BOOL clampOutput)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool ClampOutput {
                set { SetClampOutput(value); }
        }
        
        /// <summary>	
        /// <p>Sets the list of values used to define the transfer function for the red channel.</p>	
        /// </summary>	
        /// <param name="tableValues"><dd>  <p>The list of values used to define the transfer function for the red channel.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of values in the tableValues parameter.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetRedTable']/*"/>	
        /// <msdn-id>dn919798</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetRedTable([In, Buffer] const float* tableValues,[In] unsigned int count)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetRedTable</unmanaged-short>	
        public void SetRedTable(float[] tableValues, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* tableValues_ = tableValues)
                    __result__= 
    				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, tableValues_, count,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the list of values used to define the transfer function for the green channel.</p>	
        /// </summary>	
        /// <param name="tableValues"><dd>  <p>The list of values used to define the transfer function for the green channel.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of values in the tableValues parameter.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetGreenTable']/*"/>	
        /// <msdn-id>dn919794</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetGreenTable([In, Buffer] const float* tableValues,[In] unsigned int count)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetGreenTable</unmanaged-short>	
        public void SetGreenTable(float[] tableValues, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* tableValues_ = tableValues)
                    __result__= 
    				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, tableValues_, count,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the list of values used to define the transfer function for the blue channel.</p>	
        /// </summary>	
        /// <param name="tableValues"><dd>  <p>The list of values used to define the transfer function for the blue channel.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of values in the tableValues parameter.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetBlueTable']/*"/>	
        /// <msdn-id>dn919789</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetBlueTable([In, Buffer] const float* tableValues,[In] unsigned int count)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetBlueTable</unmanaged-short>	
        public void SetBlueTable(float[] tableValues, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* tableValues_ = tableValues)
                    __result__= 
    				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, tableValues_, count,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the list of values used to define the transfer function for the alpha channel.</p>	
        /// </summary>	
        /// <param name="tableValues"><dd>  <p>The list of values used to define the transfer function for the alpha channel.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of values in the tableValues parameter.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetAlphaTable']/*"/>	
        /// <msdn-id>dn919785</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetAlphaTable([In, Buffer] const float* tableValues,[In] unsigned int count)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetAlphaTable</unmanaged-short>	
        public void SetAlphaTable(float[] tableValues, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* tableValues_ = tableValues)
                    __result__= 
    				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, tableValues_, count,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="redDisable">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetRedDisable']/*"/>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetRedDisable([In] BOOL redDisable)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetRedDisable</unmanaged-short>	
        internal void SetRedDisable(SharpDX.Mathematics.Interop.RawBool redDisable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint9(_nativePointer, redDisable,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies whether to apply the transfer function to the green channel.</p>	
        /// </summary>	
        /// <param name="greenDisable"><dd>  <p> A boolean value that specifies whether to apply the transfer function to the green channel. If you set this to TRUE the effect does not apply the transfer function to the green channel. If you set this to <see cref="SharpDX.Result.False"/> it applies the GreenTableTransfer function to the green channel. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetGreenDisable']/*"/>	
        /// <msdn-id>dn919793</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetGreenDisable([In] BOOL greenDisable)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetGreenDisable</unmanaged-short>	
        internal void SetGreenDisable(SharpDX.Mathematics.Interop.RawBool greenDisable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint9(_nativePointer, greenDisable,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies whether to apply the transfer function to the blue channel.</p>	
        /// </summary>	
        /// <param name="blueDisable"><dd>  <p> A boolean value that specifies whether to apply the transfer function to the blue channel. If you set this to TRUE the effect does not apply the transfer function to the blue channel. If you set this to <see cref="SharpDX.Result.False"/> it applies the BlueTableTransfer function to the Blue channel. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetBlueDisable']/*"/>	
        /// <msdn-id>dn919788</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetBlueDisable([In] BOOL blueDisable)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetBlueDisable</unmanaged-short>	
        internal void SetBlueDisable(SharpDX.Mathematics.Interop.RawBool blueDisable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint9(_nativePointer, blueDisable,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies whether to apply the transfer function to the Alpha channel.</p>	
        /// </summary>	
        /// <param name="alphaDisable"><dd>  <p> A boolean value that specifies whether to apply the transfer function to the alpha channel. If you set this to TRUE the effect does not apply the transfer function to the Alpha channel. If you set this to <see cref="SharpDX.Result.False"/> it applies the AlphaTableTransfer function to the Alpha channel. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetAlphaDisable']/*"/>	
        /// <msdn-id>dn919784</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetAlphaDisable([In] BOOL alphaDisable)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetAlphaDisable</unmanaged-short>	
        internal void SetAlphaDisable(SharpDX.Mathematics.Interop.RawBool alphaDisable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint9(_nativePointer, alphaDisable,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph.</p>	
        /// </summary>	
        /// <param name="clampOutput"><dd>  <p> A boolean value that specifies whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph. If you set this to TRUE the effect will clamp the values. If you set this to <see cref="SharpDX.Result.False"/>, the effect will not clamp the color values, but other effects and the output surface may clamp the values if they are not of high enough precision. The effect clamps the values before it premultiplies the alpha. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetClampOutput']/*"/>	
        /// <msdn-id>dn919792</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetClampOutput([In] BOOL clampOutput)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetClampOutput</unmanaged-short>	
        internal void SetClampOutput(SharpDX.Mathematics.Interop.RawBool clampOutput) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint9(_nativePointer, clampOutput,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a value in the red table.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the value to set.</p> </dd></param>	
        /// <param name="animation"><dd>  <p>The new value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetRedTableValue']/*"/>	
        /// <msdn-id>dn919799</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetRedTableValue([In] unsigned int index,[In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetRedTableValue</unmanaged-short>	
        public void SetRedTableValue(int index, SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, index, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a value in the red table.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the value to set.</p> </dd></param>	
        /// <param name="value"><dd>  <p>The new value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetRedTableValue']/*"/>	
        /// <msdn-id>dn919799</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetRedTableValue([In] unsigned int index,[In] float value)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetRedTableValue</unmanaged-short>	
        public void SetRedTableValue(int index, float value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, index, value,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a value in the green table.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the value to set.</p> </dd></param>	
        /// <param name="animation"><dd>  <p>The value to set.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetGreenTableValue']/*"/>	
        /// <msdn-id>dn919795</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetGreenTableValue([In] unsigned int index,[In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetGreenTableValue</unmanaged-short>	
        public void SetGreenTableValue(int index, SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, index, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a value in the green table.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the value to set.</p> </dd></param>	
        /// <param name="value"><dd>  <p>The value to set.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetGreenTableValue']/*"/>	
        /// <msdn-id>dn919795</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetGreenTableValue([In] unsigned int index,[In] float value)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetGreenTableValue</unmanaged-short>	
        public void SetGreenTableValue(int index, float value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, index, value,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a value in the blue table.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the value to set.</p> </dd></param>	
        /// <param name="animation"><dd>  <p>The new value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetBlueTableValue']/*"/>	
        /// <msdn-id>dn919790</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetBlueTableValue([In] unsigned int index,[In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetBlueTableValue</unmanaged-short>	
        public void SetBlueTableValue(int index, SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, index, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a value in the blue table.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the value to set.</p> </dd></param>	
        /// <param name="value"><dd>  <p>The new value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetBlueTableValue']/*"/>	
        /// <msdn-id>dn919790</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetBlueTableValue([In] unsigned int index,[In] float value)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetBlueTableValue</unmanaged-short>	
        public void SetBlueTableValue(int index, float value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, index, value,((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a value in the alpha table.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Index of the value to change.</p> </dd></param>	
        /// <param name="animation"><dd>  <p>An animation that represents how the value in the alpha table changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetAlphaTableValue']/*"/>	
        /// <msdn-id>dn919787</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetAlphaTableValue([In] unsigned int index,[In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetAlphaTableValue</unmanaged-short>	
        public void SetAlphaTableValue(int index, SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, index, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a value in the alpha table.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Index of the value to change.</p> </dd></param>	
        /// <param name="value"><dd>  <p>An animation that represents how the value in the alpha table changes over time. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTableTransferEffect::SetAlphaTableValue']/*"/>	
        /// <msdn-id>dn919787</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTableTransferEffect::SetAlphaTableValue([In] unsigned int index,[In] float value)</unmanaged>	
        /// <unmanaged-short>IDCompositionTableTransferEffect::SetAlphaTableValue</unmanaged-short>	
        public void SetAlphaTableValue(int index, float value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, index, value,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a binding between a Microsoft DirectComposition visual tree and a destination on top of which the visual tree should be composed. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTarget']/*"/>	
    /// <msdn-id>hh449108</msdn-id>	
    /// <unmanaged>IDCompositionTarget</unmanaged>	
    /// <unmanaged-short>IDCompositionTarget</unmanaged-short>	
    [Guid("eacdd04c-117e-4e17-88f4-d1b12b0e3d89")]
    public partial class Target : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.Target"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Target(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.Target"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.Target(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.Target(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets a visual object as the new root object of a visual tree.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>A visual can be either the root of a single visual tree, or a child of another visual, but it cannot be both at the same time. This method fails if the <em>visual</em> parameter is already the root of another visual tree, or is a child of another visual.</p><p>If <em>visual</em> is <c>null</c>, the visual tree is empty. If there was a previous non-<c>null</c> root visual, that visual becomes available for use as the root of another visual tree, or as a child of another visual.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTarget::SetRoot']/*"/>	
        /// <msdn-id>hh449109</msdn-id>	
        /// <unmanaged>SetRoot</unmanaged>	
        /// <unmanaged-short>SetRoot</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionTarget::SetRoot([In, Optional] IDCompositionVisual* visual)</unmanaged>
        public SharpDX.DirectComposition.Visual Root {
                set { SetRoot(value); }
        }
        
        /// <summary>	
        /// <p>Sets a visual object as the new root object of a visual tree.</p>	
        /// </summary>	
        /// <param name="visual"><dd>  <p>The visual object that is the new root of this visual tree. This parameter can be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A visual can be either the root of a single visual tree, or a child of another visual, but it cannot be both at the same time. This method fails if the <em>visual</em> parameter is already the root of another visual tree, or is a child of another visual.</p><p>If <em>visual</em> is <c>null</c>, the visual tree is empty. If there was a previous non-<c>null</c> root visual, that visual becomes available for use as the root of another visual tree, or as a child of another visual.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTarget::SetRoot']/*"/>	
        /// <msdn-id>hh449109</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTarget::SetRoot([In, Optional] IDCompositionVisual* visual)</unmanaged>	
        /// <unmanaged-short>IDCompositionTarget::SetRoot</unmanaged-short>	
        internal void SetRoot(SharpDX.DirectComposition.Visual visual) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((visual == null)?IntPtr.Zero:visual.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a 2D transformation that can be used to modify the coordinate space of a visual subtree. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.DirectComposition.Transform"/></strong> interface is an abstract interface that represents a 2D affine transformation. Transformations affect the entire visual subtree that is rooted at the visual that the transform is associated with. A transform object can be associated with multiple visuals. When a transform object is modified, all affected visuals are recomposed to reflect the change.</p><p>Transforms operate by modifying the coordinate system for all rendering operations on a visual. For example, ordinarily a bitmap that is associated with a visual draws at position (0,0) and extends the full width and height of the bitmap. If a translation transform is applied, the bitmap draws at a position that is offset by that transform. If a scale transform is applied, the extent covered by the bitmap is affected by the scale transform. More than one transform can be simultaneously applied to a visual by using the <strong><see cref="SharpDX.DirectComposition.Device.CreateTransformGroup"/></strong> interface.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTransform']/*"/>	
    /// <msdn-id>hh449110</msdn-id>	
    /// <unmanaged>IDCompositionTransform</unmanaged>	
    /// <unmanaged-short>IDCompositionTransform</unmanaged-short>	
    [Guid("FD55FAA7-37E0-4c20-95D2-9BE45BC33F55")]
    public partial class Transform : SharpDX.DirectComposition.Transform3D {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.Transform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Transform(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.Transform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.Transform(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.Transform(nativePointer);
		}
        
    }
    /// <summary>	
    /// <p>Represents a 3D transformation effect that can be used to modify the rasterization of a visual subtree. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.DirectComposition.Transform3D"/></strong> interface is an abstract interface that represents a 3D perspective transformation effect. A 3D transform object can be associated with multiple visuals and multiple effect groups. When a 3D transform object is modified, all affected visuals are recomposed to reflect the change.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTransform3D']/*"/>	
    /// <msdn-id>hh449112</msdn-id>	
    /// <unmanaged>IDCompositionTransform3D</unmanaged>	
    /// <unmanaged-short>IDCompositionTransform3D</unmanaged-short>	
    [Guid("71185722-246B-41f2-AAD1-0443F7F4BFC2")]
    public partial class Transform3D : SharpDX.DirectComposition.Effect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.Transform3D"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Transform3D(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.Transform3D"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.Transform3D(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.Transform3D(nativePointer);
		}
        
    }
    /// <summary>	
    /// <p>Represents a 2D transformation that affects only the offset of a visual along the x-axis and y-axis.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A translation transform represents the following 3-by-2 matrix:</p><p></p><p>The effect is simply to offset the coordinate system by <em>x</em> and <em>y</em>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTranslateTransform']/*"/>	
    /// <msdn-id>hh449113</msdn-id>	
    /// <unmanaged>IDCompositionTranslateTransform</unmanaged>	
    /// <unmanaged-short>IDCompositionTranslateTransform</unmanaged-short>	
    [Guid("06791122-C6F0-417d-8323-269E987F5954")]
    public partial class TranslateTransform : SharpDX.DirectComposition.Transform {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.TranslateTransform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TranslateTransform(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.TranslateTransform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.TranslateTransform(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.TranslateTransform(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Changes the value of the OffsetX property of a 2D translation transform. The OffsetX property specifies the distance to translate along the x-axis.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p> The distance to translate along the x-axis, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method perfoms an affine transformation, which moves every point by a fixed distance in the same direction. It is similar to shifting the origin of the coordinate space. </p><p>This method fails if the <em>offsetX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the OffsetX property was previously animated, this method removes the animation and sets the OffsetX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTranslateTransform::SetOffsetX']/*"/>	
        /// <msdn-id>hh449124</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTranslateTransform::SetOffsetX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionTranslateTransform::SetOffsetX</unmanaged-short>	
        public void SetOffsetX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the OffsetX property of a 2D translation transform. The OffsetX property specifies the distance to translate along the x-axis.</p>	
        /// </summary>	
        /// <param name="offsetX"><dd>  <p> The distance to translate along the x-axis, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method perfoms an affine transformation, which moves every point by a fixed distance in the same direction. It is similar to shifting the origin of the coordinate space. </p><p>This method fails if the <em>offsetX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the OffsetX property was previously animated, this method removes the animation and sets the OffsetX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTranslateTransform::SetOffsetX']/*"/>	
        /// <msdn-id>hh449124</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTranslateTransform::SetOffsetX([In] float offsetX)</unmanaged>	
        /// <unmanaged-short>IDCompositionTranslateTransform::SetOffsetX</unmanaged-short>	
        public void SetOffsetX(float offsetX) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, offsetX,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the OffsetY property of a 2D translation transform. The OffsetY property specifies the distance to translate along the y-axis.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The distance to translate along the y-axis, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>offsetY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the OffsetY property was previously animated, this method removes the animation and sets the OffsetY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTranslateTransform::SetOffsetY']/*"/>	
        /// <msdn-id>hh449127</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTranslateTransform::SetOffsetY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionTranslateTransform::SetOffsetY</unmanaged-short>	
        public void SetOffsetY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the OffsetY property of a 2D translation transform. The OffsetY property specifies the distance to translate along the y-axis.</p>	
        /// </summary>	
        /// <param name="offsetY"><dd>  <p>The distance to translate along the y-axis, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>offsetY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the OffsetY property was previously animated, this method removes the animation and sets the OffsetY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTranslateTransform::SetOffsetY']/*"/>	
        /// <msdn-id>hh449127</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTranslateTransform::SetOffsetY([In] float offsetY)</unmanaged>	
        /// <unmanaged-short>IDCompositionTranslateTransform::SetOffsetY</unmanaged-short>	
        public void SetOffsetY(float offsetY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, offsetY,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Animates the value of the OffsetZ property of a 3D translation transform effect. The OffsetZ property specifies the distance to translate along the z-axis.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This method makes a copy of the specified animation. If the object referenced by the <em>animation</em> parameter is changed after calling this method, the change does not affect the OffsetZ property unless this method is called again. If the OffsetZ property was previously animated, calling this method replaces the previous animation with the new animation.  </p><p>This method fails if <em>animation</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface that created the affected visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
    /// </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTranslateTransform3D']/*"/>	
    /// <msdn-id>hh449122</msdn-id>	
    /// <unmanaged>IDCompositionTranslateTransform3D</unmanaged>	
    /// <unmanaged-short>IDCompositionTranslateTransform3D</unmanaged-short>	
    [Guid("91636D4B-9BA1-4532-AAF7-E3344994D788")]
    public partial class TranslateTransform3D : SharpDX.DirectComposition.Transform3D {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.TranslateTransform3D"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TranslateTransform3D(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.TranslateTransform3D"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.TranslateTransform3D(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.TranslateTransform3D(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Changes the value of the OffsetX property of a 3D translation transform effect. The OffsetX property specifies the distance to translate along the x-axis.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The distance to translate along the x-axis, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>offsetX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the OffsetX property was previously animated, this method removes the animation and sets the OffsetX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTranslateTransform3D::SetOffsetX']/*"/>	
        /// <msdn-id>hh449115</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTranslateTransform3D::SetOffsetX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionTranslateTransform3D::SetOffsetX</unmanaged-short>	
        public void SetOffsetX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the OffsetX property of a 3D translation transform effect. The OffsetX property specifies the distance to translate along the x-axis.</p>	
        /// </summary>	
        /// <param name="offsetX"><dd>  <p>The distance to translate along the x-axis, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>offsetX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the OffsetX property was previously animated, this method removes the animation and sets the OffsetX property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTranslateTransform3D::SetOffsetX']/*"/>	
        /// <msdn-id>hh449115</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTranslateTransform3D::SetOffsetX([In] float offsetX)</unmanaged>	
        /// <unmanaged-short>IDCompositionTranslateTransform3D::SetOffsetX</unmanaged-short>	
        public void SetOffsetX(float offsetX) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, offsetX,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the OffsetY property of a 3D translation transform effect. The OffsetY property specifies the distance to translate along the y-axis.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The distance to translate along the y-axis, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>offsetY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the OffsetY property was previously animated, this method removes the animation and sets the OffsetY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTranslateTransform3D::SetOffsetY']/*"/>	
        /// <msdn-id>hh449118</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTranslateTransform3D::SetOffsetY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionTranslateTransform3D::SetOffsetY</unmanaged-short>	
        public void SetOffsetY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the OffsetY property of a 3D translation transform effect. The OffsetY property specifies the distance to translate along the y-axis.</p>	
        /// </summary>	
        /// <param name="offsetY"><dd>  <p>The distance to translate along the y-axis, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>offsetY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the OffsetY property was previously animated, this method removes the animation and sets the OffsetY property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTranslateTransform3D::SetOffsetY']/*"/>	
        /// <msdn-id>hh449118</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTranslateTransform3D::SetOffsetY([In] float offsetY)</unmanaged>	
        /// <unmanaged-short>IDCompositionTranslateTransform3D::SetOffsetY</unmanaged-short>	
        public void SetOffsetY(float offsetY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, offsetY,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the OffsetZ property of a 3D translation transform effect. The OffsetZ property specifies the distance to translate along the z-axis.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The distance to translate along the z-axis, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>offsetZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the OffsetZ property was previously animated, this method removes the animation and sets the OffsetZ property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTranslateTransform3D::SetOffsetZ']/*"/>	
        /// <msdn-id>hh449121</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTranslateTransform3D::SetOffsetZ([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionTranslateTransform3D::SetOffsetZ</unmanaged-short>	
        public void SetOffsetZ(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the OffsetZ property of a 3D translation transform effect. The OffsetZ property specifies the distance to translate along the z-axis.</p>	
        /// </summary>	
        /// <param name="offsetZ"><dd>  <p>The distance to translate along the z-axis, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>offsetZ</em> parameter is NaN, positive infinity, or negative infinity. </p><p>If the OffsetZ property was previously animated, this method removes the animation and sets the OffsetZ property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTranslateTransform3D::SetOffsetZ']/*"/>	
        /// <msdn-id>hh449121</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTranslateTransform3D::SetOffsetZ([In] float offsetZ)</unmanaged>	
        /// <unmanaged-short>IDCompositionTranslateTransform3D::SetOffsetZ</unmanaged-short>	
        public void SetOffsetZ(float offsetZ) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, offsetZ,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> The turbulence effect is used to generate a bitmap based on the Perlin noise function. The turbulence effect has no input image. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTurbulenceEffect']/*"/>	
    /// <msdn-id>dn919801</msdn-id>	
    /// <unmanaged>IDCompositionTurbulenceEffect</unmanaged>	
    /// <unmanaged-short>IDCompositionTurbulenceEffect</unmanaged-short>	
    [Guid("A6A55BDA-C09C-49F3-9193-A41922C89715")]
    public partial class TurbulenceEffect : SharpDX.DirectComposition.FilterEffect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.TurbulenceEffect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TurbulenceEffect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.TurbulenceEffect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.TurbulenceEffect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.TurbulenceEffect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the coordinates where the turbulence output is generated.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTurbulenceEffect::SetOffset']/*"/>	
        /// <msdn-id>dn919805</msdn-id>	
        /// <unmanaged>SetOffset</unmanaged>	
        /// <unmanaged-short>SetOffset</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetOffset([In] const D2D_VECTOR_2F& offset)</unmanaged>
        public SharpDX.Mathematics.Interop.RawVector2 Offset {
                set { SetOffset(value); }
        }
        
        /// <summary>	
        /// <p>Sets the base frequencies in the X and Y direction.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTurbulenceEffect::SetBaseFrequency']/*"/>	
        /// <msdn-id>dn919802</msdn-id>	
        /// <unmanaged>SetBaseFrequency</unmanaged>	
        /// <unmanaged-short>SetBaseFrequency</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetBaseFrequency([In] const D2D_VECTOR_2F& frequency)</unmanaged>
        public SharpDX.Mathematics.Interop.RawVector2 BaseFrequency {
                set { SetBaseFrequency(value); }
        }
        
        /// <summary>	
        /// <p>Sets the size of the turbulence output.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTurbulenceEffect::SetSize']/*"/>	
        /// <msdn-id>dn919807</msdn-id>	
        /// <unmanaged>SetSize</unmanaged>	
        /// <unmanaged-short>SetSize</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetSize([In] const D2D_VECTOR_2F& size)</unmanaged>
        public SharpDX.Mathematics.Interop.RawVector2 Size {
                set { SetSize(value); }
        }
        
        /// <summary>	
        /// <p>Sets the number of octaves for the noise function.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTurbulenceEffect::SetNumOctaves']/*"/>	
        /// <msdn-id>dn919804</msdn-id>	
        /// <unmanaged>SetNumOctaves</unmanaged>	
        /// <unmanaged-short>SetNumOctaves</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetNumOctaves([In] unsigned int numOctaves)</unmanaged>
        public int NumOctaves {
                set { SetNumOctaves(value); }
        }
        
        /// <summary>	
        /// <p>Sets the seed for the pseudo random generator.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTurbulenceEffect::SetSeed']/*"/>	
        /// <msdn-id>dn919806</msdn-id>	
        /// <unmanaged>SetSeed</unmanaged>	
        /// <unmanaged-short>SetSeed</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetSeed([In] unsigned int seed)</unmanaged>
        public int Seed {
                set { SetSeed(value); }
        }
        
        /// <summary>	
        /// <p>Sets the turbulence noise mode.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTurbulenceEffect::SetNoise']/*"/>	
        /// <msdn-id>dn919803</msdn-id>	
        /// <unmanaged>SetNoise</unmanaged>	
        /// <unmanaged-short>SetNoise</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetNoise([In] D2D1_TURBULENCE_NOISE noise)</unmanaged>
        public SharpDX.Direct2D1.TurbulenceNoise Noise {
                set { SetNoise(value); }
        }
        
        /// <summary>	
        /// <p>Specifies whether stitching is on or off.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTurbulenceEffect::SetStitchable']/*"/>	
        /// <msdn-id>dn919808</msdn-id>	
        /// <unmanaged>SetStitchable</unmanaged>	
        /// <unmanaged-short>SetStitchable</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetStitchable([In] BOOL stitchable)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool Stitchable {
                set { SetStitchable(value); }
        }
        
        /// <summary>	
        /// <p>Sets the coordinates where the turbulence output is generated.</p>	
        /// </summary>	
        /// <param name="offset"><dd>  <p> The coordinates where the turbulence output is generated. The algorithm used to generate the Perlin noise is position dependent, so a different offset results in a different output. This value is not bounded and the units are specified in DIPs </p> <strong>Note</strong>??Note  The offset does not have the same effect as a translation because the noise function output is infinite and the function will wrap around the tile. ? </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTurbulenceEffect::SetOffset']/*"/>	
        /// <msdn-id>dn919805</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetOffset([In] const D2D_VECTOR_2F&amp; offset)</unmanaged>	
        /// <unmanaged-short>IDCompositionTurbulenceEffect::SetOffset</unmanaged-short>	
        internal void SetOffset(SharpDX.Mathematics.Interop.RawVector2 offset) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &offset,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the base frequencies in the X and Y direction.</p>	
        /// </summary>	
        /// <param name="frequency"><dd>  <p> The base frequencies in the X and Y direction. This must be greater than 0. The units are specified in 1/DIPs. A value of 1 (1/DIPs) for the base frequency results in the Perlin noise completing an entire cycle between two pixels. The ease interpolation for these pixels results in completely random pixels, since there is no correlation between the pixels. A value of 0.1(1/DIPs) for the base frequency results in the Perlin noise function repeating every 10 DIPs. This results in correlation between pixels and the typical turbulence effect is visible. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTurbulenceEffect::SetBaseFrequency']/*"/>	
        /// <msdn-id>dn919802</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetBaseFrequency([In] const D2D_VECTOR_2F&amp; frequency)</unmanaged>	
        /// <unmanaged-short>IDCompositionTurbulenceEffect::SetBaseFrequency</unmanaged-short>	
        internal void SetBaseFrequency(SharpDX.Mathematics.Interop.RawVector2 frequency) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &frequency,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the size of the turbulence output.</p>	
        /// </summary>	
        /// <param name="size"><dd>  <p>The size of the turbulence output</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTurbulenceEffect::SetSize']/*"/>	
        /// <msdn-id>dn919807</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetSize([In] const D2D_VECTOR_2F&amp; size)</unmanaged>	
        /// <unmanaged-short>IDCompositionTurbulenceEffect::SetSize</unmanaged-short>	
        internal void SetSize(SharpDX.Mathematics.Interop.RawVector2 size) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &size,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the number of octaves for the noise function.</p>	
        /// </summary>	
        /// <param name="numOctaves"><dd>  <p>The number of octaves for the noise function. This value must be greater than 0.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTurbulenceEffect::SetNumOctaves']/*"/>	
        /// <msdn-id>dn919804</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetNumOctaves([In] unsigned int numOctaves)</unmanaged>	
        /// <unmanaged-short>IDCompositionTurbulenceEffect::SetNumOctaves</unmanaged-short>	
        internal void SetNumOctaves(int numOctaves) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, numOctaves,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the seed for the pseudo random generator.</p>	
        /// </summary>	
        /// <param name="seed"><dd>  <p>The seed for the pseudo random generator. This value is unbounded.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTurbulenceEffect::SetSeed']/*"/>	
        /// <msdn-id>dn919806</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetSeed([In] unsigned int seed)</unmanaged>	
        /// <unmanaged-short>IDCompositionTurbulenceEffect::SetSeed</unmanaged-short>	
        internal void SetSeed(int seed) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, seed,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the turbulence noise mode.</p>	
        /// </summary>	
        /// <param name="noise"><dd>  <p>The turbulence noise mode. Indicates whether to generate a bitmap based on Fractal Noise or the Turbulence function.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTurbulenceEffect::SetNoise']/*"/>	
        /// <msdn-id>dn919803</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetNoise([In] D2D1_TURBULENCE_NOISE noise)</unmanaged>	
        /// <unmanaged-short>IDCompositionTurbulenceEffect::SetNoise</unmanaged-short>	
        internal void SetNoise(SharpDX.Direct2D1.TurbulenceNoise noise) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, unchecked((int)noise),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies whether stitching is on or off.</p>	
        /// </summary>	
        /// <param name="stitchable"><dd>  <p> A boolean value that specifies whether stitching is on or off. The base frequency is adjusted so that the output bitmap can be stitched. This is useful if you want to tile multiple copies of the turbulence effect output. If this value is TRUE, the output bitmap can be tiled (using the tile effect) without the appearance of seams and the base frequency is adjusted so that output bitmap can be stitched. If this value is <see cref="SharpDX.Result.False"/>, the base frequency is not adjusted, so seams may appear between tiles if the bitmap is tiled. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionTurbulenceEffect::SetStitchable']/*"/>	
        /// <msdn-id>dn919808</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionTurbulenceEffect::SetStitchable([In] BOOL stitchable)</unmanaged>	
        /// <unmanaged-short>IDCompositionTurbulenceEffect::SetStitchable</unmanaged-short>	
        internal void SetStitchable(SharpDX.Mathematics.Interop.RawBool stitchable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint9(_nativePointer, stitchable,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a sparsely allocated bitmap that can be associated with a visual for composition in a visual tree.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVirtualSurface']/*"/>	
    /// <msdn-id>hh449133</msdn-id>	
    /// <unmanaged>IDCompositionVirtualSurface</unmanaged>	
    /// <unmanaged-short>IDCompositionVirtualSurface</unmanaged-short>	
    [Guid("AE471C51-5F53-4A24-8D3E-D0C39C30B3F0")]
    public partial class VirtualSurface : SharpDX.DirectComposition.Surface {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.VirtualSurface"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VirtualSurface(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.VirtualSurface"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.VirtualSurface(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.VirtualSurface(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Changes the logical size of this virtual surface object.</p>	
        /// </summary>	
        /// <param name="width"><dd>  <p>The new width of the virtual surface, in pixels. The maximum width is 16,777,216 pixels.</p> </dd></param>	
        /// <param name="height"><dd>  <p>The new height of the virtual surface, in pixels. The maximum height is 16,777,216 pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>When a virtual surface is resized, its contents are preserved up to the new boundaries of the surface. If the surface is made smaller, any previously allocated pixels that fall outside of the new width or height are discarded.</p><p>This method fails if <strong><see cref="SharpDX.DirectComposition.Surface.BeginDraw"/></strong> was called for this bitmap without a corresponding call to <strong><see cref="SharpDX.DirectComposition.Surface.EndDraw"/></strong>.</p><p>This method fails if <em>width</em> or <em>height</em> exceeds 16,777,216 pixels. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVirtualSurface::Resize']/*"/>	
        /// <msdn-id>hh449135</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVirtualSurface::Resize([In] unsigned int width,[In] unsigned int height)</unmanaged>	
        /// <unmanaged-short>IDCompositionVirtualSurface::Resize</unmanaged-short>	
        public void Resize(int width, int height) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, width, height,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Discards pixels that fall outside of the specified trim rectangles.</p>	
        /// </summary>	
        /// <param name="rectangles"><dd>  <p>An array of rectangles to keep.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of rectangles in the <em>rectangles</em> array.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>A virtual surface might not  have enough storage for every pixel in the surface. An application instructs the composition engine to allocate memory for the surface by calling the <strong><see cref="SharpDX.DirectComposition.Surface.BeginDraw"/></strong> method, and to release memory for the surface by calling the <strong><see cref="SharpDX.DirectComposition.VirtualSurface.Trim"/></strong> method. The array of rectangles represents the regions of the virtual surface that should remain allocated after this method returns. Any pixels that are outside the specified set of rectangles are no longer used for texturing, and their memory may be reclaimed. </p><p>If the <em>count</em> parameter is zero, no pixels are kept, and all of the memory allocated for the virtual surface may be reclaimed. The <em>rectangles</em> parameter can be <c>null</c> only if the <em>count</em> parameter is zero. This method fails if <strong><see cref="SharpDX.DirectComposition.Surface.BeginDraw"/></strong> was called for this bitmap without a corresponding call to <strong><see cref="SharpDX.DirectComposition.Surface.EndDraw"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVirtualSurface::Trim']/*"/>	
        /// <msdn-id>hh449137</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVirtualSurface::Trim([In, Buffer, Optional] const RECT* rectangles,[In] unsigned int count)</unmanaged>	
        /// <unmanaged-short>IDCompositionVirtualSurface::Trim</unmanaged-short>	
        public void Trim(SharpDX.Mathematics.Interop.RawRectangle[] rectangles, int count) {
            unsafe {
                SharpDX.Mathematics.Interop.RawRectangle[] rectangles__ = rectangles;
                SharpDX.Result __result__;
                fixed (void* rectangles_ = rectangles__)
                    __result__= 
    				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, rectangles_, count,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a Microsoft DirectComposition visual. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual']/*"/>	
    /// <msdn-id>hh449139</msdn-id>	
    /// <unmanaged>IDCompositionVisual</unmanaged>	
    /// <unmanaged-short>IDCompositionVisual</unmanaged-short>	
    [Guid("4d93059d-097b-4651-9a60-f0f25116e2f3")]
    public partial class Visual : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.Visual"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Visual(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.Visual"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.Visual(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.Visual(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the Effect property of this visual. The Effect property modifies how the subtree that is rooted at this visual is blended with the background, and can apply a 3D perspective transform to the visual. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method creates an implicit off-screen surface to which the subtree that is rooted at this visual is composed. The surface is used as one of the inputs to the specified effect. The output of the effect is composed directly to the composition target. Some effects also use the composition target as another implicit input. This is typically the case for compositional or blend effects such as opacity, where the composition target is considered to be the "background." In that case, any visuals that are "behind" the current visual are included in the composition target when the current visual is rendered and are considered to be the "background" that this visual composes to. </p><p>If this visual is not the root of a visual tree and one of its ancestors also has an effect applied to it, the off-screen surface created by the closest ancestor is the composition target to which this visual's effect is composed. Otherwise, the composition target is the root composition target. As a consequence, the background for compositional and blend effects includes only the visuals up to the closest ancestor that itself has an effect. Conversely, any effects applied to visuals under the current visual use the newly created off-screen surface as the background, which may affect how those visuals ultimately compose on top of what the end user perceives as being "behind" those visuals. </p><p>If the <em>effect</em> parameter is <c>null</c>,  no bitmap effect is applied to this visual. Any previous effects that were associated with this visual are removed. The off-screen surface is also removed and the visual subtree is composed directly to the parent composition target, which may also affect how compositional or blend effects under this visual are rendered. </p><p>This method fails if <em>effect</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface that created this visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetEffect']/*"/>	
        /// <msdn-id>hh449159</msdn-id>	
        /// <unmanaged>SetEffect</unmanaged>	
        /// <unmanaged-short>SetEffect</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetEffect([In, Optional] IDCompositionEffect* effect)</unmanaged>
        public SharpDX.DirectComposition.Effect Effect {
                set { SetEffect(value); }
        }
        
        /// <summary>	
        /// <p>Sets the BitmapInterpolationMode property, which specifies the mode for Microsoft DirectComposition to use when interpolating pixels from bitmaps that are not axis-aligned or drawn exactly at scale. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The interpolation mode affects how a bitmap is composed when it is transformed such that there is no one-to-one correspondence between pixels in the bitmap and pixels on the screen. </p><p>By default, a visual inherits the interpolation mode of the parent visual, which may inherit the interpolation mode of its parent visual, and so on. A visual uses the default interpolation mode if this method is never called for the visual, or if this method is called with <strong><see cref="SharpDX.DirectComposition.BitmapInterpolationMode.Inherit"/></strong>. If no visuals set the interpolation mode, the default for the entire visual tree is nearest neighbor interpolation, which offers the lowest visual quality but the highest performance. </p><p>If the <em>interpolationMode</em> parameter is anything other than <strong><see cref="SharpDX.DirectComposition.BitmapInterpolationMode.Inherit"/></strong>, this visual's bitmap is composed with the specified interpolation mode, and this mode becomes the new default mode for the children of this visual. That is, if the interpolation mode of this visual's children is unchanged or explicitly set to <strong><see cref="SharpDX.DirectComposition.BitmapInterpolationMode.Inherit"/></strong>, the bitmaps of the child visuals are composed using the interpolation mode of this visual.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetBitmapInterpolationMode']/*"/>	
        /// <msdn-id>hh449147</msdn-id>	
        /// <unmanaged>SetBitmapInterpolationMode</unmanaged>	
        /// <unmanaged-short>SetBitmapInterpolationMode</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetBitmapInterpolationMode([In] DCOMPOSITION_BITMAP_INTERPOLATION_MODE interpolationMode)</unmanaged>
        public SharpDX.DirectComposition.BitmapInterpolationMode BitmapInterpolationMode {
                set { SetBitmapInterpolationMode(value); }
        }
        
        /// <summary>	
        /// <p>Sets the BorderMode property, which specifies how to compose the edges of bitmaps and clips associated with this visual, or with visuals in the subtree rooted at this visual.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The border mode affects how the edges of a bitmap are composed when the bitmap is transformed such that the edges are not exactly axis-aligned and at precise pixel boundaries. It also affects how content is clipped at the corners of a clip that has rounded corners, and at the edge of a clip that is transformed such that the edges are not exactly axis-aligned and at precise pixel boundaries. </p><p>By default, a visual inherits the border mode of  its parent visual, which may inherit the border mode of its parent visual, and so on. A visual uses the default border mode if this method is never called for the visual, or if this method is called with <strong><see cref="SharpDX.DirectComposition.BorderMode.Inherit"/></strong>. If no visuals set the border mode, the default for the entire visual tree is aliased rendering, which offers the lowest visual quality but the highest performance. </p><p>If the <em>borderMode</em> parameter is anything other than <strong><see cref="SharpDX.DirectComposition.BorderMode.Inherit"/></strong>, this visual's bitmap and clip are composed with the specified border mode. In addition, this border mode becomes the new default for the children of the current visual. That is, if the border mode of this visual's children is unchanged or explicitly set to <strong><see cref="SharpDX.DirectComposition.BorderMode.Inherit"/></strong>, the bitmaps and clips of the child visuals are composed using the border mode of this visual.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetBorderMode']/*"/>	
        /// <msdn-id>hh449149</msdn-id>	
        /// <unmanaged>SetBorderMode</unmanaged>	
        /// <unmanaged-short>SetBorderMode</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetBorderMode([In] DCOMPOSITION_BORDER_MODE borderMode)</unmanaged>
        public SharpDX.DirectComposition.BorderMode BorderMode {
                set { SetBorderMode(value); }
        }
        
        /// <summary>	
        /// <p>Sets the Content property of this visual to the specified bitmap or window wrapper.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> The <em>content</em> parameter must point to one of the following:</p><ul> <li>An object that implements the <strong><see cref="SharpDX.DirectComposition.Surface"/></strong> interface.</li> <li>An object that implements the <strong><see cref="SharpDX.DXGI.SwapChain1"/></strong> interface.</li> <li>A wrapper object that is returned by the <strong>CreateSurfaceFromHandle</strong> or  <strong>CreateSurfaceFromHwnd</strong> method.	
        /// </li> </ul><p>The new content replaces any content that was previously associated with the visual. If the <em>content</em> parameter is <c>null</c>, the visual has no associated content.</p><p>A visual can be associated with a bitmap object or a window wrapper. A bitmap is either a Microsoft DirectX swap chain or a Microsoft DirectComposition surface.</p><p>A window wrapper is created with the <strong>CreateSurfaceFromHwnd</strong> method and is a stand-in for the rasterization of another window, which must be a top-level window or a layered child window. A window wrapper is conceptually equivalent to a bitmap that is the size of the target window on which the contents of the window are drawn. The contents include the target window's child windows (layered or otherwise), and any DirectComposition content that is drawn in the child windows. </p><p>A DirectComposition surface wrapper is created with the <strong>CreateSurfaceFromHandle</strong> method and is a reference to a swap chain. An application might use a surface wrapper in a cross-process scenario where one process creates the swap chain and another process associates the bitmap with a visual.</p><p>The bitmap is always drawn at position (0,0) relative to the visual's coordinate system, although the coordinate system is directly affected by the OffsetX, OffsetY, and Transform properties, as well as indirectly by the transformations on ancestor visuals. The bitmap of a visual is always drawn behind the children of that visual.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetContent']/*"/>	
        /// <msdn-id>hh449157</msdn-id>	
        /// <unmanaged>SetContent</unmanaged>	
        /// <unmanaged-short>SetContent</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetContent([In, Optional] IUnknown* content)</unmanaged>
        public SharpDX.ComObject Content {
                set { SetContent(value); }
        }
        
        /// <summary>	
        /// <p>Sets the blending mode for this visual.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The composite mode determines how visual's bitmap is blended with the screen. By default, the visual is blended with "source over" semantics; that is, the colors are blended with per-pixel transparency.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetCompositeMode']/*"/>	
        /// <msdn-id>Hh802902</msdn-id>	
        /// <unmanaged>SetCompositeMode</unmanaged>	
        /// <unmanaged-short>SetCompositeMode</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetCompositeMode([In] DCOMPOSITION_COMPOSITE_MODE compositeMode)</unmanaged>
        public SharpDX.DirectComposition.CompositeMode CompositeMode {
                set { SetCompositeMode(value); }
        }
        
        /// <summary>	
        /// <p>Changes the value of the OffsetX property of this visual.  The OffsetX property specifies the new offset of the visual along the x-axis, relative to the parent visual.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new offset of the visual along the x-axis, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>offsetX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>Changing the OffsetX property of a visual transforms the coordinate system of the entire visual subtree that is rooted at that visual. If the Clip property of this visual is specified, the clip rectangle is also transformed. </p><p>A transformation that is specified by the Transform property is applied after the OffsetX property.  In other words, the effect of setting the Transform property and the OffsetX property is the same as setting only the Transform property on a transform group  object where the first member of the group is an <strong><see cref="SharpDX.DirectComposition.TranslateTransform"/></strong> object that has the same OffsetX value as <em>offsetX</em>. However, you should use  <strong><see cref="SharpDX.DirectComposition.Visual.SetOffsetX"/></strong> whenever possible because it is slightly faster.</p><p>If the OffsetX and OffsetY properties are set to 0, and the Transform property is set to <c>null</c>, the coordinate system of the visual is the same as that of its parent.</p><p>If the OffsetX property was previously animated, this method removes the animation and sets the property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetOffsetX']/*"/>	
        /// <msdn-id>hh449161</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetOffsetX([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::SetOffsetX</unmanaged-short>	
        public void SetOffsetX(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the OffsetX property of this visual.  The OffsetX property specifies the new offset of the visual along the x-axis, relative to the parent visual.</p>	
        /// </summary>	
        /// <param name="offsetX"><dd>  <p>The new offset of the visual along the x-axis, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>offsetX</em> parameter is NaN, positive infinity, or negative infinity. </p><p>Changing the OffsetX property of a visual transforms the coordinate system of the entire visual subtree that is rooted at that visual. If the Clip property of this visual is specified, the clip rectangle is also transformed. </p><p>A transformation that is specified by the Transform property is applied after the OffsetX property.  In other words, the effect of setting the Transform property and the OffsetX property is the same as setting only the Transform property on a transform group  object where the first member of the group is an <strong><see cref="SharpDX.DirectComposition.TranslateTransform"/></strong> object that has the same OffsetX value as <em>offsetX</em>. However, you should use  <strong><see cref="SharpDX.DirectComposition.Visual.SetOffsetX"/></strong> whenever possible because it is slightly faster.</p><p>If the OffsetX and OffsetY properties are set to 0, and the Transform property is set to <c>null</c>, the coordinate system of the visual is the same as that of its parent.</p><p>If the OffsetX property was previously animated, this method removes the animation and sets the property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetOffsetX']/*"/>	
        /// <msdn-id>hh449161</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetOffsetX([In] float offsetX)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::SetOffsetX</unmanaged-short>	
        public void SetOffsetX(float offsetX) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, offsetX,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the OffsetY property of this visual.  The OffsetY property specifies the new offset of the visual along the y-axis, relative to the parent visual.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>The new offset of the visual along the y-axis, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>offsetY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>Changing the OffsetY property transforms the coordinate system of the entire visual subtree that is rooted at this visual. If the Clip property of this visual is specified, the clip rectangle is also transformed. </p><p>A transformation that is specified by the Transform property is applied after the OffsetY property.  In other words, the effect of setting the Transform property and the OffsetY property is the same as setting only the Transform property on a transform group object where the first member of the group is an <strong><see cref="SharpDX.DirectComposition.TranslateTransform"/></strong> object that has the same OffsetY value as <em>offsetY</em>. However, you should use  <strong><see cref="SharpDX.DirectComposition.Visual.SetOffsetY"/></strong> whenever possible because it is slightly faster.</p><p>If the OffsetX and OffsetY properties are set to 0, and the Transform property is set to <c>null</c>, the coordinate system of the visual is the same as that of its parent.</p><p>If the OffsetY property was previously animated, this method removes the animation and sets the property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetOffsetY']/*"/>	
        /// <msdn-id>hh449167</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetOffsetY([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::SetOffsetY</unmanaged-short>	
        public void SetOffsetY(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the value of the OffsetY property of this visual.  The OffsetY property specifies the new offset of the visual along the y-axis, relative to the parent visual.</p>	
        /// </summary>	
        /// <param name="offsetY"><dd>  <p>The new offset of the visual along the y-axis, in pixels.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method fails if the <em>offsetY</em> parameter is NaN, positive infinity, or negative infinity. </p><p>Changing the OffsetY property transforms the coordinate system of the entire visual subtree that is rooted at this visual. If the Clip property of this visual is specified, the clip rectangle is also transformed. </p><p>A transformation that is specified by the Transform property is applied after the OffsetY property.  In other words, the effect of setting the Transform property and the OffsetY property is the same as setting only the Transform property on a transform group object where the first member of the group is an <strong><see cref="SharpDX.DirectComposition.TranslateTransform"/></strong> object that has the same OffsetY value as <em>offsetY</em>. However, you should use  <strong><see cref="SharpDX.DirectComposition.Visual.SetOffsetY"/></strong> whenever possible because it is slightly faster.</p><p>If the OffsetX and OffsetY properties are set to 0, and the Transform property is set to <c>null</c>, the coordinate system of the visual is the same as that of its parent.</p><p>If the OffsetY property was previously animated, this method removes the animation and sets the property to the specified static value.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetOffsetY']/*"/>	
        /// <msdn-id>hh449167</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetOffsetY([In] float offsetY)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::SetOffsetY</unmanaged-short>	
        public void SetOffsetY(float offsetY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, offsetY,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the Transform property of this visual to the specified 2D transform object.</p>	
        /// </summary>	
        /// <param name="transform"><dd>  <p>The transform object that is used to modify  the coordinate system of this visual. This parameter can point to an <strong><see cref="SharpDX.DirectComposition.Transform"/></strong> interface or one of its derived interfaces. This parameter can be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Setting the Transform property transforms the coordinate system of the entire visual subtree that is rooted at this visual. If the Clip property of this visual is specified, the clip rectangle is also transformed. </p><p>If the Transform property previously specified a transform matrix, the newly specified transform object replaces the transform matrix.</p><p>A transformation specified by the Transform property is applied after the OffsetX and OffsetY properties. In other words, the effect of setting the Transform property and the OffsetX and OffsetY properties is the same as setting only the Transform property on a transform group where the first member of the group is an <strong><see cref="SharpDX.DirectComposition.TranslateTransform"/></strong> object that has those same OffsetX and OffsetY values. However, you should use the <strong><see cref="SharpDX.DirectComposition.Visual.SetOffsetX"/></strong> and <strong>SetOffsetY</strong> methods whenever possible because they are slightly faster. </p><p>This method fails if <em>transform</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface that created this visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p><p>If the <em>transform</em> parameter is <c>null</c>, the coordinate system of this visual is transformed only by its OffsetX and OffsetY properties. Setting the Transform property to <c>null</c> is equivalent to setting it to an <strong><see cref="SharpDX.DirectComposition.MatrixTransform"/></strong> object where the specified matrix is the identity matrix. However, an application should set the Transform property to <c>null</c> whenever possible because it is slightly faster.</p><p>If the OffsetX and OffsetY properties are set to 0, and the Transform property is set to <c>null</c>, the coordinate system of the visual is the same as that of its parent.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetTransform']/*"/>	
        /// <msdn-id>hh449176</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetTransform([In, Optional] IDCompositionTransform* transform)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::SetTransform</unmanaged-short>	
        public void SetTransform(SharpDX.DirectComposition.Transform transform) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((transform == null)?IntPtr.Zero:transform.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the Transform property of this visual to the specified 2D transform object.</p>	
        /// </summary>	
        /// <param name="matrix"><dd>  <p>The transform object that is used to modify  the coordinate system of this visual. This parameter can point to an <strong><see cref="SharpDX.DirectComposition.Transform"/></strong> interface or one of its derived interfaces. This parameter can be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Setting the Transform property transforms the coordinate system of the entire visual subtree that is rooted at this visual. If the Clip property of this visual is specified, the clip rectangle is also transformed. </p><p>If the Transform property previously specified a transform matrix, the newly specified transform object replaces the transform matrix.</p><p>A transformation specified by the Transform property is applied after the OffsetX and OffsetY properties. In other words, the effect of setting the Transform property and the OffsetX and OffsetY properties is the same as setting only the Transform property on a transform group where the first member of the group is an <strong><see cref="SharpDX.DirectComposition.TranslateTransform"/></strong> object that has those same OffsetX and OffsetY values. However, you should use the <strong><see cref="SharpDX.DirectComposition.Visual.SetOffsetX"/></strong> and <strong>SetOffsetY</strong> methods whenever possible because they are slightly faster. </p><p>This method fails if <em>transform</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface that created this visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p><p>If the <em>transform</em> parameter is <c>null</c>, the coordinate system of this visual is transformed only by its OffsetX and OffsetY properties. Setting the Transform property to <c>null</c> is equivalent to setting it to an <strong><see cref="SharpDX.DirectComposition.MatrixTransform"/></strong> object where the specified matrix is the identity matrix. However, an application should set the Transform property to <c>null</c> whenever possible because it is slightly faster.</p><p>If the OffsetX and OffsetY properties are set to 0, and the Transform property is set to <c>null</c>, the coordinate system of the visual is the same as that of its parent.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetTransform']/*"/>	
        /// <msdn-id>hh449176</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetTransform([In] const D2D_MATRIX_3X2_F&amp; matrix)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::SetTransform</unmanaged-short>	
        public void SetTransform(ref SharpDX.Mathematics.Interop.RawMatrix3x2 matrix) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* matrix_ = &matrix)
                    __result__= 
    				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, matrix_,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the TransformParent property of this visual. The TransformParent property establishes the coordinate system relative to which this visual is composed.</p>	
        /// </summary>	
        /// <param name="visual"><dd>  <p>The new visual that establishes the base coordinate system for this visual. This parameter can be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The coordinate system of a visual is modified by the OffsetX, OffsetY, and Transform properties. Normally, these properties define the coordinate system of a visual relative to its immediate parent. This method specifies the  visual relative to which the coordinate system for this visual is based. The specified visual must be an ancestor of the current visual. If it is not an ancestor, the coordinate system is based on this visual's immediate parent, just as if the TransformParent property were set to <c>null</c>. Because visuals can be reparented, this property can take effect again if the specified visual becomes an ancestor of the target visual through a reparenting operation. </p><p>If the <em>visual</em> parameter is <c>null</c>, the coordinate system is always transformed relative to the visual's immediate parent. This is the default behavior if this method is not used.  </p><p>This method fails if the <em>visual</em> parameter is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as this visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetTransformParent']/*"/>	
        /// <msdn-id>hh449172</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetTransformParent([In, Optional] IDCompositionVisual* visual)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::SetTransformParent</unmanaged-short>	
        public void SetTransformParent(SharpDX.DirectComposition.Visual visual) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((visual == null)?IntPtr.Zero:visual.NativePointer),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the Effect property of this visual. The Effect property modifies how the subtree that is rooted at this visual is blended with the background, and can apply a 3D perspective transform to the visual. </p>	
        /// </summary>	
        /// <param name="effect"><dd>  <p>A reference to an effect object. This parameter can be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method creates an implicit off-screen surface to which the subtree that is rooted at this visual is composed. The surface is used as one of the inputs to the specified effect. The output of the effect is composed directly to the composition target. Some effects also use the composition target as another implicit input. This is typically the case for compositional or blend effects such as opacity, where the composition target is considered to be the "background." In that case, any visuals that are "behind" the current visual are included in the composition target when the current visual is rendered and are considered to be the "background" that this visual composes to. </p><p>If this visual is not the root of a visual tree and one of its ancestors also has an effect applied to it, the off-screen surface created by the closest ancestor is the composition target to which this visual's effect is composed. Otherwise, the composition target is the root composition target. As a consequence, the background for compositional and blend effects includes only the visuals up to the closest ancestor that itself has an effect. Conversely, any effects applied to visuals under the current visual use the newly created off-screen surface as the background, which may affect how those visuals ultimately compose on top of what the end user perceives as being "behind" those visuals. </p><p>If the <em>effect</em> parameter is <c>null</c>,  no bitmap effect is applied to this visual. Any previous effects that were associated with this visual are removed. The off-screen surface is also removed and the visual subtree is composed directly to the parent composition target, which may also affect how compositional or blend effects under this visual are rendered. </p><p>This method fails if <em>effect</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface that created this visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetEffect']/*"/>	
        /// <msdn-id>hh449159</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetEffect([In, Optional] IDCompositionEffect* effect)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::SetEffect</unmanaged-short>	
        internal void SetEffect(SharpDX.DirectComposition.Effect effect) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((effect == null)?IntPtr.Zero:effect.NativePointer),((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the BitmapInterpolationMode property, which specifies the mode for Microsoft DirectComposition to use when interpolating pixels from bitmaps that are not axis-aligned or drawn exactly at scale. </p>	
        /// </summary>	
        /// <param name="interpolationMode"><dd>  <p>The interpolation mode to use.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The interpolation mode affects how a bitmap is composed when it is transformed such that there is no one-to-one correspondence between pixels in the bitmap and pixels on the screen. </p><p>By default, a visual inherits the interpolation mode of the parent visual, which may inherit the interpolation mode of its parent visual, and so on. A visual uses the default interpolation mode if this method is never called for the visual, or if this method is called with <strong><see cref="SharpDX.DirectComposition.BitmapInterpolationMode.Inherit"/></strong>. If no visuals set the interpolation mode, the default for the entire visual tree is nearest neighbor interpolation, which offers the lowest visual quality but the highest performance. </p><p>If the <em>interpolationMode</em> parameter is anything other than <strong><see cref="SharpDX.DirectComposition.BitmapInterpolationMode.Inherit"/></strong>, this visual's bitmap is composed with the specified interpolation mode, and this mode becomes the new default mode for the children of this visual. That is, if the interpolation mode of this visual's children is unchanged or explicitly set to <strong><see cref="SharpDX.DirectComposition.BitmapInterpolationMode.Inherit"/></strong>, the bitmaps of the child visuals are composed using the interpolation mode of this visual.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetBitmapInterpolationMode']/*"/>	
        /// <msdn-id>hh449147</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetBitmapInterpolationMode([In] DCOMPOSITION_BITMAP_INTERPOLATION_MODE interpolationMode)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::SetBitmapInterpolationMode</unmanaged-short>	
        internal void SetBitmapInterpolationMode(SharpDX.DirectComposition.BitmapInterpolationMode interpolationMode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, unchecked((int)interpolationMode),((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the BorderMode property, which specifies how to compose the edges of bitmaps and clips associated with this visual, or with visuals in the subtree rooted at this visual.</p>	
        /// </summary>	
        /// <param name="borderMode"><dd>  <p>The border mode to use.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The border mode affects how the edges of a bitmap are composed when the bitmap is transformed such that the edges are not exactly axis-aligned and at precise pixel boundaries. It also affects how content is clipped at the corners of a clip that has rounded corners, and at the edge of a clip that is transformed such that the edges are not exactly axis-aligned and at precise pixel boundaries. </p><p>By default, a visual inherits the border mode of  its parent visual, which may inherit the border mode of its parent visual, and so on. A visual uses the default border mode if this method is never called for the visual, or if this method is called with <strong><see cref="SharpDX.DirectComposition.BorderMode.Inherit"/></strong>. If no visuals set the border mode, the default for the entire visual tree is aliased rendering, which offers the lowest visual quality but the highest performance. </p><p>If the <em>borderMode</em> parameter is anything other than <strong><see cref="SharpDX.DirectComposition.BorderMode.Inherit"/></strong>, this visual's bitmap and clip are composed with the specified border mode. In addition, this border mode becomes the new default for the children of the current visual. That is, if the border mode of this visual's children is unchanged or explicitly set to <strong><see cref="SharpDX.DirectComposition.BorderMode.Inherit"/></strong>, the bitmaps and clips of the child visuals are composed using the border mode of this visual.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetBorderMode']/*"/>	
        /// <msdn-id>hh449149</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetBorderMode([In] DCOMPOSITION_BORDER_MODE borderMode)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::SetBorderMode</unmanaged-short>	
        internal void SetBorderMode(SharpDX.DirectComposition.BorderMode borderMode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, unchecked((int)borderMode),((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the Clip property of this visual to the specified clip object. The Clip property restricts the rendering of the visual subtree that is rooted at this visual to a rectangular region.  </p>	
        /// </summary>	
        /// <param name="clip"><dd>  <p>The clip object to associate with this visual. This parameter can be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Setting the Clip property clips this visual along with all visuals in the subtree that is rooted at this visual. The clip is transformed by the OffsetX, OffsetY,  and Transform properties.</p><p>If the Clip property previously specified a clip rectangle, the newly specified Clip object replaces the clip rectangle.</p><p>This method fails if <em>clip</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface that created this visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p><p>If <em>clip</em> is <c>null</c>, the visual is not clipped relative to its parent. However, the visual is clipped by the clip object of the parent visual, or by the closest ancestor visual that has a clip object. Setting <em>clip</em> to <c>null</c> is similar to specifying a clip object whose clip rectangle has the left and top sides set to negative infinity, and the right and bottom sides set to positive infinity. Using a <c>null</c> clip object results in slightly better performance. </p><p>If <em>clip</em> specifies a clip object that has an empty rectangle, the visual is fully clipped; that is, the visual is included in the visual tree, but it does not render anything. To exclude a particular visual from a composition, remove the visual from the visual tree instead of setting an empty clip rectangle. Removing the visual results in better performance. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetClip']/*"/>	
        /// <msdn-id>hh449153</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetClip([In, Optional] IDCompositionClip* clip)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::SetClip</unmanaged-short>	
        public void SetClip(SharpDX.DirectComposition.Clip clip) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((clip == null)?IntPtr.Zero:clip.NativePointer),((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the Clip property of this visual to the specified clip object. The Clip property restricts the rendering of the visual subtree that is rooted at this visual to a rectangular region.  </p>	
        /// </summary>	
        /// <param name="rect"><dd>  <p>The clip object to associate with this visual. This parameter can be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Setting the Clip property clips this visual along with all visuals in the subtree that is rooted at this visual. The clip is transformed by the OffsetX, OffsetY,  and Transform properties.</p><p>If the Clip property previously specified a clip rectangle, the newly specified Clip object replaces the clip rectangle.</p><p>This method fails if <em>clip</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface that created this visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p><p>If <em>clip</em> is <c>null</c>, the visual is not clipped relative to its parent. However, the visual is clipped by the clip object of the parent visual, or by the closest ancestor visual that has a clip object. Setting <em>clip</em> to <c>null</c> is similar to specifying a clip object whose clip rectangle has the left and top sides set to negative infinity, and the right and bottom sides set to positive infinity. Using a <c>null</c> clip object results in slightly better performance. </p><p>If <em>clip</em> specifies a clip object that has an empty rectangle, the visual is fully clipped; that is, the visual is included in the visual tree, but it does not render anything. To exclude a particular visual from a composition, remove the visual from the visual tree instead of setting an empty clip rectangle. Removing the visual results in better performance. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetClip']/*"/>	
        /// <msdn-id>hh449153</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetClip([In] const D2D_RECT_F&amp; rect)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::SetClip</unmanaged-short>	
        public void SetClip(SharpDX.Mathematics.Interop.RawRectangleF rect) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &rect,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the Content property of this visual to the specified bitmap or window wrapper.</p>	
        /// </summary>	
        /// <param name="content"><dd>  <p>The object that is the new content of this visual. This parameter can be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p> The <em>content</em> parameter must point to one of the following:</p><ul> <li>An object that implements the <strong><see cref="SharpDX.DirectComposition.Surface"/></strong> interface.</li> <li>An object that implements the <strong><see cref="SharpDX.DXGI.SwapChain1"/></strong> interface.</li> <li>A wrapper object that is returned by the <strong>CreateSurfaceFromHandle</strong> or  <strong>CreateSurfaceFromHwnd</strong> method.	
        /// </li> </ul><p>The new content replaces any content that was previously associated with the visual. If the <em>content</em> parameter is <c>null</c>, the visual has no associated content.</p><p>A visual can be associated with a bitmap object or a window wrapper. A bitmap is either a Microsoft DirectX swap chain or a Microsoft DirectComposition surface.</p><p>A window wrapper is created with the <strong>CreateSurfaceFromHwnd</strong> method and is a stand-in for the rasterization of another window, which must be a top-level window or a layered child window. A window wrapper is conceptually equivalent to a bitmap that is the size of the target window on which the contents of the window are drawn. The contents include the target window's child windows (layered or otherwise), and any DirectComposition content that is drawn in the child windows. </p><p>A DirectComposition surface wrapper is created with the <strong>CreateSurfaceFromHandle</strong> method and is a reference to a swap chain. An application might use a surface wrapper in a cross-process scenario where one process creates the swap chain and another process associates the bitmap with a visual.</p><p>The bitmap is always drawn at position (0,0) relative to the visual's coordinate system, although the coordinate system is directly affected by the OffsetX, OffsetY, and Transform properties, as well as indirectly by the transformations on ancestor visuals. The bitmap of a visual is always drawn behind the children of that visual.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetContent']/*"/>	
        /// <msdn-id>hh449157</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetContent([In, Optional] IUnknown* content)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::SetContent</unmanaged-short>	
        internal void SetContent(SharpDX.ComObject content) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((content == null)?IntPtr.Zero:content.NativePointer),((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds a new child visual to the children list of this visual.</p>	
        /// </summary>	
        /// <param name="visual"><dd>  <p>The child visual to add. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <param name="insertAbove"><dd>  <p>TRUE to place the new child visual in front of the visual specified by the <em>referenceVisual</em> parameter, or <see cref="SharpDX.Result.False"/> to place it behind <em>referenceVisual</em>.</p> </dd></param>	
        /// <param name="referenceVisual"><dd>  <p>The existing child visual next to which the new visual should be added.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Child visuals are arranged in an ordered list. The contents of a child visual are drawn in front of (or above) the contents of its parent visual,  but behind (or below) the contents of its children.</p><p>The <em>referenceVisual</em> parameter must be an existing child of the parent visual, or it must be <c>null</c>. The <em>insertAbove</em> parameter indicates whether the new child should be rendered immediately above the reference visual in the Z order, or immediately below it.</p><p>If the <em>referenceVisual</em> parameter is <c>null</c>, the specified visual is rendered above or below all children of the parent visual, depending on the value of the <em>insertAbove</em> parameter. If <em>insertAbove</em> is TRUE, the new child visual is above no sibling, therefore it is rendered  below all of its siblings. Conversely, if <em>insertAbove</em> is <see cref="SharpDX.Result.False"/>, the visual is below no sibling, therefore it is rendered above all of its siblings.</p><p>The visual specified by the <em>visual</em> parameter cannot be either a child of a single other visual, or the root of a visual tree that is associated with a composition target. If <em>visual</em> is already a child of another visual, <strong>AddVisual</strong> fails. The child visual must be removed from the children list of its previous parent before adding it to the children list of the new parent. If <em>visual</em> is the root of a visual tree, the visual must be dissociated from that visual tree before adding it to the children list of the new parent. To dissociate the visual from a visual tree, call the <strong><see cref="SharpDX.DirectComposition.Target.SetRoot"/></strong> method and specify either a different visual or <c>null</c> as the <em>visual</em> parameter.</p><p>A child visual need not have been created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface as its parent. When visuals from different devices are combined in the same visual tree,  Microsoft DirectComposition composes the  tree as it normally would, except that changes to a particular visual take effect only when <strong><see cref="SharpDX.DirectComposition.Device.Commit"/></strong> is called on the device object that created the visual. The ability to combine visuals from different devices  enables multiple threads to create and manipulate a single visual tree while maintaining independent devices that can be used to commit changes asynchronously</p><p>This method fails if <em>visual</em> or <em>referenceVisual</em> is an invalid reference, or if the visual referenced by the <em>referenceVisual</em> parameter is not a child of the parent visual. These  interfaces cannot be custom implementations; only interfaces created by DirectComposition can be used with this method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::AddVisual']/*"/>	
        /// <msdn-id>hh449141</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::AddVisual([In] IDCompositionVisual* visual,[In] BOOL insertAbove,[In, Optional] IDCompositionVisual* referenceVisual)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::AddVisual</unmanaged-short>	
        public void AddVisual(SharpDX.DirectComposition.Visual visual, SharpDX.Mathematics.Interop.RawBool insertAbove, SharpDX.DirectComposition.Visual referenceVisual) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint12(_nativePointer, (void*)((visual == null)?IntPtr.Zero:visual.NativePointer), insertAbove, (void*)((referenceVisual == null)?IntPtr.Zero:referenceVisual.NativePointer),((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes a child visual from the children list of this visual.</p>	
        /// </summary>	
        /// <param name="visual"><dd>  <p>The child visual to remove from the children list. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The child visual is removed from the list of children. The order of the remaining child visuals is not changed.</p><p>This method fails if <em>visual</em> is not a child of the parent visual.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::RemoveVisual']/*"/>	
        /// <msdn-id>hh449145</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::RemoveVisual([In] IDCompositionVisual* visual)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::RemoveVisual</unmanaged-short>	
        public void RemoveVisual(SharpDX.DirectComposition.Visual visual) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((visual == null)?IntPtr.Zero:visual.NativePointer),((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes all visuals from the children list of this visual.</p>	
        /// </summary>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>This method can be called even if this visual has no children. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::RemoveAllVisuals']/*"/>	
        /// <msdn-id>hh449143</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::RemoveAllVisuals()</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::RemoveAllVisuals</unmanaged-short>	
        public void RemoveAllVisuals() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the blending mode for this visual.</p>	
        /// </summary>	
        /// <param name="compositeMode"><dd>  <p>The blending mode to use when composing the visual to the screen.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The composite mode determines how visual's bitmap is blended with the screen. By default, the visual is blended with "source over" semantics; that is, the colors are blended with per-pixel transparency.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual::SetCompositeMode']/*"/>	
        /// <msdn-id>Hh802902</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual::SetCompositeMode([In] DCOMPOSITION_COMPOSITE_MODE compositeMode)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual::SetCompositeMode</unmanaged-short>	
        internal void SetCompositeMode(SharpDX.DirectComposition.CompositeMode compositeMode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, unchecked((int)compositeMode),((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents one DirectComposition visual in a visual tree.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual2']/*"/>	
    /// <msdn-id>dn280426</msdn-id>	
    /// <unmanaged>IDCompositionVisual2</unmanaged>	
    /// <unmanaged-short>IDCompositionVisual2</unmanaged-short>	
    [Guid("E8DE1639-4331-4B26-BC5F-6A321D347A85")]
    public partial class Visual2 : SharpDX.DirectComposition.Visual {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.Visual2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Visual2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.Visual2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.Visual2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.Visual2(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the opacity mode for this visual.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The opacity mode affects how the Opacity property of an effect group object affects the composition of a visual sub-tree. DirectComposition supports two opacity modes: Layer and Multiply. In Layer mode, each visual sub-tree can be logically viewed as a bitmap that contains the opaque rasterization of that entire sub-tree, to which the opacity value is then applied. In this manner, overlapping opaque surfaces blend with the sub-tree?s background, but not with each other. In contrast, in Multiply mode the opacity is applied individually to each surface as it is composed, so surfaces blend with each other. Multiply mode is faster than Layer mode and always preferred if the visual tree contains entirely non-overlapping contents. However, Multiply mode may produce undesired visual results for overlapping elements. </p><p>By default, a visual inherits the opacity mode of its parent visual, which may inherit the opacity mode of its parent visual, and so on. A visual uses the <see cref="SharpDX.DirectComposition.OpacityMode.Layer"/> mode if this method is never called for the visual, or if this method is called with <see cref="SharpDX.DirectComposition.OpacityMode.Inherit"/>. If no visuals set the opacity mode, the default for the entire visual tree is <see cref="SharpDX.DirectComposition.OpacityMode.Layer"/>.  </p><p>If the <em>opacityMode</em> parameter is anything other than <see cref="SharpDX.DirectComposition.OpacityMode.Inherit"/>, this visual's surfaces are composed with the specified opacity mode. In addition, this opacity mode becomes the new default for the children of the current visual. That is, if the opacity mode of this visual's children is unchanged or explicitly set to <see cref="SharpDX.DirectComposition.OpacityMode.Inherit"/>, the surfaces the child visuals are composed using the opacity mode of this visual.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual2::SetOpacityMode']/*"/>	
        /// <msdn-id>dn280428</msdn-id>	
        /// <unmanaged>SetOpacityMode</unmanaged>	
        /// <unmanaged-short>SetOpacityMode</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionVisual2::SetOpacityMode([In] DCOMPOSITION_OPACITY_MODE mode)</unmanaged>
        public SharpDX.DirectComposition.OpacityMode OpacityMode {
                set { SetOpacityMode(value); }
        }
        
        /// <summary>	
        /// <p>Specifies whether or not surfaces that have 3D transformations applied to them should be displayed when facing away from the observer.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The back face visibility property affects how surfaces that have 3D transformations applied are rendered. </p><p>By default, a visual inherits the back face visibility property of its parent visual, which may inherit the back face visibility property of its parent visual, and so on. A visual uses the <see cref="SharpDX.DirectComposition.BackFaceVisibility.Visible"/> mode if this method is never called for the visual, or if this method is called with <see cref="SharpDX.DirectComposition.BackFaceVisibility.Inherit"/>. If no visuals set the back face visibility property, the default for the entire visual tree is <see cref="SharpDX.DirectComposition.BackFaceVisibility.Visible"/>.  </p><p>If the <em>visibility</em> parameter is anything other than <see cref="SharpDX.DirectComposition.BackFaceVisibility.Inherit"/>, this visual's surfaces are composed with the specified visibility mode. In addition, this visibility mode becomes the new default for the children of the current visual. That is, if the visibility mode of this visual's children is unchanged or explicitly set to <see cref="SharpDX.DirectComposition.BackFaceVisibility.Inherit"/>, the surfaces the child visuals are composed using the visibility mode of this visual.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual2::SetBackFaceVisibility']/*"/>	
        /// <msdn-id>dn280427</msdn-id>	
        /// <unmanaged>SetBackFaceVisibility</unmanaged>	
        /// <unmanaged-short>SetBackFaceVisibility</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionVisual2::SetBackFaceVisibility([In] DCOMPOSITION_BACKFACE_VISIBILITY visibility)</unmanaged>
        public SharpDX.DirectComposition.BackFaceVisibility BackFaceVisibility {
                set { SetBackFaceVisibility(value); }
        }
        
        /// <summary>	
        /// <p>Sets the opacity mode for this visual.</p>	
        /// </summary>	
        /// <param name="mode"><dd> <p> The opacity mode to use when composing the visual to the screen.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The opacity mode affects how the Opacity property of an effect group object affects the composition of a visual sub-tree. DirectComposition supports two opacity modes: Layer and Multiply. In Layer mode, each visual sub-tree can be logically viewed as a bitmap that contains the opaque rasterization of that entire sub-tree, to which the opacity value is then applied. In this manner, overlapping opaque surfaces blend with the sub-tree?s background, but not with each other. In contrast, in Multiply mode the opacity is applied individually to each surface as it is composed, so surfaces blend with each other. Multiply mode is faster than Layer mode and always preferred if the visual tree contains entirely non-overlapping contents. However, Multiply mode may produce undesired visual results for overlapping elements. </p><p>By default, a visual inherits the opacity mode of its parent visual, which may inherit the opacity mode of its parent visual, and so on. A visual uses the <see cref="SharpDX.DirectComposition.OpacityMode.Layer"/> mode if this method is never called for the visual, or if this method is called with <see cref="SharpDX.DirectComposition.OpacityMode.Inherit"/>. If no visuals set the opacity mode, the default for the entire visual tree is <see cref="SharpDX.DirectComposition.OpacityMode.Layer"/>.  </p><p>If the <em>opacityMode</em> parameter is anything other than <see cref="SharpDX.DirectComposition.OpacityMode.Inherit"/>, this visual's surfaces are composed with the specified opacity mode. In addition, this opacity mode becomes the new default for the children of the current visual. That is, if the opacity mode of this visual's children is unchanged or explicitly set to <see cref="SharpDX.DirectComposition.OpacityMode.Inherit"/>, the surfaces the child visuals are composed using the opacity mode of this visual.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual2::SetOpacityMode']/*"/>	
        /// <msdn-id>dn280428</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual2::SetOpacityMode([In] DCOMPOSITION_OPACITY_MODE mode)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual2::SetOpacityMode</unmanaged-short>	
        internal void SetOpacityMode(SharpDX.DirectComposition.OpacityMode mode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, unchecked((int)mode),((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies whether or not surfaces that have 3D transformations applied to them should be displayed when facing away from the observer.</p>	
        /// </summary>	
        /// <param name="visibility"><dd> <p>The back face visibility to use when composing surfaces in this visual?s sub-tree to the screen.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>The back face visibility property affects how surfaces that have 3D transformations applied are rendered. </p><p>By default, a visual inherits the back face visibility property of its parent visual, which may inherit the back face visibility property of its parent visual, and so on. A visual uses the <see cref="SharpDX.DirectComposition.BackFaceVisibility.Visible"/> mode if this method is never called for the visual, or if this method is called with <see cref="SharpDX.DirectComposition.BackFaceVisibility.Inherit"/>. If no visuals set the back face visibility property, the default for the entire visual tree is <see cref="SharpDX.DirectComposition.BackFaceVisibility.Visible"/>.  </p><p>If the <em>visibility</em> parameter is anything other than <see cref="SharpDX.DirectComposition.BackFaceVisibility.Inherit"/>, this visual's surfaces are composed with the specified visibility mode. In addition, this visibility mode becomes the new default for the children of the current visual. That is, if the visibility mode of this visual's children is unchanged or explicitly set to <see cref="SharpDX.DirectComposition.BackFaceVisibility.Inherit"/>, the surfaces the child visuals are composed using the visibility mode of this visual.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual2::SetBackFaceVisibility']/*"/>	
        /// <msdn-id>dn280427</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual2::SetBackFaceVisibility([In] DCOMPOSITION_BACKFACE_VISIBILITY visibility)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual2::SetBackFaceVisibility</unmanaged-short>	
        internal void SetBackFaceVisibility(SharpDX.DirectComposition.BackFaceVisibility visibility) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, unchecked((int)visibility),((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents one DirectComposition visual in a visual tree.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual3']/*"/>	
    /// <msdn-id>dn904490</msdn-id>	
    /// <unmanaged>IDCompositionVisual3</unmanaged>	
    /// <unmanaged-short>IDCompositionVisual3</unmanaged-short>	
    [Guid("2775F462-B6C1-4015-B0BE-B3E7D6A4976D")]
    public partial class Visual3 : SharpDX.DirectComposition.VisualDebug {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.Visual3"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Visual3(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.Visual3"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.Visual3(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.Visual3(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Represents one DirectComposition visual in a visual tree.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual3::SetDepthMode']/*"/>	
        /// <msdn-id>dn904490</msdn-id>	
        /// <unmanaged>SetDepthMode</unmanaged>	
        /// <unmanaged-short>SetDepthMode</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionVisual3::SetDepthMode([In] DCOMPOSITION_DEPTH_MODE mode)</unmanaged>
        public SharpDX.DirectComposition.DepthMode DepthMode {
                set { SetDepthMode(value); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual3::SetOffsetZ']/*"/>	
        /// <unmanaged>SetOffsetZ</unmanaged>	
        /// <unmanaged-short>SetOffsetZ</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionVisual3::SetOffsetZ([In] float offsetZ)</unmanaged>
        public float OffsetZ {
                set { SetOffsetZ(value); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual3::SetOpacity']/*"/>	
        /// <unmanaged>SetOpacity</unmanaged>	
        /// <unmanaged-short>SetOpacity</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionVisual3::SetOpacity([In] float opacity)</unmanaged>
        public float Opacity {
                set { SetOpacity(value); }
        }
        
        /// <summary>	
        /// <p>Sets the Transform property of this visual to the specified 3D transform object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Setting the Transform property transforms the coordinate system of the entire visual subtree that is rooted at this visual. If the Clip property of this visual is specified, the clip rectangle is also transformed. </p><p>If the Transform property previously specified a transform matrix, the newly specified transform object replaces the transform matrix.</p><p>A transformation specified by the Transform property is applied after the OffsetX and OffsetY properties. In other words, the effect of setting the Transform property and the OffsetX and OffsetY properties is the same as setting only the Transform property on a transform group where the first member of the group is an <strong><see cref="SharpDX.DirectComposition.TranslateTransform"/></strong> object that has those same OffsetX and OffsetY values. However, you should use the <strong><see cref="SharpDX.DirectComposition.Visual.SetOffsetX"/></strong> and <strong>SetOffsetY</strong> methods whenever possible because they are slightly faster. </p><p>This method fails if <em>transform</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface that created this visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p><p>If the <em>transform</em> parameter is <c>null</c>, the coordinate system of this visual is transformed only by its OffsetX and OffsetY properties. Setting the Transform property to <c>null</c> is equivalent to setting it to an <strong><see cref="SharpDX.DirectComposition.MatrixTransform"/></strong> object where the specified matrix is the identity matrix. However, an application should set the Transform property to <c>null</c> whenever possible because it is slightly faster.</p><p>If the OffsetX and OffsetY properties are set to 0, and the Transform property is set to <c>null</c>, the coordinate system of the visual is the same as that of its parent.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual3::SetTransform']/*"/>	
        /// <msdn-id>dn904493</msdn-id>	
        /// <unmanaged>SetTransform</unmanaged>	
        /// <unmanaged-short>SetTransform</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionVisual3::SetTransform([In] const D2D_MATRIX_4X4_F& matrix)</unmanaged>
        public SharpDX.Mathematics.Interop.RawMatrix Transform {
                set { SetTransform(ref value); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual3::SetVisible']/*"/>	
        /// <unmanaged>SetVisible</unmanaged>	
        /// <unmanaged-short>SetVisible</unmanaged-short>	
        /// <unmanaged>HRESULT IDCompositionVisual3::SetVisible([In] BOOL visible)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool Visible {
                set { SetVisible(value); }
        }
        
        /// <summary>	
        /// <p>Represents one DirectComposition visual in a visual tree.</p>	
        /// </summary>	
        /// <param name="mode">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual3::SetDepthMode']/*"/>	
        /// <msdn-id>dn904490</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual3::SetDepthMode([In] DCOMPOSITION_DEPTH_MODE mode)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual3::SetDepthMode</unmanaged-short>	
        internal void SetDepthMode(SharpDX.DirectComposition.DepthMode mode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, unchecked((int)mode),((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="animation">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual3::SetOffsetZ']/*"/>	
        /// <unmanaged>HRESULT IDCompositionVisual3::SetOffsetZ([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual3::SetOffsetZ</unmanaged-short>	
        public void SetOffsetZ(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="offsetZ">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual3::SetOffsetZ']/*"/>	
        /// <unmanaged>HRESULT IDCompositionVisual3::SetOffsetZ([In] float offsetZ)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual3::SetOffsetZ</unmanaged-short>	
        internal void SetOffsetZ(float offsetZ) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, offsetZ,((void**)(*(void**)_nativePointer))[28]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="animation">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual3::SetOpacity']/*"/>	
        /// <unmanaged>HRESULT IDCompositionVisual3::SetOpacity([In] IDCompositionAnimation* animation)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual3::SetOpacity</unmanaged-short>	
        public void SetOpacity(SharpDX.DirectComposition.Animation animation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((animation == null)?IntPtr.Zero:animation.NativePointer),((void**)(*(void**)_nativePointer))[29]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="opacity">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual3::SetOpacity']/*"/>	
        /// <unmanaged>HRESULT IDCompositionVisual3::SetOpacity([In] float opacity)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual3::SetOpacity</unmanaged-short>	
        internal void SetOpacity(float opacity) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, opacity,((void**)(*(void**)_nativePointer))[30]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the Transform property of this visual to the specified 3D transform object.</p>	
        /// </summary>	
        /// <param name="transform"><dd>  <p>The transform object that is used to modify  the coordinate system of this visual. This parameter can point to  an <strong><see cref="SharpDX.DirectComposition.Transform"/></strong> interface or one of its derived interfaces. This parameter can be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Setting the Transform property transforms the coordinate system of the entire visual subtree that is rooted at this visual. If the Clip property of this visual is specified, the clip rectangle is also transformed. </p><p>If the Transform property previously specified a transform matrix, the newly specified transform object replaces the transform matrix.</p><p>A transformation specified by the Transform property is applied after the OffsetX and OffsetY properties. In other words, the effect of setting the Transform property and the OffsetX and OffsetY properties is the same as setting only the Transform property on a transform group where the first member of the group is an <strong><see cref="SharpDX.DirectComposition.TranslateTransform"/></strong> object that has those same OffsetX and OffsetY values. However, you should use the <strong><see cref="SharpDX.DirectComposition.Visual.SetOffsetX"/></strong> and <strong>SetOffsetY</strong> methods whenever possible because they are slightly faster. </p><p>This method fails if <em>transform</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface that created this visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p><p>If the <em>transform</em> parameter is <c>null</c>, the coordinate system of this visual is transformed only by its OffsetX and OffsetY properties. Setting the Transform property to <c>null</c> is equivalent to setting it to an <strong><see cref="SharpDX.DirectComposition.MatrixTransform"/></strong> object where the specified matrix is the identity matrix. However, an application should set the Transform property to <c>null</c> whenever possible because it is slightly faster.</p><p>If the OffsetX and OffsetY properties are set to 0, and the Transform property is set to <c>null</c>, the coordinate system of the visual is the same as that of its parent.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual3::SetTransform']/*"/>	
        /// <msdn-id>dn904493</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual3::SetTransform([In, Optional] IDCompositionTransform3D* transform)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual3::SetTransform</unmanaged-short>	
        public void SetTransform(SharpDX.DirectComposition.Transform3D transform) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, (void*)((transform == null)?IntPtr.Zero:transform.NativePointer),((void**)(*(void**)_nativePointer))[31]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the Transform property of this visual to the specified 3D transform object.</p>	
        /// </summary>	
        /// <param name="matrix"><dd>  <p>The transform object that is used to modify  the coordinate system of this visual. This parameter can point to  an <strong><see cref="SharpDX.DirectComposition.Transform"/></strong> interface or one of its derived interfaces. This parameter can be <c>null</c>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Setting the Transform property transforms the coordinate system of the entire visual subtree that is rooted at this visual. If the Clip property of this visual is specified, the clip rectangle is also transformed. </p><p>If the Transform property previously specified a transform matrix, the newly specified transform object replaces the transform matrix.</p><p>A transformation specified by the Transform property is applied after the OffsetX and OffsetY properties. In other words, the effect of setting the Transform property and the OffsetX and OffsetY properties is the same as setting only the Transform property on a transform group where the first member of the group is an <strong><see cref="SharpDX.DirectComposition.TranslateTransform"/></strong> object that has those same OffsetX and OffsetY values. However, you should use the <strong><see cref="SharpDX.DirectComposition.Visual.SetOffsetX"/></strong> and <strong>SetOffsetY</strong> methods whenever possible because they are slightly faster. </p><p>This method fails if <em>transform</em> is an invalid reference or if it was not created by the same <strong><see cref="SharpDX.DirectComposition.Device"/></strong> interface that created this visual. The interface cannot be a custom implementation; only interfaces created by Microsoft DirectComposition can be used with this method.	
        /// </p><p>If the <em>transform</em> parameter is <c>null</c>, the coordinate system of this visual is transformed only by its OffsetX and OffsetY properties. Setting the Transform property to <c>null</c> is equivalent to setting it to an <strong><see cref="SharpDX.DirectComposition.MatrixTransform"/></strong> object where the specified matrix is the identity matrix. However, an application should set the Transform property to <c>null</c> whenever possible because it is slightly faster.</p><p>If the OffsetX and OffsetY properties are set to 0, and the Transform property is set to <c>null</c>, the coordinate system of the visual is the same as that of its parent.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual3::SetTransform']/*"/>	
        /// <msdn-id>dn904493</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisual3::SetTransform([In] const D2D_MATRIX_4X4_F&amp; matrix)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual3::SetTransform</unmanaged-short>	
        internal void SetTransform(ref SharpDX.Mathematics.Interop.RawMatrix matrix) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* matrix_ = &matrix)
                    __result__= 
    				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, matrix_,((void**)(*(void**)_nativePointer))[32]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="visible">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisual3::SetVisible']/*"/>	
        /// <unmanaged>HRESULT IDCompositionVisual3::SetVisible([In] BOOL visible)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisual3::SetVisible</unmanaged-short>	
        internal void SetVisible(SharpDX.Mathematics.Interop.RawBool visible) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint9(_nativePointer, visible,((void**)(*(void**)_nativePointer))[33]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a debug visual.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisualDebug']/*"/>	
    /// <msdn-id>dn280429</msdn-id>	
    /// <unmanaged>IDCompositionVisualDebug</unmanaged>	
    /// <unmanaged-short>IDCompositionVisualDebug</unmanaged-short>	
    [Guid("FED2B808-5EB4-43A0-AEA3-35F65280F91B")]
    public partial class VisualDebug : SharpDX.DirectComposition.Visual2 {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectComposition.VisualDebug"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VisualDebug(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectComposition.VisualDebug"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.DirectComposition.VisualDebug(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectComposition.VisualDebug(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Enables a visual heatmap that represents overdraw regions.</p>	
        /// </summary>	
        /// <param name="color"><dd></dd></param>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Heatmaps can be enabled by calling <strong>EnableHeatMap</strong>. The heatmaps are drawn on the source of the VisualDebug visual and child visuals. The heatmaps are represented in a specified color for all visual content. The heatmap color must have an transparency in order to see the overlaying overdraw regions. The colored surfaces are blended together to visually show all overdraw regions in a single view. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisualDebug::EnableHeatMap']/*"/>	
        /// <msdn-id>dn280432</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisualDebug::EnableHeatMap([In] const D2D_COLOR_F&amp; color)</unmanaged>	
        /// <unmanaged-short>IDCompositionVisualDebug::EnableHeatMap</unmanaged-short>	
        public void EnableHeatMap(SharpDX.Mathematics.Interop.RawColor4 color) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer, &color,((void**)(*(void**)_nativePointer))[22]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Disables visual heatmaps.</p>	
        /// </summary>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisualDebug::DisableHeatMap']/*"/>	
        /// <msdn-id>dn280430</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisualDebug::DisableHeatMap()</unmanaged>	
        /// <unmanaged-short>IDCompositionVisualDebug::DisableHeatMap</unmanaged-short>	
        public void DisableHeatMap() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[23]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Enables highlighting visuals when content is being redrawn.</p>	
        /// </summary>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <remarks>	
        /// <p>Highlighting redraw regions can be enabled by calling <strong>EnableRedrawRegions</strong>.  With this function, redrawn client areas are visually highlighted every frame the visual is updated. Redraw regions are drawn on the source of the VisualDebug and child visuals. Redraw is triggered when properties of a visual are updated. The updated visusal does not neccessarly need to visually change to trigger a redraw. The highlighting will cycle through Blue, Yellow, Pink and Green to provide an order of which content is being updated. The redraw regions are only visible while the window of the VisualDebug is being updated. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisualDebug::EnableRedrawRegions']/*"/>	
        /// <msdn-id>dn280433</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisualDebug::EnableRedrawRegions()</unmanaged>	
        /// <unmanaged-short>IDCompositionVisualDebug::EnableRedrawRegions</unmanaged-short>	
        public void EnableRedrawRegions() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[24]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Disables visual redraw regions.</p>	
        /// </summary>	
        /// <returns><p>If the function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. See DirectComposition Error Codes for a list of error codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDCompositionVisualDebug::DisableRedrawRegions']/*"/>	
        /// <msdn-id>dn280431</msdn-id>	
        /// <unmanaged>HRESULT IDCompositionVisualDebug::DisableRedrawRegions()</unmanaged>	
        /// <unmanaged-short>IDCompositionVisualDebug::DisableRedrawRegions</unmanaged-short>	
        public void DisableRedrawRegions() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.DirectComposition.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[25]);		
                __result__.CheckError();
            }
        }
    }
}
