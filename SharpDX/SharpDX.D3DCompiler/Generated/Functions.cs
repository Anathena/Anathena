// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.D3DCompiler namespace.
//     This code was generated by a tool.
//     Date : 6/25/2016 10:38:14 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.D3DCompiler {

#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574

        /// <summary>	
        /// Functions	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.D3DCompiler.D3D']/*"/>	
    static  partial class D3D {   
        
        /// <summary>	
        /// <p>Retrieves a specific part from a compilation result.</p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd>  <p>A reference to uncompiled shader data; either ASCII HLSL code or a compiled effect.</p> </dd></param>	
        /// <param name="srcDataSize"><dd>  <p>Length of uncompiled shader data that <em>pSrcData</em> points to.</p> </dd></param>	
        /// <param name="part"><dd>  <p>A <strong><see cref="SharpDX.D3DCompiler.ShaderBytecodePart"/></strong>-typed value that specifies the part of the buffer to retrieve.</p> </dd></param>	
        /// <param name="flags"><dd>  <p>Flags that indicate how to retrieve the blob part. Currently, no flags are defined.</p> </dd></param>	
        /// <param name="partOut"><dd>  <p>The address of a reference to the <strong>ID3DBlob</strong> interface that is used to retrieve the specified part of the buffer.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.D3DCompiler.D3D.GetBlobPart"/></strong> retrieves the part of a blob (arbitrary length data buffer) that contains the type of data that the  <em>Part</em> parameter specifies.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DGetBlobPart']/*"/>	
        /// <msdn-id>ff728674</msdn-id>	
        /// <unmanaged>HRESULT D3DGetBlobPart([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] D3D_BLOB_PART Part,[In] unsigned int Flags,[Out] ID3D10Blob** ppPart)</unmanaged>	
        /// <unmanaged-short>D3DGetBlobPart</unmanaged-short>	
        public static void GetBlobPart(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, SharpDX.D3DCompiler.ShaderBytecodePart part, int flags, out SharpDX.Direct3D.Blob partOut) {
            unsafe {
                IntPtr partOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DGetBlobPart_((void*)srcDataRef, (void*)srcDataSize, unchecked((int)part), flags, &partOut_);		
                partOut= (partOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(partOut_);	
                __result__.CheckError();
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DGetBlobPart", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DGetBlobPart_(void* arg0,void* arg1,int arg2,int arg3,void* arg4);
        
        /// <summary>	
        /// <p>Compiles Microsoft High Level Shader Language (HLSL) code into bytecode for a given target.</p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd>  <p>A reference to uncompiled shader data (ASCII HLSL code).</p> </dd></param>	
        /// <param name="srcDataSize"><dd>  <p>The size, in bytes, of the block of memory that <em>pSrcData</em> points to.</p> </dd></param>	
        /// <param name="sourceNameRef"><dd>  <p>An optional reference to a constant null-terminated string containing the name that identifies the source data to use in error messages. If not used, set to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="definesRef"><dd>  <p>An optional array of <strong><see cref="SharpDX.Direct3D.ShaderMacro"/></strong> structures that define shader macros. Each macro definition contains a name and a <c>null</c>-terminated definition. If not used, set to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="includeRef"><dd>  <p> An optional reference to an <strong><see cref="SharpDX.D3DCompiler.Include"/></strong> interface that the compiler uses to handle include files. If you set this parameter to <strong><c>null</c></strong> and the shader contains a #include, a compile error occurs. You can pass the <strong>D3D_COMPILE_STANDARD_FILE_INCLUDE</strong> macro, which is a reference to a default include handler. This default include handler includes files that are relative to the current directory and files that are relative to the directory of the initial source file. When you use <strong>D3D_COMPILE_STANDARD_FILE_INCLUDE</strong>, you must specify the source file name in the <em>pSourceName</em> parameter; the compiler will derive the initial relative directory from <em>pSourceName</em>.</p>  <pre>#define D3D_COMPILE_STANDARD_FILE_INCLUDE ((<see cref="SharpDX.D3DCompiler.Include"/>*)(<see cref="System.IntPtr"/>)1)</pre>  </dd></param>	
        /// <param name="entrypointRef"><dd>  <p>A reference to a constant null-terminated string that contains  the name of the shader entry point function where shader execution begins. When you compile an effect, <strong><see cref="SharpDX.D3DCompiler.D3D.Compile2"/></strong> ignores <em>pEntrypoint</em>; we recommend that you set <em>pEntrypoint</em> to <strong><c>null</c></strong> because it is good programming practice to set a reference parameter to <strong><c>null</c></strong> if the called function will not use it.</p> </dd></param>	
        /// <param name="targetRef"><dd>  <p>A reference to a constant null-terminated string that specifies the shader target or set of shader features to compile against. The shader target can be a shader model (for example, shader model 2, shader model 3, shader model 4, or shader model 5). The target can also be an effect type (for example, fx_4_1). For info about the targets that various profiles support, see Specifying Compiler Targets. </p> </dd></param>	
        /// <param name="flags1"><dd>  <p>A combination of shader <strong>compile options</strong> that are combined by using a bitwise <strong>OR</strong> operation. The resulting value specifies how the compiler compiles the HLSL code.</p> </dd></param>	
        /// <param name="flags2"><dd>  <p>A combination of effect <strong>compile options</strong> that are combined by using a bitwise <strong>OR</strong> operation. The resulting value specifies how the compiler compiles the effect. When you compile a shader and not an effect file, <strong><see cref="SharpDX.D3DCompiler.D3D.Compile2"/></strong> ignores <em>Flags2</em>; we recommend that you set <em>Flags2</em> to zero because it is good programming practice to set a nonreference parameter to zero if the called function will not use it.</p> </dd></param>	
        /// <param name="secondaryDataFlags"><dd>  <p>A combination of the following flags that are combined by using a bitwise <strong>OR</strong> operation. The resulting value specifies how the compiler compiles the HLSL code. </p> <table> <tr><th>Flag</th><th>Description</th></tr> <tr><td><see cref="SharpDX.D3DCompiler.SecondaryDataFlags.MergeUnorderedAccessViewSlots"/> (0x01)</td><td>Merge unordered access view (UAV) slots in the secondary data that the <em>pSecondaryData</em> parameter points to.</td></tr> <tr><td><see cref="SharpDX.D3DCompiler.SecondaryDataFlags.PreserveTemplateSlots"/> (0x02)</td><td>Preserve template slots in the secondary data that the <em>pSecondaryData</em> parameter points to.</td></tr> <tr><td><see cref="SharpDX.D3DCompiler.SecondaryDataFlags.RequireTemplateMatch"/> (0x04)</td><td>Require that templates in the secondary data that the <em>pSecondaryData</em> parameter points to match when the compiler compiles the HLSL code.</td></tr> </table> <p>?</p> <p>If <em>pSecondaryData</em> is <strong><c>null</c></strong>, set to zero.</p> </dd></param>	
        /// <param name="secondaryDataRef"><dd>  <p>An optional reference to secondary data. If you do not pass secondary data, set to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="secondaryDataSize"><dd>  <p>The size, in bytes, of the block of memory that <em>pSecondaryData</em> points to. If <em>pSecondaryData</em> is <strong><c>null</c></strong>, set to zero.</p> </dd></param>	
        /// <param name="codeOut"><dd>  <p>A reference to a variable that receives a reference to the <strong>ID3DBlob</strong> interface that you can use to access the compiled code.</p> </dd></param>	
        /// <param name="errorMsgsOut"><dd>  <p>An optional reference to a variable that receives a reference to the <strong>ID3DBlob</strong> interface that you can use to access compiler error messages, or <strong><c>null</c></strong> if there are no errors.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??The D3dcompiler_44.dll or later version of the file contains the <strong><see cref="SharpDX.D3DCompiler.D3D.Compile2"/></strong> compiler function.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DCompile2']/*"/>	
        /// <msdn-id>hh446869</msdn-id>	
        /// <unmanaged>HRESULT D3DCompile2([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In, Optional] const char* pSourceName,[In, Buffer, Optional] const D3D_SHADER_MACRO* pDefines,[In, Optional] ID3DInclude* pInclude,[In] const char* pEntrypoint,[In] const char* pTarget,[In] D3DCOMPILE_SHADER_FLAGS Flags1,[In] D3DCOMPILE_EFFECT_FLAGS Flags2,[In] D3DCOMPILE_SECDATA_FLAGS SecondaryDataFlags,[In, Buffer, Optional] const void* pSecondaryData,[In] SIZE_T SecondaryDataSize,[Out] ID3D10Blob** ppCode,[Out, Optional] ID3D10Blob** ppErrorMsgs)</unmanaged>	
        /// <unmanaged-short>D3DCompile2</unmanaged-short>	
        public static SharpDX.Result Compile2(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, string sourceNameRef, SharpDX.Direct3D.ShaderMacro[] definesRef, System.IntPtr includeRef, string entrypointRef, string targetRef, SharpDX.D3DCompiler.ShaderFlags flags1, SharpDX.D3DCompiler.EffectFlags flags2, SharpDX.D3DCompiler.SecondaryDataFlags secondaryDataFlags, System.IntPtr secondaryDataRef, SharpDX.PointerSize secondaryDataSize, out SharpDX.Direct3D.Blob codeOut, out SharpDX.Direct3D.Blob errorMsgsOut) {
            unsafe {
                IntPtr sourceNameRef_ = Utilities.StringToHGlobalAnsi(sourceNameRef);
                SharpDX.Direct3D.ShaderMacro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D.ShaderMacro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr entrypointRef_ = Utilities.StringToHGlobalAnsi(entrypointRef);
                IntPtr targetRef_ = Utilities.StringToHGlobalAnsi(targetRef);
                IntPtr codeOut_ = IntPtr.Zero;
                IntPtr errorMsgsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DCompile2_((void*)srcDataRef, (void*)srcDataSize, (void*)sourceNameRef_, definesRef_, (void*)includeRef, (void*)entrypointRef_, (void*)targetRef_, unchecked((int)flags1), unchecked((int)flags2), unchecked((int)secondaryDataFlags), (void*)secondaryDataRef, (void*)secondaryDataSize, &codeOut_, &errorMsgsOut_);		
                Marshal.FreeHGlobal(sourceNameRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                Marshal.FreeHGlobal(entrypointRef_ );
                Marshal.FreeHGlobal(targetRef_ );
                codeOut= (codeOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(codeOut_);	
                errorMsgsOut= (errorMsgsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorMsgsOut_);	
                return __result__;
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DCompile2", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DCompile2_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,void* arg5,void* arg6,int arg7,int arg8,int arg9,void* arg10,void* arg11,void* arg12,void* arg13);
        
        /// <summary>	
        /// <p><strong>Note</strong>??You can use this API to develop your Windows Store apps, but you can't use it in apps that you submit to the Windows Store.</p><p>Gets shader debug information.</p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd>  <p>A reference to source data; either uncompiled or compiled HLSL code.</p> </dd></param>	
        /// <param name="srcDataSize"><dd>  <p>Length of <em>pSrcData</em>.</p> </dd></param>	
        /// <param name="debugInfoOut"><dd>  <p>A reference to a buffer that receives the <strong>ID3DBlob</strong> interface that contains debug information.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <remarks>	
        /// <p>Debug information is embedded in the body of the shader after calling <strong><see cref="SharpDX.D3DCompiler.D3D.Compile"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DGetDebugInfo']/*"/>	
        /// <msdn-id>dd607328</msdn-id>	
        /// <unmanaged>HRESULT D3DGetDebugInfo([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[Out] ID3D10Blob** ppDebugInfo)</unmanaged>	
        /// <unmanaged-short>D3DGetDebugInfo</unmanaged-short>	
        public static void GetDebugInfo(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, out SharpDX.Direct3D.Blob debugInfoOut) {
            unsafe {
                IntPtr debugInfoOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DGetDebugInfo_((void*)srcDataRef, (void*)srcDataSize, &debugInfoOut_);		
                debugInfoOut= (debugInfoOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(debugInfoOut_);	
                __result__.CheckError();
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DGetDebugInfo", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DGetDebugInfo_(void* arg0,void* arg1,void* arg2);
        
        /// <summary>	
        /// <p>Disassembles a specific region of compiled Microsoft High Level Shader Language (HLSL) code.</p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd> <p>A reference to compiled shader data.</p> </dd></param>	
        /// <param name="srcDataSize"><dd> <p>The size, in bytes, of the block of memory that <em>pSrcData</em> points to.</p> </dd></param>	
        /// <param name="flags"><dd> <p>A combination of zero or more of the following flags that are combined by using a bitwise <strong>OR</strong> operation. The resulting value specifies how <strong><see cref="SharpDX.D3DCompiler.D3D.DisassembleRegion"/></strong> disassembles the compiled shader data.</p> <table> <tr><th>Flag</th><th>Description</th></tr> <tr><td><see cref="SharpDX.D3DCompiler.DisassemblyFlags.EnableColorCode"/> (0x01)</td><td>Enable the output of color codes.</td></tr> <tr><td><see cref="SharpDX.D3DCompiler.DisassemblyFlags.EnableDefaultValuePrints"/> (0x02)</td><td>Enable the output of default values.</td></tr> <tr><td><see cref="SharpDX.D3DCompiler.DisassemblyFlags.EnableInstructionNumbering"/> (0x04)</td><td>Enable instruction numbering.</td></tr> <tr><td><see cref="SharpDX.D3DCompiler.DisassemblyFlags.EnableInstructionCycle"/> (0x08)</td><td>No effect.</td></tr> <tr><td><see cref="SharpDX.D3DCompiler.DisassemblyFlags.DisableDebugInformation"/> (0x10)</td><td>Disable the output of debug information.</td></tr> <tr><td><see cref="SharpDX.D3DCompiler.DisassemblyFlags.EnableInstructionOffset"/> (0x20)</td><td>Enable the output of instruction offsets.</td></tr> <tr><td><see cref="SharpDX.D3DCompiler.DisassemblyFlags.InstructionOnly"/> (0x40)</td><td>This flag has no effect in <strong><see cref="SharpDX.D3DCompiler.D3D.DisassembleRegion"/></strong>. Cycle information comes from the trace; therefore, cycle information is available only in <strong>D3DDisassemble11Trace</strong>'s trace disassembly.</td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="szComments"><dd> <p>An optional reference to a constant null-terminated string at the top of the shader that identifies the shader constants and variables.</p> </dd></param>	
        /// <param name="startByteOffset"><dd> <p>The number of bytes offset into the compiled shader data where <strong><see cref="SharpDX.D3DCompiler.D3D.DisassembleRegion"/></strong> starts the disassembly.</p> </dd></param>	
        /// <param name="numInsts"><dd> <p>The number of instructions to disassemble.</p> </dd></param>	
        /// <param name="finishByteOffsetRef"><dd> <p>A reference to a variable that receives the number of bytes offset into the compiled shader data where <strong><see cref="SharpDX.D3DCompiler.D3D.DisassembleRegion"/></strong> finishes the disassembly.</p> </dd></param>	
        /// <param name="disassemblyOut"><dd> <p>A reference to a buffer that receives the <strong>ID3DBlob</strong> interface that accesses the disassembled HLSL code.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??The D3dcompiler_44.dll or later version of the file contains the <strong><see cref="SharpDX.D3DCompiler.D3D.DisassembleRegion"/></strong> compiler function.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DDisassembleRegion']/*"/>	
        /// <msdn-id>Hh706344</msdn-id>	
        /// <unmanaged>HRESULT D3DDisassembleRegion([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] unsigned int Flags,[In, Optional] const char* szComments,[In] SIZE_T StartByteOffset,[In] SIZE_T NumInsts,[Out, Optional] SIZE_T* pFinishByteOffset,[Out] ID3D10Blob** ppDisassembly)</unmanaged>	
        /// <unmanaged-short>D3DDisassembleRegion</unmanaged-short>	
        public static void DisassembleRegion(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, int flags, string szComments, SharpDX.PointerSize startByteOffset, SharpDX.PointerSize numInsts, out SharpDX.PointerSize finishByteOffsetRef, out SharpDX.Direct3D.Blob disassemblyOut) {
            unsafe {
                IntPtr szComments_ = Utilities.StringToHGlobalAnsi(szComments);
                finishByteOffsetRef = new SharpDX.PointerSize();
                IntPtr disassemblyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* finishByteOffsetRef_ = &finishByteOffsetRef)
                    __result__= 
    				D3DDisassembleRegion_((void*)srcDataRef, (void*)srcDataSize, flags, (void*)szComments_, (void*)startByteOffset, (void*)numInsts, finishByteOffsetRef_, &disassemblyOut_);		
                Marshal.FreeHGlobal(szComments_ );
                disassemblyOut= (disassemblyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(disassemblyOut_);	
                __result__.CheckError();
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DDisassembleRegion", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DDisassembleRegion_(void* arg0,void* arg1,int arg2,void* arg3,void* arg4,void* arg5,void* arg6,void* arg7);
        
        /// <summary>	
        /// <p><strong>Note</strong>??You can use this API to develop your Windows Store apps, but you can't use it in apps that you submit to the Windows Store.</p><p>Decompresses one or more shaders from a compressed set. </p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd>  <p>A reference to uncompiled shader data; either ASCII HLSL code or a compiled effect.</p> </dd></param>	
        /// <param name="srcDataSize"><dd>  <p>Length of uncompiled shader data that <em>pSrcData</em> points to.</p> </dd></param>	
        /// <param name="uNumShaders"><dd>  <p>The number of shaders to decompress.</p> </dd></param>	
        /// <param name="uStartIndex"><dd>  <p>The index of the first shader to decompress.</p> </dd></param>	
        /// <param name="indicesRef"><dd>  <p>An array of indexes that represent the shaders to decompress.</p> </dd></param>	
        /// <param name="uFlags"><dd>  <p>Flags that indicate how to decompress. Currently, no flags are defined.</p> </dd></param>	
        /// <param name="shadersOut"><dd>  <p>The address of a reference to the <strong>ID3DBlob</strong> interface that is used to retrieve the decompressed shader data.</p> </dd></param>	
        /// <param name="totalShadersRef"><dd>  <p>A reference to a variable that receives the total number of shaders that  <strong><see cref="SharpDX.D3DCompiler.D3D.DecompressShaders"/></strong> decompressed.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DDecompressShaders']/*"/>	
        /// <msdn-id>ff728673</msdn-id>	
        /// <unmanaged>HRESULT D3DDecompressShaders([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] unsigned int uNumShaders,[In] unsigned int uStartIndex,[In, Buffer, Optional] unsigned int* pIndices,[In] unsigned int uFlags,[Out, Buffer] ID3D10Blob** ppShaders,[Out, Optional] unsigned int* pTotalShaders)</unmanaged>	
        /// <unmanaged-short>D3DDecompressShaders</unmanaged-short>	
        public static void DecompressShaders(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, int uNumShaders, int uStartIndex, int[] indicesRef, int uFlags, SharpDX.Direct3D.Blob[] shadersOut, out int totalShadersRef) {
            unsafe {
                int[] indicesRef__ = indicesRef;
                IntPtr* shadersOut_ = stackalloc IntPtr[shadersOut.Length];
                SharpDX.Result __result__;
                fixed (void* indicesRef_ = indicesRef__)
                    fixed (void* totalShadersRef_ = &totalShadersRef)
                        __result__= 
        				D3DDecompressShaders_((void*)srcDataRef, (void*)srcDataSize, uNumShaders, uStartIndex, indicesRef_, uFlags, shadersOut_, totalShadersRef_);		
                for (int i = 0; i < shadersOut.Length; i++)
                    shadersOut[i] = (shadersOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(shadersOut_[i]);	
                __result__.CheckError();
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DDecompressShaders", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DDecompressShaders_(void* arg0,void* arg1,int arg2,int arg3,void* arg4,int arg5,void* arg6,void* arg7);
        
        /// <summary>	
        /// <p>Disassembles compiled HLSL code.</p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd>  <p>A reference to source data as compiled HLSL code.</p> </dd></param>	
        /// <param name="srcDataSize"><dd>  <p>Length of <em>pSrcData</em>.</p> </dd></param>	
        /// <param name="flags"><dd>  <p>Flags affecting the behavior of <strong><see cref="SharpDX.D3DCompiler.D3D.Disassemble"/></strong>.  <em>Flags</em> can be a combination of zero or more of the following values. </p> <table> <tr><th>Flag</th><th>Description</th></tr> <tr><td><see cref="SharpDX.D3DCompiler.DisassemblyFlags.EnableColorCode"/></td><td>Enable the output of color codes.</td></tr> <tr><td><see cref="SharpDX.D3DCompiler.DisassemblyFlags.EnableDefaultValuePrints"/></td><td>Enable the output of default values.</td></tr> <tr><td><see cref="SharpDX.D3DCompiler.DisassemblyFlags.EnableInstructionNumbering"/></td><td>Enable instruction numbering.</td></tr> <tr><td><see cref="SharpDX.D3DCompiler.DisassemblyFlags.EnableInstructionCycle"/></td><td>No effect.</td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="szComments"><dd>  <p>The optional comment string at the top of the shader that identifies the shader constants and variables.</p> </dd></param>	
        /// <param name="disassemblyOut"><dd>  <p>A reference to a buffer that receives the <strong>ID3DBlob</strong> interface that accesses assembly text.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DDisassemble']/*"/>	
        /// <msdn-id>dd607326</msdn-id>	
        /// <unmanaged>HRESULT D3DDisassemble([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] D3DCOMPILE_DISASM_FLAGS Flags,[In, Optional] const char* szComments,[Out] ID3D10Blob** ppDisassembly)</unmanaged>	
        /// <unmanaged-short>D3DDisassemble</unmanaged-short>	
        public static void Disassemble(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, SharpDX.D3DCompiler.DisassemblyFlags flags, string szComments, out SharpDX.Direct3D.Blob disassemblyOut) {
            unsafe {
                IntPtr szComments_ = Utilities.StringToHGlobalAnsi(szComments);
                IntPtr disassemblyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DDisassemble_((void*)srcDataRef, (void*)srcDataSize, unchecked((int)flags), (void*)szComments_, &disassemblyOut_);		
                Marshal.FreeHGlobal(szComments_ );
                disassemblyOut= (disassemblyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(disassemblyOut_);	
                __result__.CheckError();
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DDisassemble", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DDisassemble_(void* arg0,void* arg1,int arg2,void* arg3,void* arg4);
        
        /// <summary>	
        /// <p>Compile HLSL code or an  effect file into bytecode for a given target.</p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd>  <p>A reference to uncompiled shader data; either ASCII HLSL code or a compiled effect.</p> </dd></param>	
        /// <param name="srcDataSize"><dd>  <p>Length of <em>pSrcData</em>.</p> </dd></param>	
        /// <param name="sourceNameRef"><dd>  <p>Optional. You can use this parameter for strings that specify  error messages. If not used, set to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="definesRef"><dd>  <p>Optional. An array of <c>null</c>-terminated macro definitions (see <strong><see cref="SharpDX.Direct3D.ShaderMacro"/></strong>).</p> </dd></param>	
        /// <param name="includeRef"><dd>  <p>Optional. A reference to an <strong><see cref="SharpDX.D3DCompiler.Include"/></strong> for handling include files. Setting this to <strong><c>null</c></strong> will cause a compile error if a shader contains a #include. You can pass the <strong>D3D_COMPILE_STANDARD_FILE_INCLUDE</strong> macro, which is a reference to a default include handler. This default include handler includes files that are relative to the current directory and files that are relative to the directory of the initial source file. When you use <strong>D3D_COMPILE_STANDARD_FILE_INCLUDE</strong>, you must specify the source file name in the <em>pSourceName</em> parameter; the compiler will derive the initial relative directory from <em>pSourceName</em>.</p>  <pre>#define D3D_COMPILE_STANDARD_FILE_INCLUDE ((<see cref="SharpDX.D3DCompiler.Include"/>*)(<see cref="System.IntPtr"/>)1)</pre>  </dd></param>	
        /// <param name="entrypointRef"><dd>  <p>The name of the shader entry point function where shader execution begins. When you compile an effect, <strong><see cref="SharpDX.D3DCompiler.D3D.Compile"/></strong> ignores <em>pEntrypoint</em>; we recommend that you set <em>pEntrypoint</em> to <strong><c>null</c></strong> because it is good programming practice to set a reference parameter to <strong><c>null</c></strong> if the called function will not use it.</p> </dd></param>	
        /// <param name="targetRef"><dd>  <p>A string that specifies the shader target or set of shader features to compile against. The shader target can be shader model 2, shader model 3, shader model 4, or shader model 5. The target can also be an effect type (for example, fx_4_1). For info about the targets that various profiles support, see Specifying Compiler Targets. </p> </dd></param>	
        /// <param name="flags1"><dd>  <p>Shader <strong>compile options</strong>.</p> </dd></param>	
        /// <param name="flags2"><dd>  <p>Effect <strong>compile options</strong>. When you compile a shader and not an effect file, <strong><see cref="SharpDX.D3DCompiler.D3D.Compile"/></strong> ignores <em>Flags2</em>; we recommend that you set <em>Flags2</em> to zero because it is good programming practice to set a nonreference parameter to zero if the called function will not use it.</p> </dd></param>	
        /// <param name="codeOut"><dd>  <p>A reference to a variable that receives a reference to the <strong>ID3DBlob</strong> interface that you can use to access the compiled code.</p> </dd></param>	
        /// <param name="errorMsgsOut"><dd>  <p>An optional reference to a variable that receives a reference to the <strong>ID3DBlob</strong> interface that you can use to access compiler error messages, or <strong><c>null</c></strong> if there are no errors.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DCompile']/*"/>	
        /// <msdn-id>dd607324</msdn-id>	
        /// <unmanaged>HRESULT D3DCompile([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In, Optional] const char* pSourceName,[In, Buffer, Optional] const D3D_SHADER_MACRO* pDefines,[In, Optional] ID3DInclude* pInclude,[In, Optional] const char* pEntrypoint,[In] const char* pTarget,[In] D3DCOMPILE_SHADER_FLAGS Flags1,[In] D3DCOMPILE_EFFECT_FLAGS Flags2,[Out] ID3D10Blob** ppCode,[Out, Optional] ID3D10Blob** ppErrorMsgs)</unmanaged>	
        /// <unmanaged-short>D3DCompile</unmanaged-short>	
        public static SharpDX.Result Compile(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, string sourceNameRef, SharpDX.Direct3D.ShaderMacro[] definesRef, System.IntPtr includeRef, string entrypointRef, string targetRef, SharpDX.D3DCompiler.ShaderFlags flags1, SharpDX.D3DCompiler.EffectFlags flags2, out SharpDX.Direct3D.Blob codeOut, out SharpDX.Direct3D.Blob errorMsgsOut) {
            unsafe {
                IntPtr sourceNameRef_ = Utilities.StringToHGlobalAnsi(sourceNameRef);
                SharpDX.Direct3D.ShaderMacro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D.ShaderMacro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr entrypointRef_ = Utilities.StringToHGlobalAnsi(entrypointRef);
                IntPtr targetRef_ = Utilities.StringToHGlobalAnsi(targetRef);
                IntPtr codeOut_ = IntPtr.Zero;
                IntPtr errorMsgsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DCompile_((void*)srcDataRef, (void*)srcDataSize, (void*)sourceNameRef_, definesRef_, (void*)includeRef, (void*)entrypointRef_, (void*)targetRef_, unchecked((int)flags1), unchecked((int)flags2), &codeOut_, &errorMsgsOut_);		
                Marshal.FreeHGlobal(sourceNameRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                Marshal.FreeHGlobal(entrypointRef_ );
                Marshal.FreeHGlobal(targetRef_ );
                codeOut= (codeOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(codeOut_);	
                errorMsgsOut= (errorMsgsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorMsgsOut_);	
                return __result__;
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DCompile", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DCompile_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,void* arg5,void* arg6,int arg7,int arg8,void* arg9,void* arg10);
        
        /// <summary>	
        /// <p>Removes unwanted blobs from a compilation result.</p>	
        /// </summary>	
        /// <param name="shaderBytecodeRef"><dd>  <p>A reference to source data as compiled HLSL code.</p> </dd></param>	
        /// <param name="bytecodeLength"><dd>  <p>Length of <em>pSrcData</em>.</p> </dd></param>	
        /// <param name="uStripFlags"><dd>  <p>Strip flag options, represented by <strong><see cref="SharpDX.D3DCompiler.StripFlags"/></strong>.</p> </dd></param>	
        /// <param name="strippedBlobOut"><dd>  <p>A reference to a variable that receives a reference to the <strong>ID3DBlob</strong> interface that you can use to access the unwanted stripped out shader code.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DStripShader']/*"/>	
        /// <msdn-id>dd607335</msdn-id>	
        /// <unmanaged>HRESULT D3DStripShader([In, Buffer] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In] D3DCOMPILER_STRIP_FLAGS uStripFlags,[Out] ID3D10Blob** ppStrippedBlob)</unmanaged>	
        /// <unmanaged-short>D3DStripShader</unmanaged-short>	
        public static SharpDX.Result StripShader(System.IntPtr shaderBytecodeRef, SharpDX.PointerSize bytecodeLength, SharpDX.D3DCompiler.StripFlags uStripFlags, out SharpDX.Direct3D.Blob strippedBlobOut) {
            unsafe {
                IntPtr strippedBlobOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DStripShader_((void*)shaderBytecodeRef, (void*)bytecodeLength, unchecked((int)uStripFlags), &strippedBlobOut_);		
                strippedBlobOut= (strippedBlobOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(strippedBlobOut_);	
                return __result__;
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DStripShader", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DStripShader_(void* arg0,void* arg1,int arg2,void* arg3);
        
        /// <summary>	
        /// <p>Preprocesses uncompiled HLSL code.</p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd>  <p>A reference to uncompiled shader data; either ASCII HLSL code or a compiled effect.</p> </dd></param>	
        /// <param name="srcDataSize"><dd>  <p>Length of <em>pSrcData</em>.</p> </dd></param>	
        /// <param name="sourceNameRef"><dd>  <p>Optional. The name of the file that contains the uncompiled HLSL code.</p> </dd></param>	
        /// <param name="definesRef"><dd>  <p>Optional. An array of <c>null</c>-terminated macro definitions (see <strong><see cref="SharpDX.Direct3D.ShaderMacro"/></strong>).</p> </dd></param>	
        /// <param name="includeRef"><dd>  <p>Optional. A reference to an <strong><see cref="SharpDX.D3DCompiler.Include"/></strong> for handling include files. Setting this to <strong><c>null</c></strong> will cause a compile error if a shader contains a #include. You can pass the <strong>D3D_COMPILE_STANDARD_FILE_INCLUDE</strong> macro, which is a reference to a default include handler. This default include handler includes files that are relative to the current directory and files that are relative to the directory of the initial source file. When you use <strong>D3D_COMPILE_STANDARD_FILE_INCLUDE</strong>, you must specify the source file name in the <em>pSourceName</em> parameter; the compiler will derive the initial relative directory from <em>pSourceName</em>.</p>  <pre>#define D3D_COMPILE_STANDARD_FILE_INCLUDE ((<see cref="SharpDX.D3DCompiler.Include"/>*)(<see cref="System.IntPtr"/>)1)</pre>  </dd></param>	
        /// <param name="codeTextOut"><dd>  <p>The address of a <strong>ID3DBlob</strong> that contains the compiled code.</p> </dd></param>	
        /// <param name="errorMsgsOut"><dd>  <p>Optional. A reference to an <strong>ID3DBlob</strong> that contains compiler error messages, or <strong><c>null</c></strong> if there were no errors.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.D3DCompiler.D3D.Preprocess"/></strong> outputs #line directives and preserves line numbering of source input so that output line numbering can be properly related to the input source.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DPreprocess']/*"/>	
        /// <msdn-id>dd607332</msdn-id>	
        /// <unmanaged>HRESULT D3DPreprocess([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In, Optional] const char* pSourceName,[In, Buffer, Optional] const D3D_SHADER_MACRO* pDefines,[In, Optional] ID3DInclude* pInclude,[Out] ID3D10Blob** ppCodeText,[Out, Optional] ID3D10Blob** ppErrorMsgs)</unmanaged>	
        /// <unmanaged-short>D3DPreprocess</unmanaged-short>	
        public static void Preprocess(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, string sourceNameRef, SharpDX.Direct3D.ShaderMacro[] definesRef, System.IntPtr includeRef, out SharpDX.Direct3D.Blob codeTextOut, out SharpDX.Direct3D.Blob errorMsgsOut) {
            unsafe {
                IntPtr sourceNameRef_ = Utilities.StringToHGlobalAnsi(sourceNameRef);
                SharpDX.Direct3D.ShaderMacro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D.ShaderMacro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr codeTextOut_ = IntPtr.Zero;
                IntPtr errorMsgsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DPreprocess_((void*)srcDataRef, (void*)srcDataSize, (void*)sourceNameRef_, definesRef_, (void*)includeRef, &codeTextOut_, &errorMsgsOut_);		
                Marshal.FreeHGlobal(sourceNameRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                codeTextOut= (codeTextOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(codeTextOut_);	
                errorMsgsOut= (errorMsgsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorMsgsOut_);	
                __result__.CheckError();
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DPreprocess", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DPreprocess_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,void* arg5,void* arg6);
        
        /// <summary>	
        /// <p><strong>Note</strong>??You can use this API to develop your Windows Store apps, but you can't use it in apps that you submit to the Windows Store.</p><p>Compresses a set of shaders into a more compact form. </p>	
        /// </summary>	
        /// <param name="uNumShaders"><dd>  <p>The number of shaders to compress.</p> </dd></param>	
        /// <param name="shaderDataRef"><dd>  <p>An array of <strong><see cref="SharpDX.D3DCompiler.ShaderData"/></strong> structures that describe the set of shaders to compress.</p> </dd></param>	
        /// <param name="uFlags"><dd>  <p>Flags that indicate how to compress the shaders. Currently, only the  D3D_COMPRESS_SHADER_KEEP_ALL_PARTS (0x00000001) flag is defined.</p> </dd></param>	
        /// <param name="compressedDataOut"><dd>  <p>The address of a reference to the <strong>ID3DBlob</strong> interface that is used to retrieve the compressed shader data.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DCompressShaders']/*"/>	
        /// <msdn-id>ff728671</msdn-id>	
        /// <unmanaged>HRESULT D3DCompressShaders([In] unsigned int uNumShaders,[In, Buffer] D3D_SHADER_DATA* pShaderData,[In] unsigned int uFlags,[Out] ID3D10Blob** ppCompressedData)</unmanaged>	
        /// <unmanaged-short>D3DCompressShaders</unmanaged-short>	
        public static void CompressShaders(int uNumShaders, SharpDX.D3DCompiler.ShaderData[] shaderDataRef, int uFlags, out SharpDX.Direct3D.Blob compressedDataOut) {
            unsafe {
                IntPtr compressedDataOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* shaderDataRef_ = shaderDataRef)
                    __result__= 
    				D3DCompressShaders_(uNumShaders, shaderDataRef_, uFlags, &compressedDataOut_);		
                compressedDataOut= (compressedDataOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(compressedDataOut_);	
                __result__.CheckError();
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DCompressShaders", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DCompressShaders_(int arg0,void* arg1,int arg2,void* arg3);
        
        /// <summary>	
        /// <p>Gets a reference to a reflection interface.</p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd>  <p>A reference to source data as compiled HLSL code.</p> </dd></param>	
        /// <param name="srcDataSize"><dd>  <p>Length of <em>pSrcData</em>.</p> </dd></param>	
        /// <param name="interfaceRef"><dd>  <p>The reference <see cref="System.Guid"/> of the COM interface to use. For example, <strong>IID_ID3D11ShaderReflection</strong>.</p> </dd></param>	
        /// <param name="reflectorOut"><dd>  <p>A reference to a reflection interface.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <remarks>	
        /// <p>Shader code contains metadata that can be inspected using the reflection APIs.</p><p>The following code illustrates retrieving a <see cref="SharpDX.D3DCompiler.ShaderReflection"/> Interface from a shader.</p><pre> pd3dDevice-&gt;CreatePixelShader( pPixelShaderBuffer-&gt;GetBufferPointer(), pPixelShaderBuffer-&gt;GetBufferSize(), g_pPSClassLinkage, &amp;g_pPixelShader ); <see cref="SharpDX.D3DCompiler.ShaderReflection"/>* pReflector = <c>null</c>; 	
        /// <see cref="SharpDX.D3DCompiler.D3D.Reflect"/>( pPixelShaderBuffer-&gt;GetBufferPointer(), pPixelShaderBuffer-&gt;GetBufferSize(),  IID_ID3D11ShaderReflection, (void**) &amp;pReflector);	
        /// </pre><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DReflect']/*"/>	
        /// <msdn-id>dd607334</msdn-id>	
        /// <unmanaged>HRESULT D3DReflect([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] const GUID&amp; pInterface,[Out] void** ppReflector)</unmanaged>	
        /// <unmanaged-short>D3DReflect</unmanaged-short>	
        public static void Reflect(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, System.Guid interfaceRef, out System.IntPtr reflectorOut) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* reflectorOut_ = &reflectorOut)
                    __result__= 
    				D3DReflect_((void*)srcDataRef, (void*)srcDataSize, &interfaceRef, reflectorOut_);		
                __result__.CheckError();
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DReflect", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DReflect_(void* arg0,void* arg1,void* arg2,void* arg3);
        
        /// <summary>	
        /// <p>Creates a function-linking-graph interface. </p><p><strong>Note</strong>??This function is part of the HLSL shader linking technology that you can use on all Direct3D?11 platforms to create precompiled HLSL functions, package them into libraries, and link them into full shaders at run time.	
        /// </p>	
        /// </summary>	
        /// <param name="uFlags"><dd>  <p>Reserved</p> </dd></param>	
        /// <param name="functionLinkingGraphOut"><dd>  <p>A reference to a variable that receives a reference to the <strong><see cref="SharpDX.D3DCompiler.FunctionLinkingGraph"/></strong> interface that is used for constructing shaders that consist of a sequence of precompiled function calls.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise, returns one of the Direct3D 11 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??The D3dcompiler_47.dll or later version of the DLL contains the <strong><see cref="SharpDX.D3DCompiler.D3D.CreateFunctionLinkingGraph"/></strong> function.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DCreateFunctionLinkingGraph']/*"/>	
        /// <msdn-id>dn280340</msdn-id>	
        /// <unmanaged>HRESULT D3DCreateFunctionLinkingGraph([In] unsigned int uFlags,[Out, Fast] ID3D11FunctionLinkingGraph** ppFunctionLinkingGraph)</unmanaged>	
        /// <unmanaged-short>D3DCreateFunctionLinkingGraph</unmanaged-short>	
        public static void CreateFunctionLinkingGraph(int uFlags, SharpDX.D3DCompiler.FunctionLinkingGraph functionLinkingGraphOut) {
            unsafe {
                IntPtr functionLinkingGraphOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DCreateFunctionLinkingGraph_(uFlags, &functionLinkingGraphOut_);		
                ((SharpDX.D3DCompiler.FunctionLinkingGraph)functionLinkingGraphOut).NativePointer = functionLinkingGraphOut_;
                __result__.CheckError();
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DCreateFunctionLinkingGraph", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DCreateFunctionLinkingGraph_(int arg0,void* arg1);
        
        /// <summary>	
        /// <p>Creates a shader module interface from source data for the shader module. </p><p><strong>Note</strong>??This function is part of the HLSL shader linking technology that you can use on all Direct3D?11 platforms to create precompiled HLSL functions, package them into libraries, and link them into full shaders at run time.	
        /// </p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd>  <p>A reference to the source data for the shader module.</p> </dd></param>	
        /// <param name="cbSrcDataSize"><dd>  <p>The size, in bytes, of the block of memory that <em>pSrcData</em> points to.</p> </dd></param>	
        /// <param name="moduleOut"><dd>  <p>A reference to a variable that receives a reference to the <strong><see cref="SharpDX.D3DCompiler.Module"/></strong> interface that is used for shader resource re-binding.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise, returns one of the Direct3D 11 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??The D3dcompiler_47.dll or later version of the DLL contains the <strong><see cref="SharpDX.D3DCompiler.D3D.LoadModule"/></strong> function.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DLoadModule']/*"/>	
        /// <msdn-id>dn280342</msdn-id>	
        /// <unmanaged>HRESULT D3DLoadModule([In] const void* pSrcData,[In] SIZE_T cbSrcDataSize,[Out, Fast] ID3D11Module** ppModule)</unmanaged>	
        /// <unmanaged-short>D3DLoadModule</unmanaged-short>	
        public static SharpDX.Result LoadModule(System.IntPtr srcDataRef, SharpDX.PointerSize cbSrcDataSize, SharpDX.D3DCompiler.Module moduleOut) {
            unsafe {
                IntPtr moduleOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DLoadModule_((void*)srcDataRef, (void*)cbSrcDataSize, &moduleOut_);		
                ((SharpDX.D3DCompiler.Module)moduleOut).NativePointer = moduleOut_;
                return __result__;
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DLoadModule", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DLoadModule_(void* arg0,void* arg1,void* arg2);
        
        /// <summary>	
        /// <p>Creates a buffer.</p>	
        /// </summary>	
        /// <param name="size"><dd>  <p>Number of bytes in the blob.</p> </dd></param>	
        /// <param name="blobOut"><dd>  <p>The address of a reference to the <strong>ID3DBlob</strong> interface that is used to retrieve the buffer.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <remarks>	
        /// <p>The latest D3dcompiler_nn.dll contains the <strong><see cref="SharpDX.D3DCompiler.D3D.CreateBlob"/></strong> compiler function. Therefore, you are no longer required to create and use an arbitrary length data buffer by using the  <strong>D3D10CreateBlob</strong> function that is contained in D3d10.dll.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DCreateBlob']/*"/>	
        /// <msdn-id>ff728672</msdn-id>	
        /// <unmanaged>HRESULT D3DCreateBlob([In] SIZE_T Size,[Out] ID3D10Blob** ppBlob)</unmanaged>	
        /// <unmanaged-short>D3DCreateBlob</unmanaged-short>	
        public static void CreateBlob(SharpDX.PointerSize size, out SharpDX.Direct3D.Blob blobOut) {
            unsafe {
                IntPtr blobOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DCreateBlob_((void*)size, &blobOut_);		
                blobOut= (blobOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(blobOut_);	
                __result__.CheckError();
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DCreateBlob", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DCreateBlob_(void* arg0,void* arg1);
        
        /// <summary>	
        /// <p><strong>Note</strong>??<strong><see cref="SharpDX.D3DCompiler.D3D.GetInputSignatureBlob"/></strong> may be altered or unavailable for releases after Windows?8.1. Instead use <strong><see cref="SharpDX.D3DCompiler.D3D.GetBlobPart"/></strong> with the <strong><see cref="SharpDX.D3DCompiler.ShaderBytecodePart.InputSignatureBlob"/></strong> value. </p><p>Gets the input signature from a compilation result.</p>	
        /// </summary>	
        /// <param name="srcDataRef">No documentation.</param>	
        /// <param name="srcDataSize">No documentation.</param>	
        /// <param name="signatureBlobOut">No documentation.</param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DGetInputSignatureBlob']/*"/>	
        /// <msdn-id>dd607330</msdn-id>	
        /// <unmanaged>HRESULT D3DGetInputSignatureBlob([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[Out] ID3D10Blob** ppSignatureBlob)</unmanaged>	
        /// <unmanaged-short>D3DGetInputSignatureBlob</unmanaged-short>	
        public static SharpDX.Result GetInputSignatureBlob(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, out SharpDX.Direct3D.Blob signatureBlobOut) {
            unsafe {
                IntPtr signatureBlobOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DGetInputSignatureBlob_((void*)srcDataRef, (void*)srcDataSize, &signatureBlobOut_);		
                signatureBlobOut= (signatureBlobOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(signatureBlobOut_);	
                return __result__;
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DGetInputSignatureBlob", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DGetInputSignatureBlob_(void* arg0,void* arg1,void* arg2);
        
        /// <summary>	
        /// <p>Retrieves the byte offsets for instructions within a section of shader code.</p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd> <p>A reference to the compiled shader data.</p> </dd></param>	
        /// <param name="srcDataSize"><dd> <p>The size, in bytes, of the block of memory that <em>pSrcData</em> points to.</p> </dd></param>	
        /// <param name="flags"><dd> <p>A combination of the following flags that are combined by using a bitwise <strong>OR</strong> operation. The resulting value specifies how <strong><see cref="SharpDX.D3DCompiler.D3D.GetTraceInstructionOffsets"/></strong> retrieves the instruction offsets.</p> <table> <tr><th>Flag</th><th>Description</th></tr> <tr><td>D3D_GET_INST_OFFSETS_INCLUDE_NON_EXECUTABLE (0x01)</td><td>Include non-executable code in the retrieved information.</td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="startInstIndex"><dd> <p>The index of the instruction in the compiled shader data for which <strong><see cref="SharpDX.D3DCompiler.D3D.GetTraceInstructionOffsets"/></strong> starts to retrieve the byte offsets.</p> </dd></param>	
        /// <param name="numInsts"><dd> <p>The number of instructions for which <strong><see cref="SharpDX.D3DCompiler.D3D.GetTraceInstructionOffsets"/></strong> retrieves the byte offsets.</p> </dd></param>	
        /// <param name="totalInstsRef"><dd> <p>A reference to a variable that receives the total number of instructions in the section of shader code.</p> </dd></param>	
        /// <returns><dd> <p>A reference to a variable that receives the actual number of offsets.</p> </dd></returns>	
        /// <remarks>	
        /// <p>A new kind of Microsoft High Level Shader Language (HLSL) debugging information from a program database (PDB) file uses instruction-byte offsets within a shader blob (arbitrary-length data buffer). You use <strong><see cref="SharpDX.D3DCompiler.D3D.GetTraceInstructionOffsets"/></strong> to translate to and from instruction indexes.</p><p><strong>Note</strong>??The D3dcompiler_44.dll or later version of the file contains the <strong><see cref="SharpDX.D3DCompiler.D3D.GetTraceInstructionOffsets"/></strong> compiler function.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DGetTraceInstructionOffsets']/*"/>	
        /// <msdn-id>hh446875</msdn-id>	
        /// <unmanaged>HRESULT D3DGetTraceInstructionOffsets([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] unsigned int Flags,[In] SIZE_T StartInstIndex,[In] SIZE_T NumInsts,[Out] SIZE_T* pOffsets,[Out] SIZE_T* pTotalInsts)</unmanaged>	
        /// <unmanaged-short>D3DGetTraceInstructionOffsets</unmanaged-short>	
        public static SharpDX.PointerSize GetTraceInstructionOffsets(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, int flags, SharpDX.PointerSize startInstIndex, SharpDX.PointerSize numInsts, out SharpDX.PointerSize totalInstsRef) {
            unsafe {
                SharpDX.PointerSize offsetsRef;
                offsetsRef = new SharpDX.PointerSize();
                totalInstsRef = new SharpDX.PointerSize();
                SharpDX.Result __result__;
                fixed (void* totalInstsRef_ = &totalInstsRef)
                    __result__= 
    				D3DGetTraceInstructionOffsets_((void*)srcDataRef, (void*)srcDataSize, flags, (void*)startInstIndex, (void*)numInsts, &offsetsRef, totalInstsRef_);		
                __result__.CheckError();
                return offsetsRef;
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DGetTraceInstructionOffsets", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DGetTraceInstructionOffsets_(void* arg0,void* arg1,int arg2,void* arg3,void* arg4,void* arg5,void* arg6);
        
        /// <summary>	
        /// <p><strong>Note</strong>??You can use this API to develop your Windows Store apps, but you can't use it in apps that you submit to the Windows Store.</p><p>Reads a file  that is on disk into memory.</p>	
        /// </summary>	
        /// <param name="fileNameRef"><dd> <p>A reference to a constant null-terminated string that contains  the name of the file to read into memory.</p> </dd></param>	
        /// <param name="contentsOut"><dd> <p>A reference to a variable that receives a reference to the <strong>ID3DBlob</strong> interface that contains information that <strong><see cref="SharpDX.D3DCompiler.D3D.ReadFileToBlob"/></strong> read from the <em>pFileName</em> file. You can use this <strong>ID3DBlob</strong> interface to access the file information and pass it to other compiler functions.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??The D3dcompiler_44.dll or later version of the file contains the <strong><see cref="SharpDX.D3DCompiler.D3D.ReadFileToBlob"/></strong> compiler function.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DReadFileToBlob']/*"/>	
        /// <msdn-id>hh446877</msdn-id>	
        /// <unmanaged>HRESULT D3DReadFileToBlob([In] const wchar_t* pFileName,[Out] ID3D10Blob** ppContents)</unmanaged>	
        /// <unmanaged-short>D3DReadFileToBlob</unmanaged-short>	
        public static void ReadFileToBlob(string fileNameRef, out SharpDX.Direct3D.Blob contentsOut) {
            unsafe {
                IntPtr fileNameRef_ = Utilities.StringToHGlobalUni(fileNameRef);
                IntPtr contentsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DReadFileToBlob_((void*)fileNameRef_, &contentsOut_);		
                Marshal.FreeHGlobal(fileNameRef_ );
                contentsOut= (contentsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(contentsOut_);	
                __result__.CheckError();
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DReadFileToBlob", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DReadFileToBlob_(void* arg0,void* arg1);
        
        /// <summary>	
        /// <p><strong>Note</strong>??<strong><see cref="SharpDX.D3DCompiler.D3D.GetInputAndOutputSignatureBlob"/></strong> may be altered or unavailable for releases after Windows?8.1. Instead use <strong><see cref="SharpDX.D3DCompiler.D3D.GetBlobPart"/></strong> with the <strong><see cref="SharpDX.D3DCompiler.ShaderBytecodePart.InputAndOutputSignatureBlob"/></strong> value. </p><p>Gets the input and output signatures from a compilation result.</p>	
        /// </summary>	
        /// <param name="srcDataRef">No documentation.</param>	
        /// <param name="srcDataSize">No documentation.</param>	
        /// <param name="signatureBlobOut">No documentation.</param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DGetInputAndOutputSignatureBlob']/*"/>	
        /// <msdn-id>dd607329</msdn-id>	
        /// <unmanaged>HRESULT D3DGetInputAndOutputSignatureBlob([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[Out] ID3D10Blob** ppSignatureBlob)</unmanaged>	
        /// <unmanaged-short>D3DGetInputAndOutputSignatureBlob</unmanaged-short>	
        public static SharpDX.Result GetInputAndOutputSignatureBlob(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, out SharpDX.Direct3D.Blob signatureBlobOut) {
            unsafe {
                IntPtr signatureBlobOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DGetInputAndOutputSignatureBlob_((void*)srcDataRef, (void*)srcDataSize, &signatureBlobOut_);		
                signatureBlobOut= (signatureBlobOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(signatureBlobOut_);	
                return __result__;
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DGetInputAndOutputSignatureBlob", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DGetInputAndOutputSignatureBlob_(void* arg0,void* arg1,void* arg2);
        
        /// <summary>	
        /// <p><strong>Note</strong>??<strong><see cref="SharpDX.D3DCompiler.D3D.GetOutputSignatureBlob"/></strong> may be altered or unavailable for releases after Windows?8.1. Instead use <strong><see cref="SharpDX.D3DCompiler.D3D.GetBlobPart"/></strong> with the <strong><see cref="SharpDX.D3DCompiler.ShaderBytecodePart.OutputSignatureBlob"/></strong> value. </p><p>Gets the output signature from a compilation result.</p>	
        /// </summary>	
        /// <param name="srcDataRef">No documentation.</param>	
        /// <param name="srcDataSize">No documentation.</param>	
        /// <param name="signatureBlobOut">No documentation.</param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DGetOutputSignatureBlob']/*"/>	
        /// <msdn-id>dd607331</msdn-id>	
        /// <unmanaged>HRESULT D3DGetOutputSignatureBlob([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[Out] ID3D10Blob** ppSignatureBlob)</unmanaged>	
        /// <unmanaged-short>D3DGetOutputSignatureBlob</unmanaged-short>	
        public static SharpDX.Result GetOutputSignatureBlob(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, out SharpDX.Direct3D.Blob signatureBlobOut) {
            unsafe {
                IntPtr signatureBlobOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DGetOutputSignatureBlob_((void*)srcDataRef, (void*)srcDataSize, &signatureBlobOut_);		
                signatureBlobOut= (signatureBlobOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(signatureBlobOut_);	
                return __result__;
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DGetOutputSignatureBlob", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DGetOutputSignatureBlob_(void* arg0,void* arg1,void* arg2);
        
        /// <summary>	
        /// <p>Creates a library-reflection interface from source data that contains an HLSL library of functions. </p><p><strong>Note</strong>??This function is part of the HLSL shader linking technology that you can use on all Direct3D?11 platforms to create precompiled HLSL functions, package them into libraries, and link them into full shaders at run time.	
        /// </p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd>  <p>A reference to source data as an HLSL library of functions. </p> </dd></param>	
        /// <param name="srcDataSize"><dd>  <p>The size, in bytes, of the block of memory that <em>pSrcData</em> points to.</p> </dd></param>	
        /// <param name="riid"><dd>  <p>The reference <see cref="System.Guid"/> of the COM interface to use. For example, <strong>IID_ID3D11LibraryReflection</strong>.</p> </dd></param>	
        /// <param name="reflectorOut"><dd>  <p>A reference to a variable that receives a reference to a library-reflection interface, <strong><see cref="SharpDX.D3DCompiler.LibraryReflection"/></strong>.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise, returns one of the Direct3D 11 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p>Shader library code contains metadata that can be inspected using the library-reflection APIs, <strong><see cref="SharpDX.D3DCompiler.LibraryReflection"/></strong>.</p><p><strong>Note</strong>??The D3dcompiler_47.dll or later version of the DLL contains the <strong><see cref="SharpDX.D3DCompiler.D3D.ReflectLibrary"/></strong> function.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DReflectLibrary']/*"/>	
        /// <msdn-id>dn280343</msdn-id>	
        /// <unmanaged>HRESULT D3DReflectLibrary([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] const GUID&amp; riid,[Out] void** ppReflector)</unmanaged>	
        /// <unmanaged-short>D3DReflectLibrary</unmanaged-short>	
        public static void ReflectLibrary(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, System.Guid riid, out System.IntPtr reflectorOut) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* reflectorOut_ = &reflectorOut)
                    __result__= 
    				D3DReflectLibrary_((void*)srcDataRef, (void*)srcDataSize, &riid, reflectorOut_);		
                __result__.CheckError();
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DReflectLibrary", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DReflectLibrary_(void* arg0,void* arg1,void* arg2,void* arg3);
        
        /// <summary>	
        /// <p>Sets information in a compilation result.</p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd>  <p>A reference to compiled shader data.</p> </dd></param>	
        /// <param name="srcDataSize"><dd>  <p>The length of the compiled shader data that <em>pSrcData</em> points to.</p> </dd></param>	
        /// <param name="part"><dd>  <p>A <strong><see cref="SharpDX.D3DCompiler.ShaderBytecodePart"/></strong>-typed value that specifies the part to set. Currently, you can update only private data; that is, <strong><see cref="SharpDX.D3DCompiler.D3D.SetBlobPart"/></strong> currently only supports the <strong><see cref="SharpDX.D3DCompiler.ShaderBytecodePart.PrivateData"/></strong> value.</p> </dd></param>	
        /// <param name="flags"><dd>  <p>Flags that indicate how to set the blob part. Currently, no flags are defined; therefore, set to zero.</p> </dd></param>	
        /// <param name="partRef"><dd>  <p>A reference to data to set in the compilation result.</p> </dd></param>	
        /// <param name="partSize"><dd>  <p>The length of the data that <em>pPart</em> points to.</p> </dd></param>	
        /// <param name="newShaderOut"><dd>  <p>A reference to a buffer that receives the <strong>ID3DBlob</strong> interface for the new shader in which the new part data is set.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.D3DCompiler.D3D.SetBlobPart"/></strong> modifies data in a compiled shader.  Currently, <strong><see cref="SharpDX.D3DCompiler.D3D.SetBlobPart"/></strong> can update only the private data in a compiled shader. You can use  <strong><see cref="SharpDX.D3DCompiler.D3D.SetBlobPart"/></strong> to attach arbitrary uninterpreted data to a compiled shader.</p><p><strong>Note</strong>??The D3dcompiler_44.dll or later version of the file contains the <strong><see cref="SharpDX.D3DCompiler.D3D.SetBlobPart"/></strong> compiler function.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DSetBlobPart']/*"/>	
        /// <msdn-id>hh446880</msdn-id>	
        /// <unmanaged>HRESULT D3DSetBlobPart([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSize,[In] D3D_BLOB_PART Part,[In] unsigned int Flags,[In, Buffer] const void* pPart,[In] SIZE_T PartSize,[Out] ID3D10Blob** ppNewShader)</unmanaged>	
        /// <unmanaged-short>D3DSetBlobPart</unmanaged-short>	
        public static void SetBlobPart(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSize, SharpDX.D3DCompiler.ShaderBytecodePart part, int flags, System.IntPtr partRef, SharpDX.PointerSize partSize, out SharpDX.Direct3D.Blob newShaderOut) {
            unsafe {
                IntPtr newShaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DSetBlobPart_((void*)srcDataRef, (void*)srcDataSize, unchecked((int)part), flags, (void*)partRef, (void*)partSize, &newShaderOut_);		
                newShaderOut= (newShaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(newShaderOut_);	
                __result__.CheckError();
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DSetBlobPart", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DSetBlobPart_(void* arg0,void* arg1,int arg2,int arg3,void* arg4,void* arg5,void* arg6);
        
        /// <summary>	
        /// <p><strong>Note</strong>??You can use this API to develop your Windows Store apps, but you can't use it in apps that you submit to the Windows Store.</p><p>Writes a memory blob to a file on disk.</p>	
        /// </summary>	
        /// <param name="blobRef"><dd>  <p>A reference to a <strong>ID3DBlob</strong> interface that contains the memory blob to write to the file that the <em>pFileName</em> parameter specifies.</p> </dd></param>	
        /// <param name="fileNameRef"><dd>  <p>A reference to a constant null-terminated string that contains  the name of the file to which to write.</p> </dd></param>	
        /// <param name="bOverwrite"><dd>  <p>A Boolean value that specifies whether to overwrite information in the <em>pFileName</em> file. TRUE specifies to overwrite information and <see cref="SharpDX.Result.False"/> specifies not to overwrite information.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??The D3dcompiler_44.dll or later version of the file contains the <strong><see cref="SharpDX.D3DCompiler.D3D.WriteBlobToFile"/></strong> compiler function.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DWriteBlobToFile']/*"/>	
        /// <msdn-id>hh446883</msdn-id>	
        /// <unmanaged>HRESULT D3DWriteBlobToFile([In] ID3D10Blob* pBlob,[In] const wchar_t* pFileName,[In] BOOL bOverwrite)</unmanaged>	
        /// <unmanaged-short>D3DWriteBlobToFile</unmanaged-short>	
        public static void WriteBlobToFile(SharpDX.Direct3D.Blob blobRef, string fileNameRef, SharpDX.Mathematics.Interop.RawBool bOverwrite) {
            unsafe {
                IntPtr fileNameRef_ = Utilities.StringToHGlobalUni(fileNameRef);
                SharpDX.Result __result__;
                __result__= 
				D3DWriteBlobToFile_((void*)((blobRef == null)?IntPtr.Zero:blobRef.NativePointer), (void*)fileNameRef_, bOverwrite);		
                Marshal.FreeHGlobal(fileNameRef_ );
                __result__.CheckError();
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DWriteBlobToFile", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DWriteBlobToFile_(void* arg0,void* arg1,SharpDX.Mathematics.Interop.RawBool arg2);
        
        /// <summary>	
        /// <p>Creates a linker interface. </p><p><strong>Note</strong>??This function is part of the HLSL shader linking technology that you can use on all Direct3D?11 platforms to create precompiled HLSL functions, package them into libraries, and link them into full shaders at run time.	
        /// </p>	
        /// </summary>	
        /// <param name="linkerOut"><dd>  <p>A reference to a variable that receives a reference to the <strong><see cref="SharpDX.D3DCompiler.Linker"/></strong> interface that is used to link a shader module.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful; otherwise, returns one of the Direct3D 11 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??The D3dcompiler_47.dll or later version of the DLL contains the <strong><see cref="SharpDX.D3DCompiler.D3D.CreateLinker"/></strong> function.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DCreateLinker']/*"/>	
        /// <msdn-id>dn280341</msdn-id>	
        /// <unmanaged>HRESULT D3DCreateLinker([Out, Fast] ID3D11Linker** ppLinker)</unmanaged>	
        /// <unmanaged-short>D3DCreateLinker</unmanaged-short>	
        public static void CreateLinker(SharpDX.D3DCompiler.Linker linkerOut) {
            unsafe {
                IntPtr linkerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DCreateLinker_(&linkerOut_);		
                ((SharpDX.D3DCompiler.Linker)linkerOut).NativePointer = linkerOut_;
                __result__.CheckError();
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DCreateLinker", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DCreateLinker_(void* arg0);
        
        /// <summary>	
        /// <p><strong>Note</strong>??You can use this API to develop your Windows Store apps, but you can't use it in apps that you submit to the Windows Store.</p><p>Compiles Microsoft High Level Shader Language (HLSL) code into bytecode for a given target.</p>	
        /// </summary>	
        /// <param name="fileNameRef"><dd> <p>A reference to a constant null-terminated string that contains  the name of the file that contains the shader code.</p> </dd></param>	
        /// <param name="definesRef"><dd> <p>An optional array of <strong><see cref="SharpDX.Direct3D.ShaderMacro"/></strong> structures that define shader macros. Each macro definition contains a name and a <c>null</c>-terminated definition. If not used, set to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="includeRef"><dd> <p> An optional reference to an <strong><see cref="SharpDX.D3DCompiler.Include"/></strong> interface that the compiler uses to handle include files. If you set this parameter to <strong><c>null</c></strong> and the shader contains a #include, a compile error occurs. You can pass the <strong>D3D_COMPILE_STANDARD_FILE_INCLUDE</strong> macro, which is a reference to a default include handler. This default include handler includes files that are relative to the current directory.</p>  <pre>#define D3D_COMPILE_STANDARD_FILE_INCLUDE ((<see cref="SharpDX.D3DCompiler.Include"/>*)(<see cref="System.IntPtr"/>)1)</pre>  </dd></param>	
        /// <param name="entrypointRef"><dd> <p>A reference to a constant null-terminated string that contains  the name of the shader entry point function where shader execution begins. When you compile an effect, <strong><see cref="SharpDX.D3DCompiler.D3D.CompileFromFile"/></strong> ignores <em>pEntrypoint</em>; we recommend that you set <em>pEntrypoint</em> to <strong><c>null</c></strong> because it is good programming practice to set a reference parameter to <strong><c>null</c></strong> if the called function will not use it.</p> </dd></param>	
        /// <param name="targetRef"><dd> <p>A reference to a constant null-terminated string that specifies the shader target or set of shader features to compile against. The shader target can be a shader model (for example, shader model 2, shader model 3, shader model 4, or shader model 5 and later). The target can also be an effect type (for example, fx_4_1). For info about the targets that various profiles support, see Specifying Compiler Targets. </p> </dd></param>	
        /// <param name="flags1"><dd> <p>A combination of shader <strong>compile options</strong> that are combined by using a bitwise <strong>OR</strong> operation. The resulting value specifies how the compiler compiles the HLSL code.</p> </dd></param>	
        /// <param name="flags2"><dd> <p>A combination of effect <strong>compile options</strong> that are combined by using a bitwise <strong>OR</strong> operation. The resulting value specifies how the compiler compiles the effect. When you compile a shader and not an effect file, <strong><see cref="SharpDX.D3DCompiler.D3D.CompileFromFile"/></strong> ignores <em>Flags2</em>; we recommend that you set <em>Flags2</em> to zero because it is good programming practice to set a nonreference parameter to zero if the called function will not use it.</p> </dd></param>	
        /// <param name="codeOut"><dd> <p>A reference to a variable that receives a reference to the <strong>ID3DBlob</strong> interface that you can use to access the compiled code.</p> </dd></param>	
        /// <param name="errorMsgsOut"><dd> <p>An optional reference to a variable that receives a reference to the <strong>ID3DBlob</strong> interface that you can use to access compiler error messages, or <strong><c>null</c></strong> if there are no errors.</p> </dd></param>	
        /// <returns><p>Returns one of the Direct3D 11 return codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??The D3dcompiler_44.dll or later version of the file contains the <strong><see cref="SharpDX.D3DCompiler.D3D.CompileFromFile"/></strong> compiler function.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DCompileFromFile']/*"/>	
        /// <msdn-id>hh446872</msdn-id>	
        /// <unmanaged>HRESULT D3DCompileFromFile([In] const wchar_t* pFileName,[In, Buffer, Optional] const D3D_SHADER_MACRO* pDefines,[In, Optional] ID3DInclude* pInclude,[In] const char* pEntrypoint,[In] const char* pTarget,[In] D3DCOMPILE_SHADER_FLAGS Flags1,[In] D3DCOMPILE_EFFECT_FLAGS Flags2,[Out] ID3D10Blob** ppCode,[Out, Optional] ID3D10Blob** ppErrorMsgs)</unmanaged>	
        /// <unmanaged-short>D3DCompileFromFile</unmanaged-short>	
        public static SharpDX.Result CompileFromFile(string fileNameRef, SharpDX.Direct3D.ShaderMacro[] definesRef, System.IntPtr includeRef, string entrypointRef, string targetRef, SharpDX.D3DCompiler.ShaderFlags flags1, SharpDX.D3DCompiler.EffectFlags flags2, out SharpDX.Direct3D.Blob codeOut, out SharpDX.Direct3D.Blob errorMsgsOut) {
            unsafe {
                IntPtr fileNameRef_ = Utilities.StringToHGlobalUni(fileNameRef);
                SharpDX.Direct3D.ShaderMacro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D.ShaderMacro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr entrypointRef_ = Utilities.StringToHGlobalAnsi(entrypointRef);
                IntPtr targetRef_ = Utilities.StringToHGlobalAnsi(targetRef);
                IntPtr codeOut_ = IntPtr.Zero;
                IntPtr errorMsgsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DCompileFromFile_((void*)fileNameRef_, definesRef_, (void*)includeRef, (void*)entrypointRef_, (void*)targetRef_, unchecked((int)flags1), unchecked((int)flags2), &codeOut_, &errorMsgsOut_);		
                Marshal.FreeHGlobal(fileNameRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                Marshal.FreeHGlobal(entrypointRef_ );
                Marshal.FreeHGlobal(targetRef_ );
                codeOut= (codeOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(codeOut_);	
                errorMsgsOut= (errorMsgsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorMsgsOut_);	
                return __result__;
            }
        }
        [DllImport("d3dcompiler_47.dll", EntryPoint = "D3DCompileFromFile", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DCompileFromFile_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,int arg5,int arg6,void* arg7,void* arg8);
    }
        /// <summary>	
        /// Functions	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.D3DCompiler.D3DCommon']/*"/>	
    static  partial class D3DCommon {   
    }
}
