// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.Direct2D1 namespace.
//     This code was generated by a tool.
//     Date : 6/25/2016 10:38:12 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
namespace SharpDX.Direct2D1
{

    // Disable warning : XML comment is not placed on a valid language element
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
    /// <summary>	
    /// <p>Supplies data to an analysis effect.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> This interface can be implemented by either an <strong><see cref="SharpDX.Direct2D1.DrawTransform"/></strong> or an <strong><see cref="SharpDX.Direct2D1.ComputeTransform"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1AnalysisTransform']/*"/>	
    /// <msdn-id>hh404347</msdn-id>	
    /// <unmanaged>ID2D1AnalysisTransform</unmanaged>	
    /// <unmanaged-short>ID2D1AnalysisTransform</unmanaged-short>	
    [Guid("0359dc30-95e6-4568-9055-27720d130e93")]
    public partial class AnalysisTransform : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.AnalysisTransform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public AnalysisTransform(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.AnalysisTransform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.AnalysisTransform(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.AnalysisTransform(nativePointer);
        }


        /// <summary>	
        /// <p>Supplies the analysis data to an analysis transform.</p>	
        /// </summary>	
        /// <param name="analysisData"><dd>  <p>The data that the transform will analyze.</p> </dd></param>	
        /// <param name="analysisDataCount"><dd>  <p>The size of the analysis data.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The output of the transform will be copied to CPU-accessible memory by the imaging effects system before being passed to the implementation.</p><p> If this call fails, the corresponding <strong><see cref="SharpDX.Direct2D1.Effect"/></strong> instance is placed into an error state and fails to draw.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1AnalysisTransform::ProcessAnalysisResults']/*"/>	
        /// <msdn-id>hh404348</msdn-id>	
        /// <unmanaged>HRESULT ID2D1AnalysisTransform::ProcessAnalysisResults([In, Buffer] const void* analysisData,[In] unsigned int analysisDataCount)</unmanaged>	
        /// <unmanaged-short>ID2D1AnalysisTransform::ProcessAnalysisResults</unmanaged-short>	
        internal void ProcessAnalysisResults(System.IntPtr analysisData, int analysisDataCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)analysisData, analysisDataCount, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a bitmap that has been bound to an <strong><see cref="SharpDX.Direct2D1.RenderTarget"/></strong>.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap']/*"/>	
    /// <msdn-id>dd371109</msdn-id>	
    /// <unmanaged>ID2D1Bitmap</unmanaged>	
    /// <unmanaged-short>ID2D1Bitmap</unmanaged-short>	
    [Guid("a2296057-ea42-4099-983b-539fb6505426")]
    public partial class Bitmap : SharpDX.Direct2D1.Image
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Bitmap"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Bitmap(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Bitmap"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Bitmap(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Bitmap(nativePointer);
        }


        /// <summary>	
        /// <p>Returns the size, in device-independent pixels (DIPs), of the bitmap.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>A DIP is 1/96?of an inch. To retrieve the size in device pixels, use the <strong><see cref="SharpDX.Direct2D1.Bitmap.GetPixelSize"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap::GetSize']/*"/>	
        /// <msdn-id>dd371170</msdn-id>	
        /// <unmanaged>GetSize</unmanaged>	
        /// <unmanaged-short>GetSize</unmanaged-short>	
        /// <unmanaged>D2D_SIZE_F ID2D1Bitmap::GetSize()</unmanaged>
        public SharpDX.Size2F Size
        {
            get { return GetSize(); }
        }

        /// <summary>	
        /// <p>Returns the size, in device-dependent units (pixels), of the bitmap.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap::GetPixelSize']/*"/>	
        /// <msdn-id>dd371167</msdn-id>	
        /// <unmanaged>GetPixelSize</unmanaged>	
        /// <unmanaged-short>GetPixelSize</unmanaged-short>	
        /// <unmanaged>D2D_SIZE_U ID2D1Bitmap::GetPixelSize()</unmanaged>
        public SharpDX.Size2 PixelSize
        {
            get { return GetPixelSize(); }
        }

        /// <summary>	
        /// <p>Retrieves the pixel format and alpha mode of the bitmap.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap::GetPixelFormat']/*"/>	
        /// <msdn-id>dd371164</msdn-id>	
        /// <unmanaged>GetPixelFormat</unmanaged>	
        /// <unmanaged-short>GetPixelFormat</unmanaged-short>	
        /// <unmanaged>D2D1_PIXEL_FORMAT ID2D1Bitmap::GetPixelFormat()</unmanaged>
        public SharpDX.Direct2D1.PixelFormat PixelFormat
        {
            get { return GetPixelFormat(); }
        }

        /// <summary>	
        /// <p>Returns the size, in device-independent pixels (DIPs), of the bitmap.</p>	
        /// </summary>	
        /// <returns><p>The size, in DIPs, of the bitmap.</p></returns>	
        /// <remarks>	
        /// <p>A DIP is 1/96?of an inch. To retrieve the size in device pixels, use the <strong><see cref="SharpDX.Direct2D1.Bitmap.GetPixelSize"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap::GetSize']/*"/>	
        /// <msdn-id>dd371170</msdn-id>	
        /// <unmanaged>D2D_SIZE_F ID2D1Bitmap::GetSize()</unmanaged>	
        /// <unmanaged-short>ID2D1Bitmap::GetSize</unmanaged-short>	
        internal SharpDX.Size2F GetSize()
        {
            unsafe
            {
                SharpDX.Size2F __result__;
                SharpDX.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, (void*)&__result__, ((void**)(*(void**)_nativePointer))[4]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Returns the size, in device-dependent units (pixels), of the bitmap.</p>	
        /// </summary>	
        /// <returns><p>The size, in pixels, of the bitmap.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap::GetPixelSize']/*"/>	
        /// <msdn-id>dd371167</msdn-id>	
        /// <unmanaged>D2D_SIZE_U ID2D1Bitmap::GetPixelSize()</unmanaged>	
        /// <unmanaged-short>ID2D1Bitmap::GetPixelSize</unmanaged-short>	
        internal SharpDX.Size2 GetPixelSize()
        {
            unsafe
            {
                SharpDX.Size2 __result__;
                SharpDX.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, (void*)&__result__, ((void**)(*(void**)_nativePointer))[5]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Retrieves the pixel format and alpha mode of the bitmap.</p>	
        /// </summary>	
        /// <returns><p>The pixel format and alpha mode of the bitmap.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap::GetPixelFormat']/*"/>	
        /// <msdn-id>dd371164</msdn-id>	
        /// <unmanaged>D2D1_PIXEL_FORMAT ID2D1Bitmap::GetPixelFormat()</unmanaged>	
        /// <unmanaged-short>ID2D1Bitmap::GetPixelFormat</unmanaged-short>	
        internal SharpDX.Direct2D1.PixelFormat GetPixelFormat()
        {
            unsafe
            {
                SharpDX.Direct2D1.PixelFormat __result__;
                SharpDX.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, (void*)&__result__, ((void**)(*(void**)_nativePointer))[6]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Return the dots per inch (DPI) of the bitmap.</p>	
        /// </summary>	
        /// <param name="dpiX"><dd>  <p>The horizontal DPI of the image. You must allocate storage for this parameter.</p> </dd></param>	
        /// <param name="dpiY"><dd>  <p>The vertical DPI of the image.  You must allocate storage for this parameter.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap::GetDpi']/*"/>	
        /// <msdn-id>dd371161</msdn-id>	
        /// <unmanaged>void ID2D1Bitmap::GetDpi([Out] float* dpiX,[Out] float* dpiY)</unmanaged>	
        /// <unmanaged-short>ID2D1Bitmap::GetDpi</unmanaged-short>	
        internal void GetDpi(out float dpiX, out float dpiY)
        {
            unsafe
            {
                fixed (void* dpiX_ = &dpiX)
                    fixed (void* dpiY_ = &dpiY)
                        SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, dpiX_, dpiY_, ((void**)(*(void**)_nativePointer))[7]);
            }
        }

        /// <summary>	
        /// <p>Copies the specified region from the specified bitmap into the current bitmap. </p>	
        /// </summary>	
        /// <param name="destPoint"><dd>  <p>In the current bitmap, the upper-left corner of the area to which the region specified by <em>srcRect</em> is copied.</p> </dd></param>	
        /// <param name="bitmap"><dd>  <p>The bitmap to copy from.</p> </dd></param>	
        /// <param name="srcRect"><dd>  <p>The area of <em>bitmap</em> to copy.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method does not update the size of the  current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion, and will fail if the bitmap formats do not match.</p><p>Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <strong><see cref="SharpDX.Result"/></strong> and tag state will be returned at the next call to <strong>EndDraw</strong> or <strong>Flush</strong>.</p><p>Starting with Windows?8.1,  this method supports block compressed bitmaps.  If you are using a block compressed format, the end coordinates of the <em>srcRect</em> parameter must be multiples of 4 or the method returns <strong>E_INVALIDARG</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap::CopyFromBitmap']/*"/>	
        /// <msdn-id>dd371152</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Bitmap::CopyFromBitmap([In, Optional] const D2D_POINT_2U* destPoint,[In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_U* srcRect)</unmanaged>	
        /// <unmanaged-short>ID2D1Bitmap::CopyFromBitmap</unmanaged-short>	
        internal void CopyFromBitmap(SharpDX.Mathematics.Interop.RawPoint? destPoint, SharpDX.Direct2D1.Bitmap bitmap, SharpDX.Mathematics.Interop.RawRectangle? srcRect)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawPoint destPoint_;
                if (destPoint.HasValue)
                    destPoint_ = destPoint.Value;
                SharpDX.Mathematics.Interop.RawRectangle srcRect_;
                if (srcRect.HasValue)
                    srcRect_ = srcRect.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (destPoint.HasValue) ? &destPoint_ : (void*)IntPtr.Zero, (void*)((bitmap == null) ? IntPtr.Zero : bitmap.NativePointer), (srcRect.HasValue) ? &srcRect_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Copies the specified region from the specified render target into the current bitmap. </p>	
        /// </summary>	
        /// <param name="destPoint"><dd>  <p>In the current bitmap, the upper-left corner of the area to which the region specified by <em>srcRect</em> is copied.</p> </dd></param>	
        /// <param name="renderTarget"><dd>  <p>The render target that contains the region to copy.</p> </dd></param>	
        /// <param name="srcRect"><dd>  <p>The area of <em>renderTarget</em> to copy.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion, and will fail if the bitmap formats do not match.</p><p>Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <strong><see cref="SharpDX.Result"/></strong> and tag state will be returned at the next call to <strong>EndDraw</strong> or <strong>Flush</strong>. </p><p>All clips and layers must be popped off of the render target before calling this method.  The method returns <strong><see cref="SharpDX.Direct2D1.ResultCode.RenderTargetHasLayerOrCliprect"/></strong> if any clips or layers are currently applied to the render target.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap::CopyFromRenderTarget']/*"/>	
        /// <msdn-id>dd371158</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Bitmap::CopyFromRenderTarget([In, Optional] const D2D_POINT_2U* destPoint,[In] ID2D1RenderTarget* renderTarget,[In, Optional] const D2D_RECT_U* srcRect)</unmanaged>	
        /// <unmanaged-short>ID2D1Bitmap::CopyFromRenderTarget</unmanaged-short>	
        internal void CopyFromRenderTarget(SharpDX.Mathematics.Interop.RawPoint? destPoint, SharpDX.Direct2D1.RenderTarget renderTarget, SharpDX.Mathematics.Interop.RawRectangle? srcRect)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawPoint destPoint_;
                if (destPoint.HasValue)
                    destPoint_ = destPoint.Value;
                SharpDX.Mathematics.Interop.RawRectangle srcRect_;
                if (srcRect.HasValue)
                    srcRect_ = srcRect.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (destPoint.HasValue) ? &destPoint_ : (void*)IntPtr.Zero, (void*)((renderTarget == null) ? IntPtr.Zero : renderTarget.NativePointer), (srcRect.HasValue) ? &srcRect_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Copies the specified region from memory into the current bitmap. </p>	
        /// </summary>	
        /// <param name="dstRect"><dd>  <p>In the current bitmap, the upper-left corner of the area to which the region specified by <em>srcRect</em> is copied.</p> </dd></param>	
        /// <param name="srcData"><dd>  <p>The data to copy.</p> </dd></param>	
        /// <param name="pitch"><dd>  <p>The stride, or pitch, of the source bitmap stored in <em>srcData</em>. The stride is the byte count of a scanline (one row of pixels in memory). The stride can be computed from the following formula: pixel width * bytes per pixel + memory padding.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion; the two bitmap formats should match. </p><p>If this method is passed invalid input (such as an invalid destination rectangle), can produce unpredictable results, such as a distorted image or device failure.</p><p>Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <strong><see cref="SharpDX.Result"/></strong> and tag state will be returned at the next call to <strong>EndDraw</strong> or <strong>Flush</strong>. </p><p>Starting with Windows?8.1,  this method supports block compressed bitmaps.  If you are using a block compressed format, the end coordinates of the <em>srcRect</em> parameter must be multiples of 4 or the method returns <strong>E_INVALIDARG</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap::CopyFromMemory']/*"/>	
        /// <msdn-id>dd371155</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Bitmap::CopyFromMemory([In, Optional] const D2D_RECT_U* dstRect,[In] const void* srcData,[In] unsigned int pitch)</unmanaged>	
        /// <unmanaged-short>ID2D1Bitmap::CopyFromMemory</unmanaged-short>	
        internal void CopyFromMemory(SharpDX.Mathematics.Interop.RawRectangle? dstRect, System.IntPtr srcData, int pitch)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangle dstRect_;
                if (dstRect.HasValue)
                    dstRect_ = dstRect.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (dstRect.HasValue) ? &dstRect_ : (void*)IntPtr.Zero, (void*)srcData, pitch, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Represents a bitmap that can be used as a surface for an <strong><see cref="SharpDX.Direct2D1.DeviceContext"/></strong> or mapped into system memory, and can contain additional color context information.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap1']/*"/>	
    /// <msdn-id>hh404349</msdn-id>	
    /// <unmanaged>ID2D1Bitmap1</unmanaged>	
    /// <unmanaged-short>ID2D1Bitmap1</unmanaged-short>	
    [Guid("a898a84c-3873-4588-b08b-ebbf978df041")]
    public partial class Bitmap1 : SharpDX.Direct2D1.Bitmap
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Bitmap1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Bitmap1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Bitmap1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Bitmap1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Bitmap1(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the color context information associated with the bitmap. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If the bitmap was created without specifying a color context, the returned context is <strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap1::GetColorContext']/*"/>	
        /// <msdn-id>hh404350</msdn-id>	
        /// <unmanaged>GetColorContext</unmanaged>	
        /// <unmanaged-short>GetColorContext</unmanaged-short>	
        /// <unmanaged>void ID2D1Bitmap1::GetColorContext([Out, Optional] ID2D1ColorContext** colorContext)</unmanaged>
        public SharpDX.Direct2D1.ColorContext ColorContext
        {
            get { SharpDX.Direct2D1.ColorContext __output__; GetColorContext(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets the options used in creating the bitmap.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap1::GetOptions']/*"/>	
        /// <msdn-id>hh404351</msdn-id>	
        /// <unmanaged>GetOptions</unmanaged>	
        /// <unmanaged-short>GetOptions</unmanaged-short>	
        /// <unmanaged>D2D1_BITMAP_OPTIONS ID2D1Bitmap1::GetOptions()</unmanaged>
        public SharpDX.Direct2D1.BitmapOptions Options
        {
            get { return GetOptions(); }
        }

        /// <summary>	
        /// <p>Gets either the surface that was specified when the bitmap was created, or the default surface created when the bitmap was created. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The bitmap used must have been created from a DXGI surface render target, a derived render target, or a device context created from an <strong><see cref="SharpDX.Direct2D1.Device"/></strong>.</p><p>The returned surface can be used with Microsoft Direct3D or any other API that interoperates with shared surfaces. The application must transitively ensure that the surface is usable on the Direct3D device that is used in this context. For example, if using the surface with Direct2D  then the Direct2D render target must have been created through <strong><see cref="SharpDX.Direct2D1.Factory.CreateDxgiSurfaceRenderTarget"/></strong> or on a device context created on the same device.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap1::GetSurface']/*"/>	
        /// <msdn-id>hh404355</msdn-id>	
        /// <unmanaged>GetSurface</unmanaged>	
        /// <unmanaged-short>GetSurface</unmanaged-short>	
        /// <unmanaged>HRESULT ID2D1Bitmap1::GetSurface([Out, Optional] IDXGISurface** dxgiSurface)</unmanaged>
        public SharpDX.DXGI.Surface Surface
        {
            get { SharpDX.DXGI.Surface __output__; GetSurface(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets the color context information associated with the bitmap. </p>	
        /// </summary>	
        /// <param name="colorContext"><dd>  <p>When this method returns, contains the address of a reference to the  color context interface associated with the bitmap.</p> </dd></param>	
        /// <remarks>	
        /// <p>If the bitmap was created without specifying a color context, the returned context is <strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap1::GetColorContext']/*"/>	
        /// <msdn-id>hh404350</msdn-id>	
        /// <unmanaged>void ID2D1Bitmap1::GetColorContext([Out, Optional] ID2D1ColorContext** colorContext)</unmanaged>	
        /// <unmanaged-short>ID2D1Bitmap1::GetColorContext</unmanaged-short>	
        internal void GetColorContext(out SharpDX.Direct2D1.ColorContext colorContext)
        {
            unsafe
            {
                IntPtr colorContext_ = IntPtr.Zero;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &colorContext_, ((void**)(*(void**)_nativePointer))[11]);
                colorContext = (colorContext_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.ColorContext(colorContext_);
            }
        }

        /// <summary>	
        /// <p>Gets the options used in creating the bitmap.</p>	
        /// </summary>	
        /// <returns><p>This method returns the options used.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap1::GetOptions']/*"/>	
        /// <msdn-id>hh404351</msdn-id>	
        /// <unmanaged>D2D1_BITMAP_OPTIONS ID2D1Bitmap1::GetOptions()</unmanaged>	
        /// <unmanaged-short>ID2D1Bitmap1::GetOptions</unmanaged-short>	
        internal SharpDX.Direct2D1.BitmapOptions GetOptions()
        {
            unsafe
            {
                SharpDX.Direct2D1.BitmapOptions __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1BitmapOptions(_nativePointer, ((void**)(*(void**)_nativePointer))[12]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets either the surface that was specified when the bitmap was created, or the default surface created when the bitmap was created. </p>	
        /// </summary>	
        /// <param name="dxgiSurface"><dd>  <p>The underlying DXGI surface for the bitmap.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref="SharpDX.Direct2D1.ResultCode.BitmapBoundAsTarget"/></td><td>Cannot draw with a bitmap that is currently bound as the target bitmap.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The bitmap used must have been created from a DXGI surface render target, a derived render target, or a device context created from an <strong><see cref="SharpDX.Direct2D1.Device"/></strong>.</p><p>The returned surface can be used with Microsoft Direct3D or any other API that interoperates with shared surfaces. The application must transitively ensure that the surface is usable on the Direct3D device that is used in this context. For example, if using the surface with Direct2D  then the Direct2D render target must have been created through <strong><see cref="SharpDX.Direct2D1.Factory.CreateDxgiSurfaceRenderTarget"/></strong> or on a device context created on the same device.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap1::GetSurface']/*"/>	
        /// <msdn-id>hh404355</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Bitmap1::GetSurface([Out, Optional] IDXGISurface** dxgiSurface)</unmanaged>	
        /// <unmanaged-short>ID2D1Bitmap1::GetSurface</unmanaged-short>	
        internal void GetSurface(out SharpDX.DXGI.Surface dxgiSurface)
        {
            unsafe
            {
                IntPtr dxgiSurface_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &dxgiSurface_, ((void**)(*(void**)_nativePointer))[13]);
                dxgiSurface = (dxgiSurface_ == IntPtr.Zero) ? null : new SharpDX.DXGI.Surface(dxgiSurface_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Maps  the given bitmap into memory.</p>	
        /// </summary>	
        /// <param name="options"><dd>  <p>The options used in mapping the bitmap into memory.</p> </dd></param>	
        /// <param name="mappedRect"><dd>  <p>When this method returns, contains a reference to the rectangle that is mapped into memory.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are not valid</td></tr> <tr><td>D3DERR_DEVICELOST</td><td>The device has been lost but cannot be reset at this time.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??You can't use bitmaps for some purposes while mapped. Particularly, the <strong><see cref="SharpDX.Direct2D1.Bitmap.CopyFromBitmap"/></strong> method doesn't work if either the source or destination bitmap is mapped.</p><p>The bitmap must have been created with the <strong><see cref="SharpDX.Direct2D1.BitmapOptions.CpuRead"/></strong> flag specified.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap1::Map']/*"/>	
        /// <msdn-id>hh404357</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Bitmap1::Map([In] D2D1_MAP_OPTIONS options,[Out] D2D1_MAPPED_RECT* mappedRect)</unmanaged>	
        /// <unmanaged-short>ID2D1Bitmap1::Map</unmanaged-short>	
        internal void Map(SharpDX.Direct2D1.MapOptions options, out SharpDX.Direct2D1.MappedRectangle mappedRect)
        {
            unsafe
            {
                mappedRect = new SharpDX.Direct2D1.MappedRectangle();
                SharpDX.Result __result__;
                fixed (void* mappedRect_ = &mappedRect)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)options), mappedRect_, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Unmaps the bitmap from memory. </p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are not valid.</td></tr> <tr><td>E_POINTER</td><td>Pointer is not valid.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Any memory returned from the <strong>Map</strong> call is now invalid and may be reclaimed by the operating system or used for other purposes. </p><p>The bitmap must have been previously mapped.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Bitmap1::Unmap']/*"/>	
        /// <msdn-id>hh404359</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Bitmap1::Unmap()</unmanaged>	
        /// <unmanaged-short>ID2D1Bitmap1::Unmap</unmanaged-short>	
        public void Unmap()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Paints an area with a bitmap.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> A bitmap brush is used to fill a geometry with a bitmap. Like all brushes, it defines an infinite plane of content. Because bitmaps are finite, the brush relies on an "extend mode" to determine how the plane is filled horizontally and vertically.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush']/*"/>	
    /// <msdn-id>dd371122</msdn-id>	
    /// <unmanaged>ID2D1BitmapBrush</unmanaged>	
    /// <unmanaged-short>ID2D1BitmapBrush</unmanaged-short>	
    [Guid("2cd906aa-12e2-11dc-9fed-001143a055f9")]
    public partial class BitmapBrush : SharpDX.Direct2D1.Brush
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.BitmapBrush"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapBrush(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.BitmapBrush"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.BitmapBrush(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.BitmapBrush(nativePointer);
        }


        /// <summary>	
        /// <p>Gets or sets the method by which the brush horizontally tiles those areas that extend past its bitmap. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Like all brushes, <strong><see cref="SharpDX.Direct2D1.BitmapBrush"/></strong> defines an infinite plane of content. Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush::GetExtendModeX']/*"/>	
        /// <msdn-id>dd371128</msdn-id>	
        /// <unmanaged>GetExtendModeX / SetExtendModeX</unmanaged>	
        /// <unmanaged-short>GetExtendModeX</unmanaged-short>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BitmapBrush::GetExtendModeX()</unmanaged>
        public SharpDX.Direct2D1.ExtendMode ExtendModeX
        {
            get { return GetExtendModeX(); }
            set { SetExtendModeX(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the method by which the brush vertically tiles those areas that extend past its bitmap. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Like all brushes, <strong><see cref="SharpDX.Direct2D1.BitmapBrush"/></strong> defines an infinite plane of content.  Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush::GetExtendModeY']/*"/>	
        /// <msdn-id>dd371132</msdn-id>	
        /// <unmanaged>GetExtendModeY / SetExtendModeY</unmanaged>	
        /// <unmanaged-short>GetExtendModeY</unmanaged-short>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BitmapBrush::GetExtendModeY()</unmanaged>
        public SharpDX.Direct2D1.ExtendMode ExtendModeY
        {
            get { return GetExtendModeY(); }
            set { SetExtendModeY(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the interpolation method used when the brush bitmap is scaled or rotated. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method gets the interpolation mode of a bitmap, which is specified by the <strong><see cref="SharpDX.Direct2D1.BitmapInterpolationMode"/></strong> enumeration type.   <strong><see cref="SharpDX.Direct2D1.BitmapInterpolationMode.NearestNeighbor"/></strong> represents nearest neighbor filtering. It looks up the bitmap pixel nearest to the current rendering pixel and chooses its exact color. <strong><see cref="SharpDX.Direct2D1.BitmapInterpolationMode.Linear"/></strong> represents linear filtering, and  interpolates a color from the four nearest bitmap pixels.</p><p>The interpolation mode of a bitmap also affects subpixel translations. In a subpixel translation, linear interpolation positions the bitmap more precisely to the application request, but blurs the bitmap in the process. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush::GetInterpolationMode']/*"/>	
        /// <msdn-id>dd371134</msdn-id>	
        /// <unmanaged>GetInterpolationMode / SetInterpolationMode</unmanaged>	
        /// <unmanaged-short>GetInterpolationMode</unmanaged-short>	
        /// <unmanaged>D2D1_BITMAP_INTERPOLATION_MODE ID2D1BitmapBrush::GetInterpolationMode()</unmanaged>
        public SharpDX.Direct2D1.BitmapInterpolationMode InterpolationMode
        {
            get { return GetInterpolationMode(); }
            set { SetInterpolationMode(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the bitmap source that this brush uses to paint.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush::GetBitmap']/*"/>	
        /// <msdn-id>dd371124</msdn-id>	
        /// <unmanaged>GetBitmap / SetBitmap</unmanaged>	
        /// <unmanaged-short>GetBitmap</unmanaged-short>	
        /// <unmanaged>void ID2D1BitmapBrush::GetBitmap([Out] ID2D1Bitmap** bitmap)</unmanaged>
        public SharpDX.Direct2D1.Bitmap Bitmap
        {
            get { SharpDX.Direct2D1.Bitmap __output__; GetBitmap(out __output__); return __output__; }
            set { SetBitmap(value); }
        }

        /// <summary>	
        /// <p>Specifies how the brush horizontally tiles those areas that extend past its bitmap. </p>	
        /// </summary>	
        /// <param name="extendModeX"><dd>  <p>A value that specifies how the brush horizontally tiles those areas that extend past its bitmap. </p> </dd></param>	
        /// <remarks>	
        /// <p>Sometimes, the  bitmap for a bitmap brush doesn't completely fill the area being painted. When this happens, Direct2D uses the brush's horizontal (<strong>SetExtendModeX</strong>) and vertical (<strong>SetExtendModeY</strong>) extend mode settings to determine how to fill the remaining area.</p><p>The following illustration shows the results from  every  possible combination of the extend modes for an <strong><see cref="SharpDX.Direct2D1.BitmapBrush"/></strong>: <strong><see cref="SharpDX.Direct2D1.ExtendMode.Clamp"/></strong> (CLAMP), <strong><see cref="SharpDX.Direct2D1.ExtendMode.Wrap"/></strong> (WRAP), and <strong>D2D1_EXTEND_MIRROR</strong> (MIRROR).</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush::SetExtendModeX']/*"/>	
        /// <msdn-id>dd371139</msdn-id>	
        /// <unmanaged>void ID2D1BitmapBrush::SetExtendModeX([In] D2D1_EXTEND_MODE extendModeX)</unmanaged>	
        /// <unmanaged-short>ID2D1BitmapBrush::SetExtendModeX</unmanaged-short>	
        internal void SetExtendModeX(SharpDX.Direct2D1.ExtendMode extendModeX)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)extendModeX), ((void**)(*(void**)_nativePointer))[8]);
            }
        }

        /// <summary>	
        /// <p>Specifies how the brush vertically tiles those areas that extend past its bitmap.</p>	
        /// </summary>	
        /// <param name="extendModeY"><dd>  <p>A value that specifies how the brush vertically tiles those areas that extend past its bitmap.</p> </dd></param>	
        /// <remarks>	
        /// <p>Sometimes, the  bitmap for a bitmap brush doesn't completely fill the area being painted. When this happens, Direct2D uses the brush's horizontal (<strong>SetExtendModeX</strong>) and vertical (<strong>SetExtendModeY</strong>) extend mode settings to determine how to fill the remaining area.</p><p>The following illustration shows the results from  every  possible combination of the extend modes for an <strong><see cref="SharpDX.Direct2D1.BitmapBrush"/></strong>: <strong><see cref="SharpDX.Direct2D1.ExtendMode.Clamp"/></strong> (CLAMP), <strong><see cref="SharpDX.Direct2D1.ExtendMode.Wrap"/></strong> (WRAP), and <strong>D2D1_EXTEND_MIRROR</strong> (MIRROR).</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush::SetExtendModeY']/*"/>	
        /// <msdn-id>dd371142</msdn-id>	
        /// <unmanaged>void ID2D1BitmapBrush::SetExtendModeY([In] D2D1_EXTEND_MODE extendModeY)</unmanaged>	
        /// <unmanaged-short>ID2D1BitmapBrush::SetExtendModeY</unmanaged-short>	
        internal void SetExtendModeY(SharpDX.Direct2D1.ExtendMode extendModeY)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)extendModeY), ((void**)(*(void**)_nativePointer))[9]);
            }
        }

        /// <summary>	
        /// <p>Specifies the interpolation mode used when the brush bitmap is scaled or rotated.</p>	
        /// </summary>	
        /// <param name="interpolationMode"><dd>  <p>The interpolation mode used when the brush bitmap is scaled or rotated.</p> </dd></param>	
        /// <remarks>	
        /// <p>This method sets the interpolation mode for a bitmap, which is an enum value that is specified in the <strong><see cref="SharpDX.Direct2D1.BitmapInterpolationMode"/></strong> enumeration type.   <see cref="SharpDX.Direct2D1.BitmapInterpolationMode.NearestNeighbor"/> represents nearest neighbor filtering. It looks up the nearest bitmap pixel to the current rendering pixel and chooses its exact color. <see cref="SharpDX.Direct2D1.BitmapInterpolationMode.Linear"/> represents linear filtering, and  interpolates a color from the four nearest bitmap pixels.</p><p>The interpolation mode of a bitmap also affects subpixel translations. In a subpixel translation, bilinear interpolation positions the bitmap more precisely to the application requests, but blurs the bitmap in the process. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush::SetInterpolationMode']/*"/>	
        /// <msdn-id>dd371145</msdn-id>	
        /// <unmanaged>void ID2D1BitmapBrush::SetInterpolationMode([In] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode)</unmanaged>	
        /// <unmanaged-short>ID2D1BitmapBrush::SetInterpolationMode</unmanaged-short>	
        internal void SetInterpolationMode(SharpDX.Direct2D1.BitmapInterpolationMode interpolationMode)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)interpolationMode), ((void**)(*(void**)_nativePointer))[10]);
            }
        }

        /// <summary>	
        /// <p>Specifies the bitmap source that this brush uses to paint. </p>	
        /// </summary>	
        /// <param name="bitmap"><dd>  <p>The bitmap source used by the brush.</p> </dd></param>	
        /// <remarks>	
        /// <p>This method specifies the bitmap source that this brush uses to paint. The bitmap is not resized or rescaled automatically to fit the geometry that it fills. The bitmap stays at its native size. To resize or translate the bitmap, use the <strong>SetTransform</strong> method to apply  a transform to the brush. </p><p>The native size of a bitmap is the width and height in bitmap pixels, divided by the bitmap DPI. This native size forms the base tile of the brush. To tile a subregion of the bitmap, you must generate a new bitmap containing this subregion and use <strong>SetBitmap</strong> to apply it to the brush. 	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush::SetBitmap']/*"/>	
        /// <msdn-id>dd371136</msdn-id>	
        /// <unmanaged>void ID2D1BitmapBrush::SetBitmap([In, Optional] ID2D1Bitmap* bitmap)</unmanaged>	
        /// <unmanaged-short>ID2D1BitmapBrush::SetBitmap</unmanaged-short>	
        internal void SetBitmap(SharpDX.Direct2D1.Bitmap bitmap)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((bitmap == null) ? IntPtr.Zero : bitmap.NativePointer), ((void**)(*(void**)_nativePointer))[11]);
            }
        }

        /// <summary>	
        /// <p> Gets the method by which the brush horizontally tiles those areas that extend past its bitmap. </p>	
        /// </summary>	
        /// <returns><p>A value that specifies how the brush horizontally tiles those areas that extend past its bitmap.</p></returns>	
        /// <remarks>	
        /// <p>Like all brushes, <strong><see cref="SharpDX.Direct2D1.BitmapBrush"/></strong> defines an infinite plane of content. Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush::GetExtendModeX']/*"/>	
        /// <msdn-id>dd371128</msdn-id>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BitmapBrush::GetExtendModeX()</unmanaged>	
        /// <unmanaged-short>ID2D1BitmapBrush::GetExtendModeX</unmanaged-short>	
        internal SharpDX.Direct2D1.ExtendMode GetExtendModeX()
        {
            unsafe
            {
                SharpDX.Direct2D1.ExtendMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1ExtendMode(_nativePointer, ((void**)(*(void**)_nativePointer))[12]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the method by which the brush vertically tiles those areas that extend past its bitmap. </p>	
        /// </summary>	
        /// <returns><p>A value that specifies how the brush vertically tiles those areas that extend past its bitmap.</p></returns>	
        /// <remarks>	
        /// <p>Like all brushes, <strong><see cref="SharpDX.Direct2D1.BitmapBrush"/></strong> defines an infinite plane of content.  Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush::GetExtendModeY']/*"/>	
        /// <msdn-id>dd371132</msdn-id>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BitmapBrush::GetExtendModeY()</unmanaged>	
        /// <unmanaged-short>ID2D1BitmapBrush::GetExtendModeY</unmanaged-short>	
        internal SharpDX.Direct2D1.ExtendMode GetExtendModeY()
        {
            unsafe
            {
                SharpDX.Direct2D1.ExtendMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1ExtendMode(_nativePointer, ((void**)(*(void**)_nativePointer))[13]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the interpolation method used when the brush bitmap is scaled or rotated. </p>	
        /// </summary>	
        /// <returns><p>The interpolation method used when the brush bitmap is scaled or rotated.</p></returns>	
        /// <remarks>	
        /// <p>This method gets the interpolation mode of a bitmap, which is specified by the <strong><see cref="SharpDX.Direct2D1.BitmapInterpolationMode"/></strong> enumeration type.   <strong><see cref="SharpDX.Direct2D1.BitmapInterpolationMode.NearestNeighbor"/></strong> represents nearest neighbor filtering. It looks up the bitmap pixel nearest to the current rendering pixel and chooses its exact color. <strong><see cref="SharpDX.Direct2D1.BitmapInterpolationMode.Linear"/></strong> represents linear filtering, and  interpolates a color from the four nearest bitmap pixels.</p><p>The interpolation mode of a bitmap also affects subpixel translations. In a subpixel translation, linear interpolation positions the bitmap more precisely to the application request, but blurs the bitmap in the process. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush::GetInterpolationMode']/*"/>	
        /// <msdn-id>dd371134</msdn-id>	
        /// <unmanaged>D2D1_BITMAP_INTERPOLATION_MODE ID2D1BitmapBrush::GetInterpolationMode()</unmanaged>	
        /// <unmanaged-short>ID2D1BitmapBrush::GetInterpolationMode</unmanaged-short>	
        internal SharpDX.Direct2D1.BitmapInterpolationMode GetInterpolationMode()
        {
            unsafe
            {
                SharpDX.Direct2D1.BitmapInterpolationMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1BitmapInterpolationMode(_nativePointer, ((void**)(*(void**)_nativePointer))[14]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the bitmap source that this brush uses to paint.</p>	
        /// </summary>	
        /// <param name="bitmap"><dd>  <p>When this method returns, contains the address to a reference to the bitmap with which this brush paints.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush::GetBitmap']/*"/>	
        /// <msdn-id>dd371124</msdn-id>	
        /// <unmanaged>void ID2D1BitmapBrush::GetBitmap([Out] ID2D1Bitmap** bitmap)</unmanaged>	
        /// <unmanaged-short>ID2D1BitmapBrush::GetBitmap</unmanaged-short>	
        internal void GetBitmap(out SharpDX.Direct2D1.Bitmap bitmap)
        {
            unsafe
            {
                IntPtr bitmap_ = IntPtr.Zero;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &bitmap_, ((void**)(*(void**)_nativePointer))[15]);
                bitmap = (bitmap_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.Bitmap(bitmap_);
            }
        }
    }
    /// <summary>	
    /// <p>Paints an area with a bitmap. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush1']/*"/>	
    /// <msdn-id>hh871447</msdn-id>	
    /// <unmanaged>ID2D1BitmapBrush1</unmanaged>	
    /// <unmanaged-short>ID2D1BitmapBrush1</unmanaged-short>	
    [Guid("41343a53-e41a-49a2-91cd-21793bbb62e5")]
    public partial class BitmapBrush1 : SharpDX.Direct2D1.BitmapBrush
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.BitmapBrush1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapBrush1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.BitmapBrush1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.BitmapBrush1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.BitmapBrush1(nativePointer);
        }


        /// <summary>	
        /// <p>Returns or sets the current interpolation mode of the brush.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush1::GetInterpolationMode1']/*"/>	
        /// <msdn-id>hh871448</msdn-id>	
        /// <unmanaged>GetInterpolationMode1 / SetInterpolationMode1</unmanaged>	
        /// <unmanaged-short>GetInterpolationMode1</unmanaged-short>	
        /// <unmanaged>D2D1_INTERPOLATION_MODE ID2D1BitmapBrush1::GetInterpolationMode1()</unmanaged>
        public SharpDX.Direct2D1.InterpolationMode InterpolationMode1
        {
            get { return GetInterpolationMode1(); }
            set { SetInterpolationMode1(value); }
        }

        /// <summary>	
        /// <p>Sets the interpolation mode for the brush.</p>	
        /// </summary>	
        /// <param name="interpolationMode"><dd>  <p>The mode to use.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush1::SetInterpolationMode1']/*"/>	
        /// <msdn-id>hh871449</msdn-id>	
        /// <unmanaged>void ID2D1BitmapBrush1::SetInterpolationMode1([In] D2D1_INTERPOLATION_MODE interpolationMode)</unmanaged>	
        /// <unmanaged-short>ID2D1BitmapBrush1::SetInterpolationMode1</unmanaged-short>	
        internal void SetInterpolationMode1(SharpDX.Direct2D1.InterpolationMode interpolationMode)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)interpolationMode), ((void**)(*(void**)_nativePointer))[16]);
            }
        }

        /// <summary>	
        /// <p>Returns the current interpolation mode of the brush.</p>	
        /// </summary>	
        /// <returns><p>The current interpolation mode.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapBrush1::GetInterpolationMode1']/*"/>	
        /// <msdn-id>hh871448</msdn-id>	
        /// <unmanaged>D2D1_INTERPOLATION_MODE ID2D1BitmapBrush1::GetInterpolationMode1()</unmanaged>	
        /// <unmanaged-short>ID2D1BitmapBrush1::GetInterpolationMode1</unmanaged-short>	
        internal SharpDX.Direct2D1.InterpolationMode GetInterpolationMode1()
        {
            unsafe
            {
                SharpDX.Direct2D1.InterpolationMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1InterpolationMode(_nativePointer, ((void**)(*(void**)_nativePointer))[17]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Renders to an intermediate texture created by the <strong>CreateCompatibleRenderTarget</strong> method.  </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An <strong><see cref="SharpDX.Direct2D1.BitmapRenderTarget"/></strong> writes to an intermediate texture. It's useful for creating patterns for use with an <strong><see cref="SharpDX.Direct2D1.BitmapBrush"/></strong> or caching drawing data that will be used repeatedly. </p><p>To write directly to a WIC bitmap instead, use the <strong><see cref="SharpDX.Direct2D1.Factory.CreateWicBitmapRenderTarget"/></strong> method. This method returns an <strong><see cref="SharpDX.Direct2D1.RenderTarget"/></strong> that writes to the specified WIC bitmap. For an example, see the Save as Image File Sample.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapRenderTarget']/*"/>	
    /// <msdn-id>dd371146</msdn-id>	
    /// <unmanaged>ID2D1BitmapRenderTarget</unmanaged>	
    /// <unmanaged-short>ID2D1BitmapRenderTarget</unmanaged-short>	
    [Guid("2cd90695-12e2-11dc-9fed-001143a055f9")]
    public partial class BitmapRenderTarget : SharpDX.Direct2D1.RenderTarget
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.BitmapRenderTarget"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapRenderTarget(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.BitmapRenderTarget"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.BitmapRenderTarget(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.BitmapRenderTarget(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves the bitmap for this render target. The returned bitmap can be used for drawing operations. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The DPI for the <strong><see cref="SharpDX.Direct2D1.Bitmap"/></strong> obtained from <strong>GetBitmap</strong> will be the DPI of the <strong><see cref="SharpDX.Direct2D1.BitmapRenderTarget"/></strong> when the render target was created. Changing the DPI of the <strong><see cref="SharpDX.Direct2D1.BitmapRenderTarget"/></strong> by calling  <strong>SetDpi</strong> doesn't affect the DPI of the bitmap, even if <strong>SetDpi</strong> is called before <strong>GetBitmap</strong>. Using <strong>SetDpi</strong> to change the DPI of the <strong><see cref="SharpDX.Direct2D1.BitmapRenderTarget"/></strong> does affect how contents are rendered into the bitmap: it just doesn't affect the DPI of the bitmap retrieved by <strong>GetBitmap</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapRenderTarget::GetBitmap']/*"/>	
        /// <msdn-id>dd371150</msdn-id>	
        /// <unmanaged>GetBitmap</unmanaged>	
        /// <unmanaged-short>GetBitmap</unmanaged-short>	
        /// <unmanaged>HRESULT ID2D1BitmapRenderTarget::GetBitmap([Out] ID2D1Bitmap** bitmap)</unmanaged>
        public SharpDX.Direct2D1.Bitmap Bitmap
        {
            get { SharpDX.Direct2D1.Bitmap __output__; GetBitmap(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Retrieves the bitmap for this render target. The returned bitmap can be used for drawing operations. </p>	
        /// </summary>	
        /// <param name="bitmap"><dd>  <p>When this method returns, contains the address of a reference to the bitmap for this render target. This bitmap can be used for drawing operations. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The DPI for the <strong><see cref="SharpDX.Direct2D1.Bitmap"/></strong> obtained from <strong>GetBitmap</strong> will be the DPI of the <strong><see cref="SharpDX.Direct2D1.BitmapRenderTarget"/></strong> when the render target was created. Changing the DPI of the <strong><see cref="SharpDX.Direct2D1.BitmapRenderTarget"/></strong> by calling  <strong>SetDpi</strong> doesn't affect the DPI of the bitmap, even if <strong>SetDpi</strong> is called before <strong>GetBitmap</strong>. Using <strong>SetDpi</strong> to change the DPI of the <strong><see cref="SharpDX.Direct2D1.BitmapRenderTarget"/></strong> does affect how contents are rendered into the bitmap: it just doesn't affect the DPI of the bitmap retrieved by <strong>GetBitmap</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BitmapRenderTarget::GetBitmap']/*"/>	
        /// <msdn-id>dd371150</msdn-id>	
        /// <unmanaged>HRESULT ID2D1BitmapRenderTarget::GetBitmap([Out] ID2D1Bitmap** bitmap)</unmanaged>	
        /// <unmanaged-short>ID2D1BitmapRenderTarget::GetBitmap</unmanaged-short>	
        internal void GetBitmap(out SharpDX.Direct2D1.Bitmap bitmap)
        {
            unsafe
            {
                IntPtr bitmap_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &bitmap_, ((void**)(*(void**)_nativePointer))[57]);
                bitmap = (bitmap_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.Bitmap(bitmap_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides methods to allow a blend operation to be inserted into a transform graph.</p><p>The image output of the blend transform is the same as rendering an image effect graph with these steps:</p><ul> <li>Copy the first input to the destination image.</li> <li>Render the next input on top using the blend description.</li> <li>Continue for each additional input.</li> </ul>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BlendTransform']/*"/>	
    /// <msdn-id>hh404361</msdn-id>	
    /// <unmanaged>ID2D1BlendTransform</unmanaged>	
    /// <unmanaged-short>ID2D1BlendTransform</unmanaged-short>	
    [Guid("63ac0b32-ba44-450f-8806-7f4ca1ff2f1b")]
    public partial class BlendTransform : SharpDX.Direct2D1.ConcreteTransform
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.BlendTransform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BlendTransform(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.BlendTransform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.BlendTransform(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.BlendTransform(nativePointer);
        }


        /// <summary>	
        /// <p>Gets or sets the blend description of the corresponding blend transform object.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BlendTransform::GetDescription']/*"/>	
        /// <msdn-id>hh404363</msdn-id>	
        /// <unmanaged>GetDescription / SetDescription</unmanaged>	
        /// <unmanaged-short>GetDescription</unmanaged-short>	
        /// <unmanaged>void ID2D1BlendTransform::GetDescription([Out] D2D1_BLEND_DESCRIPTION* description)</unmanaged>
        public SharpDX.Direct2D1.BlendDescription Description
        {
            get { SharpDX.Direct2D1.BlendDescription __output__; GetDescription(out __output__); return __output__; }
            set { SetDescription(ref value); }
        }

        /// <summary>	
        /// <p>Changes the blend description of the corresponding blend transform object.</p>	
        /// </summary>	
        /// <param name="description"><dd>  <p>The new blend description specified for the blend transform.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BlendTransform::SetDescription']/*"/>	
        /// <msdn-id>hh404365</msdn-id>	
        /// <unmanaged>void ID2D1BlendTransform::SetDescription([In] const D2D1_BLEND_DESCRIPTION* description)</unmanaged>	
        /// <unmanaged-short>ID2D1BlendTransform::SetDescription</unmanaged-short>	
        internal void SetDescription(ref SharpDX.Direct2D1.BlendDescription description)
        {
            unsafe
            {
                fixed (void* description_ = &description)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, description_, ((void**)(*(void**)_nativePointer))[6]);
            }
        }

        /// <summary>	
        /// <p>Gets the blend description of the corresponding blend transform object.</p>	
        /// </summary>	
        /// <param name="description"><dd>  <p>When this method returns, contains the blend description specified for the blend transform.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BlendTransform::GetDescription']/*"/>	
        /// <msdn-id>hh404363</msdn-id>	
        /// <unmanaged>void ID2D1BlendTransform::GetDescription([Out] D2D1_BLEND_DESCRIPTION* description)</unmanaged>	
        /// <unmanaged-short>ID2D1BlendTransform::GetDescription</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct2D1.BlendDescription description)
        {
            unsafe
            {
                description = new SharpDX.Direct2D1.BlendDescription();
                fixed (void* description_ = &description)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, description_, ((void**)(*(void**)_nativePointer))[7]);
            }
        }
    }
    /// <summary>	
    /// <p>Extends the input rectangle to infinity using the specified extend modes.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BorderTransform']/*"/>	
    /// <msdn-id>hh404367</msdn-id>	
    /// <unmanaged>ID2D1BorderTransform</unmanaged>	
    /// <unmanaged-short>ID2D1BorderTransform</unmanaged-short>	
    [Guid("4998735c-3a19-473c-9781-656847e3a347")]
    public partial class BorderTransform : SharpDX.Direct2D1.ConcreteTransform
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.BorderTransform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BorderTransform(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.BorderTransform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.BorderTransform(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.BorderTransform(nativePointer);
        }


        /// <summary>	
        /// <p>Gets or sets the extend mode in the x direction.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BorderTransform::GetExtendModeX']/*"/>	
        /// <msdn-id>hh404381</msdn-id>	
        /// <unmanaged>GetExtendModeX / SetExtendModeX</unmanaged>	
        /// <unmanaged-short>GetExtendModeX</unmanaged-short>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BorderTransform::GetExtendModeX()</unmanaged>
        public SharpDX.Direct2D1.ExtendMode ExtendModeX
        {
            get { return GetExtendModeX(); }
            set { SetExtendModeX(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the extend mode in the y direction.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BorderTransform::GetExtendModeY']/*"/>	
        /// <msdn-id>hh404383</msdn-id>	
        /// <unmanaged>GetExtendModeY / SetExtendModeY</unmanaged>	
        /// <unmanaged-short>GetExtendModeY</unmanaged-short>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BorderTransform::GetExtendModeY()</unmanaged>
        public SharpDX.Direct2D1.ExtendMode ExtendModeY
        {
            get { return GetExtendModeY(); }
            set { SetExtendModeY(value); }
        }

        /// <summary>	
        /// <p>Sets the extend mode in the x direction.</p>	
        /// </summary>	
        /// <param name="extendMode"><dd>  <p>The extend mode in the x direction.</p> </dd></param>	
        /// <remarks>	
        /// <p>If the extend mode enumeration is invalid, this operation is ignored.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BorderTransform::SetExtendModeX']/*"/>	
        /// <msdn-id>hh404385</msdn-id>	
        /// <unmanaged>void ID2D1BorderTransform::SetExtendModeX([In] D2D1_EXTEND_MODE extendMode)</unmanaged>	
        /// <unmanaged-short>ID2D1BorderTransform::SetExtendModeX</unmanaged-short>	
        internal void SetExtendModeX(SharpDX.Direct2D1.ExtendMode extendMode)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)extendMode), ((void**)(*(void**)_nativePointer))[6]);
            }
        }

        /// <summary>	
        /// <p>Sets the extend mode in the y direction.</p>	
        /// </summary>	
        /// <param name="extendMode"><dd>  <p>The extend mode in the y direction.</p> </dd></param>	
        /// <remarks>	
        /// <p>If the extend mode enumeration is invalid, this operation is ignored.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BorderTransform::SetExtendModeY']/*"/>	
        /// <msdn-id>hh404387</msdn-id>	
        /// <unmanaged>void ID2D1BorderTransform::SetExtendModeY([In] D2D1_EXTEND_MODE extendMode)</unmanaged>	
        /// <unmanaged-short>ID2D1BorderTransform::SetExtendModeY</unmanaged-short>	
        internal void SetExtendModeY(SharpDX.Direct2D1.ExtendMode extendMode)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)extendMode), ((void**)(*(void**)_nativePointer))[7]);
            }
        }

        /// <summary>	
        /// <p>Gets the extend mode in the x direction.</p>	
        /// </summary>	
        /// <returns><p>This method returns the extend mode in the x direction.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BorderTransform::GetExtendModeX']/*"/>	
        /// <msdn-id>hh404381</msdn-id>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BorderTransform::GetExtendModeX()</unmanaged>	
        /// <unmanaged-short>ID2D1BorderTransform::GetExtendModeX</unmanaged-short>	
        internal SharpDX.Direct2D1.ExtendMode GetExtendModeX()
        {
            unsafe
            {
                SharpDX.Direct2D1.ExtendMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1ExtendMode(_nativePointer, ((void**)(*(void**)_nativePointer))[8]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the extend mode in the y direction.</p>	
        /// </summary>	
        /// <returns><p>This method returns the extend mode in the y direction.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BorderTransform::GetExtendModeY']/*"/>	
        /// <msdn-id>hh404383</msdn-id>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BorderTransform::GetExtendModeY()</unmanaged>	
        /// <unmanaged-short>ID2D1BorderTransform::GetExtendModeY</unmanaged-short>	
        internal SharpDX.Direct2D1.ExtendMode GetExtendModeY()
        {
            unsafe
            {
                SharpDX.Direct2D1.ExtendMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1ExtendMode(_nativePointer, ((void**)(*(void**)_nativePointer))[9]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>A support transform for effects to modify the output rectangle of the previous effect or bitmap.   </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The support transform can be used for two different reasons.</p><ul> <li> <p>To indicate that a region of its input image is already transparent black.  The expanded area will be treated as transparent black.</p> <p>This can increase efficiency for rendering bitmaps.</p> </li> <li> <p>To increase the size of the input image.</p> </li> </ul><p>?</p><p>?</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BoundsAdjustmentTransform']/*"/>	
    /// <msdn-id>hh847963</msdn-id>	
    /// <unmanaged>ID2D1BoundsAdjustmentTransform</unmanaged>	
    /// <unmanaged-short>ID2D1BoundsAdjustmentTransform</unmanaged-short>	
    [Guid("90f732e2-5092-4606-a819-8651970baccd")]
    public partial class BoundsAdjustmentTransform : SharpDX.Direct2D1.TransformNodeNative
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.BoundsAdjustmentTransform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BoundsAdjustmentTransform(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.BoundsAdjustmentTransform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.BoundsAdjustmentTransform(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.BoundsAdjustmentTransform(nativePointer);
        }


        /// <summary>	
        /// <p>This sets the output bounds for the support transform.</p>	
        /// </summary>	
        /// <param name="outputBounds"><dd>  <p>The output bounds.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BoundsAdjustmentTransform::SetOutputBounds']/*"/>	
        /// <msdn-id>hh847965</msdn-id>	
        /// <unmanaged>void ID2D1BoundsAdjustmentTransform::SetOutputBounds([In] const RECT* outputBounds)</unmanaged>	
        /// <unmanaged-short>ID2D1BoundsAdjustmentTransform::SetOutputBounds</unmanaged-short>	
        public void SetOutputBounds(SharpDX.Mathematics.Interop.RawRectangle outputBounds)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &outputBounds, ((void**)(*(void**)_nativePointer))[4]);
            }
        }

        /// <summary>	
        /// <p>Returns the output rectangle of the support transform.</p>	
        /// </summary>	
        /// <param name="outputBounds"><dd>  <p>The output bounds.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1BoundsAdjustmentTransform::GetOutputBounds']/*"/>	
        /// <msdn-id>hh847964</msdn-id>	
        /// <unmanaged>void ID2D1BoundsAdjustmentTransform::GetOutputBounds([Out] RECT* outputBounds)</unmanaged>	
        /// <unmanaged-short>ID2D1BoundsAdjustmentTransform::GetOutputBounds</unmanaged-short>	
        public void GetOutputBounds(out SharpDX.Mathematics.Interop.RawRectangle outputBounds)
        {
            unsafe
            {
                outputBounds = new SharpDX.Mathematics.Interop.RawRectangle();
                fixed (void* outputBounds_ = &outputBounds)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, outputBounds_, ((void**)(*(void**)_nativePointer))[5]);
            }
        }
    }
    /// <summary>	
    /// <p>Defines an object that paints an area. Interfaces that derive from <strong><see cref="SharpDX.Direct2D1.Brush"/></strong> describe how the area is painted. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An <strong><see cref="SharpDX.Direct2D1.BitmapBrush"/></strong> is a device-dependent resource: your application should create bitmap brushes after it initializes the render target with which the bitmap brush will be used, and recreate the bitmap brush whenever the render target needs recreated. (For more information about resources, see Resources Overview.)</p><p>Brush space in Direct2D is specified differently than in XPS and Windows Presentation Foundation (WPF). In Direct2D, brush space is not relative to the object being drawn, but rather is the current coordinate system of the render target, transformed by the brush transform, if present. To paint an object as it would be painted by a WPF brush, you must translate the brush space origin to the upper-left corner of the object's bounding box, and then scale the brush space so that the base tile fills the bounding box of the object.</p><p>For more information about brushes, see the Brushes Overview. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Brush']/*"/>	
    /// <msdn-id>dd371173</msdn-id>	
    /// <unmanaged>ID2D1Brush</unmanaged>	
    /// <unmanaged-short>ID2D1Brush</unmanaged-short>	
    [Guid("2cd906a8-12e2-11dc-9fed-001143a055f9")]
    public partial class Brush : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Brush"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Brush(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Brush"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Brush(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Brush(nativePointer);
        }


        /// <summary>	
        /// <p>Gets or sets the degree of opacity of this brush.   </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Brush::GetOpacity']/*"/>	
        /// <msdn-id>dd371176</msdn-id>	
        /// <unmanaged>GetOpacity / SetOpacity</unmanaged>	
        /// <unmanaged-short>GetOpacity</unmanaged-short>	
        /// <unmanaged>float ID2D1Brush::GetOpacity()</unmanaged>
        public float Opacity
        {
            get { return GetOpacity(); }
            set { SetOpacity(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the transform applied to this brush. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>When the brush transform is the identity matrix, the brush appears in the same coordinate space as the render target in which it is drawn.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Brush::GetTransform']/*"/>	
        /// <msdn-id>dd371179</msdn-id>	
        /// <unmanaged>GetTransform / SetTransform</unmanaged>	
        /// <unmanaged-short>GetTransform</unmanaged-short>	
        /// <unmanaged>void ID2D1Brush::GetTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 Transform
        {
            get { SharpDX.Mathematics.Interop.RawMatrix3x2 __output__; GetTransform(out __output__); return __output__; }
            set { SetTransform(ref value); }
        }

        /// <summary>	
        /// <p>Sets the degree of opacity of this brush.</p>	
        /// </summary>	
        /// <param name="opacity"><dd>  <p>A value between zero and 1 that indicates the opacity of the brush. This value is a constant multiplier that linearly scales the alpha value of all pixels filled by the brush. The opacity values are clamped in the range 0?1 before they are multipled together. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Brush::SetOpacity']/*"/>	
        /// <msdn-id>dd371181</msdn-id>	
        /// <unmanaged>void ID2D1Brush::SetOpacity([In] float opacity)</unmanaged>	
        /// <unmanaged-short>ID2D1Brush::SetOpacity</unmanaged-short>	
        internal void SetOpacity(float opacity)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, opacity, ((void**)(*(void**)_nativePointer))[4]);
            }
        }

        /// <summary>	
        /// Sets the transformation applied to the brush.	
        /// </summary>	
        /// <param name="transform">No documentation.</param>	
        /// <remarks>	
        /// <p>When you paint with a brush, it paints in the coordinate space of the render target. Brushes do not automatically position themselves to align with the object being painted; by default, they begin painting at the origin (0, 0) of the render target. </p><p>You can "move" the gradient defined by an <strong><see cref="SharpDX.Direct2D1.LinearGradientBrush"/></strong> to a target area by setting its start point and end point. Likewise, you can move the gradient defined by an <strong><see cref="SharpDX.Direct2D1.RadialGradientBrush"/></strong> by changing its center and radii. </p><p>To align the content of an <strong><see cref="SharpDX.Direct2D1.BitmapBrush"/></strong> to the area being painted, you can use the <strong>SetTransform</strong> method to translate the bitmap to the desired location. This transform only affects the brush; it does not affect any other content drawn by the render target. </p><p>The following illustrations show the effect of using an <strong><see cref="SharpDX.Direct2D1.BitmapBrush"/></strong> to fill a rectangle located at (100, 100). The illustration on the left illustration shows the result of filling the rectangle without transforming the brush: the bitmap is drawn at the render target's origin. As a result, only a portion of the bitmap appears in the rectangle.</p><p>The illustration on the right shows the result of transforming the <strong><see cref="SharpDX.Direct2D1.BitmapBrush"/></strong> so that its content is shifted 50 pixels to the right and 50 pixels down. The bitmap now fills the rectangle.</p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Brush::SetTransform']/*"/>	
        /// <msdn-id>dd742690</msdn-id>	
        /// <unmanaged>void ID2D1Brush::SetTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>	
        /// <unmanaged-short>ID2D1Brush::SetTransform</unmanaged-short>	
        internal void SetTransform(ref SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            unsafe
            {
                fixed (void* transform_ = &transform)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, transform_, ((void**)(*(void**)_nativePointer))[5]);
            }
        }

        /// <summary>	
        /// <p>Gets the degree of opacity of this brush.   </p>	
        /// </summary>	
        /// <returns><p>A value between zero and 1 that indicates the opacity of the brush. This value is a constant multiplier that linearly scales the alpha value of all pixels filled by the brush. The opacity values are clamped in the range 0?1 before they are multipled together. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Brush::GetOpacity']/*"/>	
        /// <msdn-id>dd371176</msdn-id>	
        /// <unmanaged>float ID2D1Brush::GetOpacity()</unmanaged>	
        /// <unmanaged-short>ID2D1Brush::GetOpacity</unmanaged-short>	
        internal float GetOpacity()
        {
            unsafe
            {
                float __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callifloat(_nativePointer, ((void**)(*(void**)_nativePointer))[6]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the transform applied to this brush. </p>	
        /// </summary>	
        /// <param name="transform"><dd>  <p>The transform applied to this brush.</p> </dd></param>	
        /// <remarks>	
        /// <p>When the brush transform is the identity matrix, the brush appears in the same coordinate space as the render target in which it is drawn.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Brush::GetTransform']/*"/>	
        /// <msdn-id>dd371179</msdn-id>	
        /// <unmanaged>void ID2D1Brush::GetTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>	
        /// <unmanaged-short>ID2D1Brush::GetTransform</unmanaged-short>	
        internal void GetTransform(out SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            unsafe
            {
                transform = new SharpDX.Mathematics.Interop.RawMatrix3x2();
                fixed (void* transform_ = &transform)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, transform_, ((void**)(*(void**)_nativePointer))[7]);
            }
        }
    }
    /// <summary>	
    /// <p>Represents a color context that can be used with an <strong><see cref="SharpDX.Direct2D1.Bitmap1"/></strong> object.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ColorContext']/*"/>	
    /// <msdn-id>hh404388</msdn-id>	
    /// <unmanaged>ID2D1ColorContext</unmanaged>	
    /// <unmanaged-short>ID2D1ColorContext</unmanaged-short>	
    [Guid("1c4820bb-5771-4518-a581-2fe4dd0ec657")]
    public partial class ColorContext : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.ColorContext"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ColorContext(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.ColorContext"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.ColorContext(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.ColorContext(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ColorContext::GetColorSpace']/*"/>	
        /// <unmanaged>GetColorSpace</unmanaged>	
        /// <unmanaged-short>GetColorSpace</unmanaged-short>	
        /// <unmanaged>D2D1_COLOR_SPACE ID2D1ColorContext::GetColorSpace()</unmanaged>
        public SharpDX.Direct2D1.ColorSpace ColorSpace
        {
            get { return GetColorSpace(); }
        }

        /// <summary>	
        /// <p>Gets the size of the color profile associated with the bitmap. 	</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This can be used to allocate a buffer to receive the color profile bytes associated with the context.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ColorContext::GetProfileSize']/*"/>	
        /// <msdn-id>hh404390</msdn-id>	
        /// <unmanaged>GetProfileSize</unmanaged>	
        /// <unmanaged-short>GetProfileSize</unmanaged-short>	
        /// <unmanaged>unsigned int ID2D1ColorContext::GetProfileSize()</unmanaged>
        internal int ProfileSize
        {
            get { return GetProfileSize(); }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ColorContext::GetColorSpace']/*"/>	
        /// <unmanaged>D2D1_COLOR_SPACE ID2D1ColorContext::GetColorSpace()</unmanaged>	
        /// <unmanaged-short>ID2D1ColorContext::GetColorSpace</unmanaged-short>	
        internal SharpDX.Direct2D1.ColorSpace GetColorSpace()
        {
            unsafe
            {
                SharpDX.Direct2D1.ColorSpace __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1ColorSpace(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the size of the color profile associated with the bitmap. 	</p>	
        /// </summary>	
        /// <returns><p>This method returns the  size of the profile in bytes.</p></returns>	
        /// <remarks>	
        /// <p>This can be used to allocate a buffer to receive the color profile bytes associated with the context.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ColorContext::GetProfileSize']/*"/>	
        /// <msdn-id>hh404390</msdn-id>	
        /// <unmanaged>unsigned int ID2D1ColorContext::GetProfileSize()</unmanaged>	
        /// <unmanaged-short>ID2D1ColorContext::GetProfileSize</unmanaged-short>	
        internal int GetProfileSize()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the color profile bytes for an <strong><see cref="SharpDX.Direct2D1.ColorContext"/></strong>. </p>	
        /// </summary>	
        /// <param name="rofileRef">No documentation.</param>	
        /// <param name="profileSize">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>D2DERR_INSUFFICIENT_BUFFER</td><td>The supplied buffer was too small to accomodate the data.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If <em>profileSize</em> is insufficient to store the entire profile, <em>profile</em> is zero-initialized before this method fails.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ColorContext::GetProfile']/*"/>	
        /// <msdn-id>hh404389</msdn-id>	
        /// <unmanaged>HRESULT ID2D1ColorContext::GetProfile([Out, Buffer] unsigned char* profile,[In] unsigned int profileSize)</unmanaged>	
        /// <unmanaged-short>ID2D1ColorContext::GetProfile</unmanaged-short>	
        internal void GetProfile(byte[] rofileRef, int profileSize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* rofileRef_ = rofileRef)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, rofileRef_, profileSize, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a sequence of commands that can be recorded and played back.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The command list does not include static copies of resources with the recorded set of commands. All bitmaps, effects, and geometries are stored as references to the actual resource and all the brushes are stored by value. All the resource creation and destruction happens outside of the command list. The following table  	lists resources and how they are treated inside of a command list.</p><table> <tr><th>Resource</th><th>How it is treated by the command list</th></tr> <tr><td>Solid-color brush</td><td>Passed by value.</td></tr> <tr><td>Bitmap brush</td><td>The brush is passed by value but the bitmap that is used to create the brush is in fact referenced.</td></tr> <tr><td>Gradient brushes ? both linear and radial gradient</td><td>The brush is passed by value but the gradient stop collection itself is referenced. The gradient stop collection object is immutable. </td></tr> <tr><td>Bitmaps</td><td>Passed by reference.</td></tr> <tr><td>Drawing state block</td><td>The actual state on the device context is converted into set functions like set transform and is passed by value.</td></tr> <tr><td>Geometry</td><td>Immutable object passed by value.</td></tr> <tr><td>Stroke style</td><td>Immutable object passed by value.</td></tr> <tr><td>Mesh</td><td>Immutable object passed by value.</td></tr> </table><p>?</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandList']/*"/>	
    /// <msdn-id>hh404392</msdn-id>	
    /// <unmanaged>ID2D1CommandList</unmanaged>	
    /// <unmanaged-short>ID2D1CommandList</unmanaged-short>	
    [Guid("b4f34a19-2383-4d76-94f6-ec343657c3dc")]
    public partial class CommandList : SharpDX.Direct2D1.Image
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.CommandList"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CommandList(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.CommandList"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.CommandList(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.CommandList(nativePointer);
        }


        /// <summary>	
        /// <p>Streams the contents of the command list  to the specified command sink. </p>	
        /// </summary>	
        /// <param name="sink"><dd>  <p>The sink into which the command list will be streamed.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p><p>The return value indicates any failures the command sink implementation  returns through its <strong>EndDraw</strong> method.</p></returns>	
        /// <remarks>	
        /// <p>The command sink can be implemented by any caller of the API.</p><p>If the caller makes any design-time failure calls while a command list is selected as a target, the command list is placed in an error state. The stream call fails without making any calls to the passed in sink.</p><p>Sample use:</p><pre>Class MyCommandSink : public <see cref="SharpDX.Direct2D1.CommandSink"/>	
        /// {	
        /// public: // All of the <see cref="SharpDX.Direct2D1.CommandSink"/> methods implemented here.	
        /// }; <see cref="SharpDX.Result"/>	
        /// StreamToMyCommandSink( __in <see cref="SharpDX.Direct2D1.CommandList"/> *pCommandList  )	
        /// { <see cref="SharpDX.Result"/> hr = <see cref="SharpDX.Result.Ok"/>; MyCommandSink *pCommandSink = new MyCommandSink(); hr = pCommandSink ? <see cref="SharpDX.Result.Ok"/> : E_OUTOFMEMORY; if (SUCCEEDED(hr)) { // Receive the contents of the command sink streamed to the sink. hr = pCommandList-&gt;Stream(pCommandSink); } SafeRelease(&amp;pCommandSink); return hr; }</pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandList::Stream']/*"/>	
        /// <msdn-id>hh404393</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandList::Stream([In] ID2D1CommandSink* sink)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandList::Stream</unmanaged-short>	
        internal void Stream_(System.IntPtr sink)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)sink, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Instructs the command list to stop accepting commands so that you can use it as an input to an effect or in a call to <strong><see cref="SharpDX.Direct2D1.DeviceContext.DrawImage"/></strong>.  You should call the method after it has been attached to an <strong><see cref="SharpDX.Direct2D1.DeviceContext"/></strong> and written to but before the command list is used.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref="SharpDX.Direct2D1.ResultCode.WrongState"/> </td><td>Close has already been called on the command list.</td></tr> </table><p>?</p><p> </p><p><strong>Note</strong>??If the device context associated with the command list has an error, the command list returns the same error.</p></returns>	
        /// <remarks>	
        /// <p>This method returns <see cref="SharpDX.Direct2D1.ResultCode.WrongState"/> if it has already been called on the command list. If an error occurred on the device context during population, the method returns that error. Otherwise, the method returns <see cref="SharpDX.Result.Ok"/>. </p><p>If the <strong>Close</strong> method returns an error, any future use of the command list results in the same error.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandList::Close']/*"/>	
        /// <msdn-id>hh871450</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandList::Close()</unmanaged>	
        /// <unmanaged-short>ID2D1CommandList::Close</unmanaged-short>	
        public void Close()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>The command sink is implemented by you for an application when you want to receive a playback of the commands recorded in a command list. A typical usage will be for transforming the command list into another format such as XPS when some degree of conversion between the Direct2D primitives and the target format is required. </p><p>The command sink interface doesn't have any resource creation methods on it. The resources are still logically bound to the Direct2D device on which the command list was created and will be passed in to the command sink implementation.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct2D1.CommandSink"/></strong> can be implemented to receive a play-back of the commands recorded in a command list. This interface is typically used for transforming the command list into another format  where some degree of conversion between the Direct2D primitives and the target format is required. </p><p>The <strong><see cref="SharpDX.Direct2D1.CommandSink"/></strong> interface does not have any resource creation methods. The resources are logically bound to the Direct2D device on which the <strong><see cref="SharpDX.Direct2D1.CommandList"/></strong> was created and will be passed in to the <strong><see cref="SharpDX.Direct2D1.CommandSink"/></strong> implementation. </p><p>Not all methods implemented by <strong><see cref="SharpDX.Direct2D1.DeviceContext"/></strong> are present.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink']/*"/>	
    /// <msdn-id>hh404394</msdn-id>	
    /// <unmanaged>ID2D1CommandSink</unmanaged>	
    /// <unmanaged-short>ID2D1CommandSink</unmanaged-short>	
    [Guid("54d7898a-a061-40a7-bec7-e465bcba2c4f")]
    public partial interface CommandSink : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p>Notifies the implementation of the command sink that drawing is about to commence.</p>	
        /// </summary>	
        /// <returns><p> This method always returns <strong><see cref="SharpDX.Result.Ok"/></strong>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::BeginDraw']/*"/>	
        /// <msdn-id>hh404395</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::BeginDraw()</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::BeginDraw</unmanaged-short>	
        /* public void BeginDraw() */

        /// <summary>	
        /// <p>Indicates when  <strong><see cref="SharpDX.Direct2D1.CommandSink"/></strong> processing has completed.</p>	
        /// </summary>	
        /// <returns><p>If the method/function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.Result"/></strong> active at the end of the command list will be returned.</p><p> It allows the calling function or method to indicate a failure back to the stream implementation.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::EndDraw']/*"/>	
        /// <msdn-id>hh404409</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::EndDraw()</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::EndDraw</unmanaged-short>	
        /* public void EndDraw() */

        /// <summary>	
        /// <p>Sets the antialiasing mode that will be used to render any subsequent geometry.</p>	
        /// </summary>	
        /// <param name="antialiasMode"><dd>  <p>The antialiasing mode selected for the command list.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::SetAntialiasMode']/*"/>	
        /// <msdn-id>hh404420</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::SetAntialiasMode([In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::SetAntialiasMode</unmanaged-short>	
        /* public void SetAntialiasMode(SharpDX.Direct2D1.AntialiasMode antialiasMode) */

        /// <summary>	
        /// <p>Sets the tags that correspond to the tags in the command sink.</p>	
        /// </summary>	
        /// <param name="tag1"><dd>  <p>The first tag to associate with the primitive.</p> </dd></param>	
        /// <param name="tag2"><dd>  <p>The second tag to associate with the primitive.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::SetTags']/*"/>	
        /// <msdn-id>hh404422</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::SetTags([In] unsigned longlong tag1,[In] unsigned longlong tag2)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::SetTags</unmanaged-short>	
        /* public void SetTags(long tag1, long tag2) */

        /// <summary>	
        /// <p>Indicates the new default antialiasing mode for text.</p>	
        /// </summary>	
        /// <param name="textAntialiasMode"><dd>  <p>The antialiasing mode for the text.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::SetTextAntialiasMode']/*"/>	
        /// <msdn-id>hh404423</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::SetTextAntialiasMode([In] D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::SetTextAntialiasMode</unmanaged-short>	
        /* public void SetTextAntialiasMode(SharpDX.Direct2D1.TextAntialiasMode textAntialiasMode) */

        /// <summary>	
        /// <p>Indicates more detailed text rendering parameters.</p>	
        /// </summary>	
        /// <param name="textRenderingParams"><dd>  <p>The parameters to use for text rendering.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::SetTextRenderingParams']/*"/>	
        /// <msdn-id>hh404424</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::SetTextRenderingParams([In, Optional] IDWriteRenderingParams* textRenderingParams)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::SetTextRenderingParams</unmanaged-short>	
        /* public void SetTextRenderingParams(SharpDX.DirectWrite.RenderingParams textRenderingParams) */

        /// <summary>	
        /// <p>Sets a new transform.</p>	
        /// </summary>	
        /// <param name="transform"><dd>  <p>The transform to be set.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p>The transform will be applied to the corresponding device context.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::SetTransform']/*"/>	
        /// <msdn-id>hh404425</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::SetTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::SetTransform</unmanaged-short>	
        /* public void SetTransform(ref SharpDX.Mathematics.Interop.RawMatrix3x2 transform) */

        /// <summary>	
        /// <p>Sets a new primitive blend mode.</p>	
        /// </summary>	
        /// <param name="primitiveBlend"><dd>  <p>The primitive blend that will apply to subsequent primitives.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::SetPrimitiveBlend']/*"/>	
        /// <msdn-id>hh404421</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::SetPrimitiveBlend([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::SetPrimitiveBlend</unmanaged-short>	
        /* public void SetPrimitiveBlend(SharpDX.Direct2D1.PrimitiveBlend primitiveBlend) */

        /// <summary>	
        /// <p>The unit mode changes the meaning of subsequent units from device-independent pixels (DIPs) to pixels  or the other way. The command sink does not record a DPI, this is implied by the playback context or other playback interface such as <strong><see cref="SharpDX.Direct2D1.PrintControl"/></strong>.</p>	
        /// </summary>	
        /// <param name="unitMode">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p>The unit mode changes the interpretation of units from DIPs to pixels  or vice versa.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::SetUnitMode']/*"/>	
        /// <msdn-id>hh404426</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::SetUnitMode([In] D2D1_UNIT_MODE unitMode)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::SetUnitMode</unmanaged-short>	
        /* public void SetUnitMode(SharpDX.Direct2D1.UnitMode unitMode) */

        /// <summary>	
        /// <p>Clears the drawing area to the specified color.  </p>	
        /// </summary>	
        /// <param name="color"><dd>  <p>The color to which the command sink should be cleared.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p>The clear color is restricted by the currently selected clip and layer bounds.</p><p>If no color is specified, the color should be interpreted by context. Examples include but are not limited to:</p><ul> <li>Transparent black for a premultiplied bitmap target.</li> <li>Opaque black for an ignore bitmap target.</li> <li>Containing no content (or white) for a printer page.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::Clear']/*"/>	
        /// <msdn-id>hh404397</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::Clear([In, Optional] const D2D_COLOR_F* color)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::Clear</unmanaged-short>	
        /* public void Clear(SharpDX.Mathematics.Interop.RawColor4? color) */

        /// <summary>	
        /// <p>Indicates the glyphs to be drawn.</p>	
        /// </summary>	
        /// <param name="baselineOrigin"><dd>  <p>The upper left corner of the baseline.</p> </dd></param>	
        /// <param name="glyphRun"><dd>  <p>The sequence of  glyphs to be sent.</p> </dd></param>	
        /// <param name="glyphRunDescription"><dd>  <p>Additional non-rendering information about the glyphs.</p> </dd></param>	
        /// <param name="foregroundBrush"><dd>  <p>The brush used to fill the glyphs.</p> </dd></param>	
        /// <param name="measuringMode"><dd>  <p>The measuring mode to apply to the glyphs.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p> <strong>DrawText</strong> and <strong>DrawTextLayout</strong> are broken down into glyph runs and rectangles by the time the command sink is processed. So, these methods aren't available on the command sink. Since the application may require additional callback processing when calling <strong>DrawTextLayout</strong>, this semantic can't be easily preserved in the command list.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::DrawGlyphRun']/*"/>	
        /// <msdn-id>hh404401</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] ID2D1Brush* foregroundBrush,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::DrawGlyphRun</unmanaged-short>	
        /* public void DrawGlyphRun(SharpDX.Mathematics.Interop.RawVector2 baselineOrigin, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.DirectWrite.GlyphRunDescription glyphRunDescription, SharpDX.Direct2D1.Brush foregroundBrush, SharpDX.Direct2D1.MeasuringMode measuringMode) */

        /// <summary>	
        /// <p>Draws a line drawn between two points.</p>	
        /// </summary>	
        /// <param name="point0"><dd>  <p>The start point of the line.</p> </dd></param>	
        /// <param name="point1"><dd>  <p>The end point of the line.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush used to fill the line.</p> </dd></param>	
        /// <param name="strokeWidth"><dd>  <p>The width of the stroke to fill the line.</p> </dd></param>	
        /// <param name="strokeStyle"><dd>  <p>The style of the stroke. If not specified, the stroke is solid.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::DrawLine']/*"/>	
        /// <msdn-id>hh404405</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawLine([In] D2D_POINT_2F point0,[In] D2D_POINT_2F point1,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::DrawLine</unmanaged-short>	
        /* public void DrawLine(SharpDX.Mathematics.Interop.RawVector2 point0, SharpDX.Mathematics.Interop.RawVector2 point1, SharpDX.Direct2D1.Brush brush, float strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle) */

        /// <summary>	
        /// <p>Indicates the geometry to be drawn to the command sink.</p>	
        /// </summary>	
        /// <param name="geometry"><dd>  <p>The geometry to be stroked.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush that will be used to fill the stroked geometry.</p> </dd></param>	
        /// <param name="strokeWidth"><dd>  <p>The width of the stroke.</p> </dd></param>	
        /// <param name="strokeStyle"><dd>  <p>The style of the stroke.</p> </dd></param>	
        /// <returns><p>An <see cref="SharpDX.Result"/>. </p></returns>	
        /// <remarks>	
        /// <p> <strong>Ellipses</strong> and <strong>rounded rectangles</strong> are converted to the corresponding ellipse and rounded rectangle geometries before calling into the <strong>DrawGeometry</strong> method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::DrawGeometry']/*"/>	
        /// <msdn-id>hh404399</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::DrawGeometry</unmanaged-short>	
        /* public void DrawGeometry(SharpDX.Direct2D1.Geometry geometry, SharpDX.Direct2D1.Brush brush, float strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle) */

        /// <summary>	
        /// <p>Draws a rectangle.</p>	
        /// </summary>	
        /// <param name="rect"><dd>  <p>The rectangle to be drawn to the command sink.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush used to stroke the geometry.</p> </dd></param>	
        /// <param name="strokeWidth"><dd>  <p>The width of the stroke.</p> </dd></param>	
        /// <param name="strokeStyle"><dd>  <p>The style of the stroke.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::DrawRectangle']/*"/>	
        /// <msdn-id>hh404407</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::DrawRectangle</unmanaged-short>	
        /* public void DrawRectangle(SharpDX.Mathematics.Interop.RawRectangleF rect, SharpDX.Direct2D1.Brush brush, float strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle) */

        /// <summary>	
        /// <p>Draws a bitmap to the render target.</p>	
        /// </summary>	
        /// <param name="bitmap"><dd>  <p>The bitmap to draw.</p> </dd></param>	
        /// <param name="destinationRectangle"><dd>  <p>The destination rectangle. The default is the size of the bitmap and the location is the upper left corner of the render target.</p> </dd></param>	
        /// <param name="opacity"><dd>  <p>The opacity of the bitmap.</p> </dd></param>	
        /// <param name="interpolationMode"><dd>  <p>The interpolation mode to use.</p> </dd></param>	
        /// <param name="sourceRectangle"><dd>  <p>An optional source rectangle.</p> </dd></param>	
        /// <param name="erspectiveTransformRef"><dd>  <p>An optional perspective transform.</p> </dd></param>	
        /// <returns><p>This method does not return a value.</p></returns>	
        /// <remarks>	
        /// <p>The <em>destinationRectangle</em> parameter defines the rectangle in the target where the bitmap will appear (in device-independent pixels (DIPs)).  This is affected by the currently set transform and the perspective transform, if set.  If you specify <c>null</c>, then the destination rectangle is (left=0, top=0, right = width(<em>sourceRectangle</em>), bottom = height(<em>sourceRectangle</em>). </p><p>The <em>sourceRectangle</em> defines the sub-rectangle of the source bitmap (in DIPs).  <strong>DrawBitmap</strong> clips this rectangle to the size of the source bitmap, so it's impossible to sample outside of the bitmap.  If you specify <c>null</c>, then the source rectangle is taken to be the size of the source bitmap. </p><p>The <em>perspectiveTransform</em> is specified in addition to the transform on device context.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::DrawBitmap']/*"/>	
        /// <msdn-id>hh847972</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle,[In, Optional] const D2D_MATRIX_4X4_F* perspectiveTransform)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::DrawBitmap</unmanaged-short>	
        /* public void DrawBitmap(SharpDX.Direct2D1.Bitmap bitmap, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, float opacity, SharpDX.Direct2D1.InterpolationMode interpolationMode, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle, SharpDX.Mathematics.Interop.RawMatrix? erspectiveTransformRef) */

        /// <summary>	
        /// <p>Draws the provided image to the command sink.  </p>	
        /// </summary>	
        /// <param name="image"><dd>  <p>The image to be drawn to the command sink.</p> </dd></param>	
        /// <param name="targetOffset"><dd>  <p>This defines the offset in the destination space that the image will be rendered to. The entire logical extent of the image will be rendered to the corresponding destination. If not specified, the destination origin will be (0, 0). The top-left corner of the image will be mapped to the target offset. This will not necessarily be the origin.</p> </dd></param>	
        /// <param name="imageRectangle"><dd>  <p>The corresponding rectangle in the image space will be mapped to the provided origins when processing the image.</p> </dd></param>	
        /// <param name="interpolationMode"><dd>  <p>The interpolation mode to use to  scale the image if necessary.</p> </dd></param>	
        /// <param name="compositeMode"><dd>  <p>If specified, the composite mode that will be applied to the limits of the currently selected clip.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p>Because the image can itself be a command list or contain an effect graph that in turn contains a command list, this method can result in recursive processing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::DrawImage']/*"/>	
        /// <msdn-id>hh404403</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawImage([In] ID2D1Image* image,[In, Optional] const D2D_POINT_2F* targetOffset,[In, Optional] const D2D_RECT_F* imageRectangle,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In] D2D1_COMPOSITE_MODE compositeMode)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::DrawImage</unmanaged-short>	
        /* public void DrawImage(SharpDX.Direct2D1.Image image, SharpDX.Mathematics.Interop.RawVector2? targetOffset, SharpDX.Mathematics.Interop.RawRectangleF? imageRectangle, SharpDX.Direct2D1.InterpolationMode interpolationMode, SharpDX.Direct2D1.CompositeMode compositeMode) */

        /// <summary>	
        /// <p>Draw a metafile to the device context.</p>	
        /// </summary>	
        /// <param name="gdiMetafile"><dd>  <p>The metafile to draw.</p> </dd></param>	
        /// <param name="targetOffset"><dd>  <p>The offset from the upper left corner of the render target.</p> </dd></param>	
        /// <returns><p>This method does not return a value.</p></returns>	
        /// <remarks>	
        /// <p>The <em>targetOffset</em> defines the offset in the destination space that the image will be rendered to. The entire logical extent of the image is rendered to the corresponding destination. If you don't specify the offset, the destination origin will be (0, 0). The top, left corner of the image will be mapped to the target offset. This will not necessarily be the origin.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::DrawGdiMetafile']/*"/>	
        /// <msdn-id>hh847973</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_POINT_2F* targetOffset)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::DrawGdiMetafile</unmanaged-short>	
        /* public void DrawGdiMetafile(SharpDX.Direct2D1.GdiMetafile gdiMetafile, SharpDX.Mathematics.Interop.RawVector2? targetOffset) */

        /// <summary>	
        /// <p>Indicates a mesh to be filled by the command sink.</p>	
        /// </summary>	
        /// <param name="mesh"><dd>  <p>The mesh object to be filled.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush with which to fill the mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::FillMesh']/*"/>	
        /// <msdn-id>hh404413</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::FillMesh([In] ID2D1Mesh* mesh,[In] ID2D1Brush* brush)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::FillMesh</unmanaged-short>	
        /* public void FillMesh(SharpDX.Direct2D1.Mesh mesh, SharpDX.Direct2D1.Brush brush) */

        /// <summary>	
        /// <p>Fills an opacity mask on the command sink.</p>	
        /// </summary>	
        /// <param name="opacityMask"><dd>  <p>The bitmap whose alpha channel will be sampled to define the opacity mask.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush with which to fill the mask.</p> </dd></param>	
        /// <param name="destinationRectangle"><dd>  <p>The destination rectangle in which to fill the mask. If not specified, this is the origin.</p> </dd></param>	
        /// <param name="sourceRectangle"><dd>  <p>The source rectangle within the opacity mask. If not specified, this is the entire mask.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p>The opacity mask bitmap must be considered to be clamped on each axis.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::FillOpacityMask']/*"/>	
        /// <msdn-id>hh404414</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::FillOpacityMask</unmanaged-short>	
        /* public void FillOpacityMask(SharpDX.Direct2D1.Bitmap opacityMask, SharpDX.Direct2D1.Brush brush, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle) */

        /// <summary>	
        /// <p>Indicates to the command sink a geometry to be filled.</p>	
        /// </summary>	
        /// <param name="geometry"><dd>  <p>The geometry that should be filled.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The primary brush used to fill the geometry.</p> </dd></param>	
        /// <param name="opacityBrush"><dd>  <p>A brush whose alpha channel is used to modify the opacity of the primary fill brush.  </p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p>If the opacity brush is specified, the primary brush will be a bitmap brush fixed on both the x-axis and the y-axis.</p><p>Ellipses and rounded rectangles are converted to the corresponding geometry before being passed to <strong>FillGeometry</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::FillGeometry']/*"/>	
        /// <msdn-id>hh404411</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::FillGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In, Optional] ID2D1Brush* opacityBrush)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::FillGeometry</unmanaged-short>	
        /* public void FillGeometry(SharpDX.Direct2D1.Geometry geometry, SharpDX.Direct2D1.Brush brush, SharpDX.Direct2D1.Brush opacityBrush) */

        /// <summary>	
        /// <p>Indicates to the command sink a rectangle to be filled.</p>	
        /// </summary>	
        /// <param name="rect"><dd>  <p>The rectangle to fill.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush with which to fill the rectangle.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::FillRectangle']/*"/>	
        /// <msdn-id>hh404415</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::FillRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::FillRectangle</unmanaged-short>	
        /* public void FillRectangle(SharpDX.Mathematics.Interop.RawRectangleF rect, SharpDX.Direct2D1.Brush brush) */

        /// <summary>	
        /// <p>Pushes a clipping rectangle onto the clip and layer stack.</p>	
        /// </summary>	
        /// <param name="clipRect"><dd>  <p>The rectangle that defines the clip.</p> </dd></param>	
        /// <param name="antialiasMode"><dd>  <p>The antialias mode for the clip.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p>If the current world transform is not preserving the axis, <em>clipRectangle</em> is transformed and the bounds of the transformed rectangle are used instead.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::PushAxisAlignedClip']/*"/>	
        /// <msdn-id>hh404418</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::PushAxisAlignedClip([In] const D2D_RECT_F* clipRect,[In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::PushAxisAlignedClip</unmanaged-short>	
        /* public void PushAxisAlignedClip(SharpDX.Mathematics.Interop.RawRectangleF clipRect, SharpDX.Direct2D1.AntialiasMode antialiasMode) */

        /// <summary>	
        /// <p>Pushes a layer onto the clip and layer stack.</p>	
        /// </summary>	
        /// <param name="layerParameters1"><dd>  <p>The parameters that define the layer.</p> </dd></param>	
        /// <param name="layer"><dd>  <p>The layer resource that receives subsequent drawing operations.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::PushLayer']/*"/>	
        /// <msdn-id>hh404419</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::PushLayer([In] const D2D1_LAYER_PARAMETERS1* layerParameters1,[In, Optional] ID2D1Layer* layer)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::PushLayer</unmanaged-short>	
        /* public void PushLayer(ref SharpDX.Direct2D1.LayerParameters1 layerParameters1, SharpDX.Direct2D1.Layer layer) */

        /// <summary>	
        /// <p>Removes an axis-aligned clip from the layer and clip stack.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::PopAxisAlignedClip']/*"/>	
        /// <msdn-id>hh404416</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::PopAxisAlignedClip()</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::PopAxisAlignedClip</unmanaged-short>	
        /* public void PopAxisAlignedClip() */

        /// <summary>	
        /// <p>Removes  a layer from the layer and clip stack.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::PopLayer']/*"/>	
        /// <msdn-id>hh404417</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::PopLayer()</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::PopLayer</unmanaged-short>	
        /* public void PopLayer() */
    }
    /// <summary>	
    /// <p>This interface performs all the same functions as the existing <strong><see cref="SharpDX.Direct2D1.CommandSink"/></strong> interface. It also enables access to the new primitive blend modes, MIN and ADD, through its <strong>SetPrimitiveBlend1</strong> method.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink1']/*"/>	
    /// <msdn-id>dn280436</msdn-id>	
    /// <unmanaged>ID2D1CommandSink1</unmanaged>	
    /// <unmanaged-short>ID2D1CommandSink1</unmanaged-short>	
    [Guid("9eb767fd-4269-4467-b8c2-eb30cb305743")]
    public partial interface CommandSink1 : SharpDX.Direct2D1.CommandSink
    {


        /// <summary>	
        /// <p>This interface performs all the same functions as the existing <strong><see cref="SharpDX.Direct2D1.CommandSink"/></strong> interface. It also enables access to the new primitive blend modes, MIN and ADD, through its <strong>SetPrimitiveBlend1</strong> method.</p>	
        /// </summary>	
        /// <param name="primitiveBlend">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink1::SetPrimitiveBlend1']/*"/>	
        /// <msdn-id>dn280436</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink1::SetPrimitiveBlend1([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink1::SetPrimitiveBlend1</unmanaged-short>	
        /* public void SetPrimitiveBlend1(SharpDX.Direct2D1.PrimitiveBlend primitiveBlend) */
    }
    /// <summary>	
    /// <p>This interface performs all the same functions as the existing <strong><see cref="SharpDX.Direct2D1.CommandSink"/></strong> interface. It also enables access to the new primitive blend modes, MIN and ADD, through its <strong>SetPrimitiveBlend1</strong> method.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink1']/*"/>	
    /// <msdn-id>dn280436</msdn-id>	
    /// <unmanaged>ID2D1CommandSink1</unmanaged>	
    /// <unmanaged-short>ID2D1CommandSink1</unmanaged-short>	
    [Guid("9eb767fd-4269-4467-b8c2-eb30cb305743")]
    internal partial class CommandSink1Native : SharpDX.Direct2D1.CommandSinkNative, SharpDX.Direct2D1.CommandSink1
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.CommandSink1Native"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CommandSink1Native(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.CommandSink1Native"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.CommandSink1Native(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.CommandSink1Native(nativePointer);
        }


        /// <summary>	
        /// <p>This interface performs all the same functions as the existing <strong><see cref="SharpDX.Direct2D1.CommandSink"/></strong> interface. It also enables access to the new primitive blend modes, MIN and ADD, through its <strong>SetPrimitiveBlend1</strong> method.</p>	
        /// </summary>	
        /// <param name="primitiveBlend">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink1::SetPrimitiveBlend1']/*"/>	
        /// <msdn-id>dn280436</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink1::SetPrimitiveBlend1([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink1::SetPrimitiveBlend1</unmanaged-short>	
        internal void SetPrimitiveBlend1_(SharpDX.Direct2D1.PrimitiveBlend primitiveBlend)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)primitiveBlend), ((void**)(*(void**)_nativePointer))[28]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Renders the given ink object using the given brush and ink style.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink2']/*"/>	
    /// <msdn-id>dn890784</msdn-id>	
    /// <unmanaged>ID2D1CommandSink2</unmanaged>	
    /// <unmanaged-short>ID2D1CommandSink2</unmanaged-short>	
    [Guid("3bab440e-417e-47df-a2e2-bc0be6a00916")]
    public partial interface CommandSink2 : SharpDX.Direct2D1.CommandSink1
    {


        /// <summary>	
        /// <p>Renders the given ink object using the given brush and ink style.</p>	
        /// </summary>	
        /// <param name="ink"><dd>  <p>The ink object to be rendered.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush with which to render the ink object.</p> </dd></param>	
        /// <param name="inkStyle"><dd>  <p>The ink style to use when rendering the ink object.</p> </dd></param>	
        /// <returns><p>This method does not return a value.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink2::DrawInk']/*"/>	
        /// <msdn-id>dn890784</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink2::DrawInk([In] ID2D1Ink* ink,[In] ID2D1Brush* brush,[In, Optional] ID2D1InkStyle* inkStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink2::DrawInk</unmanaged-short>	
        /* public void DrawInk(SharpDX.Direct2D1.Ink ink, SharpDX.Direct2D1.Brush brush, SharpDX.Direct2D1.InkStyle inkStyle) */

        /// <summary>	
        /// <p>Renders a given gradient mesh to the target.</p>	
        /// </summary>	
        /// <param name="gradientMesh"><dd>  <p>The gradient mesh to be rendered.</p> </dd></param>	
        /// <returns><p>This method does not return a value.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink2::DrawGradientMesh']/*"/>	
        /// <msdn-id>dn890783</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink2::DrawGradientMesh([In] ID2D1GradientMesh* gradientMesh)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink2::DrawGradientMesh</unmanaged-short>	
        /* public void DrawGradientMesh(SharpDX.Direct2D1.GradientMesh gradientMesh) */

        /// <summary>	
        /// <p>Draws a metafile to the command sink using the given source and destination rectangles.</p>	
        /// </summary>	
        /// <param name="gdiMetafile"><dd>  <p>The metafile to draw.</p> </dd></param>	
        /// <param name="destinationRectangle"><dd>  <p>The rectangle in the target where the metafile will be drawn, relative to the upper left corner (defined in DIPs). If <c>null</c> is specified, the destination rectangle is the size of the target.</p> </dd></param>	
        /// <param name="sourceRectangle"><dd>  <p>The rectangle of the source metafile that will be drawn, relative to the upper left corner (defined in DIPs).  If <c>null</c> is specified, the source rectangle is the value returned by <strong><see cref="SharpDX.Direct2D1.GdiMetafile1.GetSourceBounds"/></strong>.</p> </dd></param>	
        /// <returns><p>This method does not return a value.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink2::DrawGdiMetafile']/*"/>	
        /// <msdn-id>dn890782</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink2::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink2::DrawGdiMetafile</unmanaged-short>	
        /* public void DrawGdiMetafile(SharpDX.Direct2D1.GdiMetafile gdiMetafile, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle) */
    }
    /// <summary>	
    /// <p>Renders the given ink object using the given brush and ink style.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink2']/*"/>	
    /// <msdn-id>dn890784</msdn-id>	
    /// <unmanaged>ID2D1CommandSink2</unmanaged>	
    /// <unmanaged-short>ID2D1CommandSink2</unmanaged-short>	
    [Guid("3bab440e-417e-47df-a2e2-bc0be6a00916")]
    internal partial class CommandSink2Native : SharpDX.Direct2D1.CommandSink1Native, SharpDX.Direct2D1.CommandSink2
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.CommandSink2Native"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CommandSink2Native(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.CommandSink2Native"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.CommandSink2Native(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.CommandSink2Native(nativePointer);
        }


        /// <summary>	
        /// <p>Renders the given ink object using the given brush and ink style.</p>	
        /// </summary>	
        /// <param name="ink"><dd>  <p>The ink object to be rendered.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush with which to render the ink object.</p> </dd></param>	
        /// <param name="inkStyle"><dd>  <p>The ink style to use when rendering the ink object.</p> </dd></param>	
        /// <returns><p>This method does not return a value.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink2::DrawInk']/*"/>	
        /// <msdn-id>dn890784</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink2::DrawInk([In] ID2D1Ink* ink,[In] ID2D1Brush* brush,[In, Optional] ID2D1InkStyle* inkStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink2::DrawInk</unmanaged-short>	
        internal void DrawInk_(SharpDX.Direct2D1.Ink ink, SharpDX.Direct2D1.Brush brush, SharpDX.Direct2D1.InkStyle inkStyle)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((ink == null) ? IntPtr.Zero : ink.NativePointer), (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), (void*)((inkStyle == null) ? IntPtr.Zero : inkStyle.NativePointer), ((void**)(*(void**)_nativePointer))[29]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Renders a given gradient mesh to the target.</p>	
        /// </summary>	
        /// <param name="gradientMesh"><dd>  <p>The gradient mesh to be rendered.</p> </dd></param>	
        /// <returns><p>This method does not return a value.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink2::DrawGradientMesh']/*"/>	
        /// <msdn-id>dn890783</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink2::DrawGradientMesh([In] ID2D1GradientMesh* gradientMesh)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink2::DrawGradientMesh</unmanaged-short>	
        internal void DrawGradientMesh_(SharpDX.Direct2D1.GradientMesh gradientMesh)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((gradientMesh == null) ? IntPtr.Zero : gradientMesh.NativePointer), ((void**)(*(void**)_nativePointer))[30]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Draws a metafile to the command sink using the given source and destination rectangles.</p>	
        /// </summary>	
        /// <param name="gdiMetafile"><dd>  <p>The metafile to draw.</p> </dd></param>	
        /// <param name="destinationRectangle"><dd>  <p>The rectangle in the target where the metafile will be drawn, relative to the upper left corner (defined in DIPs). If <c>null</c> is specified, the destination rectangle is the size of the target.</p> </dd></param>	
        /// <param name="sourceRectangle"><dd>  <p>The rectangle of the source metafile that will be drawn, relative to the upper left corner (defined in DIPs).  If <c>null</c> is specified, the source rectangle is the value returned by <strong><see cref="SharpDX.Direct2D1.GdiMetafile1.GetSourceBounds"/></strong>.</p> </dd></param>	
        /// <returns><p>This method does not return a value.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink2::DrawGdiMetafile']/*"/>	
        /// <msdn-id>dn890782</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink2::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink2::DrawGdiMetafile</unmanaged-short>	
        internal void DrawGdiMetafile_(SharpDX.Direct2D1.GdiMetafile gdiMetafile, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
                if (destinationRectangle.HasValue)
                    destinationRectangle_ = destinationRectangle.Value;
                SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
                if (sourceRectangle.HasValue)
                    sourceRectangle_ = sourceRectangle.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((gdiMetafile == null) ? IntPtr.Zero : gdiMetafile.NativePointer), (destinationRectangle.HasValue) ? &destinationRectangle_ : (void*)IntPtr.Zero, (sourceRectangle.HasValue) ? &sourceRectangle_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[31]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> </p><p>The command sink is implemented by you for an application when you want to receive a playback of the commands recorded in a command list. A typical usage will be for transforming the command list into another format such as XPS when some degree of conversion between the Direct2D primitives and the target format is required. </p><p>The command sink interface doesn't have any resource creation methods on it. The resources are still logically bound to the Direct2D device on which the command list was created and will be passed in to the command sink implementation.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct2D1.CommandSink"/></strong> can be implemented to receive a play-back of the commands recorded in a command list. This interface is typically used for transforming the command list into another format  where some degree of conversion between the Direct2D primitives and the target format is required. </p><p>The <strong><see cref="SharpDX.Direct2D1.CommandSink"/></strong> interface does not have any resource creation methods. The resources are logically bound to the Direct2D device on which the <strong><see cref="SharpDX.Direct2D1.CommandList"/></strong> was created and will be passed in to the <strong><see cref="SharpDX.Direct2D1.CommandSink"/></strong> implementation. </p><p>Not all methods implemented by <strong><see cref="SharpDX.Direct2D1.DeviceContext"/></strong> are present.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink']/*"/>	
    /// <msdn-id>hh404394</msdn-id>	
    /// <unmanaged>ID2D1CommandSink</unmanaged>	
    /// <unmanaged-short>ID2D1CommandSink</unmanaged-short>	
    [Guid("54d7898a-a061-40a7-bec7-e465bcba2c4f")]
    internal partial class CommandSinkNative : SharpDX.ComObjectCallback, SharpDX.Direct2D1.CommandSink
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.CommandSinkNative"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CommandSinkNative(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.CommandSinkNative"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.CommandSinkNative(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.CommandSinkNative(nativePointer);
        }


        /// <summary>	
        /// <p>Notifies the implementation of the command sink that drawing is about to commence.</p>	
        /// </summary>	
        /// <returns><p> This method always returns <strong><see cref="SharpDX.Result.Ok"/></strong>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::BeginDraw']/*"/>	
        /// <msdn-id>hh404395</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::BeginDraw()</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::BeginDraw</unmanaged-short>	
        internal void BeginDraw_()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Indicates when  <strong><see cref="SharpDX.Direct2D1.CommandSink"/></strong> processing has completed.</p>	
        /// </summary>	
        /// <returns><p>If the method/function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.Result"/></strong> active at the end of the command list will be returned.</p><p> It allows the calling function or method to indicate a failure back to the stream implementation.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::EndDraw']/*"/>	
        /// <msdn-id>hh404409</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::EndDraw()</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::EndDraw</unmanaged-short>	
        internal void EndDraw_()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the antialiasing mode that will be used to render any subsequent geometry.</p>	
        /// </summary>	
        /// <param name="antialiasMode"><dd>  <p>The antialiasing mode selected for the command list.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::SetAntialiasMode']/*"/>	
        /// <msdn-id>hh404420</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::SetAntialiasMode([In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::SetAntialiasMode</unmanaged-short>	
        internal void SetAntialiasMode_(SharpDX.Direct2D1.AntialiasMode antialiasMode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)antialiasMode), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the tags that correspond to the tags in the command sink.</p>	
        /// </summary>	
        /// <param name="tag1"><dd>  <p>The first tag to associate with the primitive.</p> </dd></param>	
        /// <param name="tag2"><dd>  <p>The second tag to associate with the primitive.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::SetTags']/*"/>	
        /// <msdn-id>hh404422</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::SetTags([In] unsigned longlong tag1,[In] unsigned longlong tag2)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::SetTags</unmanaged-short>	
        internal void SetTags_(long tag1, long tag2)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, tag1, tag2, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Indicates the new default antialiasing mode for text.</p>	
        /// </summary>	
        /// <param name="textAntialiasMode"><dd>  <p>The antialiasing mode for the text.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::SetTextAntialiasMode']/*"/>	
        /// <msdn-id>hh404423</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::SetTextAntialiasMode([In] D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::SetTextAntialiasMode</unmanaged-short>	
        internal void SetTextAntialiasMode_(SharpDX.Direct2D1.TextAntialiasMode textAntialiasMode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)textAntialiasMode), ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Indicates more detailed text rendering parameters.</p>	
        /// </summary>	
        /// <param name="textRenderingParams"><dd>  <p>The parameters to use for text rendering.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::SetTextRenderingParams']/*"/>	
        /// <msdn-id>hh404424</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::SetTextRenderingParams([In, Optional] IDWriteRenderingParams* textRenderingParams)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::SetTextRenderingParams</unmanaged-short>	
        internal void SetTextRenderingParams_(SharpDX.DirectWrite.RenderingParams textRenderingParams)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((textRenderingParams == null) ? IntPtr.Zero : textRenderingParams.NativePointer), ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets a new transform.</p>	
        /// </summary>	
        /// <param name="transform"><dd>  <p>The transform to be set.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p>The transform will be applied to the corresponding device context.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::SetTransform']/*"/>	
        /// <msdn-id>hh404425</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::SetTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::SetTransform</unmanaged-short>	
        internal void SetTransform_(ref SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* transform_ = &transform)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, transform_, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets a new primitive blend mode.</p>	
        /// </summary>	
        /// <param name="primitiveBlend"><dd>  <p>The primitive blend that will apply to subsequent primitives.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::SetPrimitiveBlend']/*"/>	
        /// <msdn-id>hh404421</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::SetPrimitiveBlend([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::SetPrimitiveBlend</unmanaged-short>	
        internal void SetPrimitiveBlend_(SharpDX.Direct2D1.PrimitiveBlend primitiveBlend)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)primitiveBlend), ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>The unit mode changes the meaning of subsequent units from device-independent pixels (DIPs) to pixels  or the other way. The command sink does not record a DPI, this is implied by the playback context or other playback interface such as <strong><see cref="SharpDX.Direct2D1.PrintControl"/></strong>.</p>	
        /// </summary>	
        /// <param name="unitMode">No documentation.</param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p>The unit mode changes the interpretation of units from DIPs to pixels  or vice versa.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::SetUnitMode']/*"/>	
        /// <msdn-id>hh404426</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::SetUnitMode([In] D2D1_UNIT_MODE unitMode)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::SetUnitMode</unmanaged-short>	
        internal void SetUnitMode_(SharpDX.Direct2D1.UnitMode unitMode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)unitMode), ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Clears the drawing area to the specified color.  </p>	
        /// </summary>	
        /// <param name="color"><dd>  <p>The color to which the command sink should be cleared.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p>The clear color is restricted by the currently selected clip and layer bounds.</p><p>If no color is specified, the color should be interpreted by context. Examples include but are not limited to:</p><ul> <li>Transparent black for a premultiplied bitmap target.</li> <li>Opaque black for an ignore bitmap target.</li> <li>Containing no content (or white) for a printer page.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::Clear']/*"/>	
        /// <msdn-id>hh404397</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::Clear([In, Optional] const D2D_COLOR_F* color)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::Clear</unmanaged-short>	
        internal void Clear_(SharpDX.Mathematics.Interop.RawColor4? color)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawColor4 color_;
                if (color.HasValue)
                    color_ = color.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (color.HasValue) ? &color_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Indicates the glyphs to be drawn.</p>	
        /// </summary>	
        /// <param name="baselineOrigin"><dd>  <p>The upper left corner of the baseline.</p> </dd></param>	
        /// <param name="glyphRun"><dd>  <p>The sequence of  glyphs to be sent.</p> </dd></param>	
        /// <param name="glyphRunDescription"><dd>  <p>Additional non-rendering information about the glyphs.</p> </dd></param>	
        /// <param name="foregroundBrush"><dd>  <p>The brush used to fill the glyphs.</p> </dd></param>	
        /// <param name="measuringMode"><dd>  <p>The measuring mode to apply to the glyphs.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p> <strong>DrawText</strong> and <strong>DrawTextLayout</strong> are broken down into glyph runs and rectangles by the time the command sink is processed. So, these methods aren't available on the command sink. Since the application may require additional callback processing when calling <strong>DrawTextLayout</strong>, this semantic can't be easily preserved in the command list.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::DrawGlyphRun']/*"/>	
        /// <msdn-id>hh404401</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] ID2D1Brush* foregroundBrush,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::DrawGlyphRun</unmanaged-short>	
        internal void DrawGlyphRun_(SharpDX.Mathematics.Interop.RawVector2 baselineOrigin, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.DirectWrite.GlyphRunDescription glyphRunDescription, SharpDX.Direct2D1.Brush foregroundBrush, SharpDX.Direct2D1.MeasuringMode measuringMode)
        {
            unsafe
            {
                var glyphRun_ = new SharpDX.DirectWrite.GlyphRun.__Native();
                glyphRun.__MarshalTo(ref glyphRun_);
                var glyphRunDescription_ = new SharpDX.DirectWrite.GlyphRunDescription.__Native();
                if (glyphRunDescription != null)
                    glyphRunDescription.__MarshalTo(ref glyphRunDescription_);
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint82(_nativePointer, baselineOrigin, &glyphRun_, (glyphRunDescription != null) ? &glyphRunDescription_ : (void*)IntPtr.Zero, (void*)((foregroundBrush == null) ? IntPtr.Zero : foregroundBrush.NativePointer), unchecked((int)measuringMode), ((void**)(*(void**)_nativePointer))[13]);
                glyphRun.__MarshalFree(ref glyphRun_);
                if (glyphRunDescription != null)
                    glyphRunDescription.__MarshalFree(ref glyphRunDescription_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Draws a line drawn between two points.</p>	
        /// </summary>	
        /// <param name="point0"><dd>  <p>The start point of the line.</p> </dd></param>	
        /// <param name="point1"><dd>  <p>The end point of the line.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush used to fill the line.</p> </dd></param>	
        /// <param name="strokeWidth"><dd>  <p>The width of the stroke to fill the line.</p> </dd></param>	
        /// <param name="strokeStyle"><dd>  <p>The style of the stroke. If not specified, the stroke is solid.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::DrawLine']/*"/>	
        /// <msdn-id>hh404405</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawLine([In] D2D_POINT_2F point0,[In] D2D_POINT_2F point1,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::DrawLine</unmanaged-short>	
        internal void DrawLine_(SharpDX.Mathematics.Interop.RawVector2 point0, SharpDX.Mathematics.Interop.RawVector2 point1, SharpDX.Direct2D1.Brush brush, float strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint83(_nativePointer, point0, point1, (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), strokeWidth, (void*)((strokeStyle == null) ? IntPtr.Zero : strokeStyle.NativePointer), ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Indicates the geometry to be drawn to the command sink.</p>	
        /// </summary>	
        /// <param name="geometry"><dd>  <p>The geometry to be stroked.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush that will be used to fill the stroked geometry.</p> </dd></param>	
        /// <param name="strokeWidth"><dd>  <p>The width of the stroke.</p> </dd></param>	
        /// <param name="strokeStyle"><dd>  <p>The style of the stroke.</p> </dd></param>	
        /// <returns><p>An <see cref="SharpDX.Result"/>. </p></returns>	
        /// <remarks>	
        /// <p> <strong>Ellipses</strong> and <strong>rounded rectangles</strong> are converted to the corresponding ellipse and rounded rectangle geometries before calling into the <strong>DrawGeometry</strong> method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::DrawGeometry']/*"/>	
        /// <msdn-id>hh404399</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::DrawGeometry</unmanaged-short>	
        internal void DrawGeometry_(SharpDX.Direct2D1.Geometry geometry, SharpDX.Direct2D1.Brush brush, float strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((geometry == null) ? IntPtr.Zero : geometry.NativePointer), (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), strokeWidth, (void*)((strokeStyle == null) ? IntPtr.Zero : strokeStyle.NativePointer), ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Draws a rectangle.</p>	
        /// </summary>	
        /// <param name="rect"><dd>  <p>The rectangle to be drawn to the command sink.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush used to stroke the geometry.</p> </dd></param>	
        /// <param name="strokeWidth"><dd>  <p>The width of the stroke.</p> </dd></param>	
        /// <param name="strokeStyle"><dd>  <p>The style of the stroke.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::DrawRectangle']/*"/>	
        /// <msdn-id>hh404407</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::DrawRectangle</unmanaged-short>	
        internal void DrawRectangle_(SharpDX.Mathematics.Interop.RawRectangleF rect, SharpDX.Direct2D1.Brush brush, float strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &rect, (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), strokeWidth, (void*)((strokeStyle == null) ? IntPtr.Zero : strokeStyle.NativePointer), ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Draws a bitmap to the render target.</p>	
        /// </summary>	
        /// <param name="bitmap"><dd>  <p>The bitmap to draw.</p> </dd></param>	
        /// <param name="destinationRectangle"><dd>  <p>The destination rectangle. The default is the size of the bitmap and the location is the upper left corner of the render target.</p> </dd></param>	
        /// <param name="opacity"><dd>  <p>The opacity of the bitmap.</p> </dd></param>	
        /// <param name="interpolationMode"><dd>  <p>The interpolation mode to use.</p> </dd></param>	
        /// <param name="sourceRectangle"><dd>  <p>An optional source rectangle.</p> </dd></param>	
        /// <param name="erspectiveTransformRef"><dd>  <p>An optional perspective transform.</p> </dd></param>	
        /// <returns><p>This method does not return a value.</p></returns>	
        /// <remarks>	
        /// <p>The <em>destinationRectangle</em> parameter defines the rectangle in the target where the bitmap will appear (in device-independent pixels (DIPs)).  This is affected by the currently set transform and the perspective transform, if set.  If you specify <c>null</c>, then the destination rectangle is (left=0, top=0, right = width(<em>sourceRectangle</em>), bottom = height(<em>sourceRectangle</em>). </p><p>The <em>sourceRectangle</em> defines the sub-rectangle of the source bitmap (in DIPs).  <strong>DrawBitmap</strong> clips this rectangle to the size of the source bitmap, so it's impossible to sample outside of the bitmap.  If you specify <c>null</c>, then the source rectangle is taken to be the size of the source bitmap. </p><p>The <em>perspectiveTransform</em> is specified in addition to the transform on device context.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::DrawBitmap']/*"/>	
        /// <msdn-id>hh847972</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle,[In, Optional] const D2D_MATRIX_4X4_F* perspectiveTransform)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::DrawBitmap</unmanaged-short>	
        internal void DrawBitmap_(SharpDX.Direct2D1.Bitmap bitmap, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, float opacity, SharpDX.Direct2D1.InterpolationMode interpolationMode, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle, SharpDX.Mathematics.Interop.RawMatrix? erspectiveTransformRef)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
                if (destinationRectangle.HasValue)
                    destinationRectangle_ = destinationRectangle.Value;
                SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
                if (sourceRectangle.HasValue)
                    sourceRectangle_ = sourceRectangle.Value;
                SharpDX.Mathematics.Interop.RawMatrix erspectiveTransformRef_;
                if (erspectiveTransformRef.HasValue)
                    erspectiveTransformRef_ = erspectiveTransformRef.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((bitmap == null) ? IntPtr.Zero : bitmap.NativePointer), (destinationRectangle.HasValue) ? &destinationRectangle_ : (void*)IntPtr.Zero, opacity, unchecked((int)interpolationMode), (sourceRectangle.HasValue) ? &sourceRectangle_ : (void*)IntPtr.Zero, (erspectiveTransformRef.HasValue) ? &erspectiveTransformRef_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[17]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Draws the provided image to the command sink.  </p>	
        /// </summary>	
        /// <param name="image"><dd>  <p>The image to be drawn to the command sink.</p> </dd></param>	
        /// <param name="targetOffset"><dd>  <p>This defines the offset in the destination space that the image will be rendered to. The entire logical extent of the image will be rendered to the corresponding destination. If not specified, the destination origin will be (0, 0). The top-left corner of the image will be mapped to the target offset. This will not necessarily be the origin.</p> </dd></param>	
        /// <param name="imageRectangle"><dd>  <p>The corresponding rectangle in the image space will be mapped to the provided origins when processing the image.</p> </dd></param>	
        /// <param name="interpolationMode"><dd>  <p>The interpolation mode to use to  scale the image if necessary.</p> </dd></param>	
        /// <param name="compositeMode"><dd>  <p>If specified, the composite mode that will be applied to the limits of the currently selected clip.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p>Because the image can itself be a command list or contain an effect graph that in turn contains a command list, this method can result in recursive processing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::DrawImage']/*"/>	
        /// <msdn-id>hh404403</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawImage([In] ID2D1Image* image,[In, Optional] const D2D_POINT_2F* targetOffset,[In, Optional] const D2D_RECT_F* imageRectangle,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In] D2D1_COMPOSITE_MODE compositeMode)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::DrawImage</unmanaged-short>	
        internal void DrawImage_(SharpDX.Direct2D1.Image image, SharpDX.Mathematics.Interop.RawVector2? targetOffset, SharpDX.Mathematics.Interop.RawRectangleF? imageRectangle, SharpDX.Direct2D1.InterpolationMode interpolationMode, SharpDX.Direct2D1.CompositeMode compositeMode)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawVector2 targetOffset_;
                if (targetOffset.HasValue)
                    targetOffset_ = targetOffset.Value;
                SharpDX.Mathematics.Interop.RawRectangleF imageRectangle_;
                if (imageRectangle.HasValue)
                    imageRectangle_ = imageRectangle.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((image == null) ? IntPtr.Zero : image.NativePointer), (targetOffset.HasValue) ? &targetOffset_ : (void*)IntPtr.Zero, (imageRectangle.HasValue) ? &imageRectangle_ : (void*)IntPtr.Zero, unchecked((int)interpolationMode), unchecked((int)compositeMode), ((void**)(*(void**)_nativePointer))[18]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Draw a metafile to the device context.</p>	
        /// </summary>	
        /// <param name="gdiMetafile"><dd>  <p>The metafile to draw.</p> </dd></param>	
        /// <param name="targetOffset"><dd>  <p>The offset from the upper left corner of the render target.</p> </dd></param>	
        /// <returns><p>This method does not return a value.</p></returns>	
        /// <remarks>	
        /// <p>The <em>targetOffset</em> defines the offset in the destination space that the image will be rendered to. The entire logical extent of the image is rendered to the corresponding destination. If you don't specify the offset, the destination origin will be (0, 0). The top, left corner of the image will be mapped to the target offset. This will not necessarily be the origin.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::DrawGdiMetafile']/*"/>	
        /// <msdn-id>hh847973</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_POINT_2F* targetOffset)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::DrawGdiMetafile</unmanaged-short>	
        internal void DrawGdiMetafile_(SharpDX.Direct2D1.GdiMetafile gdiMetafile, SharpDX.Mathematics.Interop.RawVector2? targetOffset)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawVector2 targetOffset_;
                if (targetOffset.HasValue)
                    targetOffset_ = targetOffset.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((gdiMetafile == null) ? IntPtr.Zero : gdiMetafile.NativePointer), (targetOffset.HasValue) ? &targetOffset_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[19]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Indicates a mesh to be filled by the command sink.</p>	
        /// </summary>	
        /// <param name="mesh"><dd>  <p>The mesh object to be filled.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush with which to fill the mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::FillMesh']/*"/>	
        /// <msdn-id>hh404413</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::FillMesh([In] ID2D1Mesh* mesh,[In] ID2D1Brush* brush)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::FillMesh</unmanaged-short>	
        internal void FillMesh_(SharpDX.Direct2D1.Mesh mesh, SharpDX.Direct2D1.Brush brush)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((mesh == null) ? IntPtr.Zero : mesh.NativePointer), (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), ((void**)(*(void**)_nativePointer))[20]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Fills an opacity mask on the command sink.</p>	
        /// </summary>	
        /// <param name="opacityMask"><dd>  <p>The bitmap whose alpha channel will be sampled to define the opacity mask.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush with which to fill the mask.</p> </dd></param>	
        /// <param name="destinationRectangle"><dd>  <p>The destination rectangle in which to fill the mask. If not specified, this is the origin.</p> </dd></param>	
        /// <param name="sourceRectangle"><dd>  <p>The source rectangle within the opacity mask. If not specified, this is the entire mask.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p>The opacity mask bitmap must be considered to be clamped on each axis.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::FillOpacityMask']/*"/>	
        /// <msdn-id>hh404414</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::FillOpacityMask</unmanaged-short>	
        internal void FillOpacityMask_(SharpDX.Direct2D1.Bitmap opacityMask, SharpDX.Direct2D1.Brush brush, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
                if (destinationRectangle.HasValue)
                    destinationRectangle_ = destinationRectangle.Value;
                SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
                if (sourceRectangle.HasValue)
                    sourceRectangle_ = sourceRectangle.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((opacityMask == null) ? IntPtr.Zero : opacityMask.NativePointer), (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), (destinationRectangle.HasValue) ? &destinationRectangle_ : (void*)IntPtr.Zero, (sourceRectangle.HasValue) ? &sourceRectangle_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[21]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Indicates to the command sink a geometry to be filled.</p>	
        /// </summary>	
        /// <param name="geometry"><dd>  <p>The geometry that should be filled.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The primary brush used to fill the geometry.</p> </dd></param>	
        /// <param name="opacityBrush"><dd>  <p>A brush whose alpha channel is used to modify the opacity of the primary fill brush.  </p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p>If the opacity brush is specified, the primary brush will be a bitmap brush fixed on both the x-axis and the y-axis.</p><p>Ellipses and rounded rectangles are converted to the corresponding geometry before being passed to <strong>FillGeometry</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::FillGeometry']/*"/>	
        /// <msdn-id>hh404411</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::FillGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In, Optional] ID2D1Brush* opacityBrush)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::FillGeometry</unmanaged-short>	
        internal void FillGeometry_(SharpDX.Direct2D1.Geometry geometry, SharpDX.Direct2D1.Brush brush, SharpDX.Direct2D1.Brush opacityBrush)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((geometry == null) ? IntPtr.Zero : geometry.NativePointer), (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), (void*)((opacityBrush == null) ? IntPtr.Zero : opacityBrush.NativePointer), ((void**)(*(void**)_nativePointer))[22]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Indicates to the command sink a rectangle to be filled.</p>	
        /// </summary>	
        /// <param name="rect"><dd>  <p>The rectangle to fill.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush with which to fill the rectangle.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::FillRectangle']/*"/>	
        /// <msdn-id>hh404415</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::FillRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::FillRectangle</unmanaged-short>	
        internal void FillRectangle_(SharpDX.Mathematics.Interop.RawRectangleF rect, SharpDX.Direct2D1.Brush brush)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &rect, (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), ((void**)(*(void**)_nativePointer))[23]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Pushes a clipping rectangle onto the clip and layer stack.</p>	
        /// </summary>	
        /// <param name="clipRect"><dd>  <p>The rectangle that defines the clip.</p> </dd></param>	
        /// <param name="antialiasMode"><dd>  <p>The antialias mode for the clip.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <remarks>	
        /// <p>If the current world transform is not preserving the axis, <em>clipRectangle</em> is transformed and the bounds of the transformed rectangle are used instead.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::PushAxisAlignedClip']/*"/>	
        /// <msdn-id>hh404418</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::PushAxisAlignedClip([In] const D2D_RECT_F* clipRect,[In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::PushAxisAlignedClip</unmanaged-short>	
        internal void PushAxisAlignedClip_(SharpDX.Mathematics.Interop.RawRectangleF clipRect, SharpDX.Direct2D1.AntialiasMode antialiasMode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &clipRect, unchecked((int)antialiasMode), ((void**)(*(void**)_nativePointer))[24]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Pushes a layer onto the clip and layer stack.</p>	
        /// </summary>	
        /// <param name="layerParameters1"><dd>  <p>The parameters that define the layer.</p> </dd></param>	
        /// <param name="layer"><dd>  <p>The layer resource that receives subsequent drawing operations.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::PushLayer']/*"/>	
        /// <msdn-id>hh404419</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::PushLayer([In] const D2D1_LAYER_PARAMETERS1* layerParameters1,[In, Optional] ID2D1Layer* layer)</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::PushLayer</unmanaged-short>	
        internal void PushLayer_(ref SharpDX.Direct2D1.LayerParameters1 layerParameters1, SharpDX.Direct2D1.Layer layer)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* layerParameters1_ = &layerParameters1)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, layerParameters1_, (void*)((layer == null) ? IntPtr.Zero : layer.NativePointer), ((void**)(*(void**)_nativePointer))[25]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Removes an axis-aligned clip from the layer and clip stack.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::PopAxisAlignedClip']/*"/>	
        /// <msdn-id>hh404416</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::PopAxisAlignedClip()</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::PopAxisAlignedClip</unmanaged-short>	
        internal void PopAxisAlignedClip_()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[26]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Removes  a layer from the layer and clip stack.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1CommandSink::PopLayer']/*"/>	
        /// <msdn-id>hh404417</msdn-id>	
        /// <unmanaged>HRESULT ID2D1CommandSink::PopLayer()</unmanaged>	
        /// <unmanaged-short>ID2D1CommandSink::PopLayer</unmanaged-short>	
        internal void PopLayer_()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[27]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables specification of information for a compute-shader rendering pass.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The transform changes the state on this render information to specify the compute shader and its dependent resources.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ComputeInfo']/*"/>	
    /// <msdn-id>hh847966</msdn-id>	
    /// <unmanaged>ID2D1ComputeInfo</unmanaged>	
    /// <unmanaged-short>ID2D1ComputeInfo</unmanaged-short>	
    [Guid("5598b14b-9fd7-48b7-9bdb-8f0964eb38bc")]
    public partial class ComputeInformation : SharpDX.Direct2D1.RenderInformation
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.ComputeInformation"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ComputeInformation(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.ComputeInformation"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.ComputeInformation(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.ComputeInformation(nativePointer);
        }


        /// <summary>	
        /// <p>Sets the compute shader to the given shader resource.  The resource must be loaded before this call is made.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ComputeInfo::SetComputeShader']/*"/>	
        /// <msdn-id>hh847967</msdn-id>	
        /// <unmanaged>SetComputeShader</unmanaged>	
        /// <unmanaged-short>SetComputeShader</unmanaged-short>	
        /// <unmanaged>HRESULT ID2D1ComputeInfo::SetComputeShader([In] const GUID& shaderId)</unmanaged>
        public System.Guid ComputeShader
        {
            set { SetComputeShader(value); }
        }

        /// <summary>	
        /// <p>Establishes or changes the constant buffer data for this transform.</p>	
        /// </summary>	
        /// <param name="buffer"><dd>  <p>The data applied to the constant buffer.</p> </dd></param>	
        /// <param name="bufferCount"><dd>  <p>The number of bytes of data in the constant buffer.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ComputeInfo::SetComputeShaderConstantBuffer']/*"/>	
        /// <msdn-id>hh847968</msdn-id>	
        /// <unmanaged>HRESULT ID2D1ComputeInfo::SetComputeShaderConstantBuffer([In, Buffer] const void* buffer,[In] unsigned int bufferCount)</unmanaged>	
        /// <unmanaged-short>ID2D1ComputeInfo::SetComputeShaderConstantBuffer</unmanaged-short>	
        internal void SetComputeShaderConstantBuffer(System.IntPtr buffer, int bufferCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)buffer, bufferCount, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the compute shader to the given shader resource.  The resource must be loaded before this call is made.</p>	
        /// </summary>	
        /// <param name="shaderId"><dd>  <p>The <see cref="System.Guid"/> of the shader.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ComputeInfo::SetComputeShader']/*"/>	
        /// <msdn-id>hh847967</msdn-id>	
        /// <unmanaged>HRESULT ID2D1ComputeInfo::SetComputeShader([In] const GUID&amp; shaderId)</unmanaged>	
        /// <unmanaged-short>ID2D1ComputeInfo::SetComputeShader</unmanaged-short>	
        internal void SetComputeShader(System.Guid shaderId)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &shaderId, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the resource texture corresponding to the given shader texture index to the given texture resource.  The texture resource must already have been loaded with <strong><see cref="SharpDX.Direct2D1.EffectContext.CreateResourceTexture"/></strong> method. This call will fail if the specified index overlaps with any input. The input indices always precede the texture LUT indices.	
        /// </p>	
        /// </summary>	
        /// <param name="textureIndex">No documentation.</param>	
        /// <param name="resourceTexture">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ComputeInfo::SetResourceTexture']/*"/>	
        /// <msdn-id>hh847969</msdn-id>	
        /// <unmanaged>HRESULT ID2D1ComputeInfo::SetResourceTexture([In] unsigned int textureIndex,[In] ID2D1ResourceTexture* resourceTexture)</unmanaged>	
        /// <unmanaged-short>ID2D1ComputeInfo::SetResourceTexture</unmanaged-short>	
        public void SetResourceTexture(int textureIndex, SharpDX.Direct2D1.ResourceTexture resourceTexture)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, textureIndex, (void*)((resourceTexture == null) ? IntPtr.Zero : resourceTexture.NativePointer), ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Defines a transform that uses a compute shader.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The transform implements the normal Shatzis methods by  implementing <strong><see cref="SharpDX.Direct2D1.Transform"/></strong>. In addition, the caller is passed an <strong>ID2D1ComputeRenderInfo</strong> to describe the compute pass that the transform should execute.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ComputeTransform']/*"/>	
    /// <msdn-id>hh404434</msdn-id>	
    /// <unmanaged>ID2D1ComputeTransform</unmanaged>	
    /// <unmanaged-short>ID2D1ComputeTransform</unmanaged-short>	
    [Guid("0d85573c-01e3-4f7d-bfd9-0d60608bf3c3")]
    public partial interface ComputeTransform : SharpDX.Direct2D1.Transform
    {


        /// <summary>	
        /// <p>Sets the render information used to specify the compute shader pass.</p>	
        /// </summary>	
        /// <param name="computeInfo"><dd>  <p>The render information object to set.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If this method fails, <strong><see cref="SharpDX.Direct2D1.TransformGraph.AddNode_"/></strong> fails.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ComputeTransform::SetComputeInfo']/*"/>	
        /// <msdn-id>hh404450</msdn-id>	
        /// <unmanaged>HRESULT ID2D1ComputeTransform::SetComputeInfo([In] ID2D1ComputeInfo* computeInfo)</unmanaged>	
        /// <unmanaged-short>ID2D1ComputeTransform::SetComputeInfo</unmanaged-short>	
        /* public void SetComputeInfo(SharpDX.Direct2D1.ComputeInformation computeInfo) */

        /// <summary>	
        /// <p>This method allows a compute-shader?based transform to select the number of thread groups to execute based on the number of output pixels it needs to fill.</p>	
        /// </summary>	
        /// <param name="outputRect"><dd>  <p>The output rectangle that will be filled by the compute transform.</p> </dd></param>	
        /// <param name="dimensionX"><dd>  <p>The number of threads in the x dimension.</p> </dd></param>	
        /// <param name="dimensionY"><dd>  <p>The number of threads in the y dimension.</p> </dd></param>	
        /// <param name="dimensionZ"><dd>  <p>The number of threads in the z dimension.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If this call fails, the corresponding <strong><see cref="SharpDX.Direct2D1.Effect"/></strong> instance is placed into an error state and fails to draw.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ComputeTransform::CalculateThreadgroups']/*"/>	
        /// <msdn-id>hh404437</msdn-id>	
        /// <unmanaged>HRESULT ID2D1ComputeTransform::CalculateThreadgroups([In] const RECT* outputRect,[Out] unsigned int* dimensionX,[Out] unsigned int* dimensionY,[Out] unsigned int* dimensionZ)</unmanaged>	
        /// <unmanaged-short>ID2D1ComputeTransform::CalculateThreadgroups</unmanaged-short>	
        /* public void CalculateThreadgroups(SharpDX.Mathematics.Interop.RawRectangle outputRect, out int dimensionX, out int dimensionY, out int dimensionZ) */
    }
    /// <summary>	
    /// <p>Defines a transform that uses a compute shader.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The transform implements the normal Shatzis methods by  implementing <strong><see cref="SharpDX.Direct2D1.Transform"/></strong>. In addition, the caller is passed an <strong>ID2D1ComputeRenderInfo</strong> to describe the compute pass that the transform should execute.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ComputeTransform']/*"/>	
    /// <msdn-id>hh404434</msdn-id>	
    /// <unmanaged>ID2D1ComputeTransform</unmanaged>	
    /// <unmanaged-short>ID2D1ComputeTransform</unmanaged-short>	
    [Guid("0d85573c-01e3-4f7d-bfd9-0d60608bf3c3")]
    public partial class ComputeTransformNative : SharpDX.Direct2D1.TransformNative, SharpDX.Direct2D1.ComputeTransform
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.ComputeTransformNative"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ComputeTransformNative(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.ComputeTransformNative"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.ComputeTransformNative(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.ComputeTransformNative(nativePointer);
        }


        /// <summary>	
        /// <p>Sets the render information used to specify the compute shader pass.</p>	
        /// </summary>	
        /// <param name="computeInfo"><dd>  <p>The render information object to set.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If this method fails, <strong><see cref="SharpDX.Direct2D1.TransformGraph.AddNode_"/></strong> fails.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ComputeTransform::SetComputeInfo']/*"/>	
        /// <msdn-id>hh404450</msdn-id>	
        /// <unmanaged>HRESULT ID2D1ComputeTransform::SetComputeInfo([In] ID2D1ComputeInfo* computeInfo)</unmanaged>	
        /// <unmanaged-short>ID2D1ComputeTransform::SetComputeInfo</unmanaged-short>	
        internal void SetComputeInfo_(SharpDX.Direct2D1.ComputeInformation computeInfo)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((computeInfo == null) ? IntPtr.Zero : computeInfo.NativePointer), ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>This method allows a compute-shader?based transform to select the number of thread groups to execute based on the number of output pixels it needs to fill.</p>	
        /// </summary>	
        /// <param name="outputRect"><dd>  <p>The output rectangle that will be filled by the compute transform.</p> </dd></param>	
        /// <param name="dimensionX"><dd>  <p>The number of threads in the x dimension.</p> </dd></param>	
        /// <param name="dimensionY"><dd>  <p>The number of threads in the y dimension.</p> </dd></param>	
        /// <param name="dimensionZ"><dd>  <p>The number of threads in the z dimension.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If this call fails, the corresponding <strong><see cref="SharpDX.Direct2D1.Effect"/></strong> instance is placed into an error state and fails to draw.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ComputeTransform::CalculateThreadgroups']/*"/>	
        /// <msdn-id>hh404437</msdn-id>	
        /// <unmanaged>HRESULT ID2D1ComputeTransform::CalculateThreadgroups([In] const RECT* outputRect,[Out] unsigned int* dimensionX,[Out] unsigned int* dimensionY,[Out] unsigned int* dimensionZ)</unmanaged>	
        /// <unmanaged-short>ID2D1ComputeTransform::CalculateThreadgroups</unmanaged-short>	
        internal void CalculateThreadgroups_(SharpDX.Mathematics.Interop.RawRectangle outputRect, out int dimensionX, out int dimensionY, out int dimensionZ)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dimensionX_ = &dimensionX)
                    fixed (void* dimensionY_ = &dimensionY)
                        fixed (void* dimensionZ_ = &dimensionZ)
                            __result__ =
                            SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &outputRect, dimensionX_, dimensionY_, dimensionZ_, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents the set of transforms implemented by the effect-rendering system, which provides fixed-functionality.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ConcreteTransform']/*"/>	
    /// <msdn-id>hh404452</msdn-id>	
    /// <unmanaged>ID2D1ConcreteTransform</unmanaged>	
    /// <unmanaged-short>ID2D1ConcreteTransform</unmanaged-short>	
    [Guid("1a799d8a-69f7-4e4c-9fed-437ccc6684cc")]
    public partial class ConcreteTransform : SharpDX.Direct2D1.TransformNodeNative
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.ConcreteTransform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ConcreteTransform(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.ConcreteTransform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.ConcreteTransform(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.ConcreteTransform(nativePointer);
        }


        /// <summary>	
        /// <p>Sets the properties of the output buffer of the specified transform node.</p>	
        /// </summary>	
        /// <param name="bufferPrecision"><dd>  <p>The number of bits and the type of the output buffer.</p> </dd></param>	
        /// <param name="channelDepth"><dd>  <p>The number of channels in the output buffer (1 or 4).</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are not valid</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>You can use the <strong><see cref="SharpDX.Direct2D1.EffectContext.IsBufferPrecisionSupported"/></strong> method to see if buffer precision is supported.</p><p>The available channel depth and precision depend on the capabilities of the underlying Microsoft Direct3D device.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ConcreteTransform::SetOutputBuffer']/*"/>	
        /// <msdn-id>hh404456</msdn-id>	
        /// <unmanaged>HRESULT ID2D1ConcreteTransform::SetOutputBuffer([In] D2D1_BUFFER_PRECISION bufferPrecision,[In] D2D1_CHANNEL_DEPTH channelDepth)</unmanaged>	
        /// <unmanaged-short>ID2D1ConcreteTransform::SetOutputBuffer</unmanaged-short>	
        public void SetOutputBuffer(SharpDX.Direct2D1.BufferPrecision bufferPrecision, SharpDX.Direct2D1.ChannelDepth channelDepth)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)bufferPrecision), unchecked((int)channelDepth), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets whether the output of the specified transform is cached.</p>	
        /// </summary>	
        /// <param name="isCached"><dd>  <p><strong>TRUE</strong> if the output should be cached; otherwise,  <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ConcreteTransform::SetCached']/*"/>	
        /// <msdn-id>hh404454</msdn-id>	
        /// <unmanaged>void ID2D1ConcreteTransform::SetCached([In] BOOL isCached)</unmanaged>	
        /// <unmanaged-short>ID2D1ConcreteTransform::SetCached</unmanaged-short>	
        public void SetCached(SharpDX.Mathematics.Interop.RawBool isCached)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid113(_nativePointer, isCached, ((void**)(*(void**)_nativePointer))[5]);
            }
        }
    }
    /// <summary>	
    /// <p>Allows the internal context to be specified by the effect author.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectImpl']/*"/>	
    /// <msdn-id>hh404568</msdn-id>	
    /// <unmanaged>ID2D1EffectImpl</unmanaged>	
    /// <unmanaged-short>ID2D1EffectImpl</unmanaged-short>	
    [Guid("a248fd3f-3e6c-4e63-9f03-7f68ecc91db9")]
    public partial interface CustomEffect : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p>The effect can use this method to do one time initialization tasks.  If this method is not needed, the method can just return <strong><see cref="SharpDX.Result.Ok"/></strong>.</p>	
        /// </summary>	
        /// <param name="effectContext"><dd>  <p>An internal context interface that creates and returns effect author?centric types.</p> </dd></param>	
        /// <param name="transformGraph"><dd>  <p>The effect can populate the transform graph with a topology and can update it later.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This moves resource creation cost to the <strong>CreateEffect</strong> call, rather than during rendering.</p><p>If the implementation fails this call, the corresponding <strong><see cref="SharpDX.Direct2D1.DeviceContext.CreateEffect"/></strong> call also fails.</p><p>The following example shows an effect implementing an initialize method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectImpl::Initialize']/*"/>	
        /// <msdn-id>hh404570</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectImpl::Initialize([In] ID2D1EffectContext* effectContext,[In] ID2D1TransformGraph* transformGraph)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectImpl::Initialize</unmanaged-short>	
        /* public void Initialize(SharpDX.Direct2D1.EffectContext effectContext, SharpDX.Direct2D1.TransformGraph transformGraph) */

        /// <summary>	
        /// <p>Prepares an effect for the rendering process.</p>	
        /// </summary>	
        /// <param name="changeType"><dd>  <p>Indicates the type of change the effect should expect.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method is called by the renderer when the effect is within an effect graph that is drawn.</p><p> The method will be called:</p><ul> <li>If the effect has been initialized but has not previously been drawn.</li> <li>If an effect property has been set since the last draw call.</li> <li>If the context state has changed since the effect was last drawn.</li> </ul><p>The method will not otherwise be called. The transforms created by the effect will be called to handle their input and output rectangles for every draw call.</p><p>Most effects defer creating any resources or specifying a topology until this call is made. They store their properties and map them to a concrete set of rendering techniques when first drawn.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectImpl::PrepareForRender']/*"/>	
        /// <msdn-id>hh404572</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectImpl::PrepareForRender([In] D2D1_CHANGE_TYPE changeType)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectImpl::PrepareForRender</unmanaged-short>	
        /* public void PrepareForRender(SharpDX.Direct2D1.ChangeType changeType) */

        /// <summary>	
        /// <p>The renderer calls this method to provide the effect implementation with a way to specify  its transform graph and transform graph changes. </p><p>The renderer calls this method when:</p><ul> <li>When the effect is first initialized.</li> <li>If the number of inputs to the effect changes.</li> </ul>	
        /// </summary>	
        /// <param name="transformGraph"><dd>  <p>The graph to which the effect describes its transform topology through the SetDescription call.</p> </dd></param>	
        /// <returns><p>An error that prevents the effect from being initialized if called as part of the CreateEffect call. If the effect fails a subsequent SetGraph call:</p><ul> <li>The error will be returned from the property method that caused the number of inputs to the effect to change.</li> <li>The effect object will be placed into an error state, if subsequently used to render, the context will be placed into a temporary error state, that particular effect will fail to render and the failure will be returned on the next EndDraw or Flush call.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectImpl::SetGraph']/*"/>	
        /// <msdn-id>hh871459</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectImpl::SetGraph([In] ID2D1TransformGraph* transformGraph)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectImpl::SetGraph</unmanaged-short>	
        /* public void SetGraph(SharpDX.Direct2D1.TransformGraph transformGraph) */
    }
    /// <summary>	
    /// <p>Allows the internal context to be specified by the effect author.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectImpl']/*"/>	
    /// <msdn-id>hh404568</msdn-id>	
    /// <unmanaged>ID2D1EffectImpl</unmanaged>	
    /// <unmanaged-short>ID2D1EffectImpl</unmanaged-short>	
    [Guid("a248fd3f-3e6c-4e63-9f03-7f68ecc91db9")]
    internal partial class CustomEffectNative : SharpDX.ComObjectCallback, SharpDX.Direct2D1.CustomEffect
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.CustomEffectNative"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CustomEffectNative(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.CustomEffectNative"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.CustomEffectNative(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.CustomEffectNative(nativePointer);
        }


        /// <summary>	
        /// <p>The effect can use this method to do one time initialization tasks.  If this method is not needed, the method can just return <strong><see cref="SharpDX.Result.Ok"/></strong>.</p>	
        /// </summary>	
        /// <param name="effectContext"><dd>  <p>An internal context interface that creates and returns effect author?centric types.</p> </dd></param>	
        /// <param name="transformGraph"><dd>  <p>The effect can populate the transform graph with a topology and can update it later.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This moves resource creation cost to the <strong>CreateEffect</strong> call, rather than during rendering.</p><p>If the implementation fails this call, the corresponding <strong><see cref="SharpDX.Direct2D1.DeviceContext.CreateEffect"/></strong> call also fails.</p><p>The following example shows an effect implementing an initialize method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectImpl::Initialize']/*"/>	
        /// <msdn-id>hh404570</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectImpl::Initialize([In] ID2D1EffectContext* effectContext,[In] ID2D1TransformGraph* transformGraph)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectImpl::Initialize</unmanaged-short>	
        internal void Initialize_(SharpDX.Direct2D1.EffectContext effectContext, SharpDX.Direct2D1.TransformGraph transformGraph)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((effectContext == null) ? IntPtr.Zero : effectContext.NativePointer), (void*)((transformGraph == null) ? IntPtr.Zero : transformGraph.NativePointer), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Prepares an effect for the rendering process.</p>	
        /// </summary>	
        /// <param name="changeType"><dd>  <p>Indicates the type of change the effect should expect.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method is called by the renderer when the effect is within an effect graph that is drawn.</p><p> The method will be called:</p><ul> <li>If the effect has been initialized but has not previously been drawn.</li> <li>If an effect property has been set since the last draw call.</li> <li>If the context state has changed since the effect was last drawn.</li> </ul><p>The method will not otherwise be called. The transforms created by the effect will be called to handle their input and output rectangles for every draw call.</p><p>Most effects defer creating any resources or specifying a topology until this call is made. They store their properties and map them to a concrete set of rendering techniques when first drawn.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectImpl::PrepareForRender']/*"/>	
        /// <msdn-id>hh404572</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectImpl::PrepareForRender([In] D2D1_CHANGE_TYPE changeType)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectImpl::PrepareForRender</unmanaged-short>	
        internal void PrepareForRender_(SharpDX.Direct2D1.ChangeType changeType)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)changeType), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>The renderer calls this method to provide the effect implementation with a way to specify  its transform graph and transform graph changes. </p><p>The renderer calls this method when:</p><ul> <li>When the effect is first initialized.</li> <li>If the number of inputs to the effect changes.</li> </ul>	
        /// </summary>	
        /// <param name="transformGraph"><dd>  <p>The graph to which the effect describes its transform topology through the SetDescription call.</p> </dd></param>	
        /// <returns><p>An error that prevents the effect from being initialized if called as part of the CreateEffect call. If the effect fails a subsequent SetGraph call:</p><ul> <li>The error will be returned from the property method that caused the number of inputs to the effect to change.</li> <li>The effect object will be placed into an error state, if subsequently used to render, the context will be placed into a temporary error state, that particular effect will fail to render and the failure will be returned on the next EndDraw or Flush call.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectImpl::SetGraph']/*"/>	
        /// <msdn-id>hh871459</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectImpl::SetGraph([In] ID2D1TransformGraph* transformGraph)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectImpl::SetGraph</unmanaged-short>	
        internal void SetGraph_(SharpDX.Direct2D1.TransformGraph transformGraph)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((transformGraph == null) ? IntPtr.Zero : transformGraph.NativePointer), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a resource domain whose objects and device contexts can be used together.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device']/*"/>	
    /// <msdn-id>hh404478</msdn-id>	
    /// <unmanaged>ID2D1Device</unmanaged>	
    /// <unmanaged-short>ID2D1Device</unmanaged-short>	
    [Guid("47dd575d-ac05-4cdd-8049-9b02cd16f44c")]
    public partial class Device : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Device"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Device(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Device"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Device(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Device(nativePointer);
        }


        /// <summary>	
        /// <p>Sets the maximum amount of texture memory Direct2D accumulates before it purges the image caches and cached texture allocations.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device::GetMaximumTextureMemory']/*"/>	
        /// <msdn-id>hh847984</msdn-id>	
        /// <unmanaged>GetMaximumTextureMemory / SetMaximumTextureMemory</unmanaged>	
        /// <unmanaged-short>GetMaximumTextureMemory</unmanaged-short>	
        /// <unmanaged>unsigned longlong ID2D1Device::GetMaximumTextureMemory()</unmanaged>
        public long MaximumTextureMemory
        {
            get { return GetMaximumTextureMemory(); }
            set { SetMaximumTextureMemory(value); }
        }

        /// <summary>	
        /// <p>Creates a new device context from a Direct2D device.</p>	
        /// </summary>	
        /// <param name="options"><dd>  <p>The options to be applied to the created device context.</p> </dd></param>	
        /// <param name="deviceContext"><dd>  <p>When this method returns, contains the address of a reference to the new device context.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The new device context will not have a  selected target bitmap. The caller must create and select a bitmap as the target surface of the context.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device::CreateDeviceContext']/*"/>	
        /// <msdn-id>hh404545</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Device::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out, Fast] ID2D1DeviceContext** deviceContext)</unmanaged>	
        /// <unmanaged-short>ID2D1Device::CreateDeviceContext</unmanaged-short>	
        internal void CreateDeviceContext(SharpDX.Direct2D1.DeviceContextOptions options, SharpDX.Direct2D1.DeviceContext deviceContext)
        {
            unsafe
            {
                IntPtr deviceContext_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)options), &deviceContext_, ((void**)(*(void**)_nativePointer))[4]);
                ((SharpDX.Direct2D1.DeviceContext)deviceContext).NativePointer = deviceContext_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// Creates an <strong><see cref="SharpDX.Direct2D1.PrintControl"/></strong> object that converts Direct2D primitives stored in <strong><see cref="SharpDX.Direct2D1.CommandList"/></strong> into a fixed page representation.  The print sub-system then consumes the primitives.	
        /// </summary>	
        /// <param name="wicFactory">No documentation.</param>	
        /// <param name="documentTarget">No documentation.</param>	
        /// <param name="rintControlPropertiesRef">No documentation.</param>	
        /// <param name="rintControlRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device::CreatePrintControl']/*"/>	
        /// <msdn-id>jj841160</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Device::CreatePrintControl([In] IWICImagingFactory* wicFactory,[In] IPrintDocumentPackageTarget* documentTarget,[In, Optional] const D2D1_PRINT_CONTROL_PROPERTIES* printControlProperties,[Out, Fast] ID2D1PrintControl** printControl)</unmanaged>	
        /// <unmanaged-short>ID2D1Device::CreatePrintControl</unmanaged-short>	
        internal void CreatePrintControl(SharpDX.WIC.ImagingFactory wicFactory, SharpDX.ComObject documentTarget, SharpDX.Direct2D1.PrintControlProperties? rintControlPropertiesRef, SharpDX.Direct2D1.PrintControl rintControlRef)
        {
            unsafe
            {
                SharpDX.Direct2D1.PrintControlProperties rintControlPropertiesRef_;
                if (rintControlPropertiesRef.HasValue)
                    rintControlPropertiesRef_ = rintControlPropertiesRef.Value;
                IntPtr rintControlRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((wicFactory == null) ? IntPtr.Zero : wicFactory.NativePointer), (void*)((documentTarget == null) ? IntPtr.Zero : documentTarget.NativePointer), (rintControlPropertiesRef.HasValue) ? &rintControlPropertiesRef_ : (void*)IntPtr.Zero, &rintControlRef_, ((void**)(*(void**)_nativePointer))[5]);
                ((SharpDX.Direct2D1.PrintControl)rintControlRef).NativePointer = rintControlRef_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the maximum amount of texture memory Direct2D accumulates before it purges the image caches and cached texture allocations.</p>	
        /// </summary>	
        /// <param name="maximumInBytes"><dd>  <p>The new maximum texture memory in bytes.</p> </dd></param>	
        /// <remarks>	
        /// <p><strong>Note</strong>??Direct2D may exceed the  maximum texture memory you set with this method for a single frame if necessary to render the frame.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device::SetMaximumTextureMemory']/*"/>	
        /// <msdn-id>hh847985</msdn-id>	
        /// <unmanaged>void ID2D1Device::SetMaximumTextureMemory([In] unsigned longlong maximumInBytes)</unmanaged>	
        /// <unmanaged-short>ID2D1Device::SetMaximumTextureMemory</unmanaged-short>	
        internal void SetMaximumTextureMemory(long maximumInBytes)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, maximumInBytes, ((void**)(*(void**)_nativePointer))[6]);
            }
        }

        /// <summary>	
        /// <p>Sets the maximum amount of texture memory Direct2D accumulates before it purges the image caches and cached texture allocations.</p>	
        /// </summary>	
        /// <returns><p>The maximum amount of texture memory in bytes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device::GetMaximumTextureMemory']/*"/>	
        /// <msdn-id>hh847984</msdn-id>	
        /// <unmanaged>unsigned longlong ID2D1Device::GetMaximumTextureMemory()</unmanaged>	
        /// <unmanaged-short>ID2D1Device::GetMaximumTextureMemory</unmanaged-short>	
        internal long GetMaximumTextureMemory()
        {
            unsafe
            {
                long __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callilong(_nativePointer, ((void**)(*(void**)_nativePointer))[7]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Clears all of the rendering resources used by Direct2D. </p>	
        /// </summary>	
        /// <param name="millisecondsSinceUse"><dd>  <p>Discards only resources that haven't been used for greater than the specified time in milliseconds. The default is 0 milliseconds.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device::ClearResources']/*"/>	
        /// <msdn-id>hh404542</msdn-id>	
        /// <unmanaged>void ID2D1Device::ClearResources([In] unsigned int millisecondsSinceUse)</unmanaged>	
        /// <unmanaged-short>ID2D1Device::ClearResources</unmanaged-short>	
        public void ClearResources(int millisecondsSinceUse)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, millisecondsSinceUse, ((void**)(*(void**)_nativePointer))[8]);
            }
        }
    }
    /// <summary>	
    /// <p>Represents a resource domain whose objects and device contexts can be used together. This interface performs all the same functions as the existing <strong><see cref="SharpDX.Direct2D1.Device"/></strong> interface. It also enables control of the device's rendering priority.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device1']/*"/>	
    /// <msdn-id>dn280458</msdn-id>	
    /// <unmanaged>ID2D1Device1</unmanaged>	
    /// <unmanaged-short>ID2D1Device1</unmanaged-short>	
    [Guid("d21768e1-23a4-4823-a14b-7c3eba85d658")]
    public partial class Device1 : SharpDX.Direct2D1.Device
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Device1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Device1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Device1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Device1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Device1(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves or sets the current rendering priority of the device.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device1::GetRenderingPriority']/*"/>	
        /// <msdn-id>dn280459</msdn-id>	
        /// <unmanaged>GetRenderingPriority / SetRenderingPriority</unmanaged>	
        /// <unmanaged-short>GetRenderingPriority</unmanaged-short>	
        /// <unmanaged>D2D1_RENDERING_PRIORITY ID2D1Device1::GetRenderingPriority()</unmanaged>
        public SharpDX.Direct2D1.RenderingPriority RenderingPriority
        {
            get { return GetRenderingPriority(); }
            set { SetRenderingPriority(value); }
        }

        /// <summary>	
        /// <p>Retrieves the current rendering priority of the device.</p>	
        /// </summary>	
        /// <returns><p> The current rendering priority of the device.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device1::GetRenderingPriority']/*"/>	
        /// <msdn-id>dn280459</msdn-id>	
        /// <unmanaged>D2D1_RENDERING_PRIORITY ID2D1Device1::GetRenderingPriority()</unmanaged>	
        /// <unmanaged-short>ID2D1Device1::GetRenderingPriority</unmanaged-short>	
        internal SharpDX.Direct2D1.RenderingPriority GetRenderingPriority()
        {
            unsafe
            {
                SharpDX.Direct2D1.RenderingPriority __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1RenderingPriority(_nativePointer, ((void**)(*(void**)_nativePointer))[9]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets the priority of Direct2D rendering operations performed on any device context associated with the device.</p>	
        /// </summary>	
        /// <param name="renderingPriority"><dd>  <p>The desired rendering priority for the device and associated contexts.</p> </dd></param>	
        /// <remarks>	
        /// <p>Calling this method affects the rendering priority of all device contexts associated with the device. This method can be called at any time, but is not guaranteed to take effect until the beginning of the next frame. The recommended usage is to call this method outside of <strong>BeginDraw</strong> and <strong>EndDraw</strong> blocks. Cycling this property frequently within drawing blocks will effectively reduce the benefits of any throttling that is applied.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device1::SetRenderingPriority']/*"/>	
        /// <msdn-id>dn280460</msdn-id>	
        /// <unmanaged>void ID2D1Device1::SetRenderingPriority([In] D2D1_RENDERING_PRIORITY renderingPriority)</unmanaged>	
        /// <unmanaged-short>ID2D1Device1::SetRenderingPriority</unmanaged-short>	
        internal void SetRenderingPriority(SharpDX.Direct2D1.RenderingPriority renderingPriority)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)renderingPriority), ((void**)(*(void**)_nativePointer))[10]);
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>	
        /// <param name="deviceContext1">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device1::CreateDeviceContext']/*"/>	
        /// <unmanaged>HRESULT ID2D1Device1::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out, Fast] ID2D1DeviceContext1** deviceContext1)</unmanaged>	
        /// <unmanaged-short>ID2D1Device1::CreateDeviceContext</unmanaged-short>	
        internal void CreateDeviceContext(SharpDX.Direct2D1.DeviceContextOptions options, SharpDX.Direct2D1.DeviceContext1 deviceContext1)
        {
            unsafe
            {
                IntPtr deviceContext1_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)options), &deviceContext1_, ((void**)(*(void**)_nativePointer))[11]);
                ((SharpDX.Direct2D1.DeviceContext1)deviceContext1).NativePointer = deviceContext1_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Flush all device contexts that reference a given bitmap.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device2']/*"/>	
    /// <msdn-id>dn890788</msdn-id>	
    /// <unmanaged>ID2D1Device2</unmanaged>	
    /// <unmanaged-short>ID2D1Device2</unmanaged-short>	
    [Guid("a44472e1-8dfb-4e60-8492-6e2861c9ca8b")]
    public partial class Device2 : SharpDX.Direct2D1.Device1
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Device2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Device2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Device2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Device2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Device2(nativePointer);
        }


        /// <summary>	
        /// <p>Returns the DXGI device associated with this Direct2D device.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device2::GetDxgiDevice']/*"/>	
        /// <msdn-id>dn917489</msdn-id>	
        /// <unmanaged>GetDxgiDevice</unmanaged>	
        /// <unmanaged-short>GetDxgiDevice</unmanaged-short>	
        /// <unmanaged>HRESULT ID2D1Device2::GetDxgiDevice([Out] IDXGIDevice** dxgiDevice)</unmanaged>
        public SharpDX.DXGI.Device DxgiDevice
        {
            get { SharpDX.DXGI.Device __output__; GetDxgiDevice(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Creates a new <strong><see cref="SharpDX.Direct2D1.DeviceContext2"/></strong> from a Direct2D device.</p>	
        /// </summary>	
        /// <param name="options">No documentation.</param>	
        /// <param name="deviceContext2">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device2::CreateDeviceContext']/*"/>	
        /// <msdn-id>dn890787</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Device2::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out, Fast] ID2D1DeviceContext2** deviceContext2)</unmanaged>	
        /// <unmanaged-short>ID2D1Device2::CreateDeviceContext</unmanaged-short>	
        public void CreateDeviceContext(SharpDX.Direct2D1.DeviceContextOptions options, SharpDX.Direct2D1.DeviceContext2 deviceContext2)
        {
            unsafe
            {
                IntPtr deviceContext2_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)options), &deviceContext2_, ((void**)(*(void**)_nativePointer))[12]);
                ((SharpDX.Direct2D1.DeviceContext2)deviceContext2).NativePointer = deviceContext2_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Flush all device contexts that reference a given bitmap.</p>	
        /// </summary>	
        /// <param name="bitmap"><dd>  <p>The bitmap, created on this device, for which all referencing device contexts will be flushed. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device2::FlushDeviceContexts']/*"/>	
        /// <msdn-id>dn890788</msdn-id>	
        /// <unmanaged>void ID2D1Device2::FlushDeviceContexts([In] ID2D1Bitmap* bitmap)</unmanaged>	
        /// <unmanaged-short>ID2D1Device2::FlushDeviceContexts</unmanaged-short>	
        public void FlushDeviceContexts(SharpDX.Direct2D1.Bitmap bitmap)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((bitmap == null) ? IntPtr.Zero : bitmap.NativePointer), ((void**)(*(void**)_nativePointer))[13]);
            }
        }

        /// <summary>	
        /// <p>Returns the DXGI device associated with this Direct2D device.</p>	
        /// </summary>	
        /// <param name="dxgiDevice"><dd>  <p>The DXGI device associated with this Direct2D device.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Device2::GetDxgiDevice']/*"/>	
        /// <msdn-id>dn917489</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Device2::GetDxgiDevice([Out] IDXGIDevice** dxgiDevice)</unmanaged>	
        /// <unmanaged-short>ID2D1Device2::GetDxgiDevice</unmanaged-short>	
        internal void GetDxgiDevice(out SharpDX.DXGI.Device dxgiDevice)
        {
            unsafe
            {
                IntPtr dxgiDevice_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &dxgiDevice_, ((void**)(*(void**)_nativePointer))[14]);
                dxgiDevice = (dxgiDevice_ == IntPtr.Zero) ? null : new SharpDX.DXGI.Device(dxgiDevice_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a set of state and command buffers that are used to render to a target.</p><p>The device context can render to a target bitmap or a command list.	
    /// </p>	
    /// </summary>	
    /// <remarks>	
    /// <p> Any resource created from a device context can be shared with any other resource created from a device context when both contexts are created on the same device. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext']/*"/>	
    /// <msdn-id>hh404479</msdn-id>	
    /// <unmanaged>ID2D1DeviceContext</unmanaged>	
    /// <unmanaged-short>ID2D1DeviceContext</unmanaged-short>	
    [Guid("e8f7fe7a-191c-466d-ad95-975678bda998")]
    public partial class DeviceContext : SharpDX.Direct2D1.RenderTarget
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.DeviceContext"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DeviceContext(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.DeviceContext"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.DeviceContext(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.DeviceContext(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the device associated with a device context.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The application can retrieve the device even if it is created from an earlier render target code-path. The application must use an <strong><see cref="SharpDX.Direct2D1.DeviceContext"/></strong> interface and then call <strong>GetDevice</strong>. Some functionality for controlling all of the resources for a set of device contexts is maintained only on an <strong><see cref="SharpDX.Direct2D1.Device"/></strong> object.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetDevice']/*"/>	
        /// <msdn-id>hh404513</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>void ID2D1DeviceContext::GetDevice([Out] ID2D1Device** device)</unmanaged>
        public SharpDX.Direct2D1.Device Device
        {
            get { SharpDX.Direct2D1.Device __output__; GetDevice(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets or sets the target currently associated with the device context.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If a target is not associated with the device context, <em>target</em> will contain <strong><c>null</c></strong> when the methods returns.</p><p>If the currently selected target is a bitmap rather than a command list, the application can gain access to the initial bitmaps created by using one of the following methods:</p><ul> <li> <strong>CreateHwndRenderTarget</strong> </li> <li> <strong>CreateDxgiSurfaceRenderTarget</strong> </li> <li> <strong>CreateWicBitmapRenderTarget</strong> </li> <li> <strong>CreateDCRenderTarget</strong> </li> <li> <strong>CreateCompatibleRenderTarget</strong> </li> </ul><p>It is not possible for an application to destroy these bitmaps.  All of these bitmaps are bindable as bitmap targets.  However not all of these bitmaps can be used as bitmap sources for  <strong><see cref="SharpDX.Direct2D1.RenderTarget"/></strong> methods.</p><p> <strong>CreateDxgiSurfaceRenderTarget</strong> will create a bitmap that is usable as a bitmap source if the DXGI surface is bindable as a shader resource view.</p><p> <strong>CreateCompatibleRenderTarget</strong> will always create bitmaps that are usable as a bitmap source.</p><p> <strong><see cref="SharpDX.Direct2D1.RenderTarget.BeginDraw"/></strong> will copy from the <see cref="System.IntPtr"/> to the original bitmap associated with it.  <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> will copy from the original bitmap to the <see cref="System.IntPtr"/>.  </p><p> <strong><see cref="SharpDX.WIC.Bitmap"/></strong> objects will be locked in the following circumstances:</p><ul> <li>BeginDraw has been called and the currently selected target bitmap is a WIC bitmap.</li> <li>A WIC bitmap is set as the target of a device context after BeginDraw has been called and before EndDraw has been called.</li> <li>Any of the ID2D1Bitmap::Copy* methods are called with a WIC bitmap as either the source or destination.</li> </ul><p><see cref="SharpDX.WIC.Bitmap"/> objects will be unlocked in the following circumstances:</p><ul> <li>EndDraw is called and the currently selected target bitmap is a WIC bitmap.</li> <li>A WIC bitmap is removed as the target of a device context between the calls to BeginDraw and EndDraw.</li> <li>Any of the ID2D1Bitmap::Copy* methods are called with a WIC bitmap as either the source or destination.</li> </ul><p>Direct2D will only lock bitmaps that are not currently locked.</p><p>Calling <strong>QueryInterface</strong> for <strong><see cref="SharpDX.Direct2D1.GdiInteropRenderTarget"/></strong> will always succeed.  <strong><see cref="SharpDX.Direct2D1.GdiInteropRenderTarget.GetDC"/></strong> will return a device context corresponding to the currently bound target bitmap.  GetDC will fail if the target bitmap was not created with the GDI_COMPATIBLE flag set.</p><p> <strong><see cref="SharpDX.Direct2D1.WindowRenderTarget.Resize"/></strong> will return <strong><see cref="SharpDX.DXGI.ResultCode.InvalidCall"/></strong> if there are any outstanding references to the original target bitmap associated with the render target.</p><p>Although the target can be a command list, it cannot be any other type of image. It cannot be the output image of an effect.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetTarget']/*"/>	
        /// <msdn-id>hh404523</msdn-id>	
        /// <unmanaged>GetTarget / SetTarget</unmanaged>	
        /// <unmanaged-short>GetTarget</unmanaged-short>	
        /// <unmanaged>void ID2D1DeviceContext::GetTarget([Out, Optional] ID2D1Image** image)</unmanaged>
        public SharpDX.Direct2D1.Image Target
        {
            get { SharpDX.Direct2D1.Image __output__; GetTarget(out __output__); return __output__; }
            set { SetTarget(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the rendering controls that have been applied to the context.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetRenderingControls']/*"/>	
        /// <msdn-id>hh404519</msdn-id>	
        /// <unmanaged>GetRenderingControls / SetRenderingControls</unmanaged>	
        /// <unmanaged-short>GetRenderingControls</unmanaged-short>	
        /// <unmanaged>void ID2D1DeviceContext::GetRenderingControls([Out] D2D1_RENDERING_CONTROLS* renderingControls)</unmanaged>
        public SharpDX.Direct2D1.RenderingControls RenderingControls
        {
            get { SharpDX.Direct2D1.RenderingControls __output__; GetRenderingControls(out __output__); return __output__; }
            set { SetRenderingControls(value); }
        }

        /// <summary>	
        /// <p>Returns or sets the currently set primitive blend used by the device context.  </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetPrimitiveBlend']/*"/>	
        /// <msdn-id>hh404517</msdn-id>	
        /// <unmanaged>GetPrimitiveBlend / SetPrimitiveBlend</unmanaged>	
        /// <unmanaged-short>GetPrimitiveBlend</unmanaged-short>	
        /// <unmanaged>D2D1_PRIMITIVE_BLEND ID2D1DeviceContext::GetPrimitiveBlend()</unmanaged>
        public SharpDX.Direct2D1.PrimitiveBlend PrimitiveBlend
        {
            get { return GetPrimitiveBlend(); }
            set { SetPrimitiveBlend(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the mode that  is being used to interpret values by the device context.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetUnitMode']/*"/>	
        /// <msdn-id>hh404525</msdn-id>	
        /// <unmanaged>GetUnitMode / SetUnitMode</unmanaged>	
        /// <unmanaged-short>GetUnitMode</unmanaged-short>	
        /// <unmanaged>D2D1_UNIT_MODE ID2D1DeviceContext::GetUnitMode()</unmanaged>
        public SharpDX.Direct2D1.UnitMode UnitMode
        {
            get { return GetUnitMode(); }
            set { SetUnitMode(value); }
        }

        /// <summary>	
        /// <p>Creates a bitmap that can be used as a target surface, for reading back to the CPU, or as a source for the <strong>DrawBitmap</strong> and <strong><see cref="SharpDX.Direct2D1.BitmapBrush"/></strong> APIs. In addition, color context information can be passed to the bitmap.</p>	
        /// </summary>	
        /// <param name="size">No documentation.</param>	
        /// <param name="sourceData">No documentation.</param>	
        /// <param name="pitch">No documentation.</param>	
        /// <param name="bitmapProperties">No documentation.</param>	
        /// <param name="bitmap">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The new bitmap can be used as a target for <strong>SetTarget</strong> if it is created with <strong><see cref="SharpDX.Direct2D1.BitmapOptions.Target"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::CreateBitmap']/*"/>	
        /// <msdn-id>hh404480</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmap([In] D2D_SIZE_U size,[In, Optional] const void* sourceData,[In] unsigned int pitch,[In] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out, Fast] ID2D1Bitmap1** bitmap)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::CreateBitmap</unmanaged-short>	
        internal void CreateBitmap(SharpDX.Size2 size, System.IntPtr sourceData, int pitch, SharpDX.Direct2D1.BitmapProperties1 bitmapProperties, SharpDX.Direct2D1.Bitmap1 bitmap)
        {
            unsafe
            {
                var bitmapProperties_ = new SharpDX.Direct2D1.BitmapProperties1.__Native();
                bitmapProperties.__MarshalTo(ref bitmapProperties_);
                IntPtr bitmap_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint25(_nativePointer, size, (void*)sourceData, pitch, &bitmapProperties_, &bitmap_, ((void**)(*(void**)_nativePointer))[57]);
                bitmapProperties.__MarshalFree(ref bitmapProperties_);
                ((SharpDX.Direct2D1.Bitmap1)bitmap).NativePointer = bitmap_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a Direct2D bitmap by copying a WIC bitmap.</p>	
        /// </summary>	
        /// <param name="wicBitmapSource"><dd>  <p>The WIC bitmap source to copy from.</p> </dd></param>	
        /// <param name="bitmapProperties"><dd>  <p>A bitmap properties structure that specifies bitmap creation options.</p> </dd></param>	
        /// <param name="bitmap"><dd>  <p>The address of the newly created bitmap object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Starting with Windows?8.1, the  <em>bitmapProperties</em> parameter is optional. When it is not specified, the created bitmap inherits the pixel format and alpha mode from  <em>wicBitmapSource</em>. For a list of supported pixel formats and alpha modes, see Supported Pixel Formats and Alpha Modes.</p><p>When the <em>bitmapProperties</em> parameter is specified, the value in <em>bitmapProperties-&gt;pixelFormat</em> must either be <strong><see cref="SharpDX.DXGI.Format.Unknown"/></strong> or must match the WIC pixel format in <em>wicBitmapSource</em>.</p><p>When <em>bitmapProperties-&gt;pixelFormat.alphaMode</em> is set to <strong><see cref="SharpDX.Direct2D1.AlphaMode.Unknown"/></strong>, the newly created bitmap inherits the alpha mode from <em>wicBitmapSource</em>. When <em>bitmapProperties-&gt;pixelFormat.alphaMode</em> is set to <strong><see cref="SharpDX.Direct2D1.AlphaMode.Premultiplied"/></strong>, <strong><see cref="SharpDX.Direct2D1.AlphaMode.Straight"/></strong>, or <strong><see cref="SharpDX.Direct2D1.AlphaMode.Ignore"/></strong>, this forces the newly created bitmap to use the specified alpha mode.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::CreateBitmapFromWicBitmap']/*"/>	
        /// <msdn-id>hh847971</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapFromWicBitmap([In] IWICBitmapSource* wicBitmapSource,[In, Optional] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out] ID2D1Bitmap1** bitmap)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::CreateBitmapFromWicBitmap</unmanaged-short>	
        internal void CreateBitmapFromWicBitmap(SharpDX.WIC.BitmapSource wicBitmapSource, SharpDX.Direct2D1.BitmapProperties1 bitmapProperties, out SharpDX.Direct2D1.Bitmap1 bitmap)
        {
            unsafe
            {
                var bitmapProperties_ = new SharpDX.Direct2D1.BitmapProperties1.__Native();
                if (bitmapProperties != null)
                    bitmapProperties.__MarshalTo(ref bitmapProperties_);
                IntPtr bitmap_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((wicBitmapSource == null) ? IntPtr.Zero : wicBitmapSource.NativePointer), (bitmapProperties != null) ? &bitmapProperties_ : (void*)IntPtr.Zero, &bitmap_, ((void**)(*(void**)_nativePointer))[58]);
                if (bitmapProperties != null)
                    bitmapProperties.__MarshalFree(ref bitmapProperties_);
                bitmap = (bitmap_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.Bitmap1(bitmap_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a color context.</p>	
        /// </summary>	
        /// <param name="space"><dd>  <p>The space  of color context to create.</p> </dd></param>	
        /// <param name="rofileRef"><dd>  <p>A buffer containing the ICC profile bytes used to initialize the color context when <em>space</em> is <see cref="SharpDX.Direct2D1.ColorSpace.Custom"/>.  For other types, the parameter is ignored and should be set to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="profileSize"><dd>  <p>The size in bytes of <em>Profile</em>.</p> </dd></param>	
        /// <param name="colorContext"><dd>  <p>When this method returns, contains the address of a reference to a new color context object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The new color context can be used in <strong><see cref="SharpDX.Direct2D1.BitmapProperties1"/></strong> to initialize the color context of a created bitmap.</p><p>When <em>space</em> is <see cref="SharpDX.Direct2D1.ColorSpace.Custom"/>, <em>profile</em> and <em>profileSize</em> must be specified.  Otherwise, these parameters should be set to <strong><c>null</c></strong> and zero respectively.  When the space is <see cref="SharpDX.Direct2D1.ColorSpace.Custom"/>, the model field of the profile header is inspected to determine if this profile is sRGB or scRGB and the color space is updated respectively.  Otherwise the space remains custom.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::CreateColorContext']/*"/>	
        /// <msdn-id>hh404485</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateColorContext([In] D2D1_COLOR_SPACE space,[In, Buffer, Optional] const unsigned char* profile,[In] unsigned int profileSize,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::CreateColorContext</unmanaged-short>	
        internal void CreateColorContext(SharpDX.Direct2D1.ColorSpace space, byte[] rofileRef, int profileSize, SharpDX.Direct2D1.ColorContext colorContext)
        {
            unsafe
            {
                byte[] rofileRef__ = rofileRef;
                IntPtr colorContext_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* rofileRef_ = rofileRef__)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)space), rofileRef_, profileSize, &colorContext_, ((void**)(*(void**)_nativePointer))[59]);
                ((SharpDX.Direct2D1.ColorContext)colorContext).NativePointer = colorContext_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a color context by loading it from the specified filename.  The profile bytes are the contents of the file specified by <em>Filename</em>.</p>	
        /// </summary>	
        /// <param name="filename"><dd>  <p>The path to the file containing the profile bytes to initialize the color context with.</p> </dd></param>	
        /// <param name="colorContext"><dd>  <p>When this method returns, contains the address of a reference to a new color context.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The new color context can be used in <strong><see cref="SharpDX.Direct2D1.BitmapProperties1"/></strong> to initialize the color context of a created bitmap.  The model field of the profile header is inspected to determine whether this profile is sRGB or scRGB and the color space is updated respectively.  Otherwise the space is  custom.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::CreateColorContextFromFilename']/*"/>	
        /// <msdn-id>hh404488</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateColorContextFromFilename([In] const wchar_t* filename,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::CreateColorContextFromFilename</unmanaged-short>	
        internal void CreateColorContextFromFilename(string filename, SharpDX.Direct2D1.ColorContext colorContext)
        {
            unsafe
            {
                IntPtr filename_ = Utilities.StringToHGlobalUni(filename);
                IntPtr colorContext_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)filename_, &colorContext_, ((void**)(*(void**)_nativePointer))[60]);
                Marshal.FreeHGlobal(filename_);
                ((SharpDX.Direct2D1.ColorContext)colorContext).NativePointer = colorContext_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a color context from an <strong><see cref="SharpDX.WIC.ColorContext"/></strong>.  The <strong>D2D1ColorContext</strong> space of the resulting context varies, see Remarks for more info.</p>	
        /// </summary>	
        /// <param name="wicColorContext">No documentation.</param>	
        /// <param name="colorContext">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The new color context can be used in <strong><see cref="SharpDX.Direct2D1.BitmapProperties1"/></strong> to initialize the color context of a created bitmap.  The model field of the profile header is inspected to determine whether this profile is sRGB or scRGB and the color space is updated respectively.  Otherwise the space is  custom.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::CreateColorContextFromWicColorContext']/*"/>	
        /// <msdn-id>hh404491</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateColorContextFromWicColorContext([In] IWICColorContext* wicColorContext,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::CreateColorContextFromWicColorContext</unmanaged-short>	
        internal void CreateColorContextFromWicColorContext(SharpDX.WIC.ColorContext wicColorContext, SharpDX.Direct2D1.ColorContext colorContext)
        {
            unsafe
            {
                IntPtr colorContext_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((wicColorContext == null) ? IntPtr.Zero : wicColorContext.NativePointer), &colorContext_, ((void**)(*(void**)_nativePointer))[61]);
                ((SharpDX.Direct2D1.ColorContext)colorContext).NativePointer = colorContext_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates a bitmap from a DXGI surface that can be set as a target surface or have additional color context information specified.</p>	
        /// </summary>	
        /// <param name="surface"><dd>  <p>The DXGI surface from which the bitmap can be created.  </p> <p><strong>Note</strong>??The DXGI surface must have been created from the same Direct3D device that the Direct2D device context is associated with.</p> </dd></param>	
        /// <param name="bitmapProperties"><dd>  <p>The bitmap properties specified in addition to the surface. </p> </dd></param>	
        /// <param name="bitmap"><dd>  <p>When this method returns, contains the address of a reference to a new bitmap object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the bitmap properties are not specified, the following information is assumed: </p><ul> <li>The bitmap DPI is 96.</li> <li>The pixel format matches that of the surface.</li> <li>The returned bitmap will inherit the bind flags of the DXGI surface.<ul> <li>However, only the subset of flags meaningful to Direct2D will be inherited. For example, D3D10_USAGE_DYNAMIC is not compatible with any public Direct2D flags.</li> </ul> </li> <li>The color context is unknown.</li> <li>The alpha mode of the bitmap will be premultiplied (common case) or straight (A8).	
        /// </li> </ul><p>If the bitmap properties are specified, the bitmap properties will be used as follows:</p><ul> <li>The bitmap DPI will be specified by the bitmap properties.</li> <li>If both dpiX and dpiY are 0, the bitmap DPI will be 96.</li> <li>The pixel format must be compatible with the shader resource view or render target view of the surface.</li> <li>The bitmap options must be compatible with the bind flags of the DXGI surface. However, they may be a subset. This will influence what resource views are created by the bitmap.</li> <li>The color context information will be used from the bitmap properties, if specified.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::CreateBitmapFromDxgiSurface']/*"/>	
        /// <msdn-id>hh404482</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapFromDxgiSurface([In] IDXGISurface* surface,[In, Optional] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out, Fast] ID2D1Bitmap1** bitmap)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::CreateBitmapFromDxgiSurface</unmanaged-short>	
        internal void CreateBitmapFromDxgiSurface(SharpDX.DXGI.Surface surface, SharpDX.Direct2D1.BitmapProperties1 bitmapProperties, SharpDX.Direct2D1.Bitmap1 bitmap)
        {
            unsafe
            {
                var bitmapProperties_ = new SharpDX.Direct2D1.BitmapProperties1.__Native();
                if (bitmapProperties != null)
                    bitmapProperties.__MarshalTo(ref bitmapProperties_);
                IntPtr bitmap_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((surface == null) ? IntPtr.Zero : surface.NativePointer), (bitmapProperties != null) ? &bitmapProperties_ : (void*)IntPtr.Zero, &bitmap_, ((void**)(*(void**)_nativePointer))[62]);
                if (bitmapProperties != null)
                    bitmapProperties.__MarshalFree(ref bitmapProperties_);
                ((SharpDX.Direct2D1.Bitmap1)bitmap).NativePointer = bitmap_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an effect from a  class ID. </p>	
        /// </summary>	
        /// <param name="effectId"><dd>  <p>The class ID of the effect to create.</p> </dd></param>	
        /// <param name="effect"><dd>  <p>When this method returns, contains the address of a reference to a new effect.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation.</td></tr> <tr><td><see cref="SharpDX.Direct2D1.ResultCode.EffectIsNotRegistered"/></td><td>The specified effect is not registered by the system.</td></tr> <tr><td><see cref="SharpDX.Direct2D1.ResultCode.InsufficientDeviceCapabilities"/> </td><td>The effect requires capabilities not supported by the D2D device.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the  created effect is a custom effect that is implemented in a DLL, this doesn't increment the reference count for that DLL. If the application deletes an effect while that effect is loaded, the resulting behavior is unpredictable.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::CreateEffect']/*"/>	
        /// <msdn-id>hh404500</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateEffect([In] const GUID&amp; effectId,[Out, Fast] ID2D1Effect** effect)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::CreateEffect</unmanaged-short>	
        internal void CreateEffect(System.Guid effectId, SharpDX.Direct2D1.Effect effect)
        {
            unsafe
            {
                IntPtr effect_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &effectId, &effect_, ((void**)(*(void**)_nativePointer))[63]);
                ((SharpDX.Direct2D1.Effect)effect).NativePointer = effect_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a gradient stop collection, enabling the gradient to contain color channels with values outside of [0,1] and also enabling rendering to a high-color render target with interpolation in sRGB space.</p>	
        /// </summary>	
        /// <param name="straightAlphaGradientStops"><dd>  <p>An array of color values and offsets.</p> </dd></param>	
        /// <param name="straightAlphaGradientStopsCount"><dd>  <p>The number of elements in the <em>gradientStops</em> array.</p> </dd></param>	
        /// <param name="preInterpolationSpace"><dd>  <p>Specifies both the input color space and the space in which the color interpolation occurs.</p> </dd></param>	
        /// <param name="postInterpolationSpace"><dd>  <p>The color space that colors will be converted to after interpolation occurs.</p> </dd></param>	
        /// <param name="bufferPrecision"><dd>  <p>The precision of the texture used to hold interpolated values.</p> <p><strong>Note</strong>??This method will fail if the underlying Direct3D device does not support the requested buffer precision.  Use <strong><see cref="SharpDX.Direct2D1.DeviceContext.IsBufferPrecisionSupported"/></strong> to determine what is supported.</p> </dd></param>	
        /// <param name="extendMode"><dd>  <p>Defines how colors outside of the range defined by the stop collection are determined.</p> </dd></param>	
        /// <param name="colorInterpolationMode"><dd>  <p>Defines how colors are interpolated.  <see cref="SharpDX.Direct2D1.ColorInterpolationMode.Premultiplied"/> is the default, see Remarks for more info.</p> </dd></param>	
        /// <param name="gradientStopCollection1"><dd>  <p>The new gradient stop collection.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method linearly interpolates between the color stops. An optional color space conversion is applied post-interpolation. Whether and how this gamma conversion is applied is determined by the pre- and post-interpolation. This method will fail if the device context does not support the requested buffer precision.</p><p>In order to get the desired result, you need to ensure that the inputs are specified in the correct color space. 	
        /// </p><p>You must always specify colors in straight alpha, regardless of interpolation mode being premultiplied or straight. The interpolation mode only affects the interpolated values. Likewise, the stops returned by <strong><see cref="SharpDX.Direct2D1.GradientStopCollection.GetGradientStops"/></strong> will always have straight alpha. </p><p>If you specify <strong><see cref="SharpDX.Direct2D1.ColorInterpolationMode.Premultiplied"/></strong>, then all stops are premultiplied before interpolation, and then un-premultiplied before color conversion.	
        /// </p><p>Starting with Windows?8, the interpolation behavior of this method has changed.  </p><p>The table here shows the behavior in Windows?7 and earlier.</p><table> <tr><th>Gamma</th><th>Before Interpolation Behavior</th><th>After Interpolation Behavior</th><th>GetColorInteroplationGamma	
        /// (output color space)	
        /// </th></tr> <tr><td>1.0</td><td>Clamps the inputs and then converts from sRGB to scRGB.</td><td>Converts from scRGB to sRGB post-interpolation.</td><td>1.0</td></tr> <tr><td>2.2</td><td>Clamps the inputs.</td><td>No Operation</td><td>2.2</td></tr> </table><p>?</p><p>The table here shows the behavior in Windows?8 and later.</p><table> <tr><th>Gamma</th><th>Before Interpolation Behavior</th><th>After Interpolation Behavior</th><th>GetColorInteroplationGamma	
        /// (output color space)	
        /// </th></tr> <tr><td>sRGB to scRGB</td><td>No Operation</td><td>Clamps the outputs and then converts from sRGB to scRGB.</td><td>1.0</td></tr> <tr><td>scRGB to sRGB</td><td>No Operation</td><td>Clamps the outputs and then converts from sRGB to scRGB.</td><td>2.2</td></tr> <tr><td>sRGB to sRGB</td><td>No Operation</td><td>No Operation</td><td>2.2</td></tr> <tr><td>scRGB to scRGB</td><td>No Operation</td><td>No Operation</td><td>1.0</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::CreateGradientStopCollection']/*"/>	
        /// <msdn-id>hh404502</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateGradientStopCollection([In, Buffer] const D2D1_GRADIENT_STOP* straightAlphaGradientStops,[In] unsigned int straightAlphaGradientStopsCount,[In] D2D1_COLOR_SPACE preInterpolationSpace,[In] D2D1_COLOR_SPACE postInterpolationSpace,[In] D2D1_BUFFER_PRECISION bufferPrecision,[In] D2D1_EXTEND_MODE extendMode,[In] D2D1_COLOR_INTERPOLATION_MODE colorInterpolationMode,[Out, Fast] ID2D1GradientStopCollection1** gradientStopCollection1)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::CreateGradientStopCollection</unmanaged-short>	
        internal void CreateGradientStopCollection(SharpDX.Direct2D1.GradientStop[] straightAlphaGradientStops, int straightAlphaGradientStopsCount, SharpDX.Direct2D1.ColorSpace preInterpolationSpace, SharpDX.Direct2D1.ColorSpace postInterpolationSpace, SharpDX.Direct2D1.BufferPrecision bufferPrecision, SharpDX.Direct2D1.ExtendMode extendMode, SharpDX.Direct2D1.ColorInterpolationMode colorInterpolationMode, SharpDX.Direct2D1.GradientStopCollection1 gradientStopCollection1)
        {
            unsafe
            {
                IntPtr gradientStopCollection1_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* straightAlphaGradientStops_ = straightAlphaGradientStops)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, straightAlphaGradientStops_, straightAlphaGradientStopsCount, unchecked((int)preInterpolationSpace), unchecked((int)postInterpolationSpace), unchecked((int)bufferPrecision), unchecked((int)extendMode), unchecked((int)colorInterpolationMode), &gradientStopCollection1_, ((void**)(*(void**)_nativePointer))[64]);
                ((SharpDX.Direct2D1.GradientStopCollection1)gradientStopCollection1).NativePointer = gradientStopCollection1_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an image brush. The input image can be any type of image, including a bitmap, effect, or a command list.	
        /// </p>	
        /// </summary>	
        /// <param name="image"><dd>  <p>The image to be used as a source for the image brush.</p> </dd></param>	
        /// <param name="imageBrushProperties"><dd>  <p>The properties specific to an image brush.</p> </dd></param>	
        /// <param name="brushProperties"><dd>  <p>Properties  common to all brushes.</p> </dd></param>	
        /// <param name="imageBrush"><dd>  <p>When this method returns, contains the address of a reference to the  input rectangles.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The image brush can be used to fill an arbitrary geometry, an opacity mask or text.</p><p>This sample illustrates drawing a rectangle with an image brush.</p><pre><see cref="SharpDX.Result"/>	
        /// CreatePatternBrush( __in <see cref="SharpDX.Direct2D1.DeviceContext"/> *pDeviceContext, __deref_out <see cref="SharpDX.Direct2D1.ImageBrush"/> **ppImageBrush )	
        /// { <see cref="SharpDX.Result"/> hr = <see cref="SharpDX.Result.Ok"/>; <see cref="SharpDX.Direct2D1.Image"/> *pOldTarget = <c>null</c>; pDeviceContext-&gt;GetTarget(&amp;pOldTarget); <see cref="SharpDX.Direct2D1.CommandList"/> *pCommandList = <c>null</c>; hr = pDeviceContext-&gt;CreateCommandList(&amp;pCommandList); if (SUCCEEDED(hr)) {    pDeviceContext-&gt;SetTarget(pCommandList); hr = RenderPatternToCommandList(pDeviceContext); } pDeviceContext-&gt;SetTarget(pOldTarget); <see cref="SharpDX.Direct2D1.ImageBrush"/> *pImageBrush = <c>null</c>; if (SUCCEEDED(hr)) {         hr = pDeviceContext-&gt;CreateImageBrush( pCommandList, D2D1::ImageBrushProperties( D2D1::RectF(198, 298, 370, 470), <see cref="SharpDX.Direct2D1.ExtendMode.Wrap"/>, <see cref="SharpDX.Direct2D1.ExtendMode.Wrap"/>, <see cref="SharpDX.Direct2D1.InterpolationMode.Linear"/> ), &amp;pImageBrush ); } // Fill a rectangle with the image brush. if (SUCCEEDED(hr)) { pDeviceContext-&gt;FillRectangle( D2D1::RectF(0, 0, 100, 100), pImageBrush); } SafeRelease(&amp;pImageBrush); SafeRelease(&amp;pCommandList); SafeRelease(&amp;pOldTarget); return hr;	
        /// }</pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::CreateImageBrush']/*"/>	
        /// <msdn-id>hh404506</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateImageBrush([In, Optional] ID2D1Image* image,[In] const D2D1_IMAGE_BRUSH_PROPERTIES* imageBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1ImageBrush** imageBrush)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::CreateImageBrush</unmanaged-short>	
        internal void CreateImageBrush(SharpDX.Direct2D1.Image image, ref SharpDX.Direct2D1.ImageBrushProperties imageBrushProperties, SharpDX.Direct2D1.BrushProperties? brushProperties, SharpDX.Direct2D1.ImageBrush imageBrush)
        {
            unsafe
            {
                SharpDX.Direct2D1.BrushProperties brushProperties_;
                if (brushProperties.HasValue)
                    brushProperties_ = brushProperties.Value;
                IntPtr imageBrush_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* imageBrushProperties_ = &imageBrushProperties)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((image == null) ? IntPtr.Zero : image.NativePointer), imageBrushProperties_, (brushProperties.HasValue) ? &brushProperties_ : (void*)IntPtr.Zero, &imageBrush_, ((void**)(*(void**)_nativePointer))[65]);
                ((SharpDX.Direct2D1.ImageBrush)imageBrush).NativePointer = imageBrush_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a bitmap brush, the input image is a Direct2D bitmap object.</p>	
        /// </summary>	
        /// <param name="bitmap"><dd>  <p>The bitmap to use as the brush.</p> </dd></param>	
        /// <param name="bitmapBrushProperties"><dd>  <p>The address of the newly created bitmap brush object.</p> </dd></param>	
        /// <param name="brushProperties">No documentation.</param>	
        /// <param name="bitmapBrush"><dd>  <p>The address of the newly created bitmap brush object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::CreateBitmapBrush']/*"/>	
        /// <msdn-id>jj841132</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapBrush([In, Optional] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_BITMAP_BRUSH_PROPERTIES1* bitmapBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1BitmapBrush1** bitmapBrush)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::CreateBitmapBrush</unmanaged-short>	
        internal void CreateBitmapBrush(SharpDX.Direct2D1.Bitmap bitmap, SharpDX.Direct2D1.BitmapBrushProperties1? bitmapBrushProperties, SharpDX.Direct2D1.BrushProperties? brushProperties, SharpDX.Direct2D1.BitmapBrush1 bitmapBrush)
        {
            unsafe
            {
                SharpDX.Direct2D1.BitmapBrushProperties1 bitmapBrushProperties_;
                if (bitmapBrushProperties.HasValue)
                    bitmapBrushProperties_ = bitmapBrushProperties.Value;
                SharpDX.Direct2D1.BrushProperties brushProperties_;
                if (brushProperties.HasValue)
                    brushProperties_ = brushProperties.Value;
                IntPtr bitmapBrush_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((bitmap == null) ? IntPtr.Zero : bitmap.NativePointer), (bitmapBrushProperties.HasValue) ? &bitmapBrushProperties_ : (void*)IntPtr.Zero, (brushProperties.HasValue) ? &brushProperties_ : (void*)IntPtr.Zero, &bitmapBrush_, ((void**)(*(void**)_nativePointer))[66]);
                ((SharpDX.Direct2D1.BitmapBrush1)bitmapBrush).NativePointer = bitmapBrush_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a <strong><see cref="SharpDX.Direct2D1.CommandList"/></strong> object.</p>	
        /// </summary>	
        /// <param name="commandList">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>A <strong><see cref="SharpDX.Direct2D1.CommandList"/></strong> can store Direct2D commands to be displayed later through <strong><see cref="SharpDX.Direct2D1.DeviceContext.DrawImage"/></strong> or through an image brush.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::CreateCommandList']/*"/>	
        /// <msdn-id>hh404494</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateCommandList([Out, Fast] ID2D1CommandList** commandList)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::CreateCommandList</unmanaged-short>	
        internal void CreateCommandList(SharpDX.Direct2D1.CommandList commandList)
        {
            unsafe
            {
                IntPtr commandList_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &commandList_, ((void**)(*(void**)_nativePointer))[67]);
                ((SharpDX.Direct2D1.CommandList)commandList).NativePointer = commandList_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Indicates whether the format is supported by the device context.  The formats supported are usually determined by the underlying hardware.</p>	
        /// </summary>	
        /// <param name="format"><dd>  <p>The DXGI format to check.</p> </dd></param>	
        /// <returns><p>Returns TRUE if the format is supported.  Returns <see cref="SharpDX.Result.False"/> if the format is not supported.</p></returns>	
        /// <remarks>	
        /// <p>You can use supported formats in the <strong><see cref="SharpDX.Direct2D1.PixelFormat"/></strong> structure to create bitmaps and render targets. Direct2D doesn't support all DXGI formats, even though they may have some level of Direct3D support by the hardware.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::IsDxgiFormatSupported']/*"/>	
        /// <msdn-id>hh847982</msdn-id>	
        /// <unmanaged>BOOL ID2D1DeviceContext::IsDxgiFormatSupported([In] DXGI_FORMAT format)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::IsDxgiFormatSupported</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool IsDxgiFormatSupported(SharpDX.DXGI.Format format)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, unchecked((int)format), ((void**)(*(void**)_nativePointer))[68]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Indicates whether the buffer precision is supported by the underlying Direct3D <strong>device.</strong> </p>	
        /// </summary>	
        /// <param name="bufferPrecision">No documentation.</param>	
        /// <returns><p>Returns TRUE if the buffer precision is supported.  Returns <see cref="SharpDX.Result.False"/> if the buffer precision is not supported.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::IsBufferPrecisionSupported']/*"/>	
        /// <msdn-id>dn441541</msdn-id>	
        /// <unmanaged>BOOL ID2D1DeviceContext::IsBufferPrecisionSupported([In] D2D1_BUFFER_PRECISION bufferPrecision)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::IsBufferPrecisionSupported</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool IsBufferPrecisionSupported(SharpDX.Direct2D1.BufferPrecision bufferPrecision)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, unchecked((int)bufferPrecision), ((void**)(*(void**)_nativePointer))[69]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the local bounds of an image.</p>	
        /// </summary>	
        /// <param name="image"><dd>  <p>The image whose bounds will be calculated.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains a reference to the bounds of the image in device independent pixels (DIPs) and in local space.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The image bounds don't include multiplication by the world transform.  They do reflect the current DPI, unit mode, and interpolation mode of the context.  To get the bounds that include the world trasnfrom, use <strong><see cref="SharpDX.Direct2D1.DeviceContext.GetImageWorldBounds"/></strong>. </p><p>The returned bounds reflect which pixels would be impacted by calling <strong>DrawImage</strong> with a target offset of (0,0) and an identity world transform matrix. 	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetImageLocalBounds']/*"/>	
        /// <msdn-id>hh404515</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::GetImageLocalBounds([In] ID2D1Image* image,[Out] D2D_RECT_F* localBounds)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::GetImageLocalBounds</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawRectangleF GetImageLocalBounds(SharpDX.Direct2D1.Image image)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangleF localBounds;
                localBounds = new SharpDX.Mathematics.Interop.RawRectangleF();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((image == null) ? IntPtr.Zero : image.NativePointer), &localBounds, ((void**)(*(void**)_nativePointer))[70]);
                __result__.CheckError();
                return localBounds;
            }
        }

        /// <summary>	
        /// <p>Gets the world bounds of an image.</p>	
        /// </summary>	
        /// <param name="image"><dd>  <p>The image whose bounds will be calculated.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains a reference to the bounds of the image in device independent pixels (DIPs).</p> </dd></returns>	
        /// <remarks>	
        /// <p>The image bounds reflect the current DPI, unit mode, and world transform of the context.  To get bounds which don't include the world transform, use <strong><see cref="SharpDX.Direct2D1.DeviceContext.GetImageLocalBounds"/></strong>. </p><p>The returned bounds reflect which pixels would be impacted by calling <strong>DrawImage</strong> with the same image and a target offset of (0,0).  They do not reflect the current clip rectangle set on the device context or the extent of the context?s current target image.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetImageWorldBounds']/*"/>	
        /// <msdn-id>hh847979</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::GetImageWorldBounds([In] ID2D1Image* image,[Out] D2D_RECT_F* worldBounds)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::GetImageWorldBounds</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawRectangleF GetImageWorldBounds(SharpDX.Direct2D1.Image image)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangleF worldBounds;
                worldBounds = new SharpDX.Mathematics.Interop.RawRectangleF();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((image == null) ? IntPtr.Zero : image.NativePointer), &worldBounds, ((void**)(*(void**)_nativePointer))[71]);
                __result__.CheckError();
                return worldBounds;
            }
        }

        /// <summary>	
        /// <p> Gets the world-space bounds in DIPs of the glyph run using the device context DPI. </p>	
        /// </summary>	
        /// <param name="baselineOrigin"><dd>  <p>The origin of the baseline for the glyph run.</p> </dd></param>	
        /// <param name="glyphRun"><dd>  <p>The glyph run to render.</p> </dd></param>	
        /// <param name="measuringMode"><dd>  <p>The DirectWrite measuring mode that indicates how glyph metrics are used to measure text when it is formatted.</p> </dd></param>	
        /// <returns><dd>  <p>The bounds of the glyph run in DIPs and in world space.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The image bounds reflect the current DPI, unit mode, and world transform of the context. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetGlyphRunWorldBounds']/*"/>	
        /// <msdn-id>hh847978</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::GetGlyphRunWorldBounds([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] DWRITE_MEASURING_MODE measuringMode,[Out] D2D_RECT_F* bounds)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::GetGlyphRunWorldBounds</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawRectangleF GetGlyphRunWorldBounds(SharpDX.Mathematics.Interop.RawVector2 baselineOrigin, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.Direct2D1.MeasuringMode measuringMode)
        {
            unsafe
            {
                var glyphRun_ = new SharpDX.DirectWrite.GlyphRun.__Native();
                glyphRun.__MarshalTo(ref glyphRun_);
                SharpDX.Mathematics.Interop.RawRectangleF bounds;
                bounds = new SharpDX.Mathematics.Interop.RawRectangleF();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint88(_nativePointer, baselineOrigin, &glyphRun_, unchecked((int)measuringMode), &bounds, ((void**)(*(void**)_nativePointer))[72]);
                glyphRun.__MarshalFree(ref glyphRun_);
                __result__.CheckError();
                return bounds;
            }
        }

        /// <summary>	
        /// <p>Gets the device associated with a device context.</p>	
        /// </summary>	
        /// <param name="device"><dd>  <p>When this method returns, contains the address of a reference to a Direct2D device associated with this device context.</p> </dd></param>	
        /// <remarks>	
        /// <p>The application can retrieve the device even if it is created from an earlier render target code-path. The application must use an <strong><see cref="SharpDX.Direct2D1.DeviceContext"/></strong> interface and then call <strong>GetDevice</strong>. Some functionality for controlling all of the resources for a set of device contexts is maintained only on an <strong><see cref="SharpDX.Direct2D1.Device"/></strong> object.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetDevice']/*"/>	
        /// <msdn-id>hh404513</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext::GetDevice([Out] ID2D1Device** device)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct2D1.Device device)
        {
            unsafe
            {
                IntPtr device_ = IntPtr.Zero;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &device_, ((void**)(*(void**)_nativePointer))[73]);
                device = (device_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.Device(device_);
            }
        }

        /// <summary>	
        /// <p>The bitmap or command list to which the Direct2D device context will now render.</p>	
        /// </summary>	
        /// <param name="image">No documentation.</param>	
        /// <remarks>	
        /// <p>The target can be changed at any time, including while the context is drawing.</p><p>The target can be either a bitmap created with the <strong><see cref="SharpDX.Direct2D1.BitmapOptions.Target"/></strong> flag, or it can be a command list. Other kinds of images cannot be set as a target. For example, you cannot set the output of an effect as target. If the target is not valid the context will enter the <strong><see cref="SharpDX.Direct2D1.ResultCode.InvalidTarget"/> </strong>error state.</p><p>You cannot  use <strong>SetTarget</strong> to render to a bitmap/command list from multiple device contexts simultaneously. An image is considered ?being rendered to? if it has ever been set on a device context within a <strong>BeginDraw</strong>/<strong>EndDraw</strong> timespan. If an attempt is made to render to an image through multiple device contexts, all subsequent device contexts after the first will enter an error state. </p><p>Callers wishing to attach an image to a second device context should first call <strong>EndDraw</strong> on the first device context.	
        /// </p><p>Here is an example of the correct calling order.</p><pre>pDC1-&gt;BeginDraw();	
        /// pDC1-&gt;SetTarget(pImage);	
        /// // ?	
        /// pDC1-&gt;EndDraw(); pDC2-&gt;BeginDraw();	
        /// pDC2-&gt;SetTarget(pImage);	
        /// // ?	
        /// pDC2-&gt;EndDraw();	
        /// </pre><p>Here is an example of the incorrect calling order.</p><pre>pDC1-&gt;BeginDraw();	
        /// pDC2-&gt;BeginDraw(); pDC1-&gt;SetTarget(pImage); // ... pDC1-&gt;SetTarget(<c>null</c>); pDC2-&gt;SetTarget(pImage); // This call is invalid, even though pImage is no longer set on pDC1. // ... pDC1-&gt;EndDraw(); // This EndDraw SUCCEEDs.	
        /// pDC2-&gt;EndDraw(); // This EndDraw FAILs </pre><p><strong>Note</strong>??Changing the target does not change the bitmap that an <see cref="System.IntPtr"/> render target presents from, nor does it change the bitmap that a DC render target blts to/from.</p><p>This API makes it easy for an application to use a bitmap as a source (like in <strong>DrawBitmap</strong>) and as a destination at the same time.  Attempting to use a bitmap as a source on the same device context to which it is bound as a target will put the device context into the <see cref="SharpDX.Direct2D1.ResultCode.BitmapBoundAsTarget"/> error state.</p><p>It is acceptable to have a bitmap bound as a target bitmap on multiple render targets at once.  Applications that do this must properly synchronize rendering with <strong>Flush</strong> or <strong>EndDraw</strong>.</p><p>You can change the target at any time, including while the context is drawing.</p><p>You can set the target to <c>null</c>, in which case drawing calls will put the device context into an error state with <see cref="SharpDX.Direct2D1.ResultCode.WrongState"/>.  Calling <strong>SetTarget</strong> with a <c>null</c> target does not restore the original target bitmap to the device context.</p><p>If the device context has an outstanding <see cref="System.IntPtr"/>, the context will enter the <strong><see cref="SharpDX.Direct2D1.ResultCode.WrongState"/></strong> error state.  The target will not be changed.</p><p>If the bitmap and the device context are not in the same resource domain, the context will enter <strong>\</strong> error state.  The target will not be changed.</p><p> <strong><see cref="SharpDX.Direct2D1.RenderTarget.GetPixelSize"/></strong> returns the size of the current target bitmap (or 0, 0) if there is no bitmap bound).	
        /// <strong><see cref="SharpDX.Direct2D1.RenderTarget.GetSize"/></strong> returns the pixel size of the current bitmap scaled by the DPI of the render target.	
        /// <strong>SetTarget</strong> does not affect the DPI of the render target.	
        /// </p><p> <strong><see cref="SharpDX.Direct2D1.RenderTarget.GetPixelFormat"/></strong> returns the pixel format of the current target bitmap (or <strong><see cref="SharpDX.DXGI.Format.Unknown"/></strong>, <strong><see cref="SharpDX.Direct2D1.AlphaMode.Unknown"/></strong> if there is none).</p><p> <strong><see cref="SharpDX.Direct2D1.Bitmap.CopyFromRenderTarget"/></strong> copies from the currently bound target bitmap.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::SetTarget']/*"/>	
        /// <msdn-id>hh404533</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext::SetTarget([In, Optional] ID2D1Image* image)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::SetTarget</unmanaged-short>	
        internal void SetTarget(SharpDX.Direct2D1.Image image)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((image == null) ? IntPtr.Zero : image.NativePointer), ((void**)(*(void**)_nativePointer))[74]);
            }
        }

        /// <summary>	
        /// <p>Gets the target currently associated with the device context.</p>	
        /// </summary>	
        /// <param name="image"><dd>  <p>When this method returns, contains the address of a reference to the target currently associated with the device context.</p> </dd></param>	
        /// <remarks>	
        /// <p>If a target is not associated with the device context, <em>target</em> will contain <strong><c>null</c></strong> when the methods returns.</p><p>If the currently selected target is a bitmap rather than a command list, the application can gain access to the initial bitmaps created by using one of the following methods:</p><ul> <li> <strong>CreateHwndRenderTarget</strong> </li> <li> <strong>CreateDxgiSurfaceRenderTarget</strong> </li> <li> <strong>CreateWicBitmapRenderTarget</strong> </li> <li> <strong>CreateDCRenderTarget</strong> </li> <li> <strong>CreateCompatibleRenderTarget</strong> </li> </ul><p>It is not possible for an application to destroy these bitmaps.  All of these bitmaps are bindable as bitmap targets.  However not all of these bitmaps can be used as bitmap sources for  <strong><see cref="SharpDX.Direct2D1.RenderTarget"/></strong> methods.</p><p> <strong>CreateDxgiSurfaceRenderTarget</strong> will create a bitmap that is usable as a bitmap source if the DXGI surface is bindable as a shader resource view.</p><p> <strong>CreateCompatibleRenderTarget</strong> will always create bitmaps that are usable as a bitmap source.</p><p> <strong><see cref="SharpDX.Direct2D1.RenderTarget.BeginDraw"/></strong> will copy from the <see cref="System.IntPtr"/> to the original bitmap associated with it.  <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> will copy from the original bitmap to the <see cref="System.IntPtr"/>.  </p><p> <strong><see cref="SharpDX.WIC.Bitmap"/></strong> objects will be locked in the following circumstances:</p><ul> <li>BeginDraw has been called and the currently selected target bitmap is a WIC bitmap.</li> <li>A WIC bitmap is set as the target of a device context after BeginDraw has been called and before EndDraw has been called.</li> <li>Any of the ID2D1Bitmap::Copy* methods are called with a WIC bitmap as either the source or destination.</li> </ul><p><see cref="SharpDX.WIC.Bitmap"/> objects will be unlocked in the following circumstances:</p><ul> <li>EndDraw is called and the currently selected target bitmap is a WIC bitmap.</li> <li>A WIC bitmap is removed as the target of a device context between the calls to BeginDraw and EndDraw.</li> <li>Any of the ID2D1Bitmap::Copy* methods are called with a WIC bitmap as either the source or destination.</li> </ul><p>Direct2D will only lock bitmaps that are not currently locked.</p><p>Calling <strong>QueryInterface</strong> for <strong><see cref="SharpDX.Direct2D1.GdiInteropRenderTarget"/></strong> will always succeed.  <strong><see cref="SharpDX.Direct2D1.GdiInteropRenderTarget.GetDC"/></strong> will return a device context corresponding to the currently bound target bitmap.  GetDC will fail if the target bitmap was not created with the GDI_COMPATIBLE flag set.</p><p> <strong><see cref="SharpDX.Direct2D1.WindowRenderTarget.Resize"/></strong> will return <strong><see cref="SharpDX.DXGI.ResultCode.InvalidCall"/></strong> if there are any outstanding references to the original target bitmap associated with the render target.</p><p>Although the target can be a command list, it cannot be any other type of image. It cannot be the output image of an effect.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetTarget']/*"/>	
        /// <msdn-id>hh404523</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext::GetTarget([Out, Optional] ID2D1Image** image)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::GetTarget</unmanaged-short>	
        internal void GetTarget(out SharpDX.Direct2D1.Image image)
        {
            unsafe
            {
                IntPtr image_ = IntPtr.Zero;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &image_, ((void**)(*(void**)_nativePointer))[75]);
                image = (image_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.Image(image_);
            }
        }

        /// <summary>	
        /// <p>Sets the rendering controls for the given device context. </p>	
        /// </summary>	
        /// <param name="renderingControls"><dd>  <p>The rendering controls to be applied.</p> </dd></param>	
        /// <remarks>	
        /// <p> The rendering controls allow the  application to tune the precision, performance, and resource usage of rendering operations.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::SetRenderingControls']/*"/>	
        /// <msdn-id>hh404530</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext::SetRenderingControls([In] const D2D1_RENDERING_CONTROLS* renderingControls)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::SetRenderingControls</unmanaged-short>	
        internal void SetRenderingControls(SharpDX.Direct2D1.RenderingControls renderingControls)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &renderingControls, ((void**)(*(void**)_nativePointer))[76]);
            }
        }

        /// <summary>	
        /// <p>Gets the rendering controls that have been applied to the context.</p>	
        /// </summary>	
        /// <param name="renderingControls"><dd>  <p>When this method returns, contains a reference to the rendering controls for this context.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetRenderingControls']/*"/>	
        /// <msdn-id>hh404519</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext::GetRenderingControls([Out] D2D1_RENDERING_CONTROLS* renderingControls)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::GetRenderingControls</unmanaged-short>	
        internal void GetRenderingControls(out SharpDX.Direct2D1.RenderingControls renderingControls)
        {
            unsafe
            {
                renderingControls = new SharpDX.Direct2D1.RenderingControls();
                fixed (void* renderingControls_ = &renderingControls)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, renderingControls_, ((void**)(*(void**)_nativePointer))[77]);
            }
        }

        /// <summary>	
        /// <p>Changes the primitive blend mode that is used for all rendering operations in the device context.</p>	
        /// </summary>	
        /// <param name="primitiveBlend"><dd>  <p>The primitive blend to use.</p> </dd></param>	
        /// <remarks>	
        /// <p>The primitive blend will apply to all of the primitive drawn on the context, unless this is overridden with the <em>compositeMode</em> parameter on the <strong>DrawImage</strong> API.</p><p> The primitive blend applies to the interior of any primitives drawn on the context. In the case of <strong>DrawImage</strong>, this will be implied by the image rectangle, offset and world transform.</p><p>If the primitive blend is anything other than <strong><see cref="SharpDX.Direct2D1.PrimitiveBlend.SourceOver"/></strong> then ClearType rendering will be turned off. If the application explicitly forces ClearType rendering in these modes, the drawing context will be placed in an error state. <see cref="SharpDX.Direct2D1.ResultCode.WrongState"/> will be returned from either <strong>EndDraw</strong> or <strong>Flush</strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::SetPrimitiveBlend']/*"/>	
        /// <msdn-id>hh404527</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext::SetPrimitiveBlend([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::SetPrimitiveBlend</unmanaged-short>	
        internal void SetPrimitiveBlend(SharpDX.Direct2D1.PrimitiveBlend primitiveBlend)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)primitiveBlend), ((void**)(*(void**)_nativePointer))[78]);
            }
        }

        /// <summary>	
        /// <p>Returns the currently set primitive blend used by the device context.  </p>	
        /// </summary>	
        /// <returns><p>The current primitive blend. The default value is <strong><see cref="SharpDX.Direct2D1.PrimitiveBlend.SourceOver"/></strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetPrimitiveBlend']/*"/>	
        /// <msdn-id>hh404517</msdn-id>	
        /// <unmanaged>D2D1_PRIMITIVE_BLEND ID2D1DeviceContext::GetPrimitiveBlend()</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::GetPrimitiveBlend</unmanaged-short>	
        internal SharpDX.Direct2D1.PrimitiveBlend GetPrimitiveBlend()
        {
            unsafe
            {
                SharpDX.Direct2D1.PrimitiveBlend __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1PrimitiveBlend(_nativePointer, ((void**)(*(void**)_nativePointer))[79]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets what units will be used to interpret values passed into the device context.</p><p></p>	
        /// </summary>	
        /// <param name="unitMode"><dd>  <p>An enumeration defining how passed-in units will be interpreted by the device context.</p> </dd></param>	
        /// <remarks>	
        /// <p>This method will affect all properties and parameters affected by <strong>SetDpi</strong> and <strong>GetDpi</strong>. This affects all coordinates, lengths, and other properties that are not explicitly defined as being in another unit. For example:</p><ul> <li><strong>SetUnitMode</strong> will affect a coordinate passed into <strong>ID2D1DeviceContext::DrawLine</strong>, and the scaling of a geometry passed into <strong>ID2D1DeviceContext::FillGeometry</strong>.</li> <li><strong>SetUnitMode</strong> will not affect the value returned by <strong><see cref="SharpDX.Direct2D1.Bitmap.GetPixelSize"/></strong>, or how the <em>desiredPixelSize</em> parameter is interpreted in <strong>ID2D1DeviceContext::CreateCompatibleBitmap</strong>.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::SetUnitMode']/*"/>	
        /// <msdn-id>hh404539</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext::SetUnitMode([In] D2D1_UNIT_MODE unitMode)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::SetUnitMode</unmanaged-short>	
        internal void SetUnitMode(SharpDX.Direct2D1.UnitMode unitMode)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)unitMode), ((void**)(*(void**)_nativePointer))[80]);
            }
        }

        /// <summary>	
        /// <p>Gets the mode that  is being used to interpret values by the device context.</p>	
        /// </summary>	
        /// <returns><p>The  unit mode.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetUnitMode']/*"/>	
        /// <msdn-id>hh404525</msdn-id>	
        /// <unmanaged>D2D1_UNIT_MODE ID2D1DeviceContext::GetUnitMode()</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::GetUnitMode</unmanaged-short>	
        internal SharpDX.Direct2D1.UnitMode GetUnitMode()
        {
            unsafe
            {
                SharpDX.Direct2D1.UnitMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1UnitMode(_nativePointer, ((void**)(*(void**)_nativePointer))[81]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Draws a series of glyphs to the device context.</p>	
        /// </summary>	
        /// <param name="baselineOrigin"><dd>  <p>Origin of first glyph in the series.</p> </dd></param>	
        /// <param name="glyphRun"><dd>  <p>Glyph information including glyph indices, advances, and offsets.</p> </dd></param>	
        /// <param name="glyphRunDescription"><dd>  <p>Supplementary glyph series information.</p> </dd></param>	
        /// <param name="foregroundBrush"><dd>  <p>The brush that defines the text color.</p> </dd></param>	
        /// <param name="measuringMode"><dd>  <p>The measuring mode of the glyph series, used to determine the advances and offsets. The default value is <see cref="SharpDX.Direct2D1.MeasuringMode.Natural"/>.</p> </dd></param>	
        /// <remarks>	
        /// <p>The <em>glyphRunDescription</em> is ignored when rendering, but can be useful for printing and serialization of rendering commands, such as to an XPS or SVG file. This extends <strong><see cref="SharpDX.Direct2D1.RenderTarget.DrawGlyphRun"/></strong>, which lacked the glyph run description.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::DrawGlyphRun']/*"/>	
        /// <msdn-id>hh404508</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext::DrawGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] ID2D1Brush* foregroundBrush,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::DrawGlyphRun</unmanaged-short>	
        public void DrawGlyphRun(SharpDX.Mathematics.Interop.RawVector2 baselineOrigin, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.DirectWrite.GlyphRunDescription glyphRunDescription, SharpDX.Direct2D1.Brush foregroundBrush, SharpDX.Direct2D1.MeasuringMode measuringMode)
        {
            unsafe
            {
                var glyphRun_ = new SharpDX.DirectWrite.GlyphRun.__Native();
                glyphRun.__MarshalTo(ref glyphRun_);
                var glyphRunDescription_ = new SharpDX.DirectWrite.GlyphRunDescription.__Native();
                if (glyphRunDescription != null)
                    glyphRunDescription.__MarshalTo(ref glyphRunDescription_);
                SharpDX.Direct2D1.LocalInterop.Callivoid91(_nativePointer, baselineOrigin, &glyphRun_, (glyphRunDescription != null) ? &glyphRunDescription_ : (void*)IntPtr.Zero, (void*)((foregroundBrush == null) ? IntPtr.Zero : foregroundBrush.NativePointer), unchecked((int)measuringMode), ((void**)(*(void**)_nativePointer))[82]);
                glyphRun.__MarshalFree(ref glyphRun_);
                if (glyphRunDescription != null)
                    glyphRunDescription.__MarshalFree(ref glyphRunDescription_);
            }
        }

        /// <summary>	
        /// <p>Draws an image to the device context.</p>	
        /// </summary>	
        /// <param name="image"><dd>  <p>The image to be drawn to the device context.</p> </dd></param>	
        /// <param name="targetOffset"><dd>  <p>The  offset in the destination space that the image will be rendered to. The entire logical extent of the image will be rendered to the corresponding destination. If not specified, the destination origin will be (0, 0). The top-left corner of the image will be mapped to the target offset. This will not necessarily be the origin. This default value is <em><c>null</c></em>.</p> </dd></param>	
        /// <param name="imageRectangle"><dd>  <p>The corresponding rectangle in the image space will be mapped to the given origins when processing the image. This default value is <em><c>null</c></em>.</p> </dd></param>	
        /// <param name="interpolationMode"><dd>  <p>The interpolation mode that will be used to scale the image if necessary. The default value is <strong>D2D1_IMAGE_INTERPOLATION_BILINEAR</strong>.</p> </dd></param>	
        /// <param name="compositeMode"><dd>  <p>The composite mode that will be applied to the limits of the currently selected clip. The default value is <strong>D2D1_COMPOSITE_MODE_DEFAULT</strong></p> </dd></param>	
        /// <remarks>	
        /// <p>If <em>interpolationMode</em> is <strong>D2D1_INTERPOLATION_MODE_HIGH_QUALITY</strong>, different scalers will be used depending on the scale factor implied by the world transform.</p><p>Any invalid rectangles accumulated on any effect that is drawn by this call will be discarded regardless of which portion of the image rectangle is drawn.</p><p>If <em>compositeMode</em> is <strong>D2D1_COMPOSITE_MODE_DEFAULT</strong>, <strong>DrawImage</strong> will use the currently selected primitive blend specified by <strong><see cref="SharpDX.Direct2D1.DeviceContext.SetPrimitiveBlend"/></strong>. If <em>compositeMode</em> is not <strong>D2D1_COMPOSITE_MODE_DEFAULT</strong>, the image will be extended to transparent up to the current axis-aligned clip.</p><p>If there is an image rectangle and a world transform, this is equivalent to inserting a clip effect to represent the image rectangle and a 2D affine transform to take into account the world transform.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::DrawImage']/*"/>	
        /// <msdn-id>hh404511</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext::DrawImage([In] ID2D1Image* image,[In, Optional] const D2D_POINT_2F* targetOffset,[In, Optional] const D2D_RECT_F* imageRectangle,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In] D2D1_COMPOSITE_MODE compositeMode)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::DrawImage</unmanaged-short>	
        public void DrawImage(SharpDX.Direct2D1.Image image, SharpDX.Mathematics.Interop.RawVector2? targetOffset, SharpDX.Mathematics.Interop.RawRectangleF? imageRectangle, SharpDX.Direct2D1.InterpolationMode interpolationMode, SharpDX.Direct2D1.CompositeMode compositeMode)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawVector2 targetOffset_;
                if (targetOffset.HasValue)
                    targetOffset_ = targetOffset.Value;
                SharpDX.Mathematics.Interop.RawRectangleF imageRectangle_;
                if (imageRectangle.HasValue)
                    imageRectangle_ = imageRectangle.Value;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((image == null) ? IntPtr.Zero : image.NativePointer), (targetOffset.HasValue) ? &targetOffset_ : (void*)IntPtr.Zero, (imageRectangle.HasValue) ? &imageRectangle_ : (void*)IntPtr.Zero, unchecked((int)interpolationMode), unchecked((int)compositeMode), ((void**)(*(void**)_nativePointer))[83]);
            }
        }

        /// <summary>	
        /// <p>Draw a metafile to the device context.</p>	
        /// </summary>	
        /// <param name="gdiMetafile"><dd>  <p>The metafile to draw.</p> </dd></param>	
        /// <param name="targetOffset"><dd>  <p>The offset from the upper left corner of the render target.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::DrawGdiMetafile']/*"/>	
        /// <msdn-id>jj841147</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_POINT_2F* targetOffset)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::DrawGdiMetafile</unmanaged-short>	
        public void DrawGdiMetafile(SharpDX.Direct2D1.GdiMetafile gdiMetafile, SharpDX.Mathematics.Interop.RawVector2? targetOffset)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawVector2 targetOffset_;
                if (targetOffset.HasValue)
                    targetOffset_ = targetOffset.Value;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((gdiMetafile == null) ? IntPtr.Zero : gdiMetafile.NativePointer), (targetOffset.HasValue) ? &targetOffset_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[84]);
            }
        }

        /// <summary>	
        /// <p>Draws a bitmap to the render target.</p>	
        /// </summary>	
        /// <param name="bitmap"><dd>  <p>The bitmap to draw.</p> </dd></param>	
        /// <param name="destinationRectangle"><dd>  <p>The destination rectangle. The default is the size of the bitmap and the location is the upper left corner of the render target.</p> </dd></param>	
        /// <param name="opacity"><dd>  <p>The opacity of the bitmap.</p> </dd></param>	
        /// <param name="interpolationMode"><dd>  <p>The interpolation mode to use.</p> </dd></param>	
        /// <param name="sourceRectangle"><dd>  <p>An optional source rectangle.</p> </dd></param>	
        /// <param name="erspectiveTransformRef"><dd>  <p>An optional perspective transform.</p> </dd></param>	
        /// <remarks>	
        /// <p>The destinationRectangle parameter defines the rectangle in the target where the bitmap will appear (in device-independent pixels (DIPs)).  This is affected by the currently set transform and the perspective transform, if set.  If <c>null</c> is specified, then the destination rectangle is (left=0, top=0, right = width(sourceRectangle), bottom = height(sourceRectangle)). </p><p>The <em>sourceRectangle</em> parameter defines the sub-rectangle of the source bitmap (in DIPs).  <strong>DrawBitmap</strong> will clip this rectangle to the size of the source bitmap, thus making it impossible to sample outside of the bitmap.  If <c>null</c> is specified, then the source rectangle is taken to be the size of the source bitmap. </p><p>If you specify <em>perspectiveTransform</em> it is applied to the rect in addition to the transform set on the render target.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::DrawBitmap']/*"/>	
        /// <msdn-id>jj841144</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle,[In, Optional] const D2D_MATRIX_4X4_F* perspectiveTransform)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::DrawBitmap</unmanaged-short>	
        public void DrawBitmap(SharpDX.Direct2D1.Bitmap bitmap, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, float opacity, SharpDX.Direct2D1.InterpolationMode interpolationMode, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle, SharpDX.Mathematics.Interop.RawMatrix? erspectiveTransformRef)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
                if (destinationRectangle.HasValue)
                    destinationRectangle_ = destinationRectangle.Value;
                SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
                if (sourceRectangle.HasValue)
                    sourceRectangle_ = sourceRectangle.Value;
                SharpDX.Mathematics.Interop.RawMatrix erspectiveTransformRef_;
                if (erspectiveTransformRef.HasValue)
                    erspectiveTransformRef_ = erspectiveTransformRef.Value;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((bitmap == null) ? IntPtr.Zero : bitmap.NativePointer), (destinationRectangle.HasValue) ? &destinationRectangle_ : (void*)IntPtr.Zero, opacity, unchecked((int)interpolationMode), (sourceRectangle.HasValue) ? &sourceRectangle_ : (void*)IntPtr.Zero, (erspectiveTransformRef.HasValue) ? &erspectiveTransformRef_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[85]);
            }
        }

        /// <summary>	
        /// <p>Push a layer onto the clip and layer stack of the device context.</p>	
        /// </summary>	
        /// <param name="layerParameters"><dd>  <p>The parameters that defines the layer.</p> </dd></param>	
        /// <param name="layer"><dd>  <p>The layer resource to push on the device context that receives subsequent drawing operations. </p> <p><strong>Note</strong>??If a layer is not specified, Direct2D manages the layer resource automatically.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::PushLayer']/*"/>	
        /// <msdn-id>hh847983</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext::PushLayer([In] const D2D1_LAYER_PARAMETERS1* layerParameters,[In, Optional] ID2D1Layer* layer)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::PushLayer</unmanaged-short>	
        public void PushLayer(ref SharpDX.Direct2D1.LayerParameters1 layerParameters, SharpDX.Direct2D1.Layer layer)
        {
            unsafe
            {
                fixed (void* layerParameters_ = &layerParameters)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, layerParameters_, (void*)((layer == null) ? IntPtr.Zero : layer.NativePointer), ((void**)(*(void**)_nativePointer))[86]);
            }
        }

        /// <summary>	
        /// <p>This indicates that a portion of an effect's input is invalid. This method can be called many times.</p><p>You can use this method to propagate invalid rectangles through an effect graph. You can query Direct2D using the <strong>GetEffectInvalidRectangles</strong> method.</p><p><strong>Note</strong>??Direct2D does not automatically use these invalid rectangles to reduce the region of an effect that is rendered.</p><p>You can also use this method to invalidate caches that have accumulated while rendering effects that have the <strong><see cref="SharpDX.Direct2D1.Property.Cached"/></strong> property set to true.</p>	
        /// </summary>	
        /// <param name="effect">No documentation.</param>	
        /// <param name="input">No documentation.</param>	
        /// <param name="inputRectangle">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::InvalidateEffectInputRectangle']/*"/>	
        /// <msdn-id>hh847980</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::InvalidateEffectInputRectangle([In] ID2D1Effect* effect,[In] unsigned int input,[In] const D2D_RECT_F* inputRectangle)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::InvalidateEffectInputRectangle</unmanaged-short>	
        public void InvalidateEffectInputRectangle(SharpDX.Direct2D1.Effect effect, int input, SharpDX.Mathematics.Interop.RawRectangleF inputRectangle)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((effect == null) ? IntPtr.Zero : effect.NativePointer), input, &inputRectangle, ((void**)(*(void**)_nativePointer))[87]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the number of invalid output rectangles that have accumulated on the effect. </p>	
        /// </summary>	
        /// <param name="effect"><dd>  <p>The effect to count the invalid rectangles on.</p> </dd></param>	
        /// <returns><dd>  <p>The returned rectangle count.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetEffectInvalidRectangleCount']/*"/>	
        /// <msdn-id>hh847975</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::GetEffectInvalidRectangleCount([In] ID2D1Effect* effect,[Out] unsigned int* rectangleCount)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::GetEffectInvalidRectangleCount</unmanaged-short>	
        internal int GetEffectInvalidRectangleCount(SharpDX.Direct2D1.Effect effect)
        {
            unsafe
            {
                int rectangleCount;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((effect == null) ? IntPtr.Zero : effect.NativePointer), &rectangleCount, ((void**)(*(void**)_nativePointer))[88]);
                __result__.CheckError();
                return rectangleCount;
            }
        }

        /// <summary>	
        /// <p>Gets the invalid rectangles that have accumulated since the last time the effect was drawn and <strong>EndDraw</strong> was then called on the device context.</p>	
        /// </summary>	
        /// <param name="effect">No documentation.</param>	
        /// <param name="rectangles">No documentation.</param>	
        /// <param name="rectanglesCount">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> </p><p><strong>Note</strong>??Direct2D does not automatically use these invalid rectangles to reduce the region of an effect that is rendered.</p><p>You can use the <strong>InvalidateEffectInputRectangle</strong> method to specify invalidated rectangles for Direct2D to propagate through an effect graph.</p><p>If multiple invalid rectangles are requested, the rectangles that this method returns may overlap. When this is the case, the rectangle count might be lower than the count that <strong>GetEffectInvalidRectangleCount</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetEffectInvalidRectangles']/*"/>	
        /// <msdn-id>hh847976</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::GetEffectInvalidRectangles([In] ID2D1Effect* effect,[Out, Buffer] D2D_RECT_F* rectangles,[In] unsigned int rectanglesCount)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::GetEffectInvalidRectangles</unmanaged-short>	
        internal void GetEffectInvalidRectangles(SharpDX.Direct2D1.Effect effect, SharpDX.Mathematics.Interop.RawRectangleF[] rectangles, int rectanglesCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* rectangles_ = rectangles)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((effect == null) ? IntPtr.Zero : effect.NativePointer), rectangles_, rectanglesCount, ((void**)(*(void**)_nativePointer))[89]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the maximum region of each specified input which would be used during a subsequent rendering operation. This method  returns the rectangles of effect inputs which Direct2D will use for a certain rendering operation.  In cases when the app re-renders the effect inputs to bitmap during each frame, you can use this API  to minimize unnecessary rendering on the part of the app. </p>	
        /// </summary>	
        /// <param name="renderEffect"><dd>  <p>The effect whose output is being rendered.</p> </dd></param>	
        /// <param name="renderImageRectangle"><dd>  <p>This specified the rectangle in local space which will be rendered.</p> </dd></param>	
        /// <param name="inputDescriptions"><dd>  <p> This parameter is  completely optional.  The rectangles in the structure are useful when the app is querying for information about an input which is not yet bound in the effect graph, but will be bound prior to rendering that effect graph.</p> </dd></param>	
        /// <param name="requiredInputRects"><dd>  <p>The returned input rectangles.</p> </dd></param>	
        /// <param name="inputCount"><dd>  <p>The number of required input rectangles.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::GetEffectRequiredInputRectangles']/*"/>	
        /// <msdn-id>hh847977</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext::GetEffectRequiredInputRectangles([In] ID2D1Effect* renderEffect,[In, Optional] const D2D_RECT_F* renderImageRectangle,[In, Buffer] const D2D1_EFFECT_INPUT_DESCRIPTION* inputDescriptions,[Out, Buffer] D2D_RECT_F* requiredInputRects,[In] unsigned int inputCount)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::GetEffectRequiredInputRectangles</unmanaged-short>	
        internal void GetEffectRequiredInputRectangles(SharpDX.Direct2D1.Effect renderEffect, SharpDX.Mathematics.Interop.RawRectangleF? renderImageRectangle, SharpDX.Direct2D1.EffectInputDescription[] inputDescriptions, SharpDX.Mathematics.Interop.RawRectangleF[] requiredInputRects, int inputCount)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangleF renderImageRectangle_;
                if (renderImageRectangle.HasValue)
                    renderImageRectangle_ = renderImageRectangle.Value;
                SharpDX.Direct2D1.EffectInputDescription.__Native[] inputDescriptions__ = new SharpDX.Direct2D1.EffectInputDescription.__Native[inputDescriptions.Length];
                for (int i = 0; i < inputDescriptions.Length; i++)
                    inputDescriptions[i].__MarshalTo(ref inputDescriptions__[i]);
                SharpDX.Result __result__;
                fixed (void* inputDescriptions_ = inputDescriptions__)
                    fixed (void* requiredInputRects_ = requiredInputRects)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((renderEffect == null) ? IntPtr.Zero : renderEffect.NativePointer), (renderImageRectangle.HasValue) ? &renderImageRectangle_ : (void*)IntPtr.Zero, inputDescriptions_, requiredInputRects_, inputCount, ((void**)(*(void**)_nativePointer))[90]);
                for (int i = 0; i < inputDescriptions.Length; i++)
                    inputDescriptions[i].__MarshalFree(ref inputDescriptions__[i]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Fill using the alpha channel of the supplied opacity mask bitmap. The brush opacity will be modulated by the mask. The render target antialiasing mode must be set to aliased.</p>	
        /// </summary>	
        /// <param name="opacityMask"><dd>  <p>The bitmap that acts as the opacity mask</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush to use for filling the primitive.</p> </dd></param>	
        /// <param name="destinationRectangle"><dd>  <p>The destination rectangle to output to in the render target</p> </dd></param>	
        /// <param name="sourceRectangle"><dd>  <p>The source rectangle from the opacity mask bitmap.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext::FillOpacityMask']/*"/>	
        /// <msdn-id>hh847974</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext::FillOpacityMask</unmanaged-short>	
        public void FillOpacityMask(SharpDX.Direct2D1.Bitmap opacityMask, SharpDX.Direct2D1.Brush brush, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
                if (destinationRectangle.HasValue)
                    destinationRectangle_ = destinationRectangle.Value;
                SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
                if (sourceRectangle.HasValue)
                    sourceRectangle_ = sourceRectangle.Value;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((opacityMask == null) ? IntPtr.Zero : opacityMask.NativePointer), (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), (destinationRectangle.HasValue) ? &destinationRectangle_ : (void*)IntPtr.Zero, (sourceRectangle.HasValue) ? &sourceRectangle_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[91]);
            }
        }
    }
    /// <summary>	
    /// <p>Enables creation and drawing of geometry realization objects. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext1']/*"/>	
    /// <msdn-id>dn280461</msdn-id>	
    /// <unmanaged>ID2D1DeviceContext1</unmanaged>	
    /// <unmanaged-short>ID2D1DeviceContext1</unmanaged-short>	
    [Guid("d37f57e4-6908-459f-a199-e72f24f79987")]
    public partial class DeviceContext1 : SharpDX.Direct2D1.DeviceContext
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.DeviceContext1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DeviceContext1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.DeviceContext1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.DeviceContext1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.DeviceContext1(nativePointer);
        }


        /// <summary>	
        /// <p>Creates a device-dependent representation of the fill of the geometry that can be subsequently rendered.</p>	
        /// </summary>	
        /// <param name="geometry"><dd>  <p>The geometry to realize.</p> </dd></param>	
        /// <param name="flatteningTolerance"><dd>  <p>The flattening tolerance to use when converting Beziers to line segments. This parameter shares the same units as the coordinates of the geometry.</p> </dd></param>	
        /// <param name="geometryRealization"><dd>  <p>When this method returns, contains the address of a reference to a new geometry realization object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is used in conjunction with <strong><see cref="SharpDX.Direct2D1.DeviceContext1.DrawGeometryRealization"/></strong>. The <strong>D2D1::ComputeFlatteningTolerance</strong> helper API may be used to determine the proper flattening tolerance.</p><p>If the provided stroke style specifies a stroke transform type other than <strong><see cref="SharpDX.Direct2D1.StrokeTransformType.Normal"/></strong>, then the stroke will be realized assuming the identity transform and a DPI of 96.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext1::CreateFilledGeometryRealization']/*"/>	
        /// <msdn-id>dn280462</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext1::CreateFilledGeometryRealization([In] ID2D1Geometry* geometry,[In] float flatteningTolerance,[Out, Fast] ID2D1GeometryRealization** geometryRealization)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext1::CreateFilledGeometryRealization</unmanaged-short>	
        internal void CreateFilledGeometryRealization(SharpDX.Direct2D1.Geometry geometry, float flatteningTolerance, SharpDX.Direct2D1.GeometryRealization geometryRealization)
        {
            unsafe
            {
                IntPtr geometryRealization_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((geometry == null) ? IntPtr.Zero : geometry.NativePointer), flatteningTolerance, &geometryRealization_, ((void**)(*(void**)_nativePointer))[92]);
                ((SharpDX.Direct2D1.GeometryRealization)geometryRealization).NativePointer = geometryRealization_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a device-dependent representation of the stroke of a geometry that can be subsequently rendered.</p>	
        /// </summary>	
        /// <param name="geometry"><dd>  <p>The geometry to realize.</p> </dd></param>	
        /// <param name="flatteningTolerance"><dd>  <p>The flattening tolerance to use when converting Beziers to line segments. This parameter shares the same units as the coordinates of the geometry.</p> </dd></param>	
        /// <param name="strokeWidth"><dd>  <p>The width of the stroke. This parameter shares the same units as the coordinates of the geometry.</p> </dd></param>	
        /// <param name="strokeStyle"><dd>  <p>The stroke style (optional).</p> </dd></param>	
        /// <param name="geometryRealization"><dd>  <p>When this method returns, contains the address of a reference to a new geometry realization object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method is used in conjunction with <strong><see cref="SharpDX.Direct2D1.DeviceContext1.DrawGeometryRealization"/></strong>. The <strong>D2D1::ComputeFlatteningTolerance</strong> helper API may be used to determine the proper flattening tolerance.</p><p>If the provided stroke style specifies a stroke transform type other than <strong><see cref="SharpDX.Direct2D1.StrokeTransformType.Normal"/></strong>, then the stroke will be realized assuming the identity transform and a DPI of 96.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext1::CreateStrokedGeometryRealization']/*"/>	
        /// <msdn-id>dn280463</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext1::CreateStrokedGeometryRealization([In] ID2D1Geometry* geometry,[In] float flatteningTolerance,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[Out, Fast] ID2D1GeometryRealization** geometryRealization)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext1::CreateStrokedGeometryRealization</unmanaged-short>	
        internal void CreateStrokedGeometryRealization(SharpDX.Direct2D1.Geometry geometry, float flatteningTolerance, float strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle, SharpDX.Direct2D1.GeometryRealization geometryRealization)
        {
            unsafe
            {
                IntPtr geometryRealization_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((geometry == null) ? IntPtr.Zero : geometry.NativePointer), flatteningTolerance, strokeWidth, (void*)((strokeStyle == null) ? IntPtr.Zero : strokeStyle.NativePointer), &geometryRealization_, ((void**)(*(void**)_nativePointer))[93]);
                ((SharpDX.Direct2D1.GeometryRealization)geometryRealization).NativePointer = geometryRealization_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Renders a given geometry realization to the target with the specified brush.</p>	
        /// </summary>	
        /// <param name="geometryRealization"><dd>  <p>The geometry realization to be rendered.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush to render the realization with.</p> </dd></param>	
        /// <remarks>	
        /// <p>This method respects all currently set state (transform, DPI, unit mode, target image, clips, layers); however, artifacts such as faceting may appear when rendering the realizations with a large effective scale (either via the transform or the DPI). Callers should create their realizations with an appropriate flattening tolerance using either <strong>D2D1_DEFAULT_FLATTENING_TOLERANCE</strong> or <strong>ComputeFlatteningTolerance</strong> to compensate for this.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext1::DrawGeometryRealization']/*"/>	
        /// <msdn-id>dn280464</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext1::DrawGeometryRealization([In] ID2D1GeometryRealization* geometryRealization,[In] ID2D1Brush* brush)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext1::DrawGeometryRealization</unmanaged-short>	
        public void DrawGeometryRealization(SharpDX.Direct2D1.GeometryRealization geometryRealization, SharpDX.Direct2D1.Brush brush)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((geometryRealization == null) ? IntPtr.Zero : geometryRealization.NativePointer), (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), ((void**)(*(void**)_nativePointer))[94]);
            }
        }
    }
    /// <summary>	
    /// <p>Represents a set of state and command buffers that are used to render to a target.</p><p>The device context can render to a target bitmap or a command list.	
    /// </p>	
    /// </summary>	
    /// <remarks>	
    /// <p> Any resource created from a device context can be shared with any other resource created from a device context when both contexts are created on the same device. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext2']/*"/>	
    /// <msdn-id>hh404479</msdn-id>	
    /// <unmanaged>ID2D1DeviceContext2</unmanaged>	
    /// <unmanaged-short>ID2D1DeviceContext2</unmanaged-short>	
    [Guid("394ea6a3-0c34-4321-950b-6ca20f0be6c7")]
    public partial class DeviceContext2 : SharpDX.Direct2D1.DeviceContext1
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.DeviceContext2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DeviceContext2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.DeviceContext2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.DeviceContext2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.DeviceContext2(nativePointer);
        }


        /// <summary>	
        /// <p>Creates a new <strong><see cref="SharpDX.Direct2D1.Ink"/></strong> object that starts at the given point.</p>	
        /// </summary>	
        /// <param name="startPoint">No documentation.</param>	
        /// <param name="ink">No documentation.</param>	
        /// <returns><p><see cref="SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref="SharpDX.Result"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext2::CreateInk']/*"/>	
        /// <msdn-id>dn900368</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateInk([In] const D2D1_INK_POINT* startPoint,[Out] ID2D1Ink** ink)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext2::CreateInk</unmanaged-short>	
        public void CreateInk(SharpDX.Direct2D1.InkPoint startPoint, out SharpDX.Direct2D1.Ink ink)
        {
            unsafe
            {
                IntPtr ink_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &startPoint, &ink_, ((void**)(*(void**)_nativePointer))[95]);
                ink = (ink_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.Ink(ink_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a new <strong><see cref="SharpDX.Direct2D1.InkStyle"/></strong> object, for use with ink  rendering methods such as <strong>DrawInk</strong>.</p>	
        /// </summary>	
        /// <param name="inkStyleProperties">No documentation.</param>	
        /// <param name="inkStyle">No documentation.</param>	
        /// <returns><p><see cref="SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref="SharpDX.Result"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext2::CreateInkStyle']/*"/>	
        /// <msdn-id>dn900370</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateInkStyle([In, Optional] const D2D1_INK_STYLE_PROPERTIES* inkStyleProperties,[Out] ID2D1InkStyle** inkStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext2::CreateInkStyle</unmanaged-short>	
        public void CreateInkStyle(SharpDX.Direct2D1.InkStyleProperties? inkStyleProperties, out SharpDX.Direct2D1.InkStyle inkStyle)
        {
            unsafe
            {
                SharpDX.Direct2D1.InkStyleProperties inkStyleProperties_;
                if (inkStyleProperties.HasValue)
                    inkStyleProperties_ = inkStyleProperties.Value;
                IntPtr inkStyle_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (inkStyleProperties.HasValue) ? &inkStyleProperties_ : (void*)IntPtr.Zero, &inkStyle_, ((void**)(*(void**)_nativePointer))[96]);
                inkStyle = (inkStyle_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.InkStyle(inkStyle_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a new <strong><see cref="SharpDX.Direct2D1.GradientMesh"/></strong> instance using the given array of patches.</p>	
        /// </summary>	
        /// <param name="atchesRef">No documentation.</param>	
        /// <param name="patchesCount">No documentation.</param>	
        /// <param name="gradientMesh">No documentation.</param>	
        /// <returns><p><see cref="SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref="SharpDX.Result"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext2::CreateGradientMesh']/*"/>	
        /// <msdn-id>dn890790</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateGradientMesh([In, Buffer] const D2D1_GRADIENT_MESH_PATCH* patches,[In] unsigned int patchesCount,[Out] ID2D1GradientMesh** gradientMesh)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext2::CreateGradientMesh</unmanaged-short>	
        public void CreateGradientMesh(SharpDX.Direct2D1.GradientMeshPatch[] atchesRef, int patchesCount, out SharpDX.Direct2D1.GradientMesh gradientMesh)
        {
            unsafe
            {
                IntPtr gradientMesh_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* atchesRef_ = atchesRef)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, atchesRef_, patchesCount, &gradientMesh_, ((void**)(*(void**)_nativePointer))[97]);
                gradientMesh = (gradientMesh_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.GradientMesh(gradientMesh_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an image source object from a WIC bitmap source, while populating all pixel memory within the image source.   The image is loaded and stored while using a minimal amount of memory.</p>	
        /// </summary>	
        /// <param name="wicBitmapSource"><dd>  <p>The WIC bitmap source to create the image source from.</p> </dd></param>	
        /// <param name="loadingOptions"><dd>  <p>Options for creating the image source.  Default options are used if <c>null</c>.</p> </dd></param>	
        /// <param name="alphaMode"><dd>  <p>The alpha mode of the image; this is determined automatically from the source?s pixel format if <see cref="SharpDX.Direct2D1.AlphaMode.Unknown"/> is passed.</p> </dd></param>	
        /// <param name="imageSource"><dd>  <p>Receives the new image source instance.</p> </dd></param>	
        /// <returns><p><see cref="SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref="SharpDX.Result"/>.</p></returns>	
        /// <remarks>	
        /// <p> This method creates an image source which can be used to draw the image.  </p><p>This method supports images that exceed the maximum texture size.  Large images are internally stored within a sparse tile cache.   </p><p> This API supports the same set of pixel formats and alpha modes supported by <strong>CreateBitmapFromWicBitmap</strong>.   If the GPU does not support a given pixel format, this method will return <see cref="SharpDX.Direct2D1.ResultCode.UnsupportedPixelFormat"/>.  This method does not apply adjustments such as gamma or  alpha premultiplication which affect the appearance of the image. </p><p> The alphaMode parameter must not be set to <see cref="SharpDX.Direct2D1.AlphaMode.Straight"/>.  This method fails if the WIC source uses a  pixel format with straight alpha, unless the alpha mode is overridden by setting the alphaMode parameter to <see cref="SharpDX.Direct2D1.AlphaMode.Premultiplied"/> or <see cref="SharpDX.Direct2D1.AlphaMode.Ignore"/>. </p><p> If the format of the source has an alpha channel, then <see cref="SharpDX.Direct2D1.AlphaMode.Ignore"/> must be passed.   If <see cref="SharpDX.Direct2D1.AlphaMode.Ignore"/> is passed and the format of the source does have an alpha channel, the alpha channel will be ignored. </p><p>This method automatically selects an appropriate storage format to minimize GPU memory usage,  such as using separate luminance and chrominance textures for JPEG images. </p><p>If the loadingOptions argument is <c>null</c>, D2D uses <see cref="SharpDX.Direct2D1.ImageSourceLoadingOptions.None"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext2::CreateImageSourceFromWic']/*"/>	
        /// <msdn-id>dn890792</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateImageSourceFromWic([In] IWICBitmapSource* wicBitmapSource,[In] D2D1_IMAGE_SOURCE_LOADING_OPTIONS loadingOptions,[In] D2D1_ALPHA_MODE alphaMode,[Out] ID2D1ImageSourceFromWic** imageSource)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext2::CreateImageSourceFromWic</unmanaged-short>	
        public void CreateImageSourceFromWic(SharpDX.WIC.BitmapSource wicBitmapSource, SharpDX.Direct2D1.ImageSourceLoadingOptions loadingOptions, SharpDX.Direct2D1.AlphaMode alphaMode, out SharpDX.Direct2D1.ImageSourceFromWic imageSource)
        {
            unsafe
            {
                IntPtr imageSource_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((wicBitmapSource == null) ? IntPtr.Zero : wicBitmapSource.NativePointer), unchecked((int)loadingOptions), unchecked((int)alphaMode), &imageSource_, ((void**)(*(void**)_nativePointer))[98]);
                imageSource = (imageSource_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.ImageSourceFromWic(imageSource_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a 3D lookup table for mapping a 3-channel input to a 3-channel output. The table data must be provided in 4-channel format.</p>	
        /// </summary>	
        /// <param name="precision"><dd>  <p>Precision of the input lookup table data.</p> </dd></param>	
        /// <param name="extents"><dd>  <p>Number of lookup table elements per dimension (X, Y, Z).</p> </dd></param>	
        /// <param name="data"><dd>  <p>Buffer holding the lookup table data.</p> </dd></param>	
        /// <param name="dataCount"><dd>  <p>Size of the lookup table data buffer.</p> </dd></param>	
        /// <param name="strides"><dd>  <p>An array containing two values.  The first value is the size in bytes from one row (X dimension) of LUT data to the next.   The second value is the size in bytes from one LUT data plane (X and Y dimensions) to the next.</p> </dd></param>	
        /// <param name="lookupTable"><dd>  <p>Receives the new lookup table instance.</p> </dd></param>	
        /// <returns><p><see cref="SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref="SharpDX.Result"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext2::CreateLookupTable3D']/*"/>	
        /// <msdn-id>dn900373</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateLookupTable3D([In] D2D1_BUFFER_PRECISION precision,[In, Buffer] const unsigned int* extents,[In, Buffer] const unsigned char* data,[In] unsigned int dataCount,[In, Buffer] const unsigned int* strides,[Out] ID2D1LookupTable3D** lookupTable)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext2::CreateLookupTable3D</unmanaged-short>	
        public void CreateLookupTable3D(SharpDX.Direct2D1.BufferPrecision precision, int[] extents, byte[] data, int dataCount, int[] strides, out SharpDX.Direct2D1.LookupTable3D lookupTable)
        {
            unsafe
            {
                IntPtr lookupTable_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* extents_ = extents)
                    fixed (void* data_ = data)
                        fixed (void* strides_ = strides)
                            __result__ =
                            SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)precision), extents_, data_, dataCount, strides_, &lookupTable_, ((void**)(*(void**)_nativePointer))[99]);
                lookupTable = (lookupTable_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.LookupTable3D(lookupTable_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an image source from a set of DXGI surface(s).  The YCbCr surface(s) are converted to RGBA automatically during subsequent drawing.</p>	
        /// </summary>	
        /// <param name="surfaces"><dd>  <p>The DXGI surfaces to create the image source from.</p> </dd></param>	
        /// <param name="surfaceCount"><dd>  <p>The number of surfaces provided; must be between one and three.</p> </dd></param>	
        /// <param name="colorSpace"><dd>  <p>The color space of the input.</p> </dd></param>	
        /// <param name="options"><dd>  <p>Options controlling color space conversions.</p> </dd></param>	
        /// <param name="imageSource"><dd>  <p>Receives the new image source instance.</p> </dd></param>	
        /// <returns><p><see cref="SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref="SharpDX.Result"/>.</p></returns>	
        /// <remarks>	
        /// <p> This method creates an image source which can be used to draw the image. This method supports surfaces that use a limited set of DXGI formats and DXGI color space types.  Only the below set of combinations of color space types, surface formats, and surface counts are supported: </p><table> <tr><th>Color Space Type</th><th>Surface Count(s)</th><th>Surface Format(s)</th></tr> <tr><td><see cref="SharpDX.DXGI.ColorSpaceType.RgbFullG22NoneP709"/></td><td>1</td><td> Standard D2D-supported pixel formats: <ul> <li><see cref="SharpDX.DXGI.Format.A8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.R8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.R8G8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.R8G8B8A8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.B8G8R8X8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.R8G8B8A8_UNorm_SRgb"/></li> <li><see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm_SRgb"/></li> <li><see cref="SharpDX.DXGI.Format.R16G16B16A16_Float"/></li> <li><see cref="SharpDX.DXGI.Format.R16G16B16A16_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.R32G32B32A32_Float"/></li> <li><see cref="SharpDX.DXGI.Format.BC1_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.BC2_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.BC3_UNorm"/></li> </ul> </td></tr> <tr><td><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrFullG22NoneP709X601"/></td><td>1, 2, 3</td><td> When Surface count is 1: <ul> <li><see cref="SharpDX.DXGI.Format.AYUV"/></li> <li><see cref="SharpDX.DXGI.Format.NV12"/></li> <li><see cref="SharpDX.DXGI.Format.YUY2"/></li> <li><see cref="SharpDX.DXGI.Format.P208"/></li> <li><see cref="SharpDX.DXGI.Format.V208"/></li> <li><see cref="SharpDX.DXGI.Format.V408"/></li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, <see cref="SharpDX.DXGI.Format.R8G8_UNorm"/>}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, <see cref="SharpDX.DXGI.Format.R8_UNorm"/>, <see cref="SharpDX.DXGI.Format.R8_UNorm"/>}</li> </ul> </td></tr> <tr><td> <see cref="SharpDX.DXGI.ColorSpaceType.YcbcrStudioG22LeftP601"/> <p><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrFullG22LeftP601"/></p> <p><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrStudioG22LeftP709"/></p> <p><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrFullG22LeftP709"/></p> <p><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrStudioG22LeftP2020"/></p> <p><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrFullG22LeftP2020"/></p> </td><td>1,2,3</td><td> <p>When Surface count is 1: </p> <ul> <li><see cref="SharpDX.DXGI.Format.NV12"/></li> <li><see cref="SharpDX.DXGI.Format.YUY2"/></li> <li><see cref="SharpDX.DXGI.Format.P208"/></li> <li><see cref="SharpDX.DXGI.Format.V208"/></li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, <see cref="SharpDX.DXGI.Format.R8G8_UNorm"/>}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, <see cref="SharpDX.DXGI.Format.R8_UNorm"/>, <see cref="SharpDX.DXGI.Format.R8_UNorm"/>}</li> </ul> </td></tr> </table><p>?</p><p>The GPU must also have sufficient support for a pixel format to be supported by D2D.  To determine whether D2D supports a format, call IsDxgiFormatSupported.</p><p>This API converts YCbCr formats to sRGB using the provided color space type and options.  RGBA data is assumed to be in the desired space, and D2D does not apply any conversion.</p><p> If multiple surfaces are provided, this method infers whether chroma planes are subsampled (by 2x) from the relative sizes of each corresponding source rectangle (or if the source rectangles parameter is <c>null</c>, the bounds of each surface).  The second and third rectangle must each be equal in size to the first rectangle, or to the first rectangle with one or both dimensions scaled by 0.5 (while rounding up). </p><p> If provided, the source rectangles must be within the bounds of the corresponding surface.  The source rectangles may have different origins. In this case, this method shifts the data from each plane to align with one another. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext2::CreateImageSourceFromDxgi']/*"/>	
        /// <msdn-id>dn890791</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateImageSourceFromDxgi([In, Buffer] IDXGISurface** surfaces,[In] unsigned int surfaceCount,[In] DXGI_COLOR_SPACE_TYPE colorSpace,[In] D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS options,[Out] ID2D1ImageSource** imageSource)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext2::CreateImageSourceFromDxgi</unmanaged-short>	
        public void CreateImageSourceFromDxgi(SharpDX.DXGI.Surface[] surfaces, int surfaceCount, SharpDX.DXGI.ColorSpaceType colorSpace, SharpDX.Direct2D1.ImageSourceFromDxgiOptions options, out SharpDX.Direct2D1.ImageSource imageSource)
        {
            unsafe
            {
                IntPtr* surfaces_ = (IntPtr*)0;
                if (surfaces != null)
                {
                    IntPtr* surfaces__ = stackalloc IntPtr[surfaces.Length];
                    surfaces_ = surfaces__;
                    for (int i = 0; i < surfaces.Length; i++)
                        surfaces_[i] = (surfaces[i] == null) ? IntPtr.Zero : surfaces[i].NativePointer;
                }
                IntPtr imageSource_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, surfaces_, surfaceCount, unchecked((int)colorSpace), unchecked((int)options), &imageSource_, ((void**)(*(void**)_nativePointer))[100]);
                imageSource = (imageSource_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.ImageSource(imageSource_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an image source from a set of DXGI surface(s).  The YCbCr surface(s) are converted to RGBA automatically during subsequent drawing.</p>	
        /// </summary>	
        /// <param name="surfaces"><dd>  <p>The DXGI surfaces to create the image source from.</p> </dd></param>	
        /// <param name="surfaceCount"><dd>  <p>The number of surfaces provided; must be between one and three.</p> </dd></param>	
        /// <param name="colorSpace"><dd>  <p>The color space of the input.</p> </dd></param>	
        /// <param name="options"><dd>  <p>Options controlling color space conversions.</p> </dd></param>	
        /// <param name="imageSource"><dd>  <p>Receives the new image source instance.</p> </dd></param>	
        /// <returns><p><see cref="SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref="SharpDX.Result"/>.</p></returns>	
        /// <remarks>	
        /// <p> This method creates an image source which can be used to draw the image. This method supports surfaces that use a limited set of DXGI formats and DXGI color space types.  Only the below set of combinations of color space types, surface formats, and surface counts are supported: </p><table> <tr><th>Color Space Type</th><th>Surface Count(s)</th><th>Surface Format(s)</th></tr> <tr><td><see cref="SharpDX.DXGI.ColorSpaceType.RgbFullG22NoneP709"/></td><td>1</td><td> Standard D2D-supported pixel formats: <ul> <li><see cref="SharpDX.DXGI.Format.A8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.R8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.R8G8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.R8G8B8A8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.B8G8R8X8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.R8G8B8A8_UNorm_SRgb"/></li> <li><see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm_SRgb"/></li> <li><see cref="SharpDX.DXGI.Format.R16G16B16A16_Float"/></li> <li><see cref="SharpDX.DXGI.Format.R16G16B16A16_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.R32G32B32A32_Float"/></li> <li><see cref="SharpDX.DXGI.Format.BC1_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.BC2_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.BC3_UNorm"/></li> </ul> </td></tr> <tr><td><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrFullG22NoneP709X601"/></td><td>1, 2, 3</td><td> When Surface count is 1: <ul> <li><see cref="SharpDX.DXGI.Format.AYUV"/></li> <li><see cref="SharpDX.DXGI.Format.NV12"/></li> <li><see cref="SharpDX.DXGI.Format.YUY2"/></li> <li><see cref="SharpDX.DXGI.Format.P208"/></li> <li><see cref="SharpDX.DXGI.Format.V208"/></li> <li><see cref="SharpDX.DXGI.Format.V408"/></li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, <see cref="SharpDX.DXGI.Format.R8G8_UNorm"/>}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, <see cref="SharpDX.DXGI.Format.R8_UNorm"/>, <see cref="SharpDX.DXGI.Format.R8_UNorm"/>}</li> </ul> </td></tr> <tr><td> <see cref="SharpDX.DXGI.ColorSpaceType.YcbcrStudioG22LeftP601"/> <p><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrFullG22LeftP601"/></p> <p><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrStudioG22LeftP709"/></p> <p><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrFullG22LeftP709"/></p> <p><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrStudioG22LeftP2020"/></p> <p><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrFullG22LeftP2020"/></p> </td><td>1,2,3</td><td> <p>When Surface count is 1: </p> <ul> <li><see cref="SharpDX.DXGI.Format.NV12"/></li> <li><see cref="SharpDX.DXGI.Format.YUY2"/></li> <li><see cref="SharpDX.DXGI.Format.P208"/></li> <li><see cref="SharpDX.DXGI.Format.V208"/></li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, <see cref="SharpDX.DXGI.Format.R8G8_UNorm"/>}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, <see cref="SharpDX.DXGI.Format.R8_UNorm"/>, <see cref="SharpDX.DXGI.Format.R8_UNorm"/>}</li> </ul> </td></tr> </table><p>?</p><p>The GPU must also have sufficient support for a pixel format to be supported by D2D.  To determine whether D2D supports a format, call IsDxgiFormatSupported.</p><p>This API converts YCbCr formats to sRGB using the provided color space type and options.  RGBA data is assumed to be in the desired space, and D2D does not apply any conversion.</p><p> If multiple surfaces are provided, this method infers whether chroma planes are subsampled (by 2x) from the relative sizes of each corresponding source rectangle (or if the source rectangles parameter is <c>null</c>, the bounds of each surface).  The second and third rectangle must each be equal in size to the first rectangle, or to the first rectangle with one or both dimensions scaled by 0.5 (while rounding up). </p><p> If provided, the source rectangles must be within the bounds of the corresponding surface.  The source rectangles may have different origins. In this case, this method shifts the data from each plane to align with one another. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext2::CreateImageSourceFromDxgi']/*"/>	
        /// <msdn-id>dn890791</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateImageSourceFromDxgi([In, Buffer] IDXGISurface** surfaces,[In] unsigned int surfaceCount,[In] DXGI_COLOR_SPACE_TYPE colorSpace,[In] D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS options,[Out] ID2D1ImageSource** imageSource)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext2::CreateImageSourceFromDxgi</unmanaged-short>	
        public void CreateImageSourceFromDxgi(SharpDX.ComArray<SharpDX.DXGI.Surface> surfaces, int surfaceCount, SharpDX.DXGI.ColorSpaceType colorSpace, SharpDX.Direct2D1.ImageSourceFromDxgiOptions options, out SharpDX.Direct2D1.ImageSource imageSource)
        {
            unsafe
            {
                IntPtr imageSource_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((surfaces == null) ? IntPtr.Zero : surfaces.NativePointer), surfaceCount, unchecked((int)colorSpace), unchecked((int)options), &imageSource_, ((void**)(*(void**)_nativePointer))[100]);
                imageSource = (imageSource_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.ImageSource(imageSource_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an image source from a set of DXGI surface(s).  The YCbCr surface(s) are converted to RGBA automatically during subsequent drawing.</p>	
        /// </summary>	
        /// <param name="surfaces"><dd>  <p>The DXGI surfaces to create the image source from.</p> </dd></param>	
        /// <param name="surfaceCount"><dd>  <p>The number of surfaces provided; must be between one and three.</p> </dd></param>	
        /// <param name="colorSpace"><dd>  <p>The color space of the input.</p> </dd></param>	
        /// <param name="options"><dd>  <p>Options controlling color space conversions.</p> </dd></param>	
        /// <param name="imageSource"><dd>  <p>Receives the new image source instance.</p> </dd></param>	
        /// <returns><p><see cref="SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref="SharpDX.Result"/>.</p></returns>	
        /// <remarks>	
        /// <p> This method creates an image source which can be used to draw the image. This method supports surfaces that use a limited set of DXGI formats and DXGI color space types.  Only the below set of combinations of color space types, surface formats, and surface counts are supported: </p><table> <tr><th>Color Space Type</th><th>Surface Count(s)</th><th>Surface Format(s)</th></tr> <tr><td><see cref="SharpDX.DXGI.ColorSpaceType.RgbFullG22NoneP709"/></td><td>1</td><td> Standard D2D-supported pixel formats: <ul> <li><see cref="SharpDX.DXGI.Format.A8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.R8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.R8G8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.R8G8B8A8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.B8G8R8X8_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.R8G8B8A8_UNorm_SRgb"/></li> <li><see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm_SRgb"/></li> <li><see cref="SharpDX.DXGI.Format.R16G16B16A16_Float"/></li> <li><see cref="SharpDX.DXGI.Format.R16G16B16A16_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.R32G32B32A32_Float"/></li> <li><see cref="SharpDX.DXGI.Format.BC1_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.BC2_UNorm"/></li> <li><see cref="SharpDX.DXGI.Format.BC3_UNorm"/></li> </ul> </td></tr> <tr><td><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrFullG22NoneP709X601"/></td><td>1, 2, 3</td><td> When Surface count is 1: <ul> <li><see cref="SharpDX.DXGI.Format.AYUV"/></li> <li><see cref="SharpDX.DXGI.Format.NV12"/></li> <li><see cref="SharpDX.DXGI.Format.YUY2"/></li> <li><see cref="SharpDX.DXGI.Format.P208"/></li> <li><see cref="SharpDX.DXGI.Format.V208"/></li> <li><see cref="SharpDX.DXGI.Format.V408"/></li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, <see cref="SharpDX.DXGI.Format.R8G8_UNorm"/>}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, <see cref="SharpDX.DXGI.Format.R8_UNorm"/>, <see cref="SharpDX.DXGI.Format.R8_UNorm"/>}</li> </ul> </td></tr> <tr><td> <see cref="SharpDX.DXGI.ColorSpaceType.YcbcrStudioG22LeftP601"/> <p><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrFullG22LeftP601"/></p> <p><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrStudioG22LeftP709"/></p> <p><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrFullG22LeftP709"/></p> <p><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrStudioG22LeftP2020"/></p> <p><see cref="SharpDX.DXGI.ColorSpaceType.YcbcrFullG22LeftP2020"/></p> </td><td>1,2,3</td><td> <p>When Surface count is 1: </p> <ul> <li><see cref="SharpDX.DXGI.Format.NV12"/></li> <li><see cref="SharpDX.DXGI.Format.YUY2"/></li> <li><see cref="SharpDX.DXGI.Format.P208"/></li> <li><see cref="SharpDX.DXGI.Format.V208"/></li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, <see cref="SharpDX.DXGI.Format.R8G8_UNorm"/>}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, <see cref="SharpDX.DXGI.Format.R8_UNorm"/>, <see cref="SharpDX.DXGI.Format.R8_UNorm"/>}</li> </ul> </td></tr> </table><p>?</p><p>The GPU must also have sufficient support for a pixel format to be supported by D2D.  To determine whether D2D supports a format, call IsDxgiFormatSupported.</p><p>This API converts YCbCr formats to sRGB using the provided color space type and options.  RGBA data is assumed to be in the desired space, and D2D does not apply any conversion.</p><p> If multiple surfaces are provided, this method infers whether chroma planes are subsampled (by 2x) from the relative sizes of each corresponding source rectangle (or if the source rectangles parameter is <c>null</c>, the bounds of each surface).  The second and third rectangle must each be equal in size to the first rectangle, or to the first rectangle with one or both dimensions scaled by 0.5 (while rounding up). </p><p> If provided, the source rectangles must be within the bounds of the corresponding surface.  The source rectangles may have different origins. In this case, this method shifts the data from each plane to align with one another. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext2::CreateImageSourceFromDxgi']/*"/>	
        /// <msdn-id>dn890791</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateImageSourceFromDxgi([In, Buffer] IDXGISurface** surfaces,[In] unsigned int surfaceCount,[In] DXGI_COLOR_SPACE_TYPE colorSpace,[In] D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS options,[Out] ID2D1ImageSource** imageSource)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext2::CreateImageSourceFromDxgi</unmanaged-short>	
        private void CreateImageSourceFromDxgi(System.IntPtr surfaces, int surfaceCount, SharpDX.DXGI.ColorSpaceType colorSpace, SharpDX.Direct2D1.ImageSourceFromDxgiOptions options, System.IntPtr imageSource)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)surfaces, surfaceCount, unchecked((int)colorSpace), unchecked((int)options), (void*)imageSource, ((void**)(*(void**)_nativePointer))[100]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Returns the world bounds of a given gradient mesh.</p>	
        /// </summary>	
        /// <param name="gradientMesh"><dd>  <p>The gradient mesh whose world bounds will be calculated.</p> </dd></param>	
        /// <param name="boundsRef"><dd>  <p>When this method returns, contains a reference to the bounds of the gradient mesh, in device independent pixels (DIPs).</p> </dd></param>	
        /// <returns><p><see cref="SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref="SharpDX.Result"/>.</p></returns>	
        /// <remarks>	
        /// <p>The world bounds reflect the current DPI, unit mode, and world transform of the context. They indicate which pixels would be impacted by calling DrawGradientMesh with the given gradient mesh. 	
        /// They do not reflect the current clip rectangle set on the device context or the extent of the context?s current target.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext2::GetGradientMeshWorldBounds']/*"/>	
        /// <msdn-id>dn900380</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext2::GetGradientMeshWorldBounds([In] ID2D1GradientMesh* gradientMesh,[Out] D2D_RECT_F* pBounds)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext2::GetGradientMeshWorldBounds</unmanaged-short>	
        public void GetGradientMeshWorldBounds(SharpDX.Direct2D1.GradientMesh gradientMesh, out SharpDX.Mathematics.Interop.RawRectangleF boundsRef)
        {
            unsafe
            {
                boundsRef = new SharpDX.Mathematics.Interop.RawRectangleF();
                SharpDX.Result __result__;
                fixed (void* boundsRef_ = &boundsRef)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((gradientMesh == null) ? IntPtr.Zero : gradientMesh.NativePointer), boundsRef_, ((void**)(*(void**)_nativePointer))[101]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Renders the given ink object using the given brush and ink style.</p>	
        /// </summary>	
        /// <param name="ink"><dd>  <p>The ink object to be rendered.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush with which to render the ink object.</p> </dd></param>	
        /// <param name="inkStyle"><dd>  <p>The ink style to use when rendering the ink object.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext2::DrawInk']/*"/>	
        /// <msdn-id>dn900379</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext2::DrawInk([In] ID2D1Ink* ink,[In] ID2D1Brush* brush,[In, Optional] ID2D1InkStyle* inkStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext2::DrawInk</unmanaged-short>	
        public void DrawInk(SharpDX.Direct2D1.Ink ink, SharpDX.Direct2D1.Brush brush, SharpDX.Direct2D1.InkStyle inkStyle)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((ink == null) ? IntPtr.Zero : ink.NativePointer), (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), (void*)((inkStyle == null) ? IntPtr.Zero : inkStyle.NativePointer), ((void**)(*(void**)_nativePointer))[102]);
            }
        }

        /// <summary>	
        /// <p>Renders a given gradient mesh to the target.</p>	
        /// </summary>	
        /// <param name="gradientMesh"><dd>  <p>The gradient mesh to be rendered.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext2::DrawGradientMesh']/*"/>	
        /// <msdn-id>dn900378</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext2::DrawGradientMesh([In] ID2D1GradientMesh* gradientMesh)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext2::DrawGradientMesh</unmanaged-short>	
        public void DrawGradientMesh(SharpDX.Direct2D1.GradientMesh gradientMesh)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((gradientMesh == null) ? IntPtr.Zero : gradientMesh.NativePointer), ((void**)(*(void**)_nativePointer))[103]);
            }
        }

        /// <summary>	
        /// <p>Draws a metafile to the device context using the given source and destination rectangles.</p>	
        /// </summary>	
        /// <param name="gdiMetafile"><dd>  <p>The metafile to draw.</p> </dd></param>	
        /// <param name="destinationRectangle"><dd>  <p>The rectangle in the target where the metafile will be drawn, relative to the upper left corner (defined in DIPs) of the render target.  If <c>null</c> is specified, the destination rectangle is {0, 0, w, h}, where w and h are the width and height of the metafile as reported by  <strong><see cref="SharpDX.Direct2D1.GdiMetafile.GetBounds"/></strong>. </p> </dd></param>	
        /// <param name="sourceRectangle"><dd>  <p>The rectangle of the source metafile that will be drawn, relative to the upper left corner (defined in DIPs) of the metafile.  If <c>null</c> is specified, the source rectangle is the value returned by <strong><see cref="SharpDX.Direct2D1.GdiMetafile1.GetSourceBounds"/></strong>.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext2::DrawGdiMetafile']/*"/>	
        /// <msdn-id>dn900374</msdn-id>	
        /// <unmanaged>void ID2D1DeviceContext2::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext2::DrawGdiMetafile</unmanaged-short>	
        public void DrawGdiMetafile(SharpDX.Direct2D1.GdiMetafile gdiMetafile, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
                if (destinationRectangle.HasValue)
                    destinationRectangle_ = destinationRectangle.Value;
                SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
                if (sourceRectangle.HasValue)
                    sourceRectangle_ = sourceRectangle.Value;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((gdiMetafile == null) ? IntPtr.Zero : gdiMetafile.NativePointer), (destinationRectangle.HasValue) ? &destinationRectangle_ : (void*)IntPtr.Zero, (sourceRectangle.HasValue) ? &sourceRectangle_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[104]);
            }
        }

        /// <summary>	
        /// <p>Creates an image source which shares resources with an original.</p>	
        /// </summary>	
        /// <param name="imageSource"><dd>  <p>The original image.</p> </dd></param>	
        /// <param name="ropertiesRef"><dd>  <p>Properties for the source image.</p> </dd></param>	
        /// <param name="transformedImageSource"><dd>  <p>Receives the new image source.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DeviceContext2::CreateTransformedImageSource']/*"/>	
        /// <msdn-id>dn934381</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateTransformedImageSource([In] ID2D1ImageSource* imageSource,[In] const D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES* properties,[Out] ID2D1TransformedImageSource** transformedImageSource)</unmanaged>	
        /// <unmanaged-short>ID2D1DeviceContext2::CreateTransformedImageSource</unmanaged-short>	
        public void CreateTransformedImageSource(SharpDX.Direct2D1.ImageSource imageSource, ref SharpDX.Direct2D1.TransformedImageSourceProperties ropertiesRef, out SharpDX.Direct2D1.TransformedImageSource transformedImageSource)
        {
            unsafe
            {
                IntPtr transformedImageSource_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* ropertiesRef_ = &ropertiesRef)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((imageSource == null) ? IntPtr.Zero : imageSource.NativePointer), ropertiesRef_, &transformedImageSource_, ((void**)(*(void**)_nativePointer))[105]);
                transformedImageSource = (transformedImageSource_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.TransformedImageSource(transformedImageSource_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Issues drawing commands to a GDI device context. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DCRenderTarget']/*"/>	
    /// <msdn-id>dd371213</msdn-id>	
    /// <unmanaged>ID2D1DCRenderTarget</unmanaged>	
    /// <unmanaged-short>ID2D1DCRenderTarget</unmanaged-short>	
    [Guid("1c51bc64-de61-46fd-9899-63a5d8f03950")]
    public partial class DeviceContextRenderTarget : SharpDX.Direct2D1.RenderTarget
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.DeviceContextRenderTarget"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DeviceContextRenderTarget(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.DeviceContextRenderTarget"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.DeviceContextRenderTarget(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.DeviceContextRenderTarget(nativePointer);
        }


        /// <summary>	
        /// <p> Binds the render target to the device context to which it issues drawing commands.</p>	
        /// </summary>	
        /// <param name="hDC"><dd>  <p>The device context to which the render target issues drawing commands.</p> </dd></param>	
        /// <param name="subRectRef"><dd>  <p>The dimensions of the handle to a device context (<see cref="System.IntPtr"/>) to which the render target is bound. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Before you can render with the DC render target, you must use its <strong>BindDC</strong> method to associate it with a GDI DC.  You do this each time you  use a different DC, or the size of the area you want to draw to changes.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DCRenderTarget::BindDC']/*"/>	
        /// <msdn-id>dd371214</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DCRenderTarget::BindDC([In] const HDC hDC,[In] const RECT* pSubRect)</unmanaged>	
        /// <unmanaged-short>ID2D1DCRenderTarget::BindDC</unmanaged-short>	
        public void BindDeviceContext(System.IntPtr hDC, SharpDX.Mathematics.Interop.RawRectangle subRectRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)hDC, &subRectRef, ((void**)(*(void**)_nativePointer))[57]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>This interface is used to describe a GPU rendering pass on a vertex or pixel shader. It is passed to <strong><see cref="SharpDX.Direct2D1.DrawTransform"/></strong>.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawInfo']/*"/>	
    /// <msdn-id>hh847986</msdn-id>	
    /// <unmanaged>ID2D1DrawInfo</unmanaged>	
    /// <unmanaged-short>ID2D1DrawInfo</unmanaged-short>	
    [Guid("693ce632-7f2f-45de-93fe-18d88b37aa21")]
    public partial class DrawInformation : SharpDX.Direct2D1.RenderInformation
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.DrawInformation"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DrawInformation(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.DrawInformation"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.DrawInformation(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.DrawInformation(nativePointer);
        }


        /// <summary>	
        /// <p>Sets the constant buffer for this transform's pixel shader.</p>	
        /// </summary>	
        /// <param name="buffer"><dd>  <p>The data applied to the constant buffer.</p> </dd></param>	
        /// <param name="bufferCount"><dd>  <p>The number of bytes of data in the constant buffer</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawInfo::SetPixelShaderConstantBuffer']/*"/>	
        /// <msdn-id>hh847988</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DrawInfo::SetPixelShaderConstantBuffer([In, Buffer] const void* buffer,[In] unsigned int bufferCount)</unmanaged>	
        /// <unmanaged-short>ID2D1DrawInfo::SetPixelShaderConstantBuffer</unmanaged-short>	
        internal void SetPixelShaderConstantBuffer(System.IntPtr buffer, int bufferCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)buffer, bufferCount, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the resource texture corresponding to the given shader texture index.</p>	
        /// </summary>	
        /// <param name="textureIndex"><dd>  <p>The index of the texture to be bound to the pixel shader.</p> </dd></param>	
        /// <param name="resourceTexture"><dd>  <p>The created resource texture.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawInfo::SetResourceTexture']/*"/>	
        /// <msdn-id>hh847989</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DrawInfo::SetResourceTexture([In] unsigned int textureIndex,[In] ID2D1ResourceTexture* resourceTexture)</unmanaged>	
        /// <unmanaged-short>ID2D1DrawInfo::SetResourceTexture</unmanaged-short>	
        public void SetResourceTexture(int textureIndex, SharpDX.Direct2D1.ResourceTexture resourceTexture)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, textureIndex, (void*)((resourceTexture == null) ? IntPtr.Zero : resourceTexture.NativePointer), ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the constant buffer for this transform's vertex shader.</p>	
        /// </summary>	
        /// <param name="buffer"><dd>  <p>The data applied to the constant buffer</p> </dd></param>	
        /// <param name="bufferCount"><dd>  <p>The number of bytes of data in the constant buffer.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawInfo::SetVertexShaderConstantBuffer']/*"/>	
        /// <msdn-id>hh847991</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DrawInfo::SetVertexShaderConstantBuffer([In, Buffer] const void* buffer,[In] unsigned int bufferCount)</unmanaged>	
        /// <unmanaged-short>ID2D1DrawInfo::SetVertexShaderConstantBuffer</unmanaged-short>	
        internal void SetVertexShaderConstantBuffer(System.IntPtr buffer, int bufferCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)buffer, bufferCount, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Set the shader instructions for this transform.</p>	
        /// </summary>	
        /// <param name="shaderId"><dd>  <p>The resource id for the  shader.</p> </dd></param>	
        /// <param name="pixelOptions"><dd>  <p>Additional information provided to the renderer to indicate the operations the pixel shader does.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> If this call fails, the corresponding <strong><see cref="SharpDX.Direct2D1.Effect"/></strong> instance is placed into an error state and will fail to Draw, it will place the context into an error state which can be retrieved through the <strong>ID2D1DeviceContext::EndDraw</strong> call. </p><p>Specifying <em>pixelOptions</em> other than <see cref="SharpDX.Direct2D1.PixelOptions.None"/> can enable the renderer to perform certain optimizations such as combining various parts of the effect graph together. If this information does not accurately describe the shader, indeterminate rendering artifacts can result.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawInfo::SetPixelShader']/*"/>	
        /// <msdn-id>hh847987</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DrawInfo::SetPixelShader([In] const GUID&amp; shaderId,[In] D2D1_PIXEL_OPTIONS pixelOptions)</unmanaged>	
        /// <unmanaged-short>ID2D1DrawInfo::SetPixelShader</unmanaged-short>	
        public void SetPixelShader(System.Guid shaderId, SharpDX.Direct2D1.PixelOptions pixelOptions)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &shaderId, unchecked((int)pixelOptions), ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets a vertex buffer, a corresponding vertex shader, and options to control how the vertices are to be handled by the Direct2D context.</p>	
        /// </summary>	
        /// <param name="vertexBuffer"><dd>  <p>The vertex buffer, if this is cleared, the default vertex shader and mapping to the transform rectangles will be used.</p> </dd></param>	
        /// <param name="vertexOptions"><dd>  <p>Options that influence how the renderer will interact with the vertex shader.</p> </dd></param>	
        /// <param name="blendDescription"><dd>  <p>How the vertices will be blended with the output texture.</p> </dd></param>	
        /// <param name="vertexRange"><dd>  <p>The set of vertices to use from the buffer.</p> </dd></param>	
        /// <param name="vertexShader"><dd>  <p>The <see cref="System.Guid"/> of the vertex shader.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The vertex shaders associated with the vertex buffer through the vertex shader <see cref="System.Guid"/> must have been loaded through the <strong><see cref="SharpDX.Direct2D1.EffectContext.LoadVertexShader"/></strong> method before this call is made.</p><p>If you pass the vertex option <strong><see cref="SharpDX.Direct2D1.VertexOptions.DoNotClear"/></strong>, then the method fails unless the blend description is exactly this: </p><pre><see cref="SharpDX.Direct2D1.BlendDescription"/> blendDesc =  { <see cref="SharpDX.Direct2D1.Blend.One"/>, <see cref="SharpDX.Direct2D1.Blend.Zero"/>, <see cref="SharpDX.Direct2D1.BlendOperation.Add"/>, <see cref="SharpDX.Direct2D1.Blend.One"/>, <see cref="SharpDX.Direct2D1.Blend.Zero"/>, <see cref="SharpDX.Direct2D1.BlendOperation.Add"/>, { 1.0f, 1.0f, 1.0f, 1.0f } };</pre><p>If this call fails, the corresponding <strong><see cref="SharpDX.Direct2D1.Effect"/></strong> instance is placed into an error state and fails to draw.</p><p> If blendDescription is <c>null</c>, a foreground-over blend mode is used.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawInfo::SetVertexProcessing']/*"/>	
        /// <msdn-id>hh847990</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DrawInfo::SetVertexProcessing([In, Optional] ID2D1VertexBuffer* vertexBuffer,[In] D2D1_VERTEX_OPTIONS vertexOptions,[In, Optional] const D2D1_BLEND_DESCRIPTION* blendDescription,[In, Optional] const D2D1_VERTEX_RANGE* vertexRange,[In, Optional] const GUID* vertexShader)</unmanaged>	
        /// <unmanaged-short>ID2D1DrawInfo::SetVertexProcessing</unmanaged-short>	
        public void SetVertexProcessing(SharpDX.Direct2D1.VertexBuffer vertexBuffer, SharpDX.Direct2D1.VertexOptions vertexOptions, SharpDX.Direct2D1.BlendDescription? blendDescription = null, SharpDX.Direct2D1.VertexRange? vertexRange = null, System.Guid? vertexShader = null)
        {
            unsafe
            {
                SharpDX.Direct2D1.BlendDescription blendDescription_;
                if (blendDescription.HasValue)
                    blendDescription_ = blendDescription.Value;
                SharpDX.Direct2D1.VertexRange vertexRange_;
                if (vertexRange.HasValue)
                    vertexRange_ = vertexRange.Value;
                System.Guid vertexShader_;
                if (vertexShader.HasValue)
                    vertexShader_ = vertexShader.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((vertexBuffer == null) ? IntPtr.Zero : vertexBuffer.NativePointer), unchecked((int)vertexOptions), (blendDescription.HasValue) ? &blendDescription_ : (void*)IntPtr.Zero, (vertexRange.HasValue) ? &vertexRange_ : (void*)IntPtr.Zero, (vertexShader.HasValue) ? &vertexShader_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents the drawing state of a render target: the antialiasing mode, transform, tags, and text-rendering options. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawingStateBlock']/*"/>	
    /// <msdn-id>dd371218</msdn-id>	
    /// <unmanaged>ID2D1DrawingStateBlock</unmanaged>	
    /// <unmanaged-short>ID2D1DrawingStateBlock</unmanaged-short>	
    [Guid("28506e39-ebf6-46a1-bb47-fd85565ab957")]
    public partial class DrawingStateBlock : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.DrawingStateBlock"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DrawingStateBlock(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.DrawingStateBlock"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.DrawingStateBlock(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.DrawingStateBlock(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves or sets the antialiasing mode, transform, and tags portion of the drawing state.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawingStateBlock::GetDescription']/*"/>	
        /// <msdn-id>dd371223</msdn-id>	
        /// <unmanaged>GetDescription / SetDescription</unmanaged>	
        /// <unmanaged-short>GetDescription</unmanaged-short>	
        /// <unmanaged>void ID2D1DrawingStateBlock::GetDescription([Out] D2D1_DRAWING_STATE_DESCRIPTION* stateDescription)</unmanaged>
        public SharpDX.Direct2D1.DrawingStateDescription Description
        {
            get { SharpDX.Direct2D1.DrawingStateDescription __output__; GetDescription(out __output__); return __output__; }
            set { SetDescription(ref value); }
        }

        /// <summary>	
        /// <p>Retrieves or sets the text-rendering configuration of the drawing state.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawingStateBlock::GetTextRenderingParams']/*"/>	
        /// <msdn-id>dd371227</msdn-id>	
        /// <unmanaged>GetTextRenderingParams / SetTextRenderingParams</unmanaged>	
        /// <unmanaged-short>GetTextRenderingParams</unmanaged-short>	
        /// <unmanaged>void ID2D1DrawingStateBlock::GetTextRenderingParams([Out, Optional] IDWriteRenderingParams** textRenderingParams)</unmanaged>
        public SharpDX.DirectWrite.RenderingParams TextRenderingParams
        {
            get { SharpDX.DirectWrite.RenderingParams __output__; GetTextRenderingParams(out __output__); return __output__; }
            set { SetTextRenderingParams(value); }
        }

        /// <summary>	
        /// <p>Retrieves the antialiasing mode, transform, and tags portion of the drawing state.</p>	
        /// </summary>	
        /// <param name="stateDescription"><dd>  <p>When this method returns, contains the antialiasing mode, transform, and tags portion of the drawing state. You must allocate storage for this parameter.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawingStateBlock::GetDescription']/*"/>	
        /// <msdn-id>dd371223</msdn-id>	
        /// <unmanaged>void ID2D1DrawingStateBlock::GetDescription([Out] D2D1_DRAWING_STATE_DESCRIPTION* stateDescription)</unmanaged>	
        /// <unmanaged-short>ID2D1DrawingStateBlock::GetDescription</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct2D1.DrawingStateDescription stateDescription)
        {
            unsafe
            {
                stateDescription = new SharpDX.Direct2D1.DrawingStateDescription();
                fixed (void* stateDescription_ = &stateDescription)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, stateDescription_, ((void**)(*(void**)_nativePointer))[4]);
            }
        }

        /// <summary>	
        /// <p>Specifies the antialiasing mode, transform, and tags portion of the drawing state.</p>	
        /// </summary>	
        /// <param name="stateDescription"><dd>  <p>The antialiasing mode, transform, and tags portion of the drawing state.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawingStateBlock::SetDescription']/*"/>	
        /// <msdn-id>dd371231</msdn-id>	
        /// <unmanaged>void ID2D1DrawingStateBlock::SetDescription([In] const D2D1_DRAWING_STATE_DESCRIPTION* stateDescription)</unmanaged>	
        /// <unmanaged-short>ID2D1DrawingStateBlock::SetDescription</unmanaged-short>	
        internal void SetDescription(ref SharpDX.Direct2D1.DrawingStateDescription stateDescription)
        {
            unsafe
            {
                fixed (void* stateDescription_ = &stateDescription)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, stateDescription_, ((void**)(*(void**)_nativePointer))[5]);
            }
        }

        /// <summary>	
        /// <p>Specifies the text-rendering configuration of the drawing state.</p>	
        /// </summary>	
        /// <param name="textRenderingParams"><dd>  <p>The text-rendering configuration of the drawing state, or <c>null</c> to use default settings.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawingStateBlock::SetTextRenderingParams']/*"/>	
        /// <msdn-id>dd371237</msdn-id>	
        /// <unmanaged>void ID2D1DrawingStateBlock::SetTextRenderingParams([In, Optional] IDWriteRenderingParams* textRenderingParams)</unmanaged>	
        /// <unmanaged-short>ID2D1DrawingStateBlock::SetTextRenderingParams</unmanaged-short>	
        internal void SetTextRenderingParams(SharpDX.DirectWrite.RenderingParams textRenderingParams)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((textRenderingParams == null) ? IntPtr.Zero : textRenderingParams.NativePointer), ((void**)(*(void**)_nativePointer))[6]);
            }
        }

        /// <summary>	
        /// <p>Retrieves the text-rendering configuration of the drawing state.</p>	
        /// </summary>	
        /// <param name="textRenderingParams"><dd>  <p>When this method returns, contains the address of a reference to an <strong><see cref="SharpDX.DirectWrite.RenderingParams"/></strong> object that describes the text-rendering configuration of the drawing state.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawingStateBlock::GetTextRenderingParams']/*"/>	
        /// <msdn-id>dd371227</msdn-id>	
        /// <unmanaged>void ID2D1DrawingStateBlock::GetTextRenderingParams([Out, Optional] IDWriteRenderingParams** textRenderingParams)</unmanaged>	
        /// <unmanaged-short>ID2D1DrawingStateBlock::GetTextRenderingParams</unmanaged-short>	
        internal void GetTextRenderingParams(out SharpDX.DirectWrite.RenderingParams textRenderingParams)
        {
            unsafe
            {
                IntPtr textRenderingParams_ = IntPtr.Zero;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &textRenderingParams_, ((void**)(*(void**)_nativePointer))[7]);
                textRenderingParams = (textRenderingParams_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.RenderingParams(textRenderingParams_);
            }
        }
    }
    /// <summary>	
    /// <p>Implementation of a drawing state block that adds the functionality of primitive blend in addition to already existing antialias mode, transform, tags and text rendering mode.</p><p><strong>Note</strong>??You can get an <strong><see cref="SharpDX.Direct2D1.DrawingStateBlock1"/></strong> using the  <strong><see cref="SharpDX.Direct2D1.Factory.CreateDrawingStateBlock"/></strong> method or you can use the QueryInterface method on an <strong><see cref="SharpDX.Direct2D1.DrawingStateBlock"/></strong> object.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawingStateBlock1']/*"/>	
    /// <msdn-id>hh871452</msdn-id>	
    /// <unmanaged>ID2D1DrawingStateBlock1</unmanaged>	
    /// <unmanaged-short>ID2D1DrawingStateBlock1</unmanaged-short>	
    [Guid("689f1f85-c72e-4e33-8f19-85754efd5ace")]
    public partial class DrawingStateBlock1 : SharpDX.Direct2D1.DrawingStateBlock
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.DrawingStateBlock1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DrawingStateBlock1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.DrawingStateBlock1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.DrawingStateBlock1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.DrawingStateBlock1(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawingStateBlock1::GetDescription']/*"/>	
        /// <unmanaged>GetDescription / SetDescription</unmanaged>	
        /// <unmanaged-short>GetDescription</unmanaged-short>	
        /// <unmanaged>void ID2D1DrawingStateBlock1::GetDescription([Out] D2D1_DRAWING_STATE_DESCRIPTION1* stateDescription)</unmanaged>
        public new SharpDX.Direct2D1.DrawingStateDescription1 Description
        {
            get { SharpDX.Direct2D1.DrawingStateDescription1 __output__; GetDescription(out __output__); return __output__; }
            set { SetDescription(ref value); }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="stateDescription">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawingStateBlock1::GetDescription']/*"/>	
        /// <unmanaged>void ID2D1DrawingStateBlock1::GetDescription([Out] D2D1_DRAWING_STATE_DESCRIPTION1* stateDescription)</unmanaged>	
        /// <unmanaged-short>ID2D1DrawingStateBlock1::GetDescription</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct2D1.DrawingStateDescription1 stateDescription)
        {
            unsafe
            {
                stateDescription = new SharpDX.Direct2D1.DrawingStateDescription1();
                fixed (void* stateDescription_ = &stateDescription)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, stateDescription_, ((void**)(*(void**)_nativePointer))[8]);
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="stateDescription">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawingStateBlock1::SetDescription']/*"/>	
        /// <unmanaged>void ID2D1DrawingStateBlock1::SetDescription([In] const D2D1_DRAWING_STATE_DESCRIPTION1* stateDescription)</unmanaged>	
        /// <unmanaged-short>ID2D1DrawingStateBlock1::SetDescription</unmanaged-short>	
        internal void SetDescription(ref SharpDX.Direct2D1.DrawingStateDescription1 stateDescription)
        {
            unsafe
            {
                fixed (void* stateDescription_ = &stateDescription)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, stateDescription_, ((void**)(*(void**)_nativePointer))[9]);
            }
        }
    }
    /// <summary>	
    /// <p>A specialized implementation of the Shantzis calculations to a transform implemented on the GPU. These  calculations are described in the paper A model for efficient and flexible image computing.</p><p>The information required to specify a ?Pass? in the rendering algorithm on a Pixel Shader is passed to the implementation through the <strong>SetDrawInfo</strong> method. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawTransform']/*"/>	
    /// <msdn-id>hh847992</msdn-id>	
    /// <unmanaged>ID2D1DrawTransform</unmanaged>	
    /// <unmanaged-short>ID2D1DrawTransform</unmanaged-short>	
    [Guid("36bfdcb6-9739-435d-a30d-a653beff6a6f")]
    public partial interface DrawTransform : SharpDX.Direct2D1.Transform
    {


        /// <summary>	
        /// <p> Provides the GPU render info interface to the transform implementation.</p>	
        /// </summary>	
        /// <param name="drawInfo"><dd>  <p>The interface supplied back to the calling method to allow it to specify the GPU based transform pass.</p> </dd></param>	
        /// <returns><p>Any <see cref="SharpDX.Result"/> value can be returned when implementing this method. A failure will be returned from the corresponding <strong>ID2D1DeviceContext::EndDraw</strong> call.</p></returns>	
        /// <remarks>	
        /// <p>The transform can maintain a  reference to this interface for its lifetime. If any properties change on the transform, it can apply these changes to the corresponding <em>drawInfo</em> interface. </p><p>This is also used to determine that the corresponding nodes in the graph are dirty.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawTransform::SetDrawInfo']/*"/>	
        /// <msdn-id>hh847993</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DrawTransform::SetDrawInfo([In] ID2D1DrawInfo* drawInfo)</unmanaged>	
        /// <unmanaged-short>ID2D1DrawTransform::SetDrawInfo</unmanaged-short>	
        /* public void SetDrawInfo(SharpDX.Direct2D1.DrawInformation drawInfo) */
    }
    /// <summary>	
    /// <p>A specialized implementation of the Shantzis calculations to a transform implemented on the GPU. These  calculations are described in the paper A model for efficient and flexible image computing.</p><p>The information required to specify a ?Pass? in the rendering algorithm on a Pixel Shader is passed to the implementation through the <strong>SetDrawInfo</strong> method. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawTransform']/*"/>	
    /// <msdn-id>hh847992</msdn-id>	
    /// <unmanaged>ID2D1DrawTransform</unmanaged>	
    /// <unmanaged-short>ID2D1DrawTransform</unmanaged-short>	
    [Guid("36bfdcb6-9739-435d-a30d-a653beff6a6f")]
    public partial class DrawTransformNative : SharpDX.Direct2D1.TransformNative, SharpDX.Direct2D1.DrawTransform
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.DrawTransformNative"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DrawTransformNative(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.DrawTransformNative"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.DrawTransformNative(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.DrawTransformNative(nativePointer);
        }


        /// <summary>	
        /// <p> Provides the GPU render info interface to the transform implementation.</p>	
        /// </summary>	
        /// <param name="drawInfo"><dd>  <p>The interface supplied back to the calling method to allow it to specify the GPU based transform pass.</p> </dd></param>	
        /// <returns><p>Any <see cref="SharpDX.Result"/> value can be returned when implementing this method. A failure will be returned from the corresponding <strong>ID2D1DeviceContext::EndDraw</strong> call.</p></returns>	
        /// <remarks>	
        /// <p>The transform can maintain a  reference to this interface for its lifetime. If any properties change on the transform, it can apply these changes to the corresponding <em>drawInfo</em> interface. </p><p>This is also used to determine that the corresponding nodes in the graph are dirty.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1DrawTransform::SetDrawInfo']/*"/>	
        /// <msdn-id>hh847993</msdn-id>	
        /// <unmanaged>HRESULT ID2D1DrawTransform::SetDrawInfo([In] ID2D1DrawInfo* drawInfo)</unmanaged>	
        /// <unmanaged-short>ID2D1DrawTransform::SetDrawInfo</unmanaged-short>	
        internal void SetDrawInfo_(SharpDX.Direct2D1.DrawInformation drawInfo)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((drawInfo == null) ? IntPtr.Zero : drawInfo.NativePointer), ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a basic image-processing construct in Direct2D.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An effect takes zero or more input images, and has an output image. The images that are input into and output from an effect are lazily evaluated. This definition is sufficient to allow an arbitrary graph of effects to be created from the application by feeding output images into the input image of the next effect in the chain.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Effect']/*"/>	
    /// <msdn-id>hh404566</msdn-id>	
    /// <unmanaged>ID2D1Effect</unmanaged>	
    /// <unmanaged-short>ID2D1Effect</unmanaged-short>	
    [Guid("28211a43-7d89-476f-8181-2d6159b220ad")]
    public partial class Effect : SharpDX.Direct2D1.Properties
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Effect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Effect(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Effect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Effect(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Effect(nativePointer);
        }


        /// <summary>Constant Border.</summary>
        /// <unmanaged>CLSID_D2D1Border</unmanaged>
        public static readonly System.Guid Border = new System.Guid("2a2d49c0-4acf-43c7-8c6a-7c4a27874d27");

        /// <summary>Constant Saturation.</summary>
        /// <unmanaged>CLSID_D2D1Saturation</unmanaged>
        public static readonly System.Guid Saturation = new System.Guid("5cb2d9cf-327d-459f-a0ce-40c0b2086bf7");

        /// <summary>Constant ArithmeticComposite.</summary>
        /// <unmanaged>CLSID_D2D1ArithmeticComposite</unmanaged>
        public static readonly System.Guid ArithmeticComposite = new System.Guid("fc151437-049a-4784-a24a-f1c4daf20987");

        /// <summary>Constant DistantDiffuse.</summary>
        /// <unmanaged>CLSID_D2D1DistantDiffuse</unmanaged>
        public static readonly System.Guid DistantDiffuse = new System.Guid("3e7efd62-a32d-46d4-a83c-5278889ac954");

        /// <summary>Constant Scale.</summary>
        /// <unmanaged>CLSID_D2D1Scale</unmanaged>
        public static readonly System.Guid Scale = new System.Guid("9daf9369-3846-4d0e-a44e-0c607934a5d7");

        /// <summary>Constant LinearTransfer.</summary>
        /// <unmanaged>CLSID_D2D1LinearTransfer</unmanaged>
        public static readonly System.Guid LinearTransfer = new System.Guid("ad47c8fd-63ef-4acc-9b51-67979c036c06");

        /// <summary>Constant Composite.</summary>
        /// <unmanaged>CLSID_D2D1Composite</unmanaged>
        public static readonly System.Guid Composite = new System.Guid("48fc9f51-f6ac-48f1-8b58-3b28ac46f76d");

        /// <summary>Constant Turbulence.</summary>
        /// <unmanaged>CLSID_D2D1Turbulence</unmanaged>
        public static readonly System.Guid Turbulence = new System.Guid("cf2bb6ae-889a-4ad7-ba29-a2fd732c9fc9");

        /// <summary>Constant HueRotation.</summary>
        /// <unmanaged>CLSID_D2D1HueRotation</unmanaged>
        public static readonly System.Guid HueRotation = new System.Guid("0f4458ec-4b32-491b-9e85-bd73f44d3eb6");

        /// <summary>Constant DistantSpecular.</summary>
        /// <unmanaged>CLSID_D2D1DistantSpecular</unmanaged>
        public static readonly System.Guid DistantSpecular = new System.Guid("428c1ee5-77b8-4450-8ab5-72219c21abda");

        /// <summary>Constant Atlas.</summary>
        /// <unmanaged>CLSID_D2D1Atlas</unmanaged>
        public static readonly System.Guid Atlas = new System.Guid("913e2be4-fdcf-4fe2-a5f0-2454f14ff408");

        /// <summary>Constant Brightness.</summary>
        /// <unmanaged>CLSID_D2D1Brightness</unmanaged>
        public static readonly System.Guid Brightness = new System.Guid("8cea8d1e-77b0-4986-b3b9-2f0c0eae7887");

        /// <summary>Constant Premultiply.</summary>
        /// <unmanaged>CLSID_D2D1Premultiply</unmanaged>
        public static readonly System.Guid Premultiply = new System.Guid("06eab419-deed-4018-80d2-3e1d471adeb2");

        /// <summary>Constant SpotDiffuse.</summary>
        /// <unmanaged>CLSID_D2D1SpotDiffuse</unmanaged>
        public static readonly System.Guid SpotDiffuse = new System.Guid("818a1105-7932-44f4-aa86-08ae7b2f2c93");

        /// <summary>Constant TableTransfer.</summary>
        /// <unmanaged>CLSID_D2D1TableTransfer</unmanaged>
        public static readonly System.Guid TableTransfer = new System.Guid("5bf818c3-5e43-48cb-b631-868396d6a1d4");

        /// <summary>Constant ColorManagement.</summary>
        /// <unmanaged>CLSID_D2D1ColorManagement</unmanaged>
        public static readonly System.Guid ColorManagement = new System.Guid("1a28524c-fdd6-4aa4-ae8f-837eb8267b37");

        /// <summary>Constant GaussianBlur.</summary>
        /// <unmanaged>CLSID_D2D1GaussianBlur</unmanaged>
        public static readonly System.Guid GaussianBlur = new System.Guid("1feb6d69-2fe6-4ac9-8c58-1d7f93e7a6a5");

        /// <summary>Constant OpacityMetadata.</summary>
        /// <unmanaged>CLSID_D2D1OpacityMetadata</unmanaged>
        public static readonly System.Guid OpacityMetadata = new System.Guid("6c53006a-4450-4199-aa5b-ad1656fece5e");

        /// <summary>Constant DpiCompensation.</summary>
        /// <unmanaged>CLSID_D2D1DpiCompensation</unmanaged>
        public static readonly System.Guid DpiCompensation = new System.Guid("6c26c5c7-34e0-46fc-9cfd-e5823706e228");

        /// <summary>Constant Crop.</summary>
        /// <unmanaged>CLSID_D2D1Crop</unmanaged>
        public static readonly System.Guid Crop = new System.Guid("e23f7110-0e9a-4324-af47-6a2c0c46f35b");

        /// <summary>Constant DirectionalBlur.</summary>
        /// <unmanaged>CLSID_D2D1DirectionalBlur</unmanaged>
        public static readonly System.Guid DirectionalBlur = new System.Guid("174319a6-58e9-49b2-bb63-caf2c811a3db");

        /// <summary>Constant DiscreteTransfer.</summary>
        /// <unmanaged>CLSID_D2D1DiscreteTransfer</unmanaged>
        public static readonly System.Guid DiscreteTransfer = new System.Guid("90866fcd-488e-454b-af06-e5041b66c36c");

        /// <summary>Constant PointSpecular.</summary>
        /// <unmanaged>CLSID_D2D1PointSpecular</unmanaged>
        public static readonly System.Guid PointSpecular = new System.Guid("09c3ca26-3ae2-4f09-9ebc-ed3865d53f22");

        /// <summary>Constant DisplacementMap.</summary>
        /// <unmanaged>CLSID_D2D1DisplacementMap</unmanaged>
        public static readonly System.Guid DisplacementMap = new System.Guid("edc48364-0417-4111-9450-43845fa9f890");

        /// <summary>Constant LuminanceToAlpha.</summary>
        /// <unmanaged>CLSID_D2D1LuminanceToAlpha</unmanaged>
        public static readonly System.Guid LuminanceToAlpha = new System.Guid("41251ab7-0beb-46f8-9da7-59e93fcce5de");

        /// <summary>Constant UnPremultiply.</summary>
        /// <unmanaged>CLSID_D2D1UnPremultiply</unmanaged>
        public static readonly System.Guid UnPremultiply = new System.Guid("fb9ac489-ad8d-41ed-9999-bb6347d110f7");

        /// <summary>Constant SpotSpecular.</summary>
        /// <unmanaged>CLSID_D2D1SpotSpecular</unmanaged>
        public static readonly System.Guid SpotSpecular = new System.Guid("edae421e-7654-4a37-9db8-71acc1beb3c1");

        /// <summary>Constant ConvolveMatrix.</summary>
        /// <unmanaged>CLSID_D2D1ConvolveMatrix</unmanaged>
        public static readonly System.Guid ConvolveMatrix = new System.Guid("407f8c08-5533-4331-a341-23cc3877843e");

        /// <summary>Constant Morphology.</summary>
        /// <unmanaged>CLSID_D2D1Morphology</unmanaged>
        public static readonly System.Guid Morphology = new System.Guid("eae6c40d-626a-4c2d-bfcb-391001abe202");

        /// <summary>Constant Histogram.</summary>
        /// <unmanaged>CLSID_D2D1Histogram</unmanaged>
        public static readonly System.Guid Histogram = new System.Guid("881db7d0-f7ee-4d4d-a6d2-4697acc66ee8");

        /// <summary>Constant ColorMatrix.</summary>
        /// <unmanaged>CLSID_D2D1ColorMatrix</unmanaged>
        public static readonly System.Guid ColorMatrix = new System.Guid("921f03d6-641c-47df-852d-b4bb6153ae11");

        /// <summary>Constant Tile.</summary>
        /// <unmanaged>CLSID_D2D1Tile</unmanaged>
        public static readonly System.Guid Tile = new System.Guid("b0784138-3b76-4bc5-b13b-0fa2ad02659f");

        /// <summary>Constant Blend.</summary>
        /// <unmanaged>CLSID_D2D1Blend</unmanaged>
        public static readonly System.Guid Blend = new System.Guid("81c5b77b-13f8-4cdd-ad20-c890547ac65d");

        /// <summary>Constant GammaTransfer.</summary>
        /// <unmanaged>CLSID_D2D1GammaTransfer</unmanaged>
        public static readonly System.Guid GammaTransfer = new System.Guid("409444c4-c419-41a0-b0c1-8cd0c0a18e42");

        /// <summary>Constant Shadow.</summary>
        /// <unmanaged>CLSID_D2D1Shadow</unmanaged>
        public static readonly System.Guid Shadow = new System.Guid("c67ea361-1863-4e69-89db-695d3e9a5b6b");

        /// <summary>Constant Flood.</summary>
        /// <unmanaged>CLSID_D2D1Flood</unmanaged>
        public static readonly System.Guid Flood = new System.Guid("61c23c20-ae69-4d8e-94cf-50078df638f2");

        /// <summary>Constant BitmapSource.</summary>
        /// <unmanaged>CLSID_D2D1BitmapSource</unmanaged>
        public static readonly System.Guid BitmapSource = new System.Guid("5fb6c24d-c6dd-4231-9404-50f4d5c3252d");

        /// <summary>Constant PointDiffuse.</summary>
        /// <unmanaged>CLSID_D2D1PointDiffuse</unmanaged>
        public static readonly System.Guid PointDiffuse = new System.Guid("b9e303c3-c08c-4f91-8b7b-38656bc48c20");

        /// <summary>Constant YCbCr.</summary>
        /// <unmanaged>CLSID_D2D1YCbCr</unmanaged>
        public static readonly System.Guid YCbCr = new System.Guid("99503cc1-66c7-45c9-a875-8ad8a7914401");

        /// <summary>Constant Exposure.</summary>
        /// <unmanaged>CLSID_D2D1Exposure</unmanaged>
        public static readonly System.Guid Exposure = new System.Guid("b56c8cfa-f634-41ee-bee0-ffa617106004");

        /// <summary>Constant Invert.</summary>
        /// <unmanaged>CLSID_D2D1Invert</unmanaged>
        public static readonly System.Guid Invert = new System.Guid("e0c3784d-cb39-4e84-b6fd-6b72f0810263");

        /// <summary>Constant EdgeDetection.</summary>
        /// <unmanaged>CLSID_D2D1EdgeDetection</unmanaged>
        public static readonly System.Guid EdgeDetection = new System.Guid("eff583ca-cb07-4aa9-ac5d-2cc44c76460f");

        /// <summary>Constant LookupTable3D.</summary>
        /// <unmanaged>CLSID_D2D1LookupTable3D</unmanaged>
        public static readonly System.Guid LookupTable3D = new System.Guid("349e0eda-0088-4a79-9ca3-c7e300202020");

        /// <summary>Constant Contrast.</summary>
        /// <unmanaged>CLSID_D2D1Contrast</unmanaged>
        public static readonly System.Guid Contrast = new System.Guid("b648a78a-0ed5-4f80-a94a-8e825aca6b77");

        /// <summary>Constant Sharpen.</summary>
        /// <unmanaged>CLSID_D2D1Sharpen</unmanaged>
        public static readonly System.Guid Sharpen = new System.Guid("c9b887cb-c5ff-4dc5-9779-273dcf417c7d");

        /// <summary>Constant Vignette.</summary>
        /// <unmanaged>CLSID_D2D1Vignette</unmanaged>
        public static readonly System.Guid Vignette = new System.Guid("c00c40be-5e67-4ca3-95b4-f4b02c115135");

        /// <summary>Constant TemperatureTint.</summary>
        /// <unmanaged>CLSID_D2D1TemperatureTint</unmanaged>
        public static readonly System.Guid TemperatureTint = new System.Guid("89176087-8af9-4a08-aeb1-895f38db1766");

        /// <summary>Constant HueToRgb.</summary>
        /// <unmanaged>CLSID_D2D1HueToRgb</unmanaged>
        public static readonly System.Guid HueToRgb = new System.Guid("7b78a6bd-0141-4def-8a52-6356ee0cbdd5");

        /// <summary>Constant Straighten.</summary>
        /// <unmanaged>CLSID_D2D1Straighten</unmanaged>
        public static readonly System.Guid Straighten = new System.Guid("4da47b12-79a3-4fb0-8237-bbc3b2a4de08");

        /// <summary>Constant Emboss.</summary>
        /// <unmanaged>CLSID_D2D1Emboss</unmanaged>
        public static readonly System.Guid Emboss = new System.Guid("b1c5eb2b-0348-43f0-8107-4957cacba2ae");

        /// <summary>Constant HighlightsShadows.</summary>
        /// <unmanaged>CLSID_D2D1HighlightsShadows</unmanaged>
        public static readonly System.Guid HighlightsShadows = new System.Guid("cadc8384-323f-4c7e-a361-2e2b24df6ee4");

        /// <summary>Constant ChromaKey.</summary>
        /// <unmanaged>CLSID_D2D1ChromaKey</unmanaged>
        public static readonly System.Guid ChromaKey = new System.Guid("74c01f5b-2a0d-408c-88e2-c7a3c7197742");

        /// <summary>Constant Posterize.</summary>
        /// <unmanaged>CLSID_D2D1Posterize</unmanaged>
        public static readonly System.Guid Posterize = new System.Guid("2188945e-33a3-4366-b7bc-086bd02d0884");

        /// <summary>Constant Sepia.</summary>
        /// <unmanaged>CLSID_D2D1Sepia</unmanaged>
        public static readonly System.Guid Sepia = new System.Guid("3a1af410-5f1d-4dbe-84df-915da79b7153");

        /// <summary>Constant RgbToHue.</summary>
        /// <unmanaged>CLSID_D2D1RgbToHue</unmanaged>
        public static readonly System.Guid RgbToHue = new System.Guid("23f3e5ec-91e8-4d3d-ad0a-afadc1004aa1");

        /// <summary>Constant Grayscale.</summary>
        /// <unmanaged>CLSID_D2D1Grayscale</unmanaged>
        public static readonly System.Guid Grayscale = new System.Guid("36dde0eb-3725-42e0-836d-52fb20aee644");

        /// <summary>Constant AffineTransform2D.</summary>
        /// <unmanaged>CLSID_D2D12DAffineTransform</unmanaged>
        public static readonly System.Guid AffineTransform2D = new System.Guid("6aa97485-6354-4cfc-908c-e4a74f62c96c");

        /// <summary>Constant PerspectiveTransform3D.</summary>
        /// <unmanaged>CLSID_D2D13DPerspectiveTransform</unmanaged>
        public static readonly System.Guid PerspectiveTransform3D = new System.Guid("c2844d0b-3d86-46e7-85ba-526c9240f3fb");

        /// <summary>Constant Transform3D.</summary>
        /// <unmanaged>CLSID_D2D13DTransform</unmanaged>
        public static readonly System.Guid Transform3D = new System.Guid("e8467b04-ec61-4b8a-b5de-d4d73debea5a");

        /// <summary>	
        /// <p>Gets or sets the number of inputs to the effect. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Effect::GetInputCount']/*"/>	
        /// <msdn-id>hh404582</msdn-id>	
        /// <unmanaged>GetInputCount / SetInputCount</unmanaged>	
        /// <unmanaged-short>GetInputCount</unmanaged-short>	
        /// <unmanaged>unsigned int ID2D1Effect::GetInputCount()</unmanaged>
        public int InputCount
        {
            get { return GetInputCount(); }
            set { SetInputCount(value); }
        }

        /// <summary>	
        /// <p>Gets the output image from the effect. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The output image  can be set as an input to another effect, or can be directly passed into the <strong><see cref="SharpDX.Direct2D1.DeviceContext"/></strong> in order to render the effect. </p><p>It is  also possible to use <strong>QueryInterface</strong> to retrieve the same output image.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Effect::GetOutput']/*"/>	
        /// <msdn-id>hh404585</msdn-id>	
        /// <unmanaged>GetOutput</unmanaged>	
        /// <unmanaged-short>GetOutput</unmanaged-short>	
        /// <unmanaged>void ID2D1Effect::GetOutput([Out] ID2D1Image** outputImage)</unmanaged>
        public SharpDX.Direct2D1.Image Output
        {
            get { SharpDX.Direct2D1.Image __output__; GetOutput(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Sets the given input image by index. </p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the image to set.</p> </dd></param>	
        /// <param name="input"><dd>  <p>The input image to set.</p> </dd></param>	
        /// <param name="invalidate"><dd>  <p>Whether to invalidate the graph at the location of the effect input</p> </dd></param>	
        /// <remarks>	
        /// <p>If the input index is out of range, the input image is ignored. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Effect::SetInput']/*"/>	
        /// <msdn-id>hh404591</msdn-id>	
        /// <unmanaged>void ID2D1Effect::SetInput([In] unsigned int index,[In, Optional] ID2D1Image* input,[In] BOOL invalidate)</unmanaged>	
        /// <unmanaged-short>ID2D1Effect::SetInput</unmanaged-short>	
        public void SetInput(int index, SharpDX.Direct2D1.Image input, SharpDX.Mathematics.Interop.RawBool invalidate)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid105(_nativePointer, index, (void*)((input == null) ? IntPtr.Zero : input.NativePointer), invalidate, ((void**)(*(void**)_nativePointer))[14]);
            }
        }

        /// <summary>	
        /// <p>Allows the application to change the number of inputs to an effect.</p>	
        /// </summary>	
        /// <param name="inputCount"><dd>  <p>The number of inputs to the effect.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are invalid.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Failed to allocate necessary memory.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Most effects do not support a variable number of inputs. Use <strong><see cref="SharpDX.Direct2D1.Properties.GetValue"/></strong> with the <strong><see cref="SharpDX.Direct2D1.Property.MinimumInputs"/></strong> and <strong><see cref="SharpDX.Direct2D1.Property.MaximumInputs"/></strong> values to determine the number of inputs supported by an effect.</p><p>If the input count is less than the minimum or more than the maximum supported inputs, the call will fail.</p><p>If the input count is unchanged, the call will succeed with <strong><see cref="SharpDX.Result.Ok"/></strong>. </p><p>Any inputs currently selected on the effect will be unaltered by this call unless the number of inputs is made smaller. If the number of inputs is made smaller, inputs beyond the selected range will be released.</p><p>If the method fails, the existing input and input count will remain unchanged.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Effect::SetInputCount']/*"/>	
        /// <msdn-id>hh404594</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Effect::SetInputCount([In] unsigned int inputCount)</unmanaged>	
        /// <unmanaged-short>ID2D1Effect::SetInputCount</unmanaged-short>	
        internal void SetInputCount(int inputCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, inputCount, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the given input image by index. </p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the image to retrieve.</p> </dd></param>	
        /// <remarks>	
        /// <p>If the input index is out of range, the returned image will be <strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Effect::GetInput']/*"/>	
        /// <msdn-id>hh404579</msdn-id>	
        /// <unmanaged>void ID2D1Effect::GetInput([In] unsigned int index,[Out, Optional] ID2D1Image** input)</unmanaged>	
        /// <unmanaged-short>ID2D1Effect::GetInput</unmanaged-short>	
        public SharpDX.Direct2D1.Image GetInput(int index)
        {
            unsafe
            {
                SharpDX.Direct2D1.Image input;
                IntPtr input_ = IntPtr.Zero;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, index, &input_, ((void**)(*(void**)_nativePointer))[16]);
                input = (input_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.Image(input_);
                return input;
            }
        }

        /// <summary>	
        /// <p>Gets the number of inputs to the effect. </p>	
        /// </summary>	
        /// <returns><p>This method returns the number of inputs to the effect. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Effect::GetInputCount']/*"/>	
        /// <msdn-id>hh404582</msdn-id>	
        /// <unmanaged>unsigned int ID2D1Effect::GetInputCount()</unmanaged>	
        /// <unmanaged-short>ID2D1Effect::GetInputCount</unmanaged-short>	
        internal int GetInputCount()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[17]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the output image from the effect. </p>	
        /// </summary>	
        /// <param name="outputImage"><dd>  <p>When this method returns, contains the address of a reference to the output image for the effect.</p> </dd></param>	
        /// <remarks>	
        /// <p>The output image  can be set as an input to another effect, or can be directly passed into the <strong><see cref="SharpDX.Direct2D1.DeviceContext"/></strong> in order to render the effect. </p><p>It is  also possible to use <strong>QueryInterface</strong> to retrieve the same output image.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Effect::GetOutput']/*"/>	
        /// <msdn-id>hh404585</msdn-id>	
        /// <unmanaged>void ID2D1Effect::GetOutput([Out] ID2D1Image** outputImage)</unmanaged>	
        /// <unmanaged-short>ID2D1Effect::GetOutput</unmanaged-short>	
        internal void GetOutput(out SharpDX.Direct2D1.Image outputImage)
        {
            unsafe
            {
                IntPtr outputImage_ = IntPtr.Zero;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &outputImage_, ((void**)(*(void**)_nativePointer))[18]);
                outputImage = (outputImage_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.Image(outputImage_);
            }
        }
    }
    /// <summary>	
    /// <p>Provides factory methods and other state management for effect and transform authors.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface  is passed to an effect implementation through the <strong><see cref="SharpDX.Direct2D1.CustomEffect.Initialize"/></strong> method. In order to prevent applications casually gaining access to this interface, and to separate reference counts between the public and private interfaces, it is not possible to call <strong>QueryInterface</strong> between the <strong><see cref="SharpDX.Direct2D1.DeviceContext"/></strong> and the <strong><see cref="SharpDX.Direct2D1.EffectContext"/></strong>.</p><p>Each call to <strong>ID2D1Effect::Initialize</strong> will be provided a different <strong><see cref="SharpDX.Direct2D1.EffectContext"/></strong> interface. This interface tracks resource allocations for the effect. When the effect is released, the corresponding allocations will also be released.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext']/*"/>	
    /// <msdn-id>hh404459</msdn-id>	
    /// <unmanaged>ID2D1EffectContext</unmanaged>	
    /// <unmanaged-short>ID2D1EffectContext</unmanaged-short>	
    [Guid("3d9f916b-27dc-4ad7-b4f1-64945340f563")]
    public partial class EffectContext : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.EffectContext"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectContext(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.EffectContext"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.EffectContext(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.EffectContext(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the unit mapping that an effect will use for properties that could be in either dots per inch (dpi) or pixels.</p>	
        /// </summary>	
        /// <param name="dpiX"><dd>  <p>The dpi on the x-axis.</p> </dd></param>	
        /// <param name="dpiY"><dd>  <p>The dpi on the y-axis.</p> </dd></param>	
        /// <remarks>	
        /// <p> If the <strong><see cref="SharpDX.Direct2D1.UnitMode"/></strong> is <strong><see cref="SharpDX.Direct2D1.UnitMode.Pixels"/></strong>, both <em>dpiX</em> and <em>dpiY</em> will be set to 96.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::GetDpi']/*"/>	
        /// <msdn-id>hh404472</msdn-id>	
        /// <unmanaged>void ID2D1EffectContext::GetDpi([Out] float* dpiX,[Out] float* dpiY)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::GetDpi</unmanaged-short>	
        internal void GetDpi(out float dpiX, out float dpiY)
        {
            unsafe
            {
                fixed (void* dpiX_ = &dpiX)
                    fixed (void* dpiY_ = &dpiY)
                        SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, dpiX_, dpiY_, ((void**)(*(void**)_nativePointer))[3]);
            }
        }

        /// <summary>	
        /// <p>Creates a Direct2D effect from a  class ID. This is the same as <strong><see cref="SharpDX.Direct2D1.DeviceContext.CreateEffect"/></strong> so custom effects can create other effects and wrap them in a transform.</p>	
        /// </summary>	
        /// <param name="effectId">No documentation.</param>	
        /// <param name="effect">No documentation.</param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation.</td></tr> <tr><td><see cref="SharpDX.Direct2D1.ResultCode.EffectIsNotRegistered"/></td><td>The specified effect is not registered by the system.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The created effect does not reference count the DLL from which the effect was created. If the caller unregisters an effect while this effect is loaded, the resulting behavior is unpredictable.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::CreateEffect']/*"/>	
        /// <msdn-id>hh404467</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateEffect([In] const GUID&amp; effectId,[Out, Fast] ID2D1Effect** effect)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::CreateEffect</unmanaged-short>	
        internal void CreateEffect(System.Guid effectId, SharpDX.Direct2D1.Effect effect)
        {
            unsafe
            {
                IntPtr effect_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &effectId, &effect_, ((void**)(*(void**)_nativePointer))[4]);
                ((SharpDX.Direct2D1.Effect)effect).NativePointer = effect_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>This indicates the maximum feature level from the provided list which is supported by the device. If none of the provided levels are supported, then this API fails with <see cref="SharpDX.Direct2D1.ResultCode.InsufficientDeviceCapabilities"/>.</p>	
        /// </summary>	
        /// <param name="featureLevels"><dd>  <p>The feature levels provided by the application.</p> </dd></param>	
        /// <param name="featureLevelsCount"><dd>  <p>The count of feature levels provided by the application</p> </dd></param>	
        /// <returns><dd>  <p>The maximum feature level from the <em>featureLevels</em> list which is supported by the D2D device.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::GetMaximumSupportedFeatureLevel']/*"/>	
        /// <msdn-id>hh404473</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::GetMaximumSupportedFeatureLevel([In, Buffer] const D3D_FEATURE_LEVEL* featureLevels,[In] unsigned int featureLevelsCount,[Out] D3D_FEATURE_LEVEL* maximumSupportedFeatureLevel)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::GetMaximumSupportedFeatureLevel</unmanaged-short>	
        internal SharpDX.Direct3D.FeatureLevel GetMaximumSupportedFeatureLevel(SharpDX.Direct3D.FeatureLevel[] featureLevels, int featureLevelsCount)
        {
            unsafe
            {
                SharpDX.Direct3D.FeatureLevel maximumSupportedFeatureLevel;
                SharpDX.Result __result__;
                fixed (void* featureLevels_ = featureLevels)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, featureLevels_, featureLevelsCount, &maximumSupportedFeatureLevel, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
                return maximumSupportedFeatureLevel;
            }
        }

        /// <summary>	
        /// <p>Wraps an effect graph into a single transform node and then inserted into a transform graph. This allows an effect to aggregate other effects. This will typically be done in order to allow the effect properties to be re-expressed with a different contract, or to allow different components to integrate each-other?s effects.</p>	
        /// </summary>	
        /// <param name="effect"><dd>  <p>The effect to be wrapped in a transform node.</p> </dd></param>	
        /// <returns><dd>  <p>The returned transform node that encapsulates the effect graph.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::CreateTransformNodeFromEffect']/*"/>	
        /// <msdn-id>hh404470</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateTransformNodeFromEffect([In] ID2D1Effect* effect,[Out] ID2D1TransformNode** transformNode)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::CreateTransformNodeFromEffect</unmanaged-short>	
        public SharpDX.Direct2D1.TransformNode CreateTransformNodeFromEffect(SharpDX.Direct2D1.Effect effect)
        {
            unsafe
            {
                SharpDX.Direct2D1.TransformNode transformNode;
                IntPtr transformNode_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((effect == null) ? IntPtr.Zero : effect.NativePointer), &transformNode_, ((void**)(*(void**)_nativePointer))[6]);
                transformNode = (transformNode_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.TransformNodeNative(transformNode_);
                __result__.CheckError();
                return transformNode;
            }
        }

        /// <summary>	
        /// <p>This creates a blend transform that can be inserted into a transform graph.  </p>	
        /// </summary>	
        /// <param name="numInputs"><dd>  <p>The number of inputs to the blend transform.</p> </dd></param>	
        /// <param name="blendDescription"><dd>  <p>Describes the blend transform that is to be created.</p> </dd></param>	
        /// <param name="transform"><dd>  <p>The returned blend transform.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::CreateBlendTransform']/*"/>	
        /// <msdn-id>hh404461</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateBlendTransform([In] unsigned int numInputs,[In] const D2D1_BLEND_DESCRIPTION* blendDescription,[Out, Fast] ID2D1BlendTransform** transform)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::CreateBlendTransform</unmanaged-short>	
        internal void CreateBlendTransform(int numInputs, ref SharpDX.Direct2D1.BlendDescription blendDescription, SharpDX.Direct2D1.BlendTransform transform)
        {
            unsafe
            {
                IntPtr transform_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* blendDescription_ = &blendDescription)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, numInputs, blendDescription_, &transform_, ((void**)(*(void**)_nativePointer))[7]);
                ((SharpDX.Direct2D1.BlendTransform)transform).NativePointer = transform_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a transform that extends its input infinitely in every direction based on the passed in extend mode.</p>	
        /// </summary>	
        /// <param name="extendModeX"><dd>  <p>The extend mode in the X-axis direction.</p> </dd></param>	
        /// <param name="extendModeY"><dd>  <p>The extend mode in the Y-axis direction.</p> </dd></param>	
        /// <param name="transform"><dd>  <p>The returned transform.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::CreateBorderTransform']/*"/>	
        /// <msdn-id>hh404463</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateBorderTransform([In] D2D1_EXTEND_MODE extendModeX,[In] D2D1_EXTEND_MODE extendModeY,[Out, Fast] ID2D1BorderTransform** transform)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::CreateBorderTransform</unmanaged-short>	
        internal void CreateBorderTransform(SharpDX.Direct2D1.ExtendMode extendModeX, SharpDX.Direct2D1.ExtendMode extendModeY, SharpDX.Direct2D1.BorderTransform transform)
        {
            unsafe
            {
                IntPtr transform_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)extendModeX), unchecked((int)extendModeY), &transform_, ((void**)(*(void**)_nativePointer))[8]);
                ((SharpDX.Direct2D1.BorderTransform)transform).NativePointer = transform_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates and returns an offset transform.</p>	
        /// </summary>	
        /// <param name="offset"><dd>  <p>The offset amount.</p> </dd></param>	
        /// <param name="transform"><dd>  <p>When this method returns, contains the address of a reference to an offset transform object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>An offset transform is used to offset an input bitmap without having to insert a rendering pass. An offset transform is automatically inserted by an Affine transform if the transform evaluates to a pixel-aligned transform.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::CreateOffsetTransform']/*"/>	
        /// <msdn-id>hh404468</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateOffsetTransform([In] POINT offset,[Out, Fast] ID2D1OffsetTransform** transform)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::CreateOffsetTransform</unmanaged-short>	
        internal void CreateOffsetTransform(SharpDX.Mathematics.Interop.RawPoint offset, SharpDX.Direct2D1.OffsetTransform transform)
        {
            unsafe
            {
                IntPtr transform_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint118(_nativePointer, offset, &transform_, ((void**)(*(void**)_nativePointer))[9]);
                ((SharpDX.Direct2D1.OffsetTransform)transform).NativePointer = transform_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates and returns a bounds adjustment  transform.</p>	
        /// </summary>	
        /// <param name="outputRectangle"><dd>  <p>The initial output rectangle for the bounds adjustment transform.</p> </dd></param>	
        /// <param name="transform"><dd>  <p>The returned bounds adjustment transform.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>A support transform can be used for two different reasons.</p><ul> <li>To indicate that a region of its input image is already transparent black. This can increase efficiency for rendering bitmaps. <p><strong>Note</strong>??If the indicated region does NOT contain only transparent black pixels, then rendering results are undefined.</p> </li> <li>To increase the size of the input image. The expanded area will be treated as transparent black	
        /// </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::CreateBoundsAdjustmentTransform']/*"/>	
        /// <msdn-id>hh871456</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateBoundsAdjustmentTransform([In] const RECT* outputRectangle,[Out, Fast] ID2D1BoundsAdjustmentTransform** transform)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::CreateBoundsAdjustmentTransform</unmanaged-short>	
        internal void CreateBoundsAdjustmentTransform(SharpDX.Mathematics.Interop.RawRectangle outputRectangle, SharpDX.Direct2D1.BoundsAdjustmentTransform transform)
        {
            unsafe
            {
                IntPtr transform_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &outputRectangle, &transform_, ((void**)(*(void**)_nativePointer))[10]);
                ((SharpDX.Direct2D1.BoundsAdjustmentTransform)transform).NativePointer = transform_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Loads the given shader by its unique ID. Loading the shader multiple times is ignored. When the shader is loaded it is also handed to the driver to JIT, if it hasn?t been already.</p>	
        /// </summary>	
        /// <param name="shaderId"><dd>  <p>The unique id that identifies the shader.</p> </dd></param>	
        /// <param name="shaderBuffer"><dd>  <p>The buffer that contains the shader to register.</p> </dd></param>	
        /// <param name="shaderBufferCount"><dd>  <p>The size of the shader buffer in bytes.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The shader you specify must be compiled,  not  in raw HLSL code.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::LoadPixelShader']/*"/>	
        /// <msdn-id>hh404476</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::LoadPixelShader([In] const GUID&amp; shaderId,[In, Buffer] const unsigned char* shaderBuffer,[In] unsigned int shaderBufferCount)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::LoadPixelShader</unmanaged-short>	
        internal void LoadPixelShader(System.Guid shaderId, byte[] shaderBuffer, int shaderBufferCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* shaderBuffer_ = shaderBuffer)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &shaderId, shaderBuffer_, shaderBufferCount, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Loads the given shader by its unique ID. Loading the shader multiple times is ignored. When the shader is loaded it is also handed to the driver to JIT, if it hasn?t been already.</p>	
        /// </summary>	
        /// <param name="resourceId"><dd>  <p>The unique id that identifies the shader.</p> </dd></param>	
        /// <param name="shaderBuffer"><dd>  <p>The buffer that contains the shader to register.</p> </dd></param>	
        /// <param name="shaderBufferCount"><dd>  <p>The size of the shader buffer in bytes.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The shader you specify must be compiled,  not  in raw HLSL code.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::LoadVertexShader']/*"/>	
        /// <msdn-id>hh404477</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::LoadVertexShader([In] const GUID&amp; resourceId,[In, Buffer] const unsigned char* shaderBuffer,[In] unsigned int shaderBufferCount)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::LoadVertexShader</unmanaged-short>	
        internal void LoadVertexShader(System.Guid resourceId, byte[] shaderBuffer, int shaderBufferCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* shaderBuffer_ = shaderBuffer)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &resourceId, shaderBuffer_, shaderBufferCount, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Loads the given shader by its unique ID. Loading the shader multiple times is ignored. When the shader is loaded it is also handed to the driver to JIT, if it hasn?t been already.</p>	
        /// </summary>	
        /// <param name="resourceId"><dd>  <p>The unique id that identifies the shader.</p> </dd></param>	
        /// <param name="shaderBuffer"><dd>  <p>The buffer that contains the shader to register.</p> </dd></param>	
        /// <param name="shaderBufferCount"><dd>  <p>The size of the shader buffer in bytes.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The shader you specify must be compiled,  not  in raw HLSL code.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::LoadComputeShader']/*"/>	
        /// <msdn-id>hh404475</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::LoadComputeShader([In] const GUID&amp; resourceId,[In, Buffer] const unsigned char* shaderBuffer,[In] unsigned int shaderBufferCount)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::LoadComputeShader</unmanaged-short>	
        internal void LoadComputeShader(System.Guid resourceId, byte[] shaderBuffer, int shaderBufferCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* shaderBuffer_ = shaderBuffer)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &resourceId, shaderBuffer_, shaderBufferCount, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>This tests to see if the given shader is loaded.</p>	
        /// </summary>	
        /// <param name="shaderId"><dd>  <p>The unique id that identifies the shader.</p> </dd></param>	
        /// <returns><p>Whether the shader is loaded.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::IsShaderLoaded']/*"/>	
        /// <msdn-id>hh404474</msdn-id>	
        /// <unmanaged>BOOL ID2D1EffectContext::IsShaderLoaded([In] const GUID&amp; shaderId)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::IsShaderLoaded</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool IsShaderLoaded(System.Guid shaderId)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, &shaderId, ((void**)(*(void**)_nativePointer))[14]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Creates or finds the given resource texture, depending on whether a resource id is specified. It also optionally initializes the texture with the specified data.</p>	
        /// </summary>	
        /// <param name="resourceId"><dd>  <p>An optional reference to the unique id that identifies the lookup table.</p> </dd></param>	
        /// <param name="resourceTextureProperties"><dd>  <p>The properties used to create the resource texture.</p> </dd></param>	
        /// <param name="data"><dd>  <p>The optional data to be loaded into the resource texture.</p> </dd></param>	
        /// <param name="strides"><dd>  <p>An optional reference to the stride to advance through the resource texture, according to dimension.</p> </dd></param>	
        /// <param name="dataSize"><dd>  <p>The size, in bytes, of the data.</p> </dd></param>	
        /// <param name="resourceTexture"><dd>  <p>The returned texture that can be used as a resource in a Direct2D effect.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::CreateResourceTexture']/*"/>	
        /// <msdn-id>hh404469</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateResourceTexture([In, Optional] const GUID* resourceId,[In] const void* resourceTextureProperties,[In, Buffer, Optional] const unsigned char* data,[In, Buffer, Optional] const unsigned int* strides,[In] unsigned int dataSize,[Out, Fast] ID2D1ResourceTexture** resourceTexture)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::CreateResourceTexture</unmanaged-short>	
        internal void CreateResourceTexture(System.Guid? resourceId, System.IntPtr resourceTextureProperties, byte[] data, int[] strides, int dataSize, SharpDX.Direct2D1.ResourceTexture resourceTexture)
        {
            unsafe
            {
                System.Guid resourceId_;
                if (resourceId.HasValue)
                    resourceId_ = resourceId.Value;
                byte[] data__ = data;
                int[] strides__ = strides;
                IntPtr resourceTexture_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* data_ = data__)
                    fixed (void* strides_ = strides__)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (resourceId.HasValue) ? &resourceId_ : (void*)IntPtr.Zero, (void*)resourceTextureProperties, data_, strides_, dataSize, &resourceTexture_, ((void**)(*(void**)_nativePointer))[15]);
                ((SharpDX.Direct2D1.ResourceTexture)resourceTexture).NativePointer = resourceTexture_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Finds the given resource texture if it has already been created with <strong><see cref="SharpDX.Direct2D1.EffectContext.CreateResourceTexture"/></strong> with the same <see cref="System.Guid"/>.</p>	
        /// </summary>	
        /// <param name="resourceId">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::FindResourceTexture']/*"/>	
        /// <msdn-id>hh871457</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::FindResourceTexture([In] const GUID* resourceId,[Out] ID2D1ResourceTexture** resourceTexture)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::FindResourceTexture</unmanaged-short>	
        public SharpDX.Direct2D1.ResourceTexture FindResourceTexture(System.Guid resourceId)
        {
            unsafe
            {
                SharpDX.Direct2D1.ResourceTexture resourceTexture;
                IntPtr resourceTexture_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &resourceId, &resourceTexture_, ((void**)(*(void**)_nativePointer))[16]);
                resourceTexture = (resourceTexture_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.ResourceTexture(resourceTexture_);
                return resourceTexture;
            }
        }

        /// <summary>	
        /// <p>Creates a vertex buffer or finds a standard vertex buffer and optionally initializes it with vertices. The returned buffer can be specified in the render info to specify both a vertex shader and or to pass custom vertices to the standard vertex shader used by Direct2D. </p>	
        /// </summary>	
        /// <param name="vertexBufferProperties">No documentation.</param>	
        /// <param name="resourceId">No documentation.</param>	
        /// <param name="customVertexBufferProperties">No documentation.</param>	
        /// <param name="buffer">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::CreateVertexBuffer']/*"/>	
        /// <msdn-id>hh404471</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateVertexBuffer([In] const D2D1_VERTEX_BUFFER_PROPERTIES* vertexBufferProperties,[In, Optional] const GUID* resourceId,[In, Optional] const void* customVertexBufferProperties,[Out, Fast] ID2D1VertexBuffer** buffer)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::CreateVertexBuffer</unmanaged-short>	
        internal void CreateVertexBuffer(SharpDX.Direct2D1.VertexBufferProperties vertexBufferProperties, System.Guid? resourceId, System.IntPtr customVertexBufferProperties, SharpDX.Direct2D1.VertexBuffer buffer)
        {
            unsafe
            {
                var vertexBufferProperties_ = new SharpDX.Direct2D1.VertexBufferProperties.__Native();
                vertexBufferProperties.__MarshalTo(ref vertexBufferProperties_);
                System.Guid resourceId_;
                if (resourceId.HasValue)
                    resourceId_ = resourceId.Value;
                IntPtr buffer_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &vertexBufferProperties_, (resourceId.HasValue) ? &resourceId_ : (void*)IntPtr.Zero, (void*)customVertexBufferProperties, &buffer_, ((void**)(*(void**)_nativePointer))[17]);
                vertexBufferProperties.__MarshalFree(ref vertexBufferProperties_);
                ((SharpDX.Direct2D1.VertexBuffer)buffer).NativePointer = buffer_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>This finds the given vertex buffer if it has already been created with <strong><see cref="SharpDX.Direct2D1.EffectContext.CreateVertexBuffer"/></strong> with the same <see cref="System.Guid"/>.</p>	
        /// </summary>	
        /// <param name="resourceId">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::FindVertexBuffer']/*"/>	
        /// <msdn-id>hh871458</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::FindVertexBuffer([In] const GUID* resourceId,[Out] ID2D1VertexBuffer** buffer)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::FindVertexBuffer</unmanaged-short>	
        public SharpDX.Direct2D1.VertexBuffer FindVertexBuffer(System.Guid resourceId)
        {
            unsafe
            {
                SharpDX.Direct2D1.VertexBuffer buffer;
                IntPtr buffer_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &resourceId, &buffer_, ((void**)(*(void**)_nativePointer))[18]);
                buffer = (buffer_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.VertexBuffer(buffer_);
                return buffer;
            }
        }

        /// <summary>	
        /// <p>Creates a color context from a color space.  </p><p>If the color space is Custom, the context is initialized from the <em>profile</em> and <em>profileSize</em> parameters.</p><p>If the color space is not Custom, the context is       initialized with the profile bytes associated with the color space. The <em>profile</em> and <em>profileSize</em> parameters are ignored.</p>	
        /// </summary>	
        /// <param name="space"><dd>  <p>The space  of color context to create.</p> </dd></param>	
        /// <param name="rofileRef"><dd>  <p>A buffer containing the ICC profile bytes used to initialize the color context when <em>space</em> is <see cref="SharpDX.Direct2D1.ColorSpace.Custom"/>.  For other types, the parameter is ignored and should be set to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="profileSize"><dd>  <p>The size in bytes of <em>Profile</em>.</p> </dd></param>	
        /// <param name="colorContext"><dd>  <p>When this method returns, contains the address of a reference to a new color context object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::CreateColorContext']/*"/>	
        /// <msdn-id>hh404464</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateColorContext([In] D2D1_COLOR_SPACE space,[In, Buffer, Optional] const unsigned char* profile,[In] unsigned int profileSize,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::CreateColorContext</unmanaged-short>	
        internal void CreateColorContext(SharpDX.Direct2D1.ColorSpace space, byte[] rofileRef, int profileSize, SharpDX.Direct2D1.ColorContext colorContext)
        {
            unsafe
            {
                byte[] rofileRef__ = rofileRef;
                IntPtr colorContext_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* rofileRef_ = rofileRef__)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)space), rofileRef_, profileSize, &colorContext_, ((void**)(*(void**)_nativePointer))[19]);
                ((SharpDX.Direct2D1.ColorContext)colorContext).NativePointer = colorContext_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a color context by loading it from the specified filename.  The profile bytes are the contents of the file specified by <em>filename</em>.</p>	
        /// </summary>	
        /// <param name="filename"><dd>  <p>The path to the file containing the profile bytes to initialize the color context with.</p> </dd></param>	
        /// <param name="colorContext"><dd>  <p>When this method returns, contains the address of a reference to a new color context.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::CreateColorContextFromFilename']/*"/>	
        /// <msdn-id>hh404465</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateColorContextFromFilename([In] const wchar_t* filename,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::CreateColorContextFromFilename</unmanaged-short>	
        internal void CreateColorContextFromFilename(string filename, SharpDX.Direct2D1.ColorContext colorContext)
        {
            unsafe
            {
                IntPtr filename_ = Utilities.StringToHGlobalUni(filename);
                IntPtr colorContext_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)filename_, &colorContext_, ((void**)(*(void**)_nativePointer))[20]);
                Marshal.FreeHGlobal(filename_);
                ((SharpDX.Direct2D1.ColorContext)colorContext).NativePointer = colorContext_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a color context from an <strong><see cref="SharpDX.WIC.ColorContext"/></strong>.  The <strong>D2D1ColorContext</strong> space of the resulting context varies, see Remarks for more info.</p>	
        /// </summary>	
        /// <param name="wicColorContext">No documentation.</param>	
        /// <param name="colorContext">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The new color context can be used in <strong><see cref="SharpDX.Direct2D1.BitmapProperties1"/></strong> to initialize the color context of a created bitmap.  The model field of the profile header is inspected to determine whether this profile is sRGB or scRGB and the color space is updated respectively.  Otherwise the space is  custom.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::CreateColorContextFromWicColorContext']/*"/>	
        /// <msdn-id>hh404466</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateColorContextFromWicColorContext([In] IWICColorContext* wicColorContext,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::CreateColorContextFromWicColorContext</unmanaged-short>	
        internal void CreateColorContextFromWicColorContext(SharpDX.WIC.ColorContext wicColorContext, SharpDX.Direct2D1.ColorContext colorContext)
        {
            unsafe
            {
                IntPtr colorContext_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((wicColorContext == null) ? IntPtr.Zero : wicColorContext.NativePointer), &colorContext_, ((void**)(*(void**)_nativePointer))[21]);
                ((SharpDX.Direct2D1.ColorContext)colorContext).NativePointer = colorContext_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>This indicates whether an optional capability is supported by the D3D device.</p>	
        /// </summary>	
        /// <param name="feature"><dd>  <p>The feature to query support for.</p> </dd></param>	
        /// <param name="featureSupportData"><dd>  <p>A structure indicating information about how or if the feature is supported.</p> </dd></param>	
        /// <param name="featureSupportDataSize"><dd>  <p>The size of the <em>featureSupportData</em> parameter.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::CheckFeatureSupport']/*"/>	
        /// <msdn-id>hh871455</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext::CheckFeatureSupport([In] D2D1_FEATURE feature,[Out, Buffer] void* featureSupportData,[In] unsigned int featureSupportDataSize)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::CheckFeatureSupport</unmanaged-short>	
        internal SharpDX.Result CheckFeatureSupport(SharpDX.Direct2D1.Feature feature, System.IntPtr featureSupportData, int featureSupportDataSize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)feature), (void*)featureSupportData, featureSupportDataSize, ((void**)(*(void**)_nativePointer))[22]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Indicates whether the buffer precision is supported by the underlying Direct2D <strong>device.</strong> </p>	
        /// </summary>	
        /// <param name="bufferPrecision">No documentation.</param>	
        /// <returns><p>Returns TRUE if the buffer precision is supported.  Returns <see cref="SharpDX.Result.False"/> if the buffer precision is not supported.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext::IsBufferPrecisionSupported']/*"/>	
        /// <msdn-id>hh847981</msdn-id>	
        /// <unmanaged>BOOL ID2D1EffectContext::IsBufferPrecisionSupported([In] D2D1_BUFFER_PRECISION bufferPrecision)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext::IsBufferPrecisionSupported</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool IsBufferPrecisionSupported(SharpDX.Direct2D1.BufferPrecision bufferPrecision)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, unchecked((int)bufferPrecision), ((void**)(*(void**)_nativePointer))[23]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Provides factory methods and other state management for effect and transform authors.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext1']/*"/>	
    /// <msdn-id>dn949338</msdn-id>	
    /// <unmanaged>ID2D1EffectContext1</unmanaged>	
    /// <unmanaged-short>ID2D1EffectContext1</unmanaged-short>	
    [Guid("84ab595a-fc81-4546-bacd-e8ef4d8abe7a")]
    public partial class EffectContext1 : SharpDX.Direct2D1.EffectContext
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.EffectContext1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectContext1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.EffectContext1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.EffectContext1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.EffectContext1(nativePointer);
        }


        /// <summary>	
        /// <p>Creates a 3D lookup table for mapping a 3-channel input to a 3-channel output. The table data must be provided in 4-channel format.</p>	
        /// </summary>	
        /// <param name="precision"><dd>  <p>Precision of the input lookup table data.</p> </dd></param>	
        /// <param name="extents"><dd>  <p>Number of lookup table elements per dimension (X, Y, Z).</p> </dd></param>	
        /// <param name="data"><dd>  <p>Buffer holding the lookup table data.</p> </dd></param>	
        /// <param name="dataCount"><dd>  <p>Size of the lookup table data buffer.</p> </dd></param>	
        /// <param name="strides"><dd>  <p>An array containing two values. The first value is the size in bytes from one row (X dimension) of LUT data to the next.  The second value is the size in bytes from one LUT data plane (X and Y dimensions) to the next.</p> </dd></param>	
        /// <param name="lookupTable"><dd>  <p>Receives the new lookup table instance.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EffectContext1::CreateLookupTable3D']/*"/>	
        /// <msdn-id>dn949339</msdn-id>	
        /// <unmanaged>HRESULT ID2D1EffectContext1::CreateLookupTable3D([In] D2D1_BUFFER_PRECISION precision,[In, Buffer] const unsigned int* extents,[In, Buffer] const unsigned char* data,[In] unsigned int dataCount,[In, Buffer] const unsigned int* strides,[Out] ID2D1LookupTable3D** lookupTable)</unmanaged>	
        /// <unmanaged-short>ID2D1EffectContext1::CreateLookupTable3D</unmanaged-short>	
        public void CreateLookupTable3D(SharpDX.Direct2D1.BufferPrecision precision, int[] extents, byte[] data, int dataCount, int[] strides, out SharpDX.Direct2D1.LookupTable3D lookupTable)
        {
            unsafe
            {
                IntPtr lookupTable_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* extents_ = extents)
                    fixed (void* data_ = data)
                        fixed (void* strides_ = strides)
                            __result__ =
                            SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)precision), extents_, data_, dataCount, strides_, &lookupTable_, ((void**)(*(void**)_nativePointer))[24]);
                lookupTable = (lookupTable_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.LookupTable3D(lookupTable_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents an ellipse. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EllipseGeometry']/*"/>	
    /// <msdn-id>dd371239</msdn-id>	
    /// <unmanaged>ID2D1EllipseGeometry</unmanaged>	
    /// <unmanaged-short>ID2D1EllipseGeometry</unmanaged-short>	
    [Guid("2cd906a4-12e2-11dc-9fed-001143a055f9")]
    public partial class EllipseGeometry : SharpDX.Direct2D1.Geometry
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.EllipseGeometry"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EllipseGeometry(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.EllipseGeometry"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.EllipseGeometry(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.EllipseGeometry(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the <strong><see cref="SharpDX.Direct2D1.Ellipse"/></strong> structure that describes this ellipse geometry. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EllipseGeometry::GetEllipse']/*"/>	
        /// <msdn-id>dd371243</msdn-id>	
        /// <unmanaged>GetEllipse</unmanaged>	
        /// <unmanaged-short>GetEllipse</unmanaged-short>	
        /// <unmanaged>void ID2D1EllipseGeometry::GetEllipse([Out] D2D1_ELLIPSE* ellipse)</unmanaged>
        public SharpDX.Direct2D1.Ellipse Ellipse
        {
            get { SharpDX.Direct2D1.Ellipse __output__; GetEllipse(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets the <strong><see cref="SharpDX.Direct2D1.Ellipse"/></strong> structure that describes this ellipse geometry. </p>	
        /// </summary>	
        /// <param name="ellipse">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1EllipseGeometry::GetEllipse']/*"/>	
        /// <msdn-id>dd371243</msdn-id>	
        /// <unmanaged>void ID2D1EllipseGeometry::GetEllipse([Out] D2D1_ELLIPSE* ellipse)</unmanaged>	
        /// <unmanaged-short>ID2D1EllipseGeometry::GetEllipse</unmanaged-short>	
        internal void GetEllipse(out SharpDX.Direct2D1.Ellipse ellipse)
        {
            unsafe
            {
                ellipse = new SharpDX.Direct2D1.Ellipse();
                fixed (void* ellipse_ = &ellipse)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, ellipse_, ((void**)(*(void**)_nativePointer))[17]);
            }
        }
    }
    /// <summary>	
    /// <p>Creates Direct2D resources.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct2D1.Factory"/></strong> interface is the starting point for using Direct2D; it's what you use to create other Direct2D resources that you can use to draw or describe shapes.   </p><p>A factory defines a set of Create<em>Resource</em> methods that can produce the following drawing resources:</p><p> </p><ul> <li>Render targets: objects that render drawing commands.</li> <li>Drawing state blocks: objects that store drawing state information, such as the current transformation and antialiasing mode.</li> <li>Geometries: objects that represent simple and potentially complex shapes.</li> </ul><p>To create an <strong><see cref="SharpDX.Direct2D1.Factory"/></strong>, you use one of the <strong>CreateFactory</strong> methods. You should retain the <strong><see cref="SharpDX.Direct2D1.Factory"/></strong> instance for as long as you use Direct2D resources; in general, you shouldn't need to recreate it when the application is running. For more information about Direct2D resources, see the Resources Overview.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory']/*"/>	
    /// <msdn-id>dd371246</msdn-id>	
    /// <unmanaged>ID2D1Factory</unmanaged>	
    /// <unmanaged-short>ID2D1Factory</unmanaged-short>	
    [Guid("06152247-6f50-465a-9245-118bfd3b6007")]
    public partial class Factory : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Factory"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Factory(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Factory"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Factory(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Factory(nativePointer);
        }


        /// <summary>	
        /// <p>Forces the factory to refresh any system defaults that it might have changed since factory creation.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>You should call this method before calling the <strong>GetDesktopDpi</strong> method, to ensure that the system DPI is current.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::ReloadSystemMetrics']/*"/>	
        /// <msdn-id>dd371319</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory::ReloadSystemMetrics()</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::ReloadSystemMetrics</unmanaged-short>	
        public void ReloadSystemMetrics()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Retrieves the current desktop dots per inch (DPI). To refresh this value, call <strong>ReloadSystemMetrics</strong>.</p>	
        /// </summary>	
        /// <param name="dpiX">No documentation.</param>	
        /// <param name="dpiY">No documentation.</param>	
        /// <remarks>	
        /// <p>Use this method to obtain the system DPI when setting physical pixel values, such as when you specify the size of a window.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::GetDesktopDpi']/*"/>	
        /// <msdn-id>dd371316</msdn-id>	
        /// <unmanaged>void ID2D1Factory::GetDesktopDpi([Out] float* dpiX,[Out] float* dpiY)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::GetDesktopDpi</unmanaged-short>	
        internal void GetDesktopDpi(out float dpiX, out float dpiY)
        {
            unsafe
            {
                fixed (void* dpiX_ = &dpiX)
                    fixed (void* dpiY_ = &dpiY)
                        SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, dpiX_, dpiY_, ((void**)(*(void**)_nativePointer))[4]);
            }
        }

        /// <summary>	
        /// <p> Creates an <strong><see cref="SharpDX.Direct2D1.RectangleGeometry"/></strong>. </p>	
        /// </summary>	
        /// <param name="rectangle">No documentation.</param>	
        /// <param name="rectangleGeometry">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::CreateRectangleGeometry']/*"/>	
        /// <msdn-id>dd371286</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory::CreateRectangleGeometry([In] const D2D_RECT_F* rectangle,[Out, Fast] ID2D1RectangleGeometry** rectangleGeometry)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::CreateRectangleGeometry</unmanaged-short>	
        internal void CreateRectangleGeometry(SharpDX.Mathematics.Interop.RawRectangleF rectangle, SharpDX.Direct2D1.RectangleGeometry rectangleGeometry)
        {
            unsafe
            {
                IntPtr rectangleGeometry_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &rectangle, &rectangleGeometry_, ((void**)(*(void**)_nativePointer))[5]);
                ((SharpDX.Direct2D1.RectangleGeometry)rectangleGeometry).NativePointer = rectangleGeometry_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates an <strong><see cref="SharpDX.Direct2D1.RoundedRectangleGeometry"/></strong>. </p>	
        /// </summary>	
        /// <param name="roundedRectangle">No documentation.</param>	
        /// <param name="roundedRectangleGeometry">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::CreateRoundedRectangleGeometry']/*"/>	
        /// <msdn-id>dd371292</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory::CreateRoundedRectangleGeometry([In] const D2D1_ROUNDED_RECT* roundedRectangle,[Out, Fast] ID2D1RoundedRectangleGeometry** roundedRectangleGeometry)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::CreateRoundedRectangleGeometry</unmanaged-short>	
        internal void CreateRoundedRectangleGeometry(ref SharpDX.Direct2D1.RoundedRectangle roundedRectangle, SharpDX.Direct2D1.RoundedRectangleGeometry roundedRectangleGeometry)
        {
            unsafe
            {
                IntPtr roundedRectangleGeometry_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* roundedRectangle_ = &roundedRectangle)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, roundedRectangle_, &roundedRectangleGeometry_, ((void**)(*(void**)_nativePointer))[6]);
                ((SharpDX.Direct2D1.RoundedRectangleGeometry)roundedRectangleGeometry).NativePointer = roundedRectangleGeometry_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// Creates an <strong><see cref="SharpDX.Direct2D1.EllipseGeometry"/></strong>.	
        /// </summary>	
        /// <param name="ellipse">No documentation.</param>	
        /// <param name="ellipseGeometry">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::CreateEllipseGeometry']/*"/>	
        /// <msdn-id>dd742725</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory::CreateEllipseGeometry([In] const D2D1_ELLIPSE* ellipse,[Out, Fast] ID2D1EllipseGeometry** ellipseGeometry)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::CreateEllipseGeometry</unmanaged-short>	
        internal void CreateEllipseGeometry(SharpDX.Direct2D1.Ellipse ellipse, SharpDX.Direct2D1.EllipseGeometry ellipseGeometry)
        {
            unsafe
            {
                IntPtr ellipseGeometry_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &ellipse, &ellipseGeometry_, ((void**)(*(void**)_nativePointer))[7]);
                ((SharpDX.Direct2D1.EllipseGeometry)ellipseGeometry).NativePointer = ellipseGeometry_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.Direct2D1.GeometryGroup"/></strong>, which is an object that holds other geometries.</p>	
        /// </summary>	
        /// <param name="fillMode">No documentation.</param>	
        /// <param name="geometries">No documentation.</param>	
        /// <param name="geometriesCount">No documentation.</param>	
        /// <param name="geometryGroup">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Geometry groups are a convenient way to group several geometries simultaneously so all figures of several distinct geometries are concatenated into one. To create a  <strong><see cref="SharpDX.Direct2D1.GeometryGroup"/></strong> object, call  the <strong>CreateGeometryGroup</strong> method on the <strong><see cref="SharpDX.Direct2D1.Factory"/></strong> object, passing in the <em>fillMode</em> with possible values of   <strong><see cref="SharpDX.Direct2D1.FillMode.Alternate"/></strong> (alternate) and <strong><see cref="SharpDX.Direct2D1.FillMode.Winding"/></strong>, an array of geometry objects to add to the geometry group, and the number of elements in this array. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::CreateGeometryGroup']/*"/>	
        /// <msdn-id>dd371273</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory::CreateGeometryGroup([In] D2D1_FILL_MODE fillMode,[In, Buffer] ID2D1Geometry** geometries,[In] unsigned int geometriesCount,[Out, Fast] ID2D1GeometryGroup** geometryGroup)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::CreateGeometryGroup</unmanaged-short>	
        internal void CreateGeometryGroup(SharpDX.Direct2D1.FillMode fillMode, SharpDX.Direct2D1.Geometry[] geometries, int geometriesCount, SharpDX.Direct2D1.GeometryGroup geometryGroup)
        {
            unsafe
            {
                IntPtr* geometries_ = (IntPtr*)0;
                if (geometries != null)
                {
                    IntPtr* geometries__ = stackalloc IntPtr[geometries.Length];
                    geometries_ = geometries__;
                    for (int i = 0; i < geometries.Length; i++)
                        geometries_[i] = (geometries[i] == null) ? IntPtr.Zero : geometries[i].NativePointer;
                }
                IntPtr geometryGroup_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)fillMode), geometries_, geometriesCount, &geometryGroup_, ((void**)(*(void**)_nativePointer))[8]);
                ((SharpDX.Direct2D1.GeometryGroup)geometryGroup).NativePointer = geometryGroup_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.Direct2D1.GeometryGroup"/></strong>, which is an object that holds other geometries.</p>	
        /// </summary>	
        /// <param name="fillMode">No documentation.</param>	
        /// <param name="geometries">No documentation.</param>	
        /// <param name="geometriesCount">No documentation.</param>	
        /// <param name="geometryGroup">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Geometry groups are a convenient way to group several geometries simultaneously so all figures of several distinct geometries are concatenated into one. To create a  <strong><see cref="SharpDX.Direct2D1.GeometryGroup"/></strong> object, call  the <strong>CreateGeometryGroup</strong> method on the <strong><see cref="SharpDX.Direct2D1.Factory"/></strong> object, passing in the <em>fillMode</em> with possible values of   <strong><see cref="SharpDX.Direct2D1.FillMode.Alternate"/></strong> (alternate) and <strong><see cref="SharpDX.Direct2D1.FillMode.Winding"/></strong>, an array of geometry objects to add to the geometry group, and the number of elements in this array. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::CreateGeometryGroup']/*"/>	
        /// <msdn-id>dd371273</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory::CreateGeometryGroup([In] D2D1_FILL_MODE fillMode,[In, Buffer] ID2D1Geometry** geometries,[In] unsigned int geometriesCount,[Out, Fast] ID2D1GeometryGroup** geometryGroup)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::CreateGeometryGroup</unmanaged-short>	
        internal void CreateGeometryGroup(SharpDX.Direct2D1.FillMode fillMode, SharpDX.ComArray<SharpDX.Direct2D1.Geometry> geometries, int geometriesCount, SharpDX.Direct2D1.GeometryGroup geometryGroup)
        {
            unsafe
            {
                IntPtr geometryGroup_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)fillMode), (void*)((geometries == null) ? IntPtr.Zero : geometries.NativePointer), geometriesCount, &geometryGroup_, ((void**)(*(void**)_nativePointer))[8]);
                ((SharpDX.Direct2D1.GeometryGroup)geometryGroup).NativePointer = geometryGroup_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.Direct2D1.GeometryGroup"/></strong>, which is an object that holds other geometries.</p>	
        /// </summary>	
        /// <param name="fillMode">No documentation.</param>	
        /// <param name="geometries">No documentation.</param>	
        /// <param name="geometriesCount">No documentation.</param>	
        /// <param name="geometryGroup">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Geometry groups are a convenient way to group several geometries simultaneously so all figures of several distinct geometries are concatenated into one. To create a  <strong><see cref="SharpDX.Direct2D1.GeometryGroup"/></strong> object, call  the <strong>CreateGeometryGroup</strong> method on the <strong><see cref="SharpDX.Direct2D1.Factory"/></strong> object, passing in the <em>fillMode</em> with possible values of   <strong><see cref="SharpDX.Direct2D1.FillMode.Alternate"/></strong> (alternate) and <strong><see cref="SharpDX.Direct2D1.FillMode.Winding"/></strong>, an array of geometry objects to add to the geometry group, and the number of elements in this array. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::CreateGeometryGroup']/*"/>	
        /// <msdn-id>dd371273</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory::CreateGeometryGroup([In] D2D1_FILL_MODE fillMode,[In, Buffer] ID2D1Geometry** geometries,[In] unsigned int geometriesCount,[Out, Fast] ID2D1GeometryGroup** geometryGroup)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::CreateGeometryGroup</unmanaged-short>	
        private void CreateGeometryGroup(SharpDX.Direct2D1.FillMode fillMode, System.IntPtr geometries, int geometriesCount, System.IntPtr geometryGroup)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)fillMode), (void*)geometries, geometriesCount, (void*)geometryGroup, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Transforms the specified geometry and stores the result as an <strong><see cref="SharpDX.Direct2D1.TransformedGeometry"/></strong> object.  </p>	
        /// </summary>	
        /// <param name="sourceGeometry">No documentation.</param>	
        /// <param name="transform">No documentation.</param>	
        /// <param name="transformedGeometry">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Like other resources, a transformed geometry inherits the resource space and threading policy of the factory that created it. This object is immutable.</p><p>When stroking a transformed geometry with the <strong>DrawGeometry</strong> method, the stroke width is not affected by the transform applied to the geometry.  The stroke width is only affected by the world transform.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::CreateTransformedGeometry']/*"/>	
        /// <msdn-id>dd371304</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory::CreateTransformedGeometry([In] ID2D1Geometry* sourceGeometry,[In] const D2D_MATRIX_3X2_F* transform,[Out, Fast] ID2D1TransformedGeometry** transformedGeometry)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::CreateTransformedGeometry</unmanaged-short>	
        internal void CreateTransformedGeometry(SharpDX.Direct2D1.Geometry sourceGeometry, ref SharpDX.Mathematics.Interop.RawMatrix3x2 transform, SharpDX.Direct2D1.TransformedGeometry transformedGeometry)
        {
            unsafe
            {
                IntPtr transformedGeometry_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* transform_ = &transform)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((sourceGeometry == null) ? IntPtr.Zero : sourceGeometry.NativePointer), transform_, &transformedGeometry_, ((void**)(*(void**)_nativePointer))[9]);
                ((SharpDX.Direct2D1.TransformedGeometry)transformedGeometry).NativePointer = transformedGeometry_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an empty <strong><see cref="SharpDX.Direct2D1.PathGeometry"/></strong>.</p>	
        /// </summary>	
        /// <param name="athGeometryRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::CreatePathGeometry']/*"/>	
        /// <msdn-id>dd371282</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory::CreatePathGeometry([Out, Fast] ID2D1PathGeometry** pathGeometry)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::CreatePathGeometry</unmanaged-short>	
        internal void CreatePathGeometry(SharpDX.Direct2D1.PathGeometry athGeometryRef)
        {
            unsafe
            {
                IntPtr athGeometryRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &athGeometryRef_, ((void**)(*(void**)_nativePointer))[10]);
                ((SharpDX.Direct2D1.PathGeometry)athGeometryRef).NativePointer = athGeometryRef_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates an <strong><see cref="SharpDX.Direct2D1.StrokeStyle"/></strong> that describes start cap, dash pattern, and other features of a stroke.</p>	
        /// </summary>	
        /// <param name="strokeStyleProperties">No documentation.</param>	
        /// <param name="dashes">No documentation.</param>	
        /// <param name="dashesCount">No documentation.</param>	
        /// <param name="strokeStyle">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::CreateStrokeStyle']/*"/>	
        /// <msdn-id>dd371301</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory::CreateStrokeStyle([In] const D2D1_STROKE_STYLE_PROPERTIES* strokeStyleProperties,[In, Buffer, Optional] const float* dashes,[In] unsigned int dashesCount,[Out, Fast] ID2D1StrokeStyle** strokeStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::CreateStrokeStyle</unmanaged-short>	
        internal void CreateStrokeStyle(ref SharpDX.Direct2D1.StrokeStyleProperties strokeStyleProperties, float[] dashes, int dashesCount, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            unsafe
            {
                float[] dashes__ = dashes;
                IntPtr strokeStyle_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* strokeStyleProperties_ = &strokeStyleProperties)
                    fixed (void* dashes_ = dashes__)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, strokeStyleProperties_, dashes_, dashesCount, &strokeStyle_, ((void**)(*(void**)_nativePointer))[11]);
                ((SharpDX.Direct2D1.StrokeStyle)strokeStyle).NativePointer = strokeStyle_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.Direct2D1.DrawingStateBlock"/></strong> that can be used with the <strong>SaveDrawingState</strong> and <strong>RestoreDrawingState</strong> methods of a render target.</p>	
        /// </summary>	
        /// <param name="drawingStateDescription">No documentation.</param>	
        /// <param name="textRenderingParams">No documentation.</param>	
        /// <param name="drawingStateBlock">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::CreateDrawingStateBlock']/*"/>	
        /// <msdn-id>dd371252</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory::CreateDrawingStateBlock([In, Optional] const D2D1_DRAWING_STATE_DESCRIPTION* drawingStateDescription,[In, Optional] IDWriteRenderingParams* textRenderingParams,[Out, Fast] ID2D1DrawingStateBlock** drawingStateBlock)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::CreateDrawingStateBlock</unmanaged-short>	
        internal void CreateDrawingStateBlock(SharpDX.Direct2D1.DrawingStateDescription? drawingStateDescription, SharpDX.DirectWrite.RenderingParams textRenderingParams, SharpDX.Direct2D1.DrawingStateBlock drawingStateBlock)
        {
            unsafe
            {
                SharpDX.Direct2D1.DrawingStateDescription drawingStateDescription_;
                if (drawingStateDescription.HasValue)
                    drawingStateDescription_ = drawingStateDescription.Value;
                IntPtr drawingStateBlock_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (drawingStateDescription.HasValue) ? &drawingStateDescription_ : (void*)IntPtr.Zero, (void*)((textRenderingParams == null) ? IntPtr.Zero : textRenderingParams.NativePointer), &drawingStateBlock_, ((void**)(*(void**)_nativePointer))[12]);
                ((SharpDX.Direct2D1.DrawingStateBlock)drawingStateBlock).NativePointer = drawingStateBlock_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a render target that renders to a Microsoft Windows Imaging Component (WIC)  bitmap.</p>	
        /// </summary>	
        /// <param name="target"><dd>  <p>The bitmap that receives the rendering output of the render target.</p> </dd></param>	
        /// <param name="renderTargetProperties"><dd>  <p>The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering. For information about supported pixel formats, see  Supported Pixel  Formats and Alpha Modes.</p> </dd></param>	
        /// <param name="renderTarget"><dd>  <p>When this method returns, contains the address of the reference to the <strong><see cref="SharpDX.Direct2D1.RenderTarget"/></strong> object created by this method. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>You must use <strong><see cref="SharpDX.Direct2D1.FeatureLevel.Level_DEFAULT"/></strong> for the <strong>minLevel</strong> member of the  <em>renderTargetProperties</em> parameter with this method.</p><p>Your application should create render targets once and hold onto them for the life of the application or until the <strong><see cref="SharpDX.Direct2D1.ResultCode.RecreateTarget"/></strong> error is received. When you receive this error, you need to recreate the render target (and any resources it created).</p><ul> <li></li> </ul>  <p><strong>Note</strong>??  This method isn't supported on Windows Phone and will fail when called on a device with error code 0x8899000b  (?There is no hardware rendering device available for this operation?). Because the Windows Phone Emulator supports WARP rendering,  this method will fail when called on the emulator with a different error code, 0x88982f80  (wincodec_err_unsupportedpixelformat).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::CreateWicBitmapRenderTarget']/*"/>	
        /// <msdn-id>dd371309</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory::CreateWicBitmapRenderTarget([In] IWICBitmap* target,[In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,[Out, Fast] ID2D1RenderTarget** renderTarget)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::CreateWicBitmapRenderTarget</unmanaged-short>	
        internal void CreateWicBitmapRenderTarget(SharpDX.WIC.Bitmap target, ref SharpDX.Direct2D1.RenderTargetProperties renderTargetProperties, SharpDX.Direct2D1.RenderTarget renderTarget)
        {
            unsafe
            {
                IntPtr renderTarget_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* renderTargetProperties_ = &renderTargetProperties)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((target == null) ? IntPtr.Zero : target.NativePointer), renderTargetProperties_, &renderTarget_, ((void**)(*(void**)_nativePointer))[13]);
                ((SharpDX.Direct2D1.RenderTarget)renderTarget).NativePointer = renderTarget_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.Direct2D1.WindowRenderTarget"/></strong>, a render target that renders to a window.</p>	
        /// </summary>	
        /// <param name="renderTargetProperties">No documentation.</param>	
        /// <param name="hwndRenderTargetProperties">No documentation.</param>	
        /// <param name="hwndRenderTarget">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>When you create a render target and hardware acceleration is available, you allocate resources on the computer's GPU. By creating a render target once and retaining it as long as possible, you gain performance benefits. Your application should create render targets once and hold onto them for the life of the application or until the <strong><see cref="SharpDX.Direct2D1.ResultCode.RecreateTarget"/></strong> error is received. When you receive this error, you need to recreate the render target (and any resources it created).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::CreateHwndRenderTarget']/*"/>	
        /// <msdn-id>dd371279</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory::CreateHwndRenderTarget([In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,[In] const D2D1_HWND_RENDER_TARGET_PROPERTIES* hwndRenderTargetProperties,[Out, Fast] ID2D1HwndRenderTarget** hwndRenderTarget)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::CreateHwndRenderTarget</unmanaged-short>	
        internal void CreateHwndRenderTarget(ref SharpDX.Direct2D1.RenderTargetProperties renderTargetProperties, SharpDX.Direct2D1.HwndRenderTargetProperties hwndRenderTargetProperties, SharpDX.Direct2D1.WindowRenderTarget hwndRenderTarget)
        {
            unsafe
            {
                IntPtr hwndRenderTarget_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* renderTargetProperties_ = &renderTargetProperties)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, renderTargetProperties_, &hwndRenderTargetProperties, &hwndRenderTarget_, ((void**)(*(void**)_nativePointer))[14]);
                ((SharpDX.Direct2D1.WindowRenderTarget)hwndRenderTarget).NativePointer = hwndRenderTarget_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a render target that draws to a DirectX Graphics Infrastructure (DXGI) surface.  </p>	
        /// </summary>	
        /// <param name="dxgiSurface"><dd>  <p>The <see cref="SharpDX.DXGI.Surface"/> to which the render target will draw.</p> </dd></param>	
        /// <param name="renderTargetProperties"><dd>  <p>The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering. For information about supported pixel formats, see  Supported Pixel  Formats and Alpha Modes.</p> </dd></param>	
        /// <param name="renderTarget"><dd>  <p>When this method returns, contains the address of the reference to the <strong><see cref="SharpDX.Direct2D1.RenderTarget"/></strong> object created by this method.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To write to a Direct3D surface, you obtain an <see cref="SharpDX.DXGI.Surface"/> and pass it to the <strong>CreateDxgiSurfaceRenderTarget</strong> method to create a DXGI surface render target; you can then use the DXGI surface render target to draw 2-D content to the DXGI surface.  </p><p>A DXGI surface render target is a type of <strong><see cref="SharpDX.Direct2D1.RenderTarget"/></strong>. Like other Direct2D render targets, you can use it to create resources and issue drawing commands. </p><p>The DXGI surface render target and the DXGI surface must use the same DXGI format. If you specify the DXGI_FORMAT_UNKOWN format when you create the render target, it will automatically use the surface's format.</p><p>The DXGI surface render target does not perform DXGI surface synchronization. </p><p>For more information about creating and using DXGI surface render targets, see the Direct2D and Direct3D Interoperability Overview.</p><p>To work with Direct2D, the Direct3D device that provides the <see cref="SharpDX.DXGI.Surface"/> must be created with the <strong>D3D10_CREATE_DEVICE_BGRA_SUPPORT</strong> flag.</p><p>When you create a render target and hardware acceleration is available, you allocate resources on the computer's GPU. By creating a render target once and retaining it as long as possible, you gain performance benefits. Your application should create render targets once and hold onto them for the life of the application or until the render target's <strong>EndDraw</strong> method returns the <strong><see cref="SharpDX.Direct2D1.ResultCode.RecreateTarget"/></strong> error. When you receive this error, you need to recreate the render target (and any resources it created). </p><p></p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::CreateDxgiSurfaceRenderTarget']/*"/>	
        /// <msdn-id>dd371264</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory::CreateDxgiSurfaceRenderTarget([In] IDXGISurface* dxgiSurface,[In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,[Out, Fast] ID2D1RenderTarget** renderTarget)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::CreateDxgiSurfaceRenderTarget</unmanaged-short>	
        internal void CreateDxgiSurfaceRenderTarget(SharpDX.DXGI.Surface dxgiSurface, ref SharpDX.Direct2D1.RenderTargetProperties renderTargetProperties, SharpDX.Direct2D1.RenderTarget renderTarget)
        {
            unsafe
            {
                IntPtr renderTarget_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* renderTargetProperties_ = &renderTargetProperties)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((dxgiSurface == null) ? IntPtr.Zero : dxgiSurface.NativePointer), renderTargetProperties_, &renderTarget_, ((void**)(*(void**)_nativePointer))[15]);
                ((SharpDX.Direct2D1.RenderTarget)renderTarget).NativePointer = renderTarget_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a render target that draws to a Windows Graphics Device Interface (GDI) device context.</p>	
        /// </summary>	
        /// <param name="renderTargetProperties"><dd>  <p>The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering.  To enable the device context (DC) render target to work with GDI, set the DXGI format to <see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm"/> and the alpha mode to <strong><see cref="SharpDX.Direct2D1.AlphaMode.Premultiplied"/></strong> or <strong><see cref="SharpDX.Direct2D1.AlphaMode.Ignore"/></strong>. For more information about pixel formats, see  Supported Pixel  Formats and Alpha Modes.</p> </dd></param>	
        /// <param name="dcRenderTarget"><dd>  <p>When this method returns, <em>dcRenderTarget</em> contains the address of the reference to the  <strong><see cref="SharpDX.Direct2D1.DeviceContextRenderTarget"/></strong> created by the method.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Before you can render with a DC render target, you must use the render target's <strong>BindDC</strong> method to associate it with a GDI DC.  Do this for each different DC and whenever there is a change in the size of the area you want to draw to.</p><p>To enable the DC render target to work with GDI, set the render target's DXGI format to <see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm"/> and alpha mode to <strong><see cref="SharpDX.Direct2D1.AlphaMode.Premultiplied"/></strong> or <strong><see cref="SharpDX.Direct2D1.AlphaMode.Ignore"/></strong>.</p><p>Your application should create render targets once and hold on to them for the life of the application or until the render target's  <strong>EndDraw</strong> method returns the <strong><see cref="SharpDX.Direct2D1.ResultCode.RecreateTarget"/></strong> error. When you receive this error, recreate the render target (and any resources it created).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory::CreateDCRenderTarget']/*"/>	
        /// <msdn-id>dd371248</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory::CreateDCRenderTarget([In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,[Out, Fast] ID2D1DCRenderTarget** dcRenderTarget)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory::CreateDCRenderTarget</unmanaged-short>	
        internal void CreateDCRenderTarget(ref SharpDX.Direct2D1.RenderTargetProperties renderTargetProperties, SharpDX.Direct2D1.DeviceContextRenderTarget dcRenderTarget)
        {
            unsafe
            {
                IntPtr dcRenderTarget_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* renderTargetProperties_ = &renderTargetProperties)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, renderTargetProperties_, &dcRenderTarget_, ((void**)(*(void**)_nativePointer))[16]);
                ((SharpDX.Direct2D1.DeviceContextRenderTarget)dcRenderTarget).NativePointer = dcRenderTarget_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Creates Direct2D resources.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct2D1.Factory1"/></strong> interface is used to create devices, register and unregister effects, and enumerate effects properties. Effects are registered and unregistered globally. The registration APIs are placed on this interface for convenience.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory1']/*"/>	
    /// <msdn-id>hh404596</msdn-id>	
    /// <unmanaged>ID2D1Factory1</unmanaged>	
    /// <unmanaged-short>ID2D1Factory1</unmanaged-short>	
    [Guid("bb12d362-daee-4b9a-aa1d-14ba401cfa1f")]
    public partial class Factory1 : SharpDX.Direct2D1.Factory
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Factory1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Factory1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Factory1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Factory1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Factory1(nativePointer);
        }


        /// <summary>	
        /// <p>Creates a device that represents a display adapter.  </p>	
        /// </summary>	
        /// <param name="dxgiDevice"><dd>  <p>The <strong><see cref="SharpDX.DXGI.Device"/></strong> object used when creating  the <strong><see cref="SharpDX.Direct2D1.Device"/></strong>. </p> </dd></param>	
        /// <param name="d2dDevice"><dd>  <p>The requested <strong><see cref="SharpDX.Direct2D1.Device"/></strong> object.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The Direct2D device defines a resource domain in which a set of Direct2D objects and Direct2D device contexts can be used together.  Each call to <strong>CreateDevice</strong> returns a unique <strong><see cref="SharpDX.Direct2D1.Device"/></strong> object, even if you pass the same <strong><see cref="SharpDX.DXGI.Device"/></strong> multiple times.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory1::CreateDevice']/*"/>	
        /// <msdn-id>hh404599</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory1::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out, Fast] ID2D1Device** d2dDevice)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory1::CreateDevice</unmanaged-short>	
        internal void CreateDevice(SharpDX.DXGI.Device dxgiDevice, SharpDX.Direct2D1.Device d2dDevice)
        {
            unsafe
            {
                IntPtr d2dDevice_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((dxgiDevice == null) ? IntPtr.Zero : dxgiDevice.NativePointer), &d2dDevice_, ((void**)(*(void**)_nativePointer))[17]);
                ((SharpDX.Direct2D1.Device)d2dDevice).NativePointer = d2dDevice_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a <strong><see cref="SharpDX.Direct2D1.StrokeStyle1"/></strong> object.</p>	
        /// </summary>	
        /// <param name="strokeStyleProperties">No documentation.</param>	
        /// <param name="dashes">No documentation.</param>	
        /// <param name="dashesCount">No documentation.</param>	
        /// <param name="strokeStyle">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>It is valid to specify a dash array only if <see cref="SharpDX.Direct2D1.DashStyle.Custom"/> is also specified.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory1::CreateStrokeStyle']/*"/>	
        /// <msdn-id>hh404605</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory1::CreateStrokeStyle([In] const D2D1_STROKE_STYLE_PROPERTIES1* strokeStyleProperties,[In, Buffer, Optional] const float* dashes,[In] unsigned int dashesCount,[Out, Fast] ID2D1StrokeStyle1** strokeStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory1::CreateStrokeStyle</unmanaged-short>	
        internal void CreateStrokeStyle(ref SharpDX.Direct2D1.StrokeStyleProperties1 strokeStyleProperties, float[] dashes, int dashesCount, SharpDX.Direct2D1.StrokeStyle1 strokeStyle)
        {
            unsafe
            {
                float[] dashes__ = dashes;
                IntPtr strokeStyle_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* strokeStyleProperties_ = &strokeStyleProperties)
                    fixed (void* dashes_ = dashes__)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, strokeStyleProperties_, dashes_, dashesCount, &strokeStyle_, ((void**)(*(void**)_nativePointer))[18]);
                ((SharpDX.Direct2D1.StrokeStyle1)strokeStyle).NativePointer = strokeStyle_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.Direct2D1.PathGeometry1"/></strong> object.</p>	
        /// </summary>	
        /// <param name="athGeometryRef">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory1::CreatePathGeometry']/*"/>	
        /// <msdn-id>hh404602</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory1::CreatePathGeometry([Out, Fast] ID2D1PathGeometry1** pathGeometry)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory1::CreatePathGeometry</unmanaged-short>	
        internal void CreatePathGeometry(SharpDX.Direct2D1.PathGeometry1 athGeometryRef)
        {
            unsafe
            {
                IntPtr athGeometryRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &athGeometryRef_, ((void**)(*(void**)_nativePointer))[19]);
                ((SharpDX.Direct2D1.PathGeometry1)athGeometryRef).NativePointer = athGeometryRef_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a new drawing state block, this can be used in subsequent SaveDrawingState and RestoreDrawingState operations on the render target.</p>	
        /// </summary>	
        /// <param name="drawingStateDescription"><dd>  <p>The drawing state description structure.</p> </dd></param>	
        /// <param name="textRenderingParams"><dd>  <p>The DirectWrite rendering params interface.</p> </dd></param>	
        /// <param name="drawingStateBlock"><dd>  <p>The address of the newly created drawing state block.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory1::CreateDrawingStateBlock']/*"/>	
        /// <msdn-id>hh847994</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory1::CreateDrawingStateBlock([In, Optional] const D2D1_DRAWING_STATE_DESCRIPTION1* drawingStateDescription,[In, Optional] IDWriteRenderingParams* textRenderingParams,[Out, Fast] ID2D1DrawingStateBlock1** drawingStateBlock)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory1::CreateDrawingStateBlock</unmanaged-short>	
        internal void CreateDrawingStateBlock(SharpDX.Direct2D1.DrawingStateDescription1? drawingStateDescription, SharpDX.DirectWrite.RenderingParams textRenderingParams, SharpDX.Direct2D1.DrawingStateBlock1 drawingStateBlock)
        {
            unsafe
            {
                SharpDX.Direct2D1.DrawingStateDescription1 drawingStateDescription_;
                if (drawingStateDescription.HasValue)
                    drawingStateDescription_ = drawingStateDescription.Value;
                IntPtr drawingStateBlock_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (drawingStateDescription.HasValue) ? &drawingStateDescription_ : (void*)IntPtr.Zero, (void*)((textRenderingParams == null) ? IntPtr.Zero : textRenderingParams.NativePointer), &drawingStateBlock_, ((void**)(*(void**)_nativePointer))[20]);
                ((SharpDX.Direct2D1.DrawingStateBlock1)drawingStateBlock).NativePointer = drawingStateBlock_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a new <strong><see cref="SharpDX.Direct2D1.GdiMetafile"/></strong> object that you can use to replay metafile content. </p>	
        /// </summary>	
        /// <param name="metafileStream">No documentation.</param>	
        /// <param name="metafile">No documentation.</param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory1::CreateGdiMetafile']/*"/>	
        /// <msdn-id>hh847995</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory1::CreateGdiMetafile([In] IStream* metafileStream,[Out] ID2D1GdiMetafile** metafile)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory1::CreateGdiMetafile</unmanaged-short>	
        internal void CreateGdiMetafile_(System.IntPtr metafileStream, out SharpDX.Direct2D1.GdiMetafile metafile)
        {
            unsafe
            {
                IntPtr metafile_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)metafileStream, &metafile_, ((void**)(*(void**)_nativePointer))[21]);
                metafile = (metafile_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.GdiMetafile(metafile_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Registers an effect within the factory instance with the property XML specified as a stream.</p>	
        /// </summary>	
        /// <param name="classId"><dd>  <p>The identifier of the effect to be registered.</p> </dd></param>	
        /// <param name="ropertyXmlRef"><dd>  <p>A list of the effect properties, types, and metadata.</p> </dd></param>	
        /// <param name="bindings"><dd>  <p>An array of properties and methods.</p> <p>This binds a property by name to a particular method implemented by the effect author to handle the property. The name must be found in the corresponding <em>propertyXml</em>.</p> </dd></param>	
        /// <param name="bindingsCount"><dd>  <p>The number of bindings in the binding array.</p> </dd></param>	
        /// <param name="effectFactory"><dd>  <p>The static factory that is used to create the corresponding effect.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Direct2D effects must define their properties at registration time via registration XML. An effect declares several required system properties, and can also declare custom properties. See Custom Effect Creation and Registration for more information about formatting the <em>propertyXml</em> parameter.</p><p> <strong>RegisterEffect</strong> is both atomic and reference counted. To unregister an effect, call <strong>UnregisterEffect</strong> with the  <em>classId</em> of the effect. </p><p><strong>Important</strong>??<strong>RegisterEffect</strong> does not hold a reference to the DLL or executable file in which the effect is contained. The application must independently  make sure that the lifetime of the DLL or executable file completely contains all instances of each registered and created effect.</p><p>Aside from the built-in effects that are globally registered, this API registers effects only for this factory, derived device, and device context interfaces.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory1::RegisterEffectFromStream']/*"/>	
        /// <msdn-id>hh847996</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory1::RegisterEffectFromStream([In] const GUID&amp; classId,[In] IStream* propertyXml,[In, Buffer, Optional] const D2D1_PROPERTY_BINDING* bindings,[In] unsigned int bindingsCount,[In] const __function__stdcall* effectFactory)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory1::RegisterEffectFromStream</unmanaged-short>	
        internal void RegisterEffectFromStream_(System.Guid classId, System.IntPtr ropertyXmlRef, SharpDX.Direct2D1.PropertyBinding[] bindings, int bindingsCount, SharpDX.FunctionCallback effectFactory)
        {
            unsafe
            {
                SharpDX.Direct2D1.PropertyBinding.__Native[] bindings__ = (bindings == null) ? null : new SharpDX.Direct2D1.PropertyBinding.__Native[bindings.Length];
                if (bindings != null)
                    for (int i = 0; i < bindings.Length; i++)
                        bindings[i].__MarshalTo(ref bindings__[i]);
                SharpDX.Result __result__;
                fixed (void* bindings_ = bindings__)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &classId, (void*)ropertyXmlRef, bindings_, bindingsCount, effectFactory, ((void**)(*(void**)_nativePointer))[22]);
                if (bindings != null)
                    for (int i = 0; i < bindings.Length; i++)
                        bindings[i].__MarshalFree(ref bindings__[i]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Registers an effect within the factory instance with the property XML specified as a string.</p>	
        /// </summary>	
        /// <param name="classId"><dd>  <p>The identifier of the effect to be registered.</p> </dd></param>	
        /// <param name="ropertyXmlRef"><dd>  <p>A list of the effect properties, types, and metadata.</p> </dd></param>	
        /// <param name="bindings"><dd>  <p>An array of properties and methods.</p> <p>This binds a property by name to a particular method implemented by the effect author to handle the property. The name must be found in the corresponding <em>propertyXml</em>.</p> </dd></param>	
        /// <param name="bindingsCount"><dd>  <p>The number of bindings in the binding array.</p> </dd></param>	
        /// <param name="effectFactory"><dd>  <p>The static factory that is used to create the corresponding effect.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Direct2D effects must define their properties at registration time via registration XML. An effect declares several required system properties, and can also declare custom properties. See Custom Effect Creation and Registration for more information about formatting the <em>propertyXml</em> parameter.</p><p><strong>RegisterEffect</strong> is both atomic and reference counted. To unregister an effect, call <strong>UnregisterEffect</strong> with the  <em>classId</em> of the effect. </p><p><strong>Important</strong>??<strong>RegisterEffect</strong> does not hold a reference to the DLL or executable file in which the effect is contained. The application must independently  make sure that the lifetime of the DLL or executable file completely contains all instances of each registered and created effect.</p><p>Aside from the built-in effects that are globally registered, this API registers effects only for this factory and derived device and device context interfaces.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory1::RegisterEffectFromString']/*"/>	
        /// <msdn-id>hh404614</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory1::RegisterEffectFromString([In] const GUID&amp; classId,[In] const wchar_t* propertyXml,[In, Buffer, Optional] const D2D1_PROPERTY_BINDING* bindings,[In] unsigned int bindingsCount,[In] const __function__stdcall* effectFactory)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory1::RegisterEffectFromString</unmanaged-short>	
        internal void RegisterEffectFromString(System.Guid classId, string ropertyXmlRef, SharpDX.Direct2D1.PropertyBinding[] bindings, int bindingsCount, SharpDX.FunctionCallback effectFactory)
        {
            unsafe
            {
                IntPtr ropertyXmlRef_ = Utilities.StringToHGlobalUni(ropertyXmlRef);
                SharpDX.Direct2D1.PropertyBinding.__Native[] bindings__ = (bindings == null) ? null : new SharpDX.Direct2D1.PropertyBinding.__Native[bindings.Length];
                if (bindings != null)
                    for (int i = 0; i < bindings.Length; i++)
                        bindings[i].__MarshalTo(ref bindings__[i]);
                SharpDX.Result __result__;
                fixed (void* bindings_ = bindings__)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &classId, (void*)ropertyXmlRef_, bindings_, bindingsCount, effectFactory, ((void**)(*(void**)_nativePointer))[23]);
                Marshal.FreeHGlobal(ropertyXmlRef_);
                if (bindings != null)
                    for (int i = 0; i < bindings.Length; i++)
                        bindings[i].__MarshalFree(ref bindings__[i]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Unregisters an  effect within the factory instance that corresponds to the <em>classId</em> provided. </p>	
        /// </summary>	
        /// <param name="classId"><dd>  <p>The identifier of the effect to be unregistered.</p> </dd></param>	
        /// <returns><p><see cref="SharpDX.Direct2D1.ResultCode.EffectIsNotRegistered"/> if the effect is not registered, <see cref="SharpDX.Result.Ok"/> otherwise.</p></returns>	
        /// <remarks>	
        /// <p>In order for the effect to be fully unloaded, you must call <strong>UnregisterEffect</strong> the same number of times that you have registered the effect.</p><p>The <strong>UnregisterEffect</strong> method unregisters only those effects that are registered on the same factory. It cannot be used to unregister a built-in effect.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory1::UnregisterEffect']/*"/>	
        /// <msdn-id>hh404617</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory1::UnregisterEffect([In] const GUID&amp; classId)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory1::UnregisterEffect</unmanaged-short>	
        internal void UnregisterEffect(System.Guid classId)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &classId, ((void**)(*(void**)_nativePointer))[24]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Returns the class IDs of the currently registered effects and global effects on this factory.</p>	
        /// </summary>	
        /// <param name="effects"><dd>  <p>When this method returns, contains an array of effects. <strong><c>null</c></strong> if no effects are retrieved.</p> </dd></param>	
        /// <param name="effectsCount"><dd>  <p>The capacity of the <em>effects</em> array.</p> </dd></param>	
        /// <param name="effectsReturned"><dd>  <p>When this method returns, contains the  number of effects copied into <em>effects</em>.</p> </dd></param>	
        /// <param name="effectsRegistered"><dd>  <p>When this method returns, contains the number of effects currently registered in the system.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>HRESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.InsufficientBuffer"/>)</td><td><em>effectsRegistered</em> is larger than <em>effectCount</em>.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The set of class IDs will be atomically returned by the API. The set will not be interrupted by other threads registering or unregistering effects.</p><p>If <em>effectsRegistered</em> is larger than <em>effectCount</em>, the supplied array will still be filled to capacity with the current set of registered effects. This method returns the CLSIDs for all global effects and all effects registered to this factory.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory1::GetRegisteredEffects']/*"/>	
        /// <msdn-id>hh404612</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory1::GetRegisteredEffects([Out, Buffer, Optional] GUID* effects,[In] unsigned int effectsCount,[Out, Optional] unsigned int* effectsReturned,[Out, Optional] unsigned int* effectsRegistered)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory1::GetRegisteredEffects</unmanaged-short>	
        internal void GetRegisteredEffects(System.Guid[] effects, int effectsCount, out int effectsReturned, out int effectsRegistered)
        {
            unsafe
            {
                System.Guid[] effects__ = effects;
                SharpDX.Result __result__;
                fixed (void* effects_ = effects__)
                    fixed (void* effectsReturned_ = &effectsReturned)
                        fixed (void* effectsRegistered_ = &effectsRegistered)
                            __result__ =
                            SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, effects_, effectsCount, effectsReturned_, effectsRegistered_, ((void**)(*(void**)_nativePointer))[25]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Retrieves the properties of an effect.</p>	
        /// </summary>	
        /// <param name="effectId"><dd>  <p>The ID of the effect to retrieve properties from.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains the address of a reference to the property interface that can be used to query the metadata of the effect.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The returned effect properties will have all the mutable properties for the effect set to a default of <strong><c>null</c></strong>, or an  empty value. </p><ul> <li>Value types will be zero-filled.</li> <li>Blob and string types will be zero-length.</li> <li>Array types will have length 1 and the element of the array will conform to the previous rules.</li> </ul><p>This method cannot be used to return the properties for any effect not visible to <strong><see cref="SharpDX.Direct2D1.DeviceContext.CreateEffect"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory1::GetEffectProperties']/*"/>	
        /// <msdn-id>hh404608</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory1::GetEffectProperties([In] const GUID&amp; effectId,[Out] ID2D1Properties** properties)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory1::GetEffectProperties</unmanaged-short>	
        public SharpDX.Direct2D1.Properties GetEffectProperties(System.Guid effectId)
        {
            unsafe
            {
                SharpDX.Direct2D1.Properties ropertiesRef;
                IntPtr ropertiesRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &effectId, &ropertiesRef_, ((void**)(*(void**)_nativePointer))[26]);
                ropertiesRef = (ropertiesRef_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.Properties(ropertiesRef_);
                __result__.CheckError();
                return ropertiesRef;
            }
        }
    }
    /// <summary>	
    /// <p>Creates Direct2D resources.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct2D1.Factory"/></strong> interface is the starting point for using Direct2D; it's what you use to create other Direct2D resources that you can use to draw or describe shapes.   </p><p>A factory defines a set of Create<em>Resource</em> methods that can produce the following drawing resources:</p><p> </p><ul> <li>Render targets: objects that render drawing commands.</li> <li>Drawing state blocks: objects that store drawing state information, such as the current transformation and antialiasing mode.</li> <li>Geometries: objects that represent simple and potentially complex shapes.</li> </ul><p>To create an <strong><see cref="SharpDX.Direct2D1.Factory"/></strong>, you use one of the <strong>CreateFactory</strong> methods. You should retain the <strong><see cref="SharpDX.Direct2D1.Factory"/></strong> instance for as long as you use Direct2D resources; in general, you shouldn't need to recreate it when the application is running. For more information about Direct2D resources, see the Resources Overview.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory2']/*"/>	
    /// <msdn-id>dd371246</msdn-id>	
    /// <unmanaged>ID2D1Factory2</unmanaged>	
    /// <unmanaged-short>ID2D1Factory2</unmanaged-short>	
    [Guid("94f81a73-9212-4376-9c58-b16a3a0d3992")]
    public partial class Factory2 : SharpDX.Direct2D1.Factory1
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Factory2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Factory2(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Factory2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Factory2(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Factory2(nativePointer);
        }


        /// <summary>	
        /// <p>In this topic you will learn about creating Direct2D <strong>device context</strong> in Windows?8. This information applies to you if you are developing Windows Store apps or a desktop app by using Direct2D. This topic describes the purpose of Direct2D device context objects, how to create that object , and a step by step guide about rendering and displaying Direct2D primitives and images. You will also learn about switching render targets and adding effects to your app.</p><p> </p><ul> <li>What</li> <li>What</li> <li>Rendering</li> <li>Why</li> <li>How</li> <li>Selecting</li> <li>How</li> </ul>	
        /// </summary>	
        /// <param name="dxgiDevice">No documentation.</param>	
        /// <param name="d2dDevice1">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory2::CreateDevice']/*"/>	
        /// <msdn-id>hh780339</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory2::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out, Fast] ID2D1Device1** d2dDevice1)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory2::CreateDevice</unmanaged-short>	
        internal void CreateDevice(SharpDX.DXGI.Device dxgiDevice, SharpDX.Direct2D1.Device1 d2dDevice1)
        {
            unsafe
            {
                IntPtr d2dDevice1_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((dxgiDevice == null) ? IntPtr.Zero : dxgiDevice.NativePointer), &d2dDevice1_, ((void**)(*(void**)_nativePointer))[27]);
                ((SharpDX.Direct2D1.Device1)d2dDevice1).NativePointer = d2dDevice1_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Creates Direct2D resources. This interface also enables the creation of <strong><see cref="SharpDX.Direct2D1.Device2"/></strong> objects.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory3']/*"/>	
    /// <msdn-id>dn900394</msdn-id>	
    /// <unmanaged>ID2D1Factory3</unmanaged>	
    /// <unmanaged-short>ID2D1Factory3</unmanaged-short>	
    [Guid("0869759f-4f00-413f-b03e-2bda45404d0f")]
    public partial class Factory3 : SharpDX.Direct2D1.Factory2
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Factory3"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Factory3(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Factory3"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Factory3(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Factory3(nativePointer);
        }


        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.Direct2D1.Device2"/></strong> object that represents a display adapter. </p>	
        /// </summary>	
        /// <param name="dxgiDevice">No documentation.</param>	
        /// <param name="d2dDevice2">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Factory3::CreateDevice']/*"/>	
        /// <msdn-id>dn900395</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Factory3::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out, Fast] ID2D1Device2** d2dDevice2)</unmanaged>	
        /// <unmanaged-short>ID2D1Factory3::CreateDevice</unmanaged-short>	
        internal void CreateDevice(SharpDX.DXGI.Device dxgiDevice, SharpDX.Direct2D1.Device2 d2dDevice2)
        {
            unsafe
            {
                IntPtr d2dDevice2_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((dxgiDevice == null) ? IntPtr.Zero : dxgiDevice.NativePointer), &d2dDevice2_, ((void**)(*(void**)_nativePointer))[28]);
                ((SharpDX.Direct2D1.Device2)d2dDevice2).NativePointer = d2dDevice2_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides access to an device context that can accept GDI drawing commands. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>You don't create an <strong><see cref="SharpDX.Direct2D1.GdiInteropRenderTarget"/></strong> object directly; instead, you use the <strong>QueryInterface</strong> method of an existing render target instance to provide an <strong><see cref="SharpDX.Direct2D1.GdiInteropRenderTarget"/></strong> version of that render target. </p><p>Not all render targets support the <strong><see cref="SharpDX.Direct2D1.GdiInteropRenderTarget"/></strong> interface. The render target must be GDI-compatible (the <strong><see cref="SharpDX.Direct2D1.RenderTargetUsage.GdiCompatible"/></strong> flag was specified when creating the render target), use the <see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm"/> pixel format, and use  the <strong><see cref="SharpDX.Direct2D1.AlphaMode.Premultiplied"/></strong> or <strong><see cref="SharpDX.Direct2D1.AlphaMode.Ignore"/></strong> alpha mode.</p><p>Note that the <strong>QueryInterface</strong> method always succeeds; if the render target doesn't support the <strong><see cref="SharpDX.Direct2D1.GdiInteropRenderTarget"/></strong> interface, calling <strong>GetDC</strong> will fail. (For render targets created through the <strong>CreateCompatibleRenderTarget</strong> method, the render target that created it must have these settings.) </p><p>To test whether a given render target supports the <strong><see cref="SharpDX.Direct2D1.GdiInteropRenderTarget"/></strong> interface, create a <strong><see cref="SharpDX.Direct2D1.RenderTargetProperties"/> </strong>that specifies GDI compatibility and the appropriate pixel format, then call the render target's <strong>IsSupported</strong> method to see whether the render target is GDI-compatible. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiInteropRenderTarget']/*"/>	
    /// <msdn-id>dd371321</msdn-id>	
    /// <unmanaged>ID2D1GdiInteropRenderTarget</unmanaged>	
    /// <unmanaged-short>ID2D1GdiInteropRenderTarget</unmanaged-short>	
    [Guid("e0db51c3-6f77-4bae-b3d5-e47509b35838")]
    public partial class GdiInteropRenderTarget : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.GdiInteropRenderTarget"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public GdiInteropRenderTarget(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.GdiInteropRenderTarget"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.GdiInteropRenderTarget(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.GdiInteropRenderTarget(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves the device context associated with this render target. </p>	
        /// </summary>	
        /// <param name="mode"><dd>  <p>A value that specifies whether the device context should be cleared.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains the device context associated with this render target. You must allocate storage for this parameter.  </p> </dd></returns>	
        /// <remarks>	
        /// <p>Calling this method flushes the render target.</p><p>This command can be called only after <strong>BeginDraw</strong> and before <strong>EndDraw</strong>. </p><p><strong>Note</strong>??In Windows?7 and earlier, you should not call <strong>GetDC</strong> between <strong>PushAxisAlignedClip</strong>/<strong>PopAxisAlignedClip</strong> commands or between <strong>PushLayer</strong>/<strong>PopLayer</strong>.  However, this restriction does not apply to Windows?8 and later.</p><p> <strong>ReleaseDC</strong> must be called once for each call to <strong>GetDC</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiInteropRenderTarget::GetDC']/*"/>	
        /// <msdn-id>dd371323</msdn-id>	
        /// <unmanaged>HRESULT ID2D1GdiInteropRenderTarget::GetDC([In] D2D1_DC_INITIALIZE_MODE mode,[Out] HDC* hdc)</unmanaged>	
        /// <unmanaged-short>ID2D1GdiInteropRenderTarget::GetDC</unmanaged-short>	
        public System.IntPtr GetDC(SharpDX.Direct2D1.DeviceContextInitializeMode mode)
        {
            unsafe
            {
                System.IntPtr hdc;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)mode), &hdc, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
                return hdc;
            }
        }

        /// <summary>	
        /// <p>Indicates that drawing with the device context retrieved using the <strong>GetDC</strong> method is finished.  </p>	
        /// </summary>	
        /// <param name="update">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><strong>ReleaseDC</strong> must be called once for each call to <strong>GetDC</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiInteropRenderTarget::ReleaseDC']/*"/>	
        /// <msdn-id>dd371327</msdn-id>	
        /// <unmanaged>HRESULT ID2D1GdiInteropRenderTarget::ReleaseDC([In, Optional] const RECT* update)</unmanaged>	
        /// <unmanaged-short>ID2D1GdiInteropRenderTarget::ReleaseDC</unmanaged-short>	
        public void ReleaseDC(SharpDX.Mathematics.Interop.RawRectangle? update)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangle update_;
                if (update.HasValue)
                    update_ = update.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (update.HasValue) ? &update_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A Direct2D resource that wraps a WMF, EMF, or EMF+ metafile.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafile']/*"/>	
    /// <msdn-id>hh871460</msdn-id>	
    /// <unmanaged>ID2D1GdiMetafile</unmanaged>	
    /// <unmanaged-short>ID2D1GdiMetafile</unmanaged-short>	
    [Guid("2f543dc3-cfc1-4211-864f-cfd91c6f3395")]
    public partial class GdiMetafile : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.GdiMetafile"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public GdiMetafile(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.GdiMetafile"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.GdiMetafile(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.GdiMetafile(nativePointer);
        }


        /// <summary>	
        /// <p> Gets the bounds of the metafile, in device-independent pixels (DIPs), as reported in the metafile?s header.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafile::GetBounds']/*"/>	
        /// <msdn-id>hh871463</msdn-id>	
        /// <unmanaged>GetBounds</unmanaged>	
        /// <unmanaged-short>GetBounds</unmanaged-short>	
        /// <unmanaged>HRESULT ID2D1GdiMetafile::GetBounds([Out] D2D_RECT_F* bounds)</unmanaged>
        public SharpDX.Mathematics.Interop.RawRectangleF Bounds
        {
            get { SharpDX.Mathematics.Interop.RawRectangleF __output__; GetBounds(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>This method streams the contents of the command  to the given metafile  sink. </p>	
        /// </summary>	
        /// <param name="sink"><dd>  <p>The sink into which Direct2D  will call back.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafile::Stream']/*"/>	
        /// <msdn-id>hh871464</msdn-id>	
        /// <unmanaged>HRESULT ID2D1GdiMetafile::Stream([In] ID2D1GdiMetafileSink* sink)</unmanaged>	
        /// <unmanaged-short>ID2D1GdiMetafile::Stream</unmanaged-short>	
        internal void Stream_(System.IntPtr sink)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)sink, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the bounds of the metafile, in device-independent pixels (DIPs), as reported in the metafile?s header.</p>	
        /// </summary>	
        /// <param name="bounds"><dd>  <p>The bounds, in DIPs, of the metafile.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafile::GetBounds']/*"/>	
        /// <msdn-id>hh871463</msdn-id>	
        /// <unmanaged>HRESULT ID2D1GdiMetafile::GetBounds([Out] D2D_RECT_F* bounds)</unmanaged>	
        /// <unmanaged-short>ID2D1GdiMetafile::GetBounds</unmanaged-short>	
        internal void GetBounds(out SharpDX.Mathematics.Interop.RawRectangleF bounds)
        {
            unsafe
            {
                bounds = new SharpDX.Mathematics.Interop.RawRectangleF();
                SharpDX.Result __result__;
                fixed (void* bounds_ = &bounds)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, bounds_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>This interface performs all the same functions as the existing <see cref="SharpDX.Direct2D1.GdiMetafile"/> interface. It also enables accessing the metafile DPI and bounds.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafile1']/*"/>	
    /// <msdn-id>dn900400</msdn-id>	
    /// <unmanaged>ID2D1GdiMetafile1</unmanaged>	
    /// <unmanaged-short>ID2D1GdiMetafile1</unmanaged-short>	
    [Guid("2e69f9e8-dd3f-4bf9-95ba-c04f49d788df")]
    public partial class GdiMetafile1 : SharpDX.Direct2D1.GdiMetafile
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.GdiMetafile1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public GdiMetafile1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.GdiMetafile1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.GdiMetafile1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.GdiMetafile1(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the bounds of the metafile in source space in DIPs. This corresponds       to the frame rect in an EMF/EMF+.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafile1::GetSourceBounds']/*"/>	
        /// <msdn-id>dn900402</msdn-id>	
        /// <unmanaged>GetSourceBounds</unmanaged>	
        /// <unmanaged-short>GetSourceBounds</unmanaged-short>	
        /// <unmanaged>HRESULT ID2D1GdiMetafile1::GetSourceBounds([Out] D2D_RECT_F* bounds)</unmanaged>
        public SharpDX.Mathematics.Interop.RawRectangleF SourceBounds
        {
            get { SharpDX.Mathematics.Interop.RawRectangleF __output__; GetSourceBounds(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets the DPI reported by the metafile.</p>	
        /// </summary>	
        /// <param name="dpiX"><dd>  <p>Receives the horizontal DPI reported by the metafile.</p> </dd></param>	
        /// <param name="dpiY"><dd>  <p>Receives the vertical DPI reported by the metafile.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafile1::GetDpi']/*"/>	
        /// <msdn-id>dn900401</msdn-id>	
        /// <unmanaged>HRESULT ID2D1GdiMetafile1::GetDpi([Out] float* dpiX,[Out] float* dpiY)</unmanaged>	
        /// <unmanaged-short>ID2D1GdiMetafile1::GetDpi</unmanaged-short>	
        public void GetDpi(out float dpiX, out float dpiY)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* dpiX_ = &dpiX)
                    fixed (void* dpiY_ = &dpiY)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, dpiX_, dpiY_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the bounds of the metafile in source space in DIPs. This corresponds       to the frame rect in an EMF/EMF+.</p>	
        /// </summary>	
        /// <param name="bounds"><dd>  <p>The bounds, in DIPs, of the metafile.</p> </dd></param>	
        /// <returns><p><see cref="SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref="SharpDX.Result"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafile1::GetSourceBounds']/*"/>	
        /// <msdn-id>dn900402</msdn-id>	
        /// <unmanaged>HRESULT ID2D1GdiMetafile1::GetSourceBounds([Out] D2D_RECT_F* bounds)</unmanaged>	
        /// <unmanaged-short>ID2D1GdiMetafile1::GetSourceBounds</unmanaged-short>	
        internal void GetSourceBounds(out SharpDX.Mathematics.Interop.RawRectangleF bounds)
        {
            unsafe
            {
                bounds = new SharpDX.Mathematics.Interop.RawRectangleF();
                SharpDX.Result __result__;
                fixed (void* bounds_ = &bounds)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, bounds_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A developer implemented interface that allows a metafile to be replayed.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafileSink']/*"/>	
    /// <msdn-id>hh871461</msdn-id>	
    /// <unmanaged>ID2D1GdiMetafileSink</unmanaged>	
    /// <unmanaged-short>ID2D1GdiMetafileSink</unmanaged-short>	
    [Guid("82237326-8111-4f7c-bcf4-b5c1175564fe")]
    public partial interface GdiMetafileSink : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p> This method is called once for each record stored in a metafile.</p>	
        /// </summary>	
        /// <param name="recordType"><dd>  <p>The type of the record.</p> </dd></param>	
        /// <param name="recordData"><dd>  <p>The data for the record.</p> </dd></param>	
        /// <param name="recordDataSize"><dd>  <p>The byte size of the record data.</p> </dd></param>	
        /// <returns><p>Return true if the record is successfully.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafileSink::ProcessRecord']/*"/>	
        /// <msdn-id>hh871462</msdn-id>	
        /// <unmanaged>HRESULT ID2D1GdiMetafileSink::ProcessRecord([In] unsigned int recordType,[In, Optional] const void* recordData,[In] unsigned int recordDataSize)</unmanaged>	
        /// <unmanaged-short>ID2D1GdiMetafileSink::ProcessRecord</unmanaged-short>	
        /* public void ProcessRecord(int recordType, System.IntPtr recordData, int recordDataSize) */
    }
    /// <summary>	
    /// <p>This interface performs all the same functions as the existing <see cref="SharpDX.Direct2D1.GdiMetafileSink"/> interface. It also enables access to metafile records.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafileSink1']/*"/>	
    /// <msdn-id>dn900403</msdn-id>	
    /// <unmanaged>ID2D1GdiMetafileSink1</unmanaged>	
    /// <unmanaged-short>ID2D1GdiMetafileSink1</unmanaged-short>	
    [Guid("fd0ecb6b-91e6-411e-8655-395e760f91b4")]
    public partial interface GdiMetafileSink1 : SharpDX.Direct2D1.GdiMetafileSink
    {


        /// <summary>	
        /// <p>Provides access to metafile records, including their type, data, and flags.</p>	
        /// </summary>	
        /// <param name="recordType"><dd>  <p>The type of metafile record being processed. Please see MS-EMF and MS-EMFPLUS for a list of record types.</p> </dd></param>	
        /// <param name="recordData"><dd>  <p>The data contained in this record. Please see MS-EMF and MS-EMFPLUS for information on record data layouts.</p> </dd></param>	
        /// <param name="recordDataSize"><dd>  <p>TThe size of the data pointed to by recordData. </p> </dd></param>	
        /// <param name="flags"><dd>  <p>The set of flags set for this record. Please see MS-EMF and MS-EMFPLUS for information on record flags.</p> </dd></param>	
        /// <returns><p><see cref="SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref="SharpDX.Result"/>.</p></returns>	
        /// <remarks>	
        /// <p>For details on the EMF and EMF+ formats, please see Microsoft technical documents  MS-EMF and MS-EMFPLUS.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafileSink1::ProcessRecord']/*"/>	
        /// <msdn-id>dn900404</msdn-id>	
        /// <unmanaged>HRESULT ID2D1GdiMetafileSink1::ProcessRecord([In] unsigned int recordType,[In, Optional] const void* recordData,[In] unsigned int recordDataSize,[In] unsigned int flags)</unmanaged>	
        /// <unmanaged-short>ID2D1GdiMetafileSink1::ProcessRecord</unmanaged-short>	
        /* public void ProcessRecord(int recordType, System.IntPtr recordData, int recordDataSize, int flags) */
    }
    /// <summary>	
    /// <p>This interface performs all the same functions as the existing <see cref="SharpDX.Direct2D1.GdiMetafileSink"/> interface. It also enables access to metafile records.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafileSink1']/*"/>	
    /// <msdn-id>dn900403</msdn-id>	
    /// <unmanaged>ID2D1GdiMetafileSink1</unmanaged>	
    /// <unmanaged-short>ID2D1GdiMetafileSink1</unmanaged-short>	
    [Guid("fd0ecb6b-91e6-411e-8655-395e760f91b4")]
    internal partial class GdiMetafileSink1Native : SharpDX.Direct2D1.GdiMetafileSinkNative, SharpDX.Direct2D1.GdiMetafileSink1
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.GdiMetafileSink1Native"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public GdiMetafileSink1Native(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.GdiMetafileSink1Native"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.GdiMetafileSink1Native(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.GdiMetafileSink1Native(nativePointer);
        }


        /// <summary>	
        /// <p>Provides access to metafile records, including their type, data, and flags.</p>	
        /// </summary>	
        /// <param name="recordType"><dd>  <p>The type of metafile record being processed. Please see MS-EMF and MS-EMFPLUS for a list of record types.</p> </dd></param>	
        /// <param name="recordData"><dd>  <p>The data contained in this record. Please see MS-EMF and MS-EMFPLUS for information on record data layouts.</p> </dd></param>	
        /// <param name="recordDataSize"><dd>  <p>TThe size of the data pointed to by recordData. </p> </dd></param>	
        /// <param name="flags"><dd>  <p>The set of flags set for this record. Please see MS-EMF and MS-EMFPLUS for information on record flags.</p> </dd></param>	
        /// <returns><p><see cref="SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref="SharpDX.Result"/>.</p></returns>	
        /// <remarks>	
        /// <p>For details on the EMF and EMF+ formats, please see Microsoft technical documents  MS-EMF and MS-EMFPLUS.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafileSink1::ProcessRecord']/*"/>	
        /// <msdn-id>dn900404</msdn-id>	
        /// <unmanaged>HRESULT ID2D1GdiMetafileSink1::ProcessRecord([In] unsigned int recordType,[In, Optional] const void* recordData,[In] unsigned int recordDataSize,[In] unsigned int flags)</unmanaged>	
        /// <unmanaged-short>ID2D1GdiMetafileSink1::ProcessRecord</unmanaged-short>	
        internal void ProcessRecord_(int recordType, System.IntPtr recordData, int recordDataSize, int flags)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, recordType, (void*)recordData, recordDataSize, flags, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A developer implemented interface that allows a metafile to be replayed.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafileSink']/*"/>	
    /// <msdn-id>hh871461</msdn-id>	
    /// <unmanaged>ID2D1GdiMetafileSink</unmanaged>	
    /// <unmanaged-short>ID2D1GdiMetafileSink</unmanaged-short>	
    [Guid("82237326-8111-4f7c-bcf4-b5c1175564fe")]
    internal partial class GdiMetafileSinkNative : SharpDX.ComObjectCallback, SharpDX.Direct2D1.GdiMetafileSink
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.GdiMetafileSinkNative"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public GdiMetafileSinkNative(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.GdiMetafileSinkNative"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.GdiMetafileSinkNative(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.GdiMetafileSinkNative(nativePointer);
        }


        /// <summary>	
        /// <p> This method is called once for each record stored in a metafile.</p>	
        /// </summary>	
        /// <param name="recordType"><dd>  <p>The type of the record.</p> </dd></param>	
        /// <param name="recordData"><dd>  <p>The data for the record.</p> </dd></param>	
        /// <param name="recordDataSize"><dd>  <p>The byte size of the record data.</p> </dd></param>	
        /// <returns><p>Return true if the record is successfully.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GdiMetafileSink::ProcessRecord']/*"/>	
        /// <msdn-id>hh871462</msdn-id>	
        /// <unmanaged>HRESULT ID2D1GdiMetafileSink::ProcessRecord([In] unsigned int recordType,[In, Optional] const void* recordData,[In] unsigned int recordDataSize)</unmanaged>	
        /// <unmanaged-short>ID2D1GdiMetafileSink::ProcessRecord</unmanaged-short>	
        internal void ProcessRecord_(int recordType, System.IntPtr recordData, int recordDataSize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, recordType, (void*)recordData, recordDataSize, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a geometry resource and defines a set of helper methods for manipulating and measuring geometric shapes.  Interfaces that inherit from <strong><see cref="SharpDX.Direct2D1.Geometry"/></strong> define specific shapes.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>There are several types of Direct2D geometry objects:  a  simple geometry (<strong><see cref="SharpDX.Direct2D1.RectangleGeometry"/></strong>, <strong><see cref="SharpDX.Direct2D1.RoundedRectangleGeometry"/></strong>, or <strong><see cref="SharpDX.Direct2D1.EllipseGeometry"/></strong>), a path geometry (<strong><see cref="SharpDX.Direct2D1.PathGeometry"/></strong>), or a composite geometry (<strong><see cref="SharpDX.Direct2D1.GeometryGroup"/></strong> and <strong><see cref="SharpDX.Direct2D1.TransformedGeometry"/></strong>).</p><p> Direct2D geometries enable you to  describe two-dimensional figures and also offer  many uses, such as defining  hit-test regions,  clip regions, and even   animation paths.</p><p>Direct2D geometries are immutable and device-independent resources created by <strong><see cref="SharpDX.Direct2D1.Factory"/></strong>.  In general, you should create geometries once and retain them for the life of the application, or until they need to be modified. For more information about device-independent and device-dependent resources, see  the Resources Overview.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Geometry']/*"/>	
    /// <msdn-id>dd316578</msdn-id>	
    /// <unmanaged>ID2D1Geometry</unmanaged>	
    /// <unmanaged-short>ID2D1Geometry</unmanaged-short>	
    [Guid("2cd906a1-12e2-11dc-9fed-001143a055f9")]
    public partial class Geometry : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Geometry"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Geometry(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Geometry"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Geometry(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Geometry(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves the bounds of the geometry.</p>	
        /// </summary>	
        /// <param name="worldTransform"><dd>  <p>The transform to apply to this geometry before calculating its bounds, or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains the bounds of this geometry. If the bounds are empty, this parameter will be a rect where <em>bounds.left</em> &gt; <em>bounds.right</em>. You must allocate storage for this parameter.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Geometry::GetBounds']/*"/>	
        /// <msdn-id>dd316699</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Geometry::GetBounds([In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[Out] D2D_RECT_F* bounds)</unmanaged>	
        /// <unmanaged-short>ID2D1Geometry::GetBounds</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawRectangleF GetBounds(SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;
                SharpDX.Mathematics.Interop.RawRectangleF bounds;
                bounds = new SharpDX.Mathematics.Interop.RawRectangleF();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (worldTransform.HasValue) ? &worldTransform_ : (void*)IntPtr.Zero, &bounds, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
                return bounds;
            }
        }

        /// <summary>	
        /// <p>Gets the bounds of the geometry after it has been widened by the specified stroke width and style and transformed by the specified matrix.</p>	
        /// </summary>	
        /// <param name="strokeWidth"><dd>  <p>The amount by which to widen the geometry by stroking its outline.</p> </dd></param>	
        /// <param name="strokeStyle"><dd>  <p>The style of the stroke that widens the geometry.</p> </dd></param>	
        /// <param name="worldTransform"><dd>  <p>A transform to apply to the geometry after the geometry is transformed and after the geometry has been stroked.</p> </dd></param>	
        /// <param name="flatteningTolerance"><dd>  <p>When this method returns, contains the bounds of the widened geometry. You must allocate storage for this parameter.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains the bounds of the widened geometry. You must allocate storage for this parameter.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Geometry::GetWidenedBounds']/*"/>	
        /// <msdn-id>dd316714</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Geometry::GetWidenedBounds([In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] D2D_RECT_F* bounds)</unmanaged>	
        /// <unmanaged-short>ID2D1Geometry::GetWidenedBounds</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawRectangleF GetWidenedBounds(float strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, float flatteningTolerance)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;
                SharpDX.Mathematics.Interop.RawRectangleF bounds;
                bounds = new SharpDX.Mathematics.Interop.RawRectangleF();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, strokeWidth, (void*)((strokeStyle == null) ? IntPtr.Zero : strokeStyle.NativePointer), (worldTransform.HasValue) ? &worldTransform_ : (void*)IntPtr.Zero, flatteningTolerance, &bounds, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
                return bounds;
            }
        }

        /// <summary>	
        /// <p>Determines whether the geometry's stroke contains the specified point given the specified stroke thickness, style, and transform. </p>	
        /// </summary>	
        /// <param name="point"><dd>  <p>The point to test for containment.</p> </dd></param>	
        /// <param name="strokeWidth"><dd>  <p>The thickness of the stroke to apply.</p> </dd></param>	
        /// <param name="strokeStyle"><dd>  <p>The style of stroke to apply.</p> </dd></param>	
        /// <param name="worldTransform"><dd>  <p>The transform to apply to the stroked geometry. </p> </dd></param>	
        /// <param name="flatteningTolerance"><dd>  <p>When this method returns, contains a boolean value set to true if the geometry's stroke contains the specified point; otherwise, false. You must allocate storage for this parameter.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains a boolean value set to true if the geometry's stroke contains the specified point; otherwise, false. You must allocate storage for this parameter.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Geometry::StrokeContainsPoint']/*"/>	
        /// <msdn-id>dd316742</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Geometry::StrokeContainsPoint([In] D2D_POINT_2F point,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>	
        /// <unmanaged-short>ID2D1Geometry::StrokeContainsPoint</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool StrokeContainsPoint(SharpDX.Mathematics.Interop.RawVector2 point, float strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, float flatteningTolerance)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;
                SharpDX.Mathematics.Interop.RawBool contains;
                contains = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint6(_nativePointer, point, strokeWidth, (void*)((strokeStyle == null) ? IntPtr.Zero : strokeStyle.NativePointer), (worldTransform.HasValue) ? &worldTransform_ : (void*)IntPtr.Zero, flatteningTolerance, &contains, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
                return contains;
            }
        }

        /// <summary>	
        /// <p>Indicates whether the area filled by the geometry would contain the specified point given the specified flattening tolerance. </p>	
        /// </summary>	
        /// <param name="point"><dd>  <p>The point to test.</p> </dd></param>	
        /// <param name="worldTransform"><dd>  <p>The transform to apply to the geometry prior to testing for containment, or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="flatteningTolerance"><dd>  <p>The numeric accuracy with which the precise geometric path and path intersection is calculated. Points missing the fill by less than the tolerance are still considered inside.  Smaller values produce more accurate results but cause slower execution. </p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains a <strong><see cref="SharpDX.Mathematics.Interop.RawBool"/></strong> value that is <strong>TRUE</strong> if the area filled by the geometry contains <em>point</em>; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.You must allocate storage for this parameter.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Geometry::FillContainsPoint']/*"/>	
        /// <msdn-id>dd316687</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Geometry::FillContainsPoint([In] D2D_POINT_2F point,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>	
        /// <unmanaged-short>ID2D1Geometry::FillContainsPoint</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool FillContainsPoint(SharpDX.Mathematics.Interop.RawVector2 point, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, float flatteningTolerance)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;
                SharpDX.Mathematics.Interop.RawBool contains;
                contains = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint7(_nativePointer, point, (worldTransform.HasValue) ? &worldTransform_ : (void*)IntPtr.Zero, flatteningTolerance, &contains, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
                return contains;
            }
        }

        /// <summary>	
        /// <p>Describes the intersection between this geometry and the specified geometry. The comparison is performed by using the specified flattening tolerance.</p>	
        /// </summary>	
        /// <param name="inputGeometry"><dd>  <p>The geometry to test. </p> </dd></param>	
        /// <param name="inputGeometryTransform"><dd>  <p>The transform to apply to <em>inputGeometry</em>, or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="flatteningTolerance"><dd>  <p>The maximum error allowed when constructing a polygonal approximation of the geometry. No point in the polygonal representation will diverge from the original geometry by more than the flattening tolerance. Smaller values produce more accurate results but cause slower execution.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains a reference to a value that describes how this geometry is related to <em>inputGeometry</em>. You must allocate storage for this parameter.  </p> </dd></returns>	
        /// <remarks>	
        /// <p>When interpreting the returned <em>relation</em> value, it is important to remember that the member <strong><see cref="SharpDX.Direct2D1.GeometryRelation.IsContained"/></strong> of the  <strong><see cref="SharpDX.Direct2D1.GeometryRelation"/></strong> enumeration type means that this geometry is contained  inside <em>inputGeometry</em>, not that this geometry contains <em>inputGeometry</em>. </p><p>For  more information about how to interpret other possible return values, see <strong><see cref="SharpDX.Direct2D1.GeometryRelation"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Geometry::CompareWithGeometry']/*"/>	
        /// <msdn-id>dd316630</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Geometry::CompareWithGeometry([In] ID2D1Geometry* inputGeometry,[In, Optional] const D2D_MATRIX_3X2_F* inputGeometryTransform,[In] float flatteningTolerance,[Out] D2D1_GEOMETRY_RELATION* relation)</unmanaged>	
        /// <unmanaged-short>ID2D1Geometry::CompareWithGeometry</unmanaged-short>	
        public SharpDX.Direct2D1.GeometryRelation Compare(SharpDX.Direct2D1.Geometry inputGeometry, SharpDX.Mathematics.Interop.RawMatrix3x2? inputGeometryTransform, float flatteningTolerance)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 inputGeometryTransform_;
                if (inputGeometryTransform.HasValue)
                    inputGeometryTransform_ = inputGeometryTransform.Value;
                SharpDX.Direct2D1.GeometryRelation relation;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((inputGeometry == null) ? IntPtr.Zero : inputGeometry.NativePointer), (inputGeometryTransform.HasValue) ? &inputGeometryTransform_ : (void*)IntPtr.Zero, flatteningTolerance, &relation, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
                return relation;
            }
        }

        /// <summary>	
        /// <p>Creates a simplified version of the geometry that contains only lines and (optionally) cubic Bezier curves and writes the result to an <strong><see cref="SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong>.</p>	
        /// </summary>	
        /// <param name="simplificationOption">No documentation.</param>	
        /// <param name="worldTransform">No documentation.</param>	
        /// <param name="flatteningTolerance">No documentation.</param>	
        /// <param name="geometrySink">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Geometry::Simplify']/*"/>	
        /// <msdn-id>dd316730</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Geometry::Simplify([In] D2D1_GEOMETRY_SIMPLIFICATION_OPTION simplificationOption,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>	
        /// <unmanaged-short>ID2D1Geometry::Simplify</unmanaged-short>	
        internal void Simplify_(SharpDX.Direct2D1.GeometrySimplificationOption simplificationOption, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, float flatteningTolerance, System.IntPtr geometrySink)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)simplificationOption), (worldTransform.HasValue) ? &worldTransform_ : (void*)IntPtr.Zero, flatteningTolerance, (void*)geometrySink, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a set of clockwise-wound triangles that cover the geometry after it has been transformed using the specified matrix and flattened using the default tolerance.</p>	
        /// </summary>	
        /// <param name="worldTransform"><dd>  <p>The transform to apply to this geometry.</p> </dd></param>	
        /// <param name="flatteningTolerance"><dd>  <p>The <strong><see cref="SharpDX.Direct2D1.TessellationSink"/></strong> to which the tessellated is appended.</p> </dd></param>	
        /// <param name="tessellationSink"><dd>  <p>The <strong><see cref="SharpDX.Direct2D1.TessellationSink"/></strong> to which the tessellated is appended.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Geometry::Tessellate']/*"/>	
        /// <msdn-id>dd316762</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Geometry::Tessellate([In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[In] ID2D1TessellationSink* tessellationSink)</unmanaged>	
        /// <unmanaged-short>ID2D1Geometry::Tessellate</unmanaged-short>	
        internal void Tessellate_(SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, float flatteningTolerance, System.IntPtr tessellationSink)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (worldTransform.HasValue) ? &worldTransform_ : (void*)IntPtr.Zero, flatteningTolerance, (void*)tessellationSink, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Combines this geometry with the specified geometry and stores the result in an <strong><see cref="SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong>.</p>	
        /// </summary>	
        /// <param name="inputGeometry">No documentation.</param>	
        /// <param name="combineMode">No documentation.</param>	
        /// <param name="inputGeometryTransform">No documentation.</param>	
        /// <param name="flatteningTolerance">No documentation.</param>	
        /// <param name="geometrySink">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Geometry::CombineWithGeometry']/*"/>	
        /// <msdn-id>dd316627</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Geometry::CombineWithGeometry([In] ID2D1Geometry* inputGeometry,[In] D2D1_COMBINE_MODE combineMode,[In, Optional] const D2D_MATRIX_3X2_F* inputGeometryTransform,[In] float flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>	
        /// <unmanaged-short>ID2D1Geometry::CombineWithGeometry</unmanaged-short>	
        internal void Combine_(SharpDX.Direct2D1.Geometry inputGeometry, SharpDX.Direct2D1.CombineMode combineMode, SharpDX.Mathematics.Interop.RawMatrix3x2? inputGeometryTransform, float flatteningTolerance, System.IntPtr geometrySink)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 inputGeometryTransform_;
                if (inputGeometryTransform.HasValue)
                    inputGeometryTransform_ = inputGeometryTransform.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((inputGeometry == null) ? IntPtr.Zero : inputGeometry.NativePointer), unchecked((int)combineMode), (inputGeometryTransform.HasValue) ? &inputGeometryTransform_ : (void*)IntPtr.Zero, flatteningTolerance, (void*)geometrySink, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Computes the outline of the geometry and writes the result to an <strong><see cref="SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong>. </p>	
        /// </summary>	
        /// <param name="worldTransform">No documentation.</param>	
        /// <param name="flatteningTolerance">No documentation.</param>	
        /// <param name="geometrySink">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <strong>Outline</strong> method allows the caller to produce a geometry with an equivalent fill to the input geometry, with the following additional properties: </p><ul> <li>The output geometry contains no transverse intersections; that is, segments may touch, but they never cross.</li> <li>The outermost figures in the output geometry are all oriented counterclockwise. </li> <li>The output geometry is fill-mode invariant; that is, the fill of the geometry does not depend on the choice of the fill mode. For more information about the fill mode, see <strong><see cref="SharpDX.Direct2D1.FillMode"/></strong>.</li> </ul><p>Additionally, the  <strong>Outline</strong> method can be useful in removing redundant portions of said geometries to simplify complex geometries. It can also be useful in combination with <strong><see cref="SharpDX.Direct2D1.GeometryGroup"/></strong> to create unions among several geometries simultaneously.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Geometry::Outline']/*"/>	
        /// <msdn-id>dd316725</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Geometry::Outline([In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>	
        /// <unmanaged-short>ID2D1Geometry::Outline</unmanaged-short>	
        internal void Outline_(SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, float flatteningTolerance, System.IntPtr geometrySink)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (worldTransform.HasValue) ? &worldTransform_ : (void*)IntPtr.Zero, flatteningTolerance, (void*)geometrySink, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Computes the area of the geometry after it has been transformed by the specified matrix and flattened using the specified tolerance.</p>	
        /// </summary>	
        /// <param name="worldTransform"><dd>  <p>The transform to apply to this geometry before computing its area, or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="flatteningTolerance"><dd>  <p>The maximum error allowed when constructing a polygonal approximation of the geometry. No point in the polygonal representation will diverge from the original geometry by more than the flattening tolerance. Smaller values produce more accurate results but cause slower execution. </p> </dd></param>	
        /// <returns><dd>  <p>When this this method returns, contains a reference to the area of the transformed, flattened version of this geometry. You must allocate storage for this parameter.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Geometry::ComputeArea']/*"/>	
        /// <msdn-id>dd316641</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Geometry::ComputeArea([In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] float* area)</unmanaged>	
        /// <unmanaged-short>ID2D1Geometry::ComputeArea</unmanaged-short>	
        public float ComputeArea(SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, float flatteningTolerance)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;
                float area;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (worldTransform.HasValue) ? &worldTransform_ : (void*)IntPtr.Zero, flatteningTolerance, &area, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
                return area;
            }
        }

        /// <summary>	
        /// Calculates the length of the geometry as though each segment were unrolled into a line.	
        /// </summary>	
        /// <param name="worldTransform">No documentation.</param>	
        /// <param name="flatteningTolerance">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Geometry::ComputeLength']/*"/>	
        /// <msdn-id>dd742744</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Geometry::ComputeLength([In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] float* length)</unmanaged>	
        /// <unmanaged-short>ID2D1Geometry::ComputeLength</unmanaged-short>	
        public float ComputeLength(SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, float flatteningTolerance)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;
                float length;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (worldTransform.HasValue) ? &worldTransform_ : (void*)IntPtr.Zero, flatteningTolerance, &length, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
                return length;
            }
        }

        /// <summary>	
        /// <p>Calculates the point and tangent vector at the specified distance along the geometry after it has been transformed by the specified matrix and flattened using the specified tolerance.</p>	
        /// </summary>	
        /// <param name="length"><dd>  <p>The distance along the geometry of the point and tangent to find. If this distance is less then 0, this method calculates the first point in the geometry. If this distance is greater than the length of the geometry, this method calculates the last point in the geometry.</p> </dd></param>	
        /// <param name="worldTransform"><dd>  <p>The transform to apply to the geometry before calculating the specified point and tangent, or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="flatteningTolerance"><dd>  <p>The maximum error allowed when constructing a polygonal approximation of the geometry. No point in the polygonal representation will diverge from the original geometry by more than the flattening tolerance. Smaller values produce more accurate results but cause slower execution.</p> </dd></param>	
        /// <param name="unitTangentVector"><dd>  <p>When this method returns, contains a reference to the tangent vector at the specified distance along the geometry. If the geometry is empty,  this vector contains NaN as its x and y values. You must allocate storage for this parameter.</p> </dd></param>	
        /// <returns><dd>  <p>The location at the specified distance along the geometry. If the geometry is empty,  this point contains NaN as its x and y values.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Geometry::ComputePointAtLength']/*"/>	
        /// <msdn-id>dd316676</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Geometry::ComputePointAtLength([In] float length,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out, Optional] D2D_POINT_2F* point,[Out, Optional] D2D_POINT_2F* unitTangentVector)</unmanaged>	
        /// <unmanaged-short>ID2D1Geometry::ComputePointAtLength</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawVector2 ComputePointAtLength(float length, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, float flatteningTolerance, out SharpDX.Mathematics.Interop.RawVector2 unitTangentVector)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;
                SharpDX.Mathematics.Interop.RawVector2 ointRef;
                ointRef = new SharpDX.Mathematics.Interop.RawVector2();
                unitTangentVector = new SharpDX.Mathematics.Interop.RawVector2();
                SharpDX.Result __result__;
                fixed (void* unitTangentVector_ = &unitTangentVector)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, length, (worldTransform.HasValue) ? &worldTransform_ : (void*)IntPtr.Zero, flatteningTolerance, &ointRef, unitTangentVector_, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
                return ointRef;
            }
        }

        /// <summary>	
        /// <p>Widens the geometry by the specified stroke and writes the result to an <strong><see cref="SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong> after it has been transformed by the specified matrix and flattened using the specified tolerance.</p>	
        /// </summary>	
        /// <param name="strokeWidth">No documentation.</param>	
        /// <param name="strokeStyle">No documentation.</param>	
        /// <param name="worldTransform">No documentation.</param>	
        /// <param name="flatteningTolerance">No documentation.</param>	
        /// <param name="geometrySink">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Geometry::Widen']/*"/>	
        /// <msdn-id>dd316766</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Geometry::Widen([In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>	
        /// <unmanaged-short>ID2D1Geometry::Widen</unmanaged-short>	
        internal void Widen_(float strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, float flatteningTolerance, System.IntPtr geometrySink)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, strokeWidth, (void*)((strokeStyle == null) ? IntPtr.Zero : strokeStyle.NativePointer), (worldTransform.HasValue) ? &worldTransform_ : (void*)IntPtr.Zero, flatteningTolerance, (void*)geometrySink, ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a composite geometry, composed of other <strong><see cref="SharpDX.Direct2D1.Geometry"/></strong> objects. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Geometry groups are a convenient way to group several geometries simultaneously so all figures of several distinct geometries are concatenated into one. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometryGroup']/*"/>	
    /// <msdn-id>dd316581</msdn-id>	
    /// <unmanaged>ID2D1GeometryGroup</unmanaged>	
    /// <unmanaged-short>ID2D1GeometryGroup</unmanaged-short>	
    [Guid("2cd906a6-12e2-11dc-9fed-001143a055f9")]
    public partial class GeometryGroup : SharpDX.Direct2D1.Geometry
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.GeometryGroup"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public GeometryGroup(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.GeometryGroup"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.GeometryGroup(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.GeometryGroup(nativePointer);
        }


        /// <summary>	
        /// <p>Indicates how the intersecting areas of the geometries contained in this geometry group are combined.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometryGroup::GetFillMode']/*"/>	
        /// <msdn-id>dd316583</msdn-id>	
        /// <unmanaged>GetFillMode</unmanaged>	
        /// <unmanaged-short>GetFillMode</unmanaged-short>	
        /// <unmanaged>D2D1_FILL_MODE ID2D1GeometryGroup::GetFillMode()</unmanaged>
        public SharpDX.Direct2D1.FillMode FillMode
        {
            get { return GetFillMode(); }
        }

        /// <summary>	
        /// <p>Indicates the number of geometry objects in the geometry group. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometryGroup::GetSourceGeometryCount']/*"/>	
        /// <msdn-id>dd316589</msdn-id>	
        /// <unmanaged>GetSourceGeometryCount</unmanaged>	
        /// <unmanaged-short>GetSourceGeometryCount</unmanaged-short>	
        /// <unmanaged>unsigned int ID2D1GeometryGroup::GetSourceGeometryCount()</unmanaged>
        public int SourceGeometryCount
        {
            get { return GetSourceGeometryCount(); }
        }

        /// <summary>	
        /// <p>Indicates how the intersecting areas of the geometries contained in this geometry group are combined.</p>	
        /// </summary>	
        /// <returns><p> A value that indicates how the intersecting areas of the geometries contained in this geometry group are combined.  </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometryGroup::GetFillMode']/*"/>	
        /// <msdn-id>dd316583</msdn-id>	
        /// <unmanaged>D2D1_FILL_MODE ID2D1GeometryGroup::GetFillMode()</unmanaged>	
        /// <unmanaged-short>ID2D1GeometryGroup::GetFillMode</unmanaged-short>	
        internal SharpDX.Direct2D1.FillMode GetFillMode()
        {
            unsafe
            {
                SharpDX.Direct2D1.FillMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1FillMode(_nativePointer, ((void**)(*(void**)_nativePointer))[17]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Indicates the number of geometry objects in the geometry group. </p>	
        /// </summary>	
        /// <returns><p>The number of geometries in the <strong><see cref="SharpDX.Direct2D1.GeometryGroup"/></strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometryGroup::GetSourceGeometryCount']/*"/>	
        /// <msdn-id>dd316589</msdn-id>	
        /// <unmanaged>unsigned int ID2D1GeometryGroup::GetSourceGeometryCount()</unmanaged>	
        /// <unmanaged-short>ID2D1GeometryGroup::GetSourceGeometryCount</unmanaged-short>	
        internal int GetSourceGeometryCount()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[18]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Retrieves the geometries in the geometry group. </p>	
        /// </summary>	
        /// <param name="geometries"><dd>  <p>When this method returns, contains the address of a reference to an array of geometries to be filled by this method. The length of the array is specified by the <em>geometryCount</em> parameter. If the array is <strong><c>null</c></strong>, then this method performs no operation. You must allocate the memory for this array.</p> </dd></param>	
        /// <param name="geometriesCount"><dd>  <p>A value indicating the number of geometries to return in the <em>geometries</em> array. If this value is less than the number of geometries in the geometry group, the remaining geometries are omitted. If this value is larger than the number of geometries in the geometry group, the extra geometries are set to <strong><c>null</c></strong>. To obtain the number of geometries currently in the geometry group, use the <strong>GetSourceGeometryCount</strong> method.</p> </dd></param>	
        /// <remarks>	
        /// <p>The returned geometries are referenced and  counted, and the caller must release them.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometryGroup::GetSourceGeometries']/*"/>	
        /// <msdn-id>dd316586</msdn-id>	
        /// <unmanaged>void ID2D1GeometryGroup::GetSourceGeometries([Out, Buffer] ID2D1Geometry** geometries,[In] unsigned int geometriesCount)</unmanaged>	
        /// <unmanaged-short>ID2D1GeometryGroup::GetSourceGeometries</unmanaged-short>	
        internal void GetSourceGeometries(SharpDX.Direct2D1.Geometry[] geometries, int geometriesCount)
        {
            unsafe
            {
                IntPtr* geometries_ = stackalloc IntPtr[geometries.Length];
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, geometries_, geometriesCount, ((void**)(*(void**)_nativePointer))[19]);
                for (int i = 0; i < geometries.Length; i++)
                    geometries[i] = (geometries_[i] == IntPtr.Zero) ? null : new SharpDX.Direct2D1.Geometry(geometries_[i]);
            }
        }
    }
    /// <summary>	
    /// <p>Encapsulates a device- and transform-dependent representation of a filled or stroked geometry.  Callers should consider creating a geometry realization when they wish to accelerate repeated rendering of a given geometry. This interface exposes no methods.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometryRealization']/*"/>	
    /// <msdn-id>dn280515</msdn-id>	
    /// <unmanaged>ID2D1GeometryRealization</unmanaged>	
    /// <unmanaged-short>ID2D1GeometryRealization</unmanaged-short>	
    [Guid("a16907d7-bc02-4801-99e8-8cf7f485f774")]
    public partial class GeometryRealization : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.GeometryRealization"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public GeometryRealization(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.GeometryRealization"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.GeometryRealization(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.GeometryRealization(nativePointer);
        }

    }
    /// <summary>	
    /// <p>Describes a geometric path that can contain lines, arcs, cubic Bezier curves, and quadratic Bezier curves. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct2D1.GeometrySink"/></strong> interface extends the <strong><see cref="SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong> interface to add support for arcs and quadratic beziers, as well as functions for adding single lines and cubic beziers.</p><p>A geometry sink consists of one or more figures. Each figure is made up of one or more line, curve, or arc segments. To create a figure, call the <strong>BeginFigure</strong> method, specify the figure's start point, and then use its Add methods (such as AddLine and AddBezier) to add segments. When you are finished adding segments, call the <strong>EndFigure</strong> method. You can repeat this sequence to create additional figures. When you are finished creating figures, call the <strong>Close</strong> method.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometrySink']/*"/>	
    /// <msdn-id>dd316592</msdn-id>	
    /// <unmanaged>ID2D1GeometrySink</unmanaged>	
    /// <unmanaged-short>ID2D1GeometrySink</unmanaged-short>	
    [Guid("2cd9069f-12e2-11dc-9fed-001143a055f9")]
    public partial interface GeometrySink : SharpDX.Direct2D1.SimplifiedGeometrySink
    {


        /// <summary>	
        /// <p>Creates a line segment between the current point and the specified end point and adds it to the geometry sink. </p>	
        /// </summary>	
        /// <param name="point"><dd>  <p>The end point of the line to draw.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometrySink::AddLine']/*"/>	
        /// <msdn-id>dd316604</msdn-id>	
        /// <unmanaged>void ID2D1GeometrySink::AddLine([In] D2D_POINT_2F point)</unmanaged>	
        /// <unmanaged-short>ID2D1GeometrySink::AddLine</unmanaged-short>	
        /* public void AddLine(SharpDX.Mathematics.Interop.RawVector2 point) */

        /// <summary>	
        /// <p> Creates  a cubic Bezier curve between the current point and the specified end point.</p>	
        /// </summary>	
        /// <param name="bezier"><dd>  <p>A structure that describes the control points and end point of the Bezier curve to add.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometrySink::AddBezier']/*"/>	
        /// <msdn-id>dd316601</msdn-id>	
        /// <unmanaged>void ID2D1GeometrySink::AddBezier([In] const D2D1_BEZIER_SEGMENT* bezier)</unmanaged>	
        /// <unmanaged-short>ID2D1GeometrySink::AddBezier</unmanaged-short>	
        /* public void AddBezier(ref SharpDX.Direct2D1.BezierSegment bezier) */

        /// <summary>	
        /// <p>Creates  a quadratic Bezier curve between the current point and the specified endpoint.</p>	
        /// </summary>	
        /// <param name="bezier"><dd>  <p>A structure that describes the control point and the endpoint of the quadratic Bezier curve to add.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometrySink::AddQuadraticBezier']/*"/>	
        /// <msdn-id>dd316611</msdn-id>	
        /// <unmanaged>void ID2D1GeometrySink::AddQuadraticBezier([In] const D2D1_QUADRATIC_BEZIER_SEGMENT* bezier)</unmanaged>	
        /// <unmanaged-short>ID2D1GeometrySink::AddQuadraticBezier</unmanaged-short>	
        /* public void AddQuadraticBezier(SharpDX.Direct2D1.QuadraticBezierSegment bezier) */

        /// <summary>	
        /// <p>Adds a sequence of quadratic Bezier segments as an array in a single call.</p>	
        /// </summary>	
        /// <param name="beziers"><dd>  <p>An array of a sequence of quadratic Bezier segments.</p> </dd></param>	
        /// <param name="beziersCount"><dd>  <p>A value indicating the number of quadratic Bezier segments in <em>beziers</em>. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometrySink::AddQuadraticBeziers']/*"/>	
        /// <msdn-id>dd316608</msdn-id>	
        /// <unmanaged>void ID2D1GeometrySink::AddQuadraticBeziers([In, Buffer] const D2D1_QUADRATIC_BEZIER_SEGMENT* beziers,[In] unsigned int beziersCount)</unmanaged>	
        /// <unmanaged-short>ID2D1GeometrySink::AddQuadraticBeziers</unmanaged-short>	
        /* public void AddQuadraticBeziers(SharpDX.Direct2D1.QuadraticBezierSegment[] beziers, int beziersCount) */

        /// <summary>	
        /// <p>Adds a single arc to the path geometry.</p>	
        /// </summary>	
        /// <param name="arc"><dd>  <p>The arc segment to add to the figure.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometrySink::AddArc']/*"/>	
        /// <msdn-id>dd316597</msdn-id>	
        /// <unmanaged>void ID2D1GeometrySink::AddArc([In] const D2D1_ARC_SEGMENT* arc)</unmanaged>	
        /// <unmanaged-short>ID2D1GeometrySink::AddArc</unmanaged-short>	
        /* public void AddArc(ref SharpDX.Direct2D1.ArcSegment arc) */
    }
    /// <summary>	
    /// <p>Describes a geometric path that can contain lines, arcs, cubic Bezier curves, and quadratic Bezier curves. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct2D1.GeometrySink"/></strong> interface extends the <strong><see cref="SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong> interface to add support for arcs and quadratic beziers, as well as functions for adding single lines and cubic beziers.</p><p>A geometry sink consists of one or more figures. Each figure is made up of one or more line, curve, or arc segments. To create a figure, call the <strong>BeginFigure</strong> method, specify the figure's start point, and then use its Add methods (such as AddLine and AddBezier) to add segments. When you are finished adding segments, call the <strong>EndFigure</strong> method. You can repeat this sequence to create additional figures. When you are finished creating figures, call the <strong>Close</strong> method.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometrySink']/*"/>	
    /// <msdn-id>dd316592</msdn-id>	
    /// <unmanaged>ID2D1GeometrySink</unmanaged>	
    /// <unmanaged-short>ID2D1GeometrySink</unmanaged-short>	
    [Guid("2cd9069f-12e2-11dc-9fed-001143a055f9")]
    internal partial class GeometrySinkNative : SharpDX.Direct2D1.SimplifiedGeometrySinkNative, SharpDX.Direct2D1.GeometrySink
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.GeometrySinkNative"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public GeometrySinkNative(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.GeometrySinkNative"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.GeometrySinkNative(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.GeometrySinkNative(nativePointer);
        }


        /// <summary>	
        /// <p>Creates a line segment between the current point and the specified end point and adds it to the geometry sink. </p>	
        /// </summary>	
        /// <param name="point"><dd>  <p>The end point of the line to draw.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometrySink::AddLine']/*"/>	
        /// <msdn-id>dd316604</msdn-id>	
        /// <unmanaged>void ID2D1GeometrySink::AddLine([In] D2D_POINT_2F point)</unmanaged>	
        /// <unmanaged-short>ID2D1GeometrySink::AddLine</unmanaged-short>	
        internal void AddLine_(SharpDX.Mathematics.Interop.RawVector2 point)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid42(_nativePointer, point, ((void**)(*(void**)_nativePointer))[10]);
            }
        }

        /// <summary>	
        /// <p> Creates  a cubic Bezier curve between the current point and the specified end point.</p>	
        /// </summary>	
        /// <param name="bezier"><dd>  <p>A structure that describes the control points and end point of the Bezier curve to add.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometrySink::AddBezier']/*"/>	
        /// <msdn-id>dd316601</msdn-id>	
        /// <unmanaged>void ID2D1GeometrySink::AddBezier([In] const D2D1_BEZIER_SEGMENT* bezier)</unmanaged>	
        /// <unmanaged-short>ID2D1GeometrySink::AddBezier</unmanaged-short>	
        internal void AddBezier_(ref SharpDX.Direct2D1.BezierSegment bezier)
        {
            unsafe
            {
                fixed (void* bezier_ = &bezier)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, bezier_, ((void**)(*(void**)_nativePointer))[11]);
            }
        }

        /// <summary>	
        /// <p>Creates  a quadratic Bezier curve between the current point and the specified endpoint.</p>	
        /// </summary>	
        /// <param name="bezier"><dd>  <p>A structure that describes the control point and the endpoint of the quadratic Bezier curve to add.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometrySink::AddQuadraticBezier']/*"/>	
        /// <msdn-id>dd316611</msdn-id>	
        /// <unmanaged>void ID2D1GeometrySink::AddQuadraticBezier([In] const D2D1_QUADRATIC_BEZIER_SEGMENT* bezier)</unmanaged>	
        /// <unmanaged-short>ID2D1GeometrySink::AddQuadraticBezier</unmanaged-short>	
        internal void AddQuadraticBezier_(SharpDX.Direct2D1.QuadraticBezierSegment bezier)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &bezier, ((void**)(*(void**)_nativePointer))[12]);
            }
        }

        /// <summary>	
        /// <p>Adds a sequence of quadratic Bezier segments as an array in a single call.</p>	
        /// </summary>	
        /// <param name="beziers"><dd>  <p>An array of a sequence of quadratic Bezier segments.</p> </dd></param>	
        /// <param name="beziersCount"><dd>  <p>A value indicating the number of quadratic Bezier segments in <em>beziers</em>. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometrySink::AddQuadraticBeziers']/*"/>	
        /// <msdn-id>dd316608</msdn-id>	
        /// <unmanaged>void ID2D1GeometrySink::AddQuadraticBeziers([In, Buffer] const D2D1_QUADRATIC_BEZIER_SEGMENT* beziers,[In] unsigned int beziersCount)</unmanaged>	
        /// <unmanaged-short>ID2D1GeometrySink::AddQuadraticBeziers</unmanaged-short>	
        internal void AddQuadraticBeziers_(SharpDX.Direct2D1.QuadraticBezierSegment[] beziers, int beziersCount)
        {
            unsafe
            {
                fixed (void* beziers_ = beziers)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, beziers_, beziersCount, ((void**)(*(void**)_nativePointer))[13]);
            }
        }

        /// <summary>	
        /// <p>Adds a single arc to the path geometry.</p>	
        /// </summary>	
        /// <param name="arc"><dd>  <p>The arc segment to add to the figure.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GeometrySink::AddArc']/*"/>	
        /// <msdn-id>dd316597</msdn-id>	
        /// <unmanaged>void ID2D1GeometrySink::AddArc([In] const D2D1_ARC_SEGMENT* arc)</unmanaged>	
        /// <unmanaged-short>ID2D1GeometrySink::AddArc</unmanaged-short>	
        internal void AddArc_(ref SharpDX.Direct2D1.ArcSegment arc)
        {
            unsafe
            {
                fixed (void* arc_ = &arc)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, arc_, ((void**)(*(void**)_nativePointer))[14]);
            }
        }
    }
    /// <summary>	
    /// <p>Represents a device-dependent representation of a gradient mesh composed of patches.  Use the <strong><see cref="SharpDX.Direct2D1.DeviceContext2.CreateGradientMesh"/> method</strong> to create an instance of <see cref="SharpDX.Direct2D1.GradientMesh"/>.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientMesh']/*"/>	
    /// <msdn-id>dn900410</msdn-id>	
    /// <unmanaged>ID2D1GradientMesh</unmanaged>	
    /// <unmanaged-short>ID2D1GradientMesh</unmanaged-short>	
    [Guid("f292e401-c050-4cde-83d7-04962d3b23c2")]
    public partial class GradientMesh : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.GradientMesh"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public GradientMesh(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.GradientMesh"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.GradientMesh(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.GradientMesh(nativePointer);
        }


        /// <summary>	
        /// <p>Returns the number of patches that make up this gradient mesh.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientMesh::GetPatchCount']/*"/>	
        /// <msdn-id>dn900411</msdn-id>	
        /// <unmanaged>GetPatchCount</unmanaged>	
        /// <unmanaged-short>GetPatchCount</unmanaged-short>	
        /// <unmanaged>unsigned int ID2D1GradientMesh::GetPatchCount()</unmanaged>
        public int PatchCount
        {
            get { return GetPatchCount(); }
        }

        /// <summary>	
        /// <p>Returns the number of patches that make up this gradient mesh.</p>	
        /// </summary>	
        /// <returns><p>Returns the number of patches that make up this gradient mesh.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientMesh::GetPatchCount']/*"/>	
        /// <msdn-id>dn900411</msdn-id>	
        /// <unmanaged>unsigned int ID2D1GradientMesh::GetPatchCount()</unmanaged>	
        /// <unmanaged-short>ID2D1GradientMesh::GetPatchCount</unmanaged-short>	
        internal int GetPatchCount()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                return __result__;
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="startIndex">No documentation.</param>	
        /// <param name="atchesRef">No documentation.</param>	
        /// <param name="patchesCount">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientMesh::GetPatches']/*"/>	
        /// <unmanaged>HRESULT ID2D1GradientMesh::GetPatches([In] unsigned int startIndex,[Out, Buffer] D2D1_GRADIENT_MESH_PATCH* patches,[In] unsigned int patchesCount)</unmanaged>	
        /// <unmanaged-short>ID2D1GradientMesh::GetPatches</unmanaged-short>	
        public void GetPatches(int startIndex, SharpDX.Direct2D1.GradientMeshPatch[] atchesRef, int patchesCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* atchesRef_ = atchesRef)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, startIndex, atchesRef_, patchesCount, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents an collection of <strong><see cref="SharpDX.Direct2D1.GradientStop"/></strong> objects for linear and radial gradient brushes.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection']/*"/>	
    /// <msdn-id>dd316783</msdn-id>	
    /// <unmanaged>ID2D1GradientStopCollection</unmanaged>	
    /// <unmanaged-short>ID2D1GradientStopCollection</unmanaged-short>	
    [Guid("2cd906a7-12e2-11dc-9fed-001143a055f9")]
    public partial class GradientStopCollection : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.GradientStopCollection"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public GradientStopCollection(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.GradientStopCollection"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.GradientStopCollection(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.GradientStopCollection(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves the number of gradient stops in the collection.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection::GetGradientStopCount']/*"/>	
        /// <msdn-id>dd371454</msdn-id>	
        /// <unmanaged>GetGradientStopCount</unmanaged>	
        /// <unmanaged-short>GetGradientStopCount</unmanaged-short>	
        /// <unmanaged>unsigned int ID2D1GradientStopCollection::GetGradientStopCount()</unmanaged>
        public int GradientStopCount
        {
            get { return GetGradientStopCount(); }
        }

        /// <summary>	
        /// <p>Indicates the gamma space in which the gradient stops are interpolated. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection::GetColorInterpolationGamma']/*"/>	
        /// <msdn-id>dd316786</msdn-id>	
        /// <unmanaged>GetColorInterpolationGamma</unmanaged>	
        /// <unmanaged-short>GetColorInterpolationGamma</unmanaged-short>	
        /// <unmanaged>D2D1_GAMMA ID2D1GradientStopCollection::GetColorInterpolationGamma()</unmanaged>
        public SharpDX.Direct2D1.Gamma ColorInterpolationGamma
        {
            get { return GetColorInterpolationGamma(); }
        }

        /// <summary>	
        /// <p>Indicates the behavior of the gradient outside the normalized gradient range. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection::GetExtendMode']/*"/>	
        /// <msdn-id>dd316789</msdn-id>	
        /// <unmanaged>GetExtendMode</unmanaged>	
        /// <unmanaged-short>GetExtendMode</unmanaged-short>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1GradientStopCollection::GetExtendMode()</unmanaged>
        public SharpDX.Direct2D1.ExtendMode ExtendMode
        {
            get { return GetExtendMode(); }
        }

        /// <summary>	
        /// <p>Retrieves the number of gradient stops in the collection.</p>	
        /// </summary>	
        /// <returns><p>The number of gradient stops in the collection.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection::GetGradientStopCount']/*"/>	
        /// <msdn-id>dd371454</msdn-id>	
        /// <unmanaged>unsigned int ID2D1GradientStopCollection::GetGradientStopCount()</unmanaged>	
        /// <unmanaged-short>ID2D1GradientStopCollection::GetGradientStopCount</unmanaged-short>	
        internal int GetGradientStopCount()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Copies the gradient stops from the collection into an array of <strong><see cref="SharpDX.Direct2D1.GradientStop"/></strong> structures.</p>	
        /// </summary>	
        /// <param name="gradientStops">No documentation.</param>	
        /// <param name="gradientStopsCount">No documentation.</param>	
        /// <remarks>	
        /// <p>Gradient stops are copied in order of position, starting with the gradient stop with the smallest position value and progressing to the gradient stop with the largest position value.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection::GetGradientStops']/*"/>	
        /// <msdn-id>dd371457</msdn-id>	
        /// <unmanaged>void ID2D1GradientStopCollection::GetGradientStops([Out, Buffer] D2D1_GRADIENT_STOP* gradientStops,[In] unsigned int gradientStopsCount)</unmanaged>	
        /// <unmanaged-short>ID2D1GradientStopCollection::GetGradientStops</unmanaged-short>	
        public void GetGradientStops(SharpDX.Direct2D1.GradientStop[] gradientStops, int gradientStopsCount)
        {
            unsafe
            {
                fixed (void* gradientStops_ = gradientStops)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, gradientStops_, gradientStopsCount, ((void**)(*(void**)_nativePointer))[5]);
            }
        }

        /// <summary>	
        /// <p>Indicates the gamma space in which the gradient stops are interpolated. </p>	
        /// </summary>	
        /// <returns><p>The gamma space in which the gradient stops are interpolated. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection::GetColorInterpolationGamma']/*"/>	
        /// <msdn-id>dd316786</msdn-id>	
        /// <unmanaged>D2D1_GAMMA ID2D1GradientStopCollection::GetColorInterpolationGamma()</unmanaged>	
        /// <unmanaged-short>ID2D1GradientStopCollection::GetColorInterpolationGamma</unmanaged-short>	
        internal SharpDX.Direct2D1.Gamma GetColorInterpolationGamma()
        {
            unsafe
            {
                SharpDX.Direct2D1.Gamma __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1Gamma(_nativePointer, ((void**)(*(void**)_nativePointer))[6]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Indicates the behavior of the gradient outside the normalized gradient range. </p>	
        /// </summary>	
        /// <returns><p>The behavior of the gradient outside the [0,1] normalized gradient range.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection::GetExtendMode']/*"/>	
        /// <msdn-id>dd316789</msdn-id>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1GradientStopCollection::GetExtendMode()</unmanaged>	
        /// <unmanaged-short>ID2D1GradientStopCollection::GetExtendMode</unmanaged-short>	
        internal SharpDX.Direct2D1.ExtendMode GetExtendMode()
        {
            unsafe
            {
                SharpDX.Direct2D1.ExtendMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1ExtendMode(_nativePointer, ((void**)(*(void**)_nativePointer))[7]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Represents a collection of <strong><see cref="SharpDX.Direct2D1.GradientStop"/></strong> objects for linear and radial gradient brushes. It provides get methods for all the new parameters added to the gradient stop collection.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection1']/*"/>	
    /// <msdn-id>hh446792</msdn-id>	
    /// <unmanaged>ID2D1GradientStopCollection1</unmanaged>	
    /// <unmanaged-short>ID2D1GradientStopCollection1</unmanaged-short>	
    [Guid("ae1572f4-5dd0-4777-998b-9279472ae63b")]
    public partial class GradientStopCollection1 : SharpDX.Direct2D1.GradientStopCollection
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.GradientStopCollection1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public GradientStopCollection1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.GradientStopCollection1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.GradientStopCollection1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.GradientStopCollection1(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the color space of the input colors as well as the space in which gradient stops are interpolated.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If this object was created using <strong><see cref="SharpDX.Direct2D1.RenderTarget.CreateGradientStopCollection"/></strong>, this method  returns the color space related to the color interpolation gamma. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection1::GetPreInterpolationSpace']/*"/>	
        /// <msdn-id>hh446802</msdn-id>	
        /// <unmanaged>GetPreInterpolationSpace</unmanaged>	
        /// <unmanaged-short>GetPreInterpolationSpace</unmanaged-short>	
        /// <unmanaged>D2D1_COLOR_SPACE ID2D1GradientStopCollection1::GetPreInterpolationSpace()</unmanaged>
        public SharpDX.Direct2D1.ColorSpace PreInterpolationSpace
        {
            get { return GetPreInterpolationSpace(); }
        }

        /// <summary>	
        /// <p>Gets the color space after interpolation has occurred.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If you create using <strong><see cref="SharpDX.Direct2D1.RenderTarget.CreateGradientStopCollection"/></strong>, this method returns <strong><see cref="SharpDX.Direct2D1.ColorSpace.SRgb"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection1::GetPostInterpolationSpace']/*"/>	
        /// <msdn-id>hh446800</msdn-id>	
        /// <unmanaged>GetPostInterpolationSpace</unmanaged>	
        /// <unmanaged-short>GetPostInterpolationSpace</unmanaged-short>	
        /// <unmanaged>D2D1_COLOR_SPACE ID2D1GradientStopCollection1::GetPostInterpolationSpace()</unmanaged>
        public SharpDX.Direct2D1.ColorSpace PostInterpolationSpace
        {
            get { return GetPostInterpolationSpace(); }
        }

        /// <summary>	
        /// <p>Gets the precision of the gradient buffer.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If this object was created using <strong><see cref="SharpDX.Direct2D1.RenderTarget.CreateGradientStopCollection"/></strong>, this method returns <see cref="SharpDX.Direct2D1.BufferPrecision.PerChannel8UNorm"/>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection1::GetBufferPrecision']/*"/>	
        /// <msdn-id>hh446796</msdn-id>	
        /// <unmanaged>GetBufferPrecision</unmanaged>	
        /// <unmanaged-short>GetBufferPrecision</unmanaged-short>	
        /// <unmanaged>D2D1_BUFFER_PRECISION ID2D1GradientStopCollection1::GetBufferPrecision()</unmanaged>
        public SharpDX.Direct2D1.BufferPrecision BufferPrecision
        {
            get { return GetBufferPrecision(); }
        }

        /// <summary>	
        /// <p>Retrieves the color interpolation mode that the gradient stop collection uses.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection1::GetColorInterpolationMode']/*"/>	
        /// <msdn-id>hh871465</msdn-id>	
        /// <unmanaged>GetColorInterpolationMode</unmanaged>	
        /// <unmanaged-short>GetColorInterpolationMode</unmanaged-short>	
        /// <unmanaged>D2D1_COLOR_INTERPOLATION_MODE ID2D1GradientStopCollection1::GetColorInterpolationMode()</unmanaged>
        public SharpDX.Direct2D1.ColorInterpolationMode ColorInterpolationMode
        {
            get { return GetColorInterpolationMode(); }
        }

        /// <summary>	
        /// <p>Copies the gradient stops from the collection into memory.</p>	
        /// </summary>	
        /// <param name="gradientStops"><dd>  <p>When this method returns, contains a reference to a one-dimensional array of <strong><see cref="SharpDX.Direct2D1.GradientStop"/></strong> structures.</p> </dd></param>	
        /// <param name="gradientStopsCount"><dd>  <p>The number of gradient stops to copy. </p> </dd></param>	
        /// <remarks>	
        /// <p>If the <strong><see cref="SharpDX.Direct2D1.GradientStopCollection1"/></strong> object was created using <strong><see cref="SharpDX.Direct2D1.DeviceContext.CreateGradientStopCollection"/></strong>, this method returns the same values specified in the creation method. If the <strong><see cref="SharpDX.Direct2D1.GradientStopCollection1"/></strong> object was created using <strong><see cref="SharpDX.Direct2D1.RenderTarget.CreateGradientStopCollection"/></strong>, the stops returned here will first be transformed into the gamma space specified by the <em>colorInterpolationGamma</em> parameter. See the <strong><see cref="SharpDX.Direct2D1.DeviceContext.CreateGradientStopCollection"/></strong> method for more info about color space and gamma space.</p><p>If <em>gradientStopsCount</em> is less than the number of gradient stops in the collection, the remaining gradient stops are omitted. If <em>gradientStopsCount</em> is larger than the number of gradient stops in the collection, the extra gradient stops are set to <strong><c>null</c></strong>. To obtain the number of gradient stops in the collection, use the <strong>GetGradientStopCount</strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection1::GetGradientStops1']/*"/>	
        /// <msdn-id>hh446798</msdn-id>	
        /// <unmanaged>void ID2D1GradientStopCollection1::GetGradientStops1([Out, Buffer] D2D1_GRADIENT_STOP* gradientStops,[In] unsigned int gradientStopsCount)</unmanaged>	
        /// <unmanaged-short>ID2D1GradientStopCollection1::GetGradientStops1</unmanaged-short>	
        public void GetGradientStops1(SharpDX.Direct2D1.GradientStop[] gradientStops, int gradientStopsCount)
        {
            unsafe
            {
                fixed (void* gradientStops_ = gradientStops)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, gradientStops_, gradientStopsCount, ((void**)(*(void**)_nativePointer))[8]);
            }
        }

        /// <summary>	
        /// <p>Gets the color space of the input colors as well as the space in which gradient stops are interpolated.</p>	
        /// </summary>	
        /// <returns><p>This method returns the color space.</p></returns>	
        /// <remarks>	
        /// <p>If this object was created using <strong><see cref="SharpDX.Direct2D1.RenderTarget.CreateGradientStopCollection"/></strong>, this method  returns the color space related to the color interpolation gamma. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection1::GetPreInterpolationSpace']/*"/>	
        /// <msdn-id>hh446802</msdn-id>	
        /// <unmanaged>D2D1_COLOR_SPACE ID2D1GradientStopCollection1::GetPreInterpolationSpace()</unmanaged>	
        /// <unmanaged-short>ID2D1GradientStopCollection1::GetPreInterpolationSpace</unmanaged-short>	
        internal SharpDX.Direct2D1.ColorSpace GetPreInterpolationSpace()
        {
            unsafe
            {
                SharpDX.Direct2D1.ColorSpace __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1ColorSpace(_nativePointer, ((void**)(*(void**)_nativePointer))[9]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the color space after interpolation has occurred.</p>	
        /// </summary>	
        /// <returns><p>This method returns the color space.</p></returns>	
        /// <remarks>	
        /// <p>If you create using <strong><see cref="SharpDX.Direct2D1.RenderTarget.CreateGradientStopCollection"/></strong>, this method returns <strong><see cref="SharpDX.Direct2D1.ColorSpace.SRgb"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection1::GetPostInterpolationSpace']/*"/>	
        /// <msdn-id>hh446800</msdn-id>	
        /// <unmanaged>D2D1_COLOR_SPACE ID2D1GradientStopCollection1::GetPostInterpolationSpace()</unmanaged>	
        /// <unmanaged-short>ID2D1GradientStopCollection1::GetPostInterpolationSpace</unmanaged-short>	
        internal SharpDX.Direct2D1.ColorSpace GetPostInterpolationSpace()
        {
            unsafe
            {
                SharpDX.Direct2D1.ColorSpace __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1ColorSpace(_nativePointer, ((void**)(*(void**)_nativePointer))[10]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the precision of the gradient buffer.</p>	
        /// </summary>	
        /// <returns><p>The buffer precision of the gradient buffer.</p></returns>	
        /// <remarks>	
        /// <p>If this object was created using <strong><see cref="SharpDX.Direct2D1.RenderTarget.CreateGradientStopCollection"/></strong>, this method returns <see cref="SharpDX.Direct2D1.BufferPrecision.PerChannel8UNorm"/>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection1::GetBufferPrecision']/*"/>	
        /// <msdn-id>hh446796</msdn-id>	
        /// <unmanaged>D2D1_BUFFER_PRECISION ID2D1GradientStopCollection1::GetBufferPrecision()</unmanaged>	
        /// <unmanaged-short>ID2D1GradientStopCollection1::GetBufferPrecision</unmanaged-short>	
        internal SharpDX.Direct2D1.BufferPrecision GetBufferPrecision()
        {
            unsafe
            {
                SharpDX.Direct2D1.BufferPrecision __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1BufferPrecision(_nativePointer, ((void**)(*(void**)_nativePointer))[11]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Retrieves the color interpolation mode that the gradient stop collection uses.</p>	
        /// </summary>	
        /// <returns><p>The color interpolation mode.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1GradientStopCollection1::GetColorInterpolationMode']/*"/>	
        /// <msdn-id>hh871465</msdn-id>	
        /// <unmanaged>D2D1_COLOR_INTERPOLATION_MODE ID2D1GradientStopCollection1::GetColorInterpolationMode()</unmanaged>	
        /// <unmanaged-short>ID2D1GradientStopCollection1::GetColorInterpolationMode</unmanaged-short>	
        internal SharpDX.Direct2D1.ColorInterpolationMode GetColorInterpolationMode()
        {
            unsafe
            {
                SharpDX.Direct2D1.ColorInterpolationMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1ColorInterpolationMode(_nativePointer, ((void**)(*(void**)_nativePointer))[12]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Represents a producer of pixels that can fill an arbitrary 2D plane.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An <strong><see cref="SharpDX.Direct2D1.Image"/></strong> is abstract.  Concrete instances can be created through <strong><see cref="SharpDX.Direct2D1.DeviceContext.CreateEffect"/></strong> and <strong><see cref="SharpDX.Direct2D1.DeviceContext.CreateBitmap"/></strong>.</p><p> Images are evaluated lazily. If the type of image passed in is concrete, then the image can be directly sampled from. Other images can act only as a source of pixels and can produce content only as a result of calling <strong><see cref="SharpDX.Direct2D1.DeviceContext.DrawImage"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Image']/*"/>	
    /// <msdn-id>hh446803</msdn-id>	
    /// <unmanaged>ID2D1Image</unmanaged>	
    /// <unmanaged-short>ID2D1Image</unmanaged-short>	
    [Guid("65019f75-8da2-497c-b32c-dfa34e48ede6")]
    public partial class Image : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Image"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Image(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Image"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Image(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Image(nativePointer);
        }

    }
    /// <summary>	
    /// <p>Represents a brush based on an <strong><see cref="SharpDX.Direct2D1.Image"/></strong>.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush']/*"/>	
    /// <msdn-id>hh446804</msdn-id>	
    /// <unmanaged>ID2D1ImageBrush</unmanaged>	
    /// <unmanaged-short>ID2D1ImageBrush</unmanaged-short>	
    [Guid("fe9e984d-3f95-407c-b5db-cb94d4e8f87c")]
    public partial class ImageBrush : SharpDX.Direct2D1.Brush
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.ImageBrush"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ImageBrush(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.ImageBrush"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.ImageBrush(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.ImageBrush(nativePointer);
        }


        /// <summary>	
        /// <p>Gets or sets the image associated with the image brush.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush::GetImage']/*"/>	
        /// <msdn-id>hh446807</msdn-id>	
        /// <unmanaged>GetImage / SetImage</unmanaged>	
        /// <unmanaged-short>GetImage</unmanaged-short>	
        /// <unmanaged>void ID2D1ImageBrush::GetImage([Out] ID2D1Image** image)</unmanaged>
        public SharpDX.Direct2D1.Image Image
        {
            get { SharpDX.Direct2D1.Image __output__; GetImage(out __output__); return __output__; }
            set { SetImage(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the extend mode of the image brush on the x-axis.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush::GetExtendModeX']/*"/>	
        /// <msdn-id>hh446805</msdn-id>	
        /// <unmanaged>GetExtendModeX / SetExtendModeX</unmanaged>	
        /// <unmanaged-short>GetExtendModeX</unmanaged-short>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1ImageBrush::GetExtendModeX()</unmanaged>
        public SharpDX.Direct2D1.ExtendMode ExtendModeX
        {
            get { return GetExtendModeX(); }
            set { SetExtendModeX(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the extend mode of the image brush on the y-axis of the image.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush::GetExtendModeY']/*"/>	
        /// <msdn-id>hh446806</msdn-id>	
        /// <unmanaged>GetExtendModeY / SetExtendModeY</unmanaged>	
        /// <unmanaged-short>GetExtendModeY</unmanaged-short>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1ImageBrush::GetExtendModeY()</unmanaged>
        public SharpDX.Direct2D1.ExtendMode ExtendModeY
        {
            get { return GetExtendModeY(); }
            set { SetExtendModeY(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the interpolation mode of the image brush.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush::GetInterpolationMode']/*"/>	
        /// <msdn-id>hh446808</msdn-id>	
        /// <unmanaged>GetInterpolationMode / SetInterpolationMode</unmanaged>	
        /// <unmanaged-short>GetInterpolationMode</unmanaged-short>	
        /// <unmanaged>D2D1_INTERPOLATION_MODE ID2D1ImageBrush::GetInterpolationMode()</unmanaged>
        public SharpDX.Direct2D1.InterpolationMode InterpolationMode
        {
            get { return GetInterpolationMode(); }
            set { SetInterpolationMode(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the rectangle that will be used as the bounds of the image when drawn as an image brush.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush::GetSourceRectangle']/*"/>	
        /// <msdn-id>hh446809</msdn-id>	
        /// <unmanaged>GetSourceRectangle / SetSourceRectangle</unmanaged>	
        /// <unmanaged-short>GetSourceRectangle</unmanaged-short>	
        /// <unmanaged>void ID2D1ImageBrush::GetSourceRectangle([Out] D2D_RECT_F* sourceRectangle)</unmanaged>
        public SharpDX.Mathematics.Interop.RawRectangleF SourceRectangle
        {
            get { SharpDX.Mathematics.Interop.RawRectangleF __output__; GetSourceRectangle(out __output__); return __output__; }
            set { SetSourceRectangle(value); }
        }

        /// <summary>	
        /// <p>Sets the image associated with the provided image brush.</p>	
        /// </summary>	
        /// <param name="image"><dd>  <p>The image to be associated with the image brush.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush::SetImage']/*"/>	
        /// <msdn-id>hh446812</msdn-id>	
        /// <unmanaged>void ID2D1ImageBrush::SetImage([In, Optional] ID2D1Image* image)</unmanaged>	
        /// <unmanaged-short>ID2D1ImageBrush::SetImage</unmanaged-short>	
        internal void SetImage(SharpDX.Direct2D1.Image image)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((image == null) ? IntPtr.Zero : image.NativePointer), ((void**)(*(void**)_nativePointer))[8]);
            }
        }

        /// <summary>	
        /// <p>Sets how the content inside the source rectangle in the image brush will be extended on the x-axis.</p>	
        /// </summary>	
        /// <param name="extendModeX"><dd>  <p>The extend mode on the x-axis of the image.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush::SetExtendModeX']/*"/>	
        /// <msdn-id>hh446810</msdn-id>	
        /// <unmanaged>void ID2D1ImageBrush::SetExtendModeX([In] D2D1_EXTEND_MODE extendModeX)</unmanaged>	
        /// <unmanaged-short>ID2D1ImageBrush::SetExtendModeX</unmanaged-short>	
        internal void SetExtendModeX(SharpDX.Direct2D1.ExtendMode extendModeX)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)extendModeX), ((void**)(*(void**)_nativePointer))[9]);
            }
        }

        /// <summary>	
        /// <p>Sets the extend mode on the y-axis.</p>	
        /// </summary>	
        /// <param name="extendModeY"><dd>  <p>The extend mode on the y-axis of the image.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush::SetExtendModeY']/*"/>	
        /// <msdn-id>hh446811</msdn-id>	
        /// <unmanaged>void ID2D1ImageBrush::SetExtendModeY([In] D2D1_EXTEND_MODE extendModeY)</unmanaged>	
        /// <unmanaged-short>ID2D1ImageBrush::SetExtendModeY</unmanaged-short>	
        internal void SetExtendModeY(SharpDX.Direct2D1.ExtendMode extendModeY)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)extendModeY), ((void**)(*(void**)_nativePointer))[10]);
            }
        }

        /// <summary>	
        /// <p>Sets the interpolation mode for the image brush.</p>	
        /// </summary>	
        /// <param name="interpolationMode"><dd>  <p>How the contents of the image will be interpolated to handle the brush transform.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush::SetInterpolationMode']/*"/>	
        /// <msdn-id>hh446813</msdn-id>	
        /// <unmanaged>void ID2D1ImageBrush::SetInterpolationMode([In] D2D1_INTERPOLATION_MODE interpolationMode)</unmanaged>	
        /// <unmanaged-short>ID2D1ImageBrush::SetInterpolationMode</unmanaged-short>	
        internal void SetInterpolationMode(SharpDX.Direct2D1.InterpolationMode interpolationMode)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)interpolationMode), ((void**)(*(void**)_nativePointer))[11]);
            }
        }

        /// <summary>	
        /// <p>Sets the source rectangle in the image brush.</p>	
        /// </summary>	
        /// <param name="sourceRectangle"><dd>  <p>The source rectangle that defines the portion of the image to tile.</p> </dd></param>	
        /// <remarks>	
        /// <p>The top left corner of the <em>sourceRectangle</em> parameter maps to the brush space origin. That is, if the  brush and world transforms are both identity, the portion of the image in the top left corner of the source rectangle will be rendered at (0,0) in the render target.</p><p>The source rectangle will be expanded differently depending on whether the input image is based on   pixels (a bitmap or effect) or by a command list. </p><ul> <li>If the input image is a bitmap or an effect, the rectangle will be expanded to encapsulate a full input pixel before being additionally down-scaled to ensure that the projected rectangle will be correct in the final scene-space.</li> <li>If the input image is a command list, the command list will be slightly expanded to encapsulate a full input pixel.	
        /// </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush::SetSourceRectangle']/*"/>	
        /// <msdn-id>hh446815</msdn-id>	
        /// <unmanaged>void ID2D1ImageBrush::SetSourceRectangle([In] const D2D_RECT_F* sourceRectangle)</unmanaged>	
        /// <unmanaged-short>ID2D1ImageBrush::SetSourceRectangle</unmanaged-short>	
        internal void SetSourceRectangle(SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &sourceRectangle, ((void**)(*(void**)_nativePointer))[12]);
            }
        }

        /// <summary>	
        /// <p>Gets the image associated with the image brush.</p>	
        /// </summary>	
        /// <param name="image"><dd>  <p> When this method returns, contains the address of a reference to the image associated with  this brush. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush::GetImage']/*"/>	
        /// <msdn-id>hh446807</msdn-id>	
        /// <unmanaged>void ID2D1ImageBrush::GetImage([Out] ID2D1Image** image)</unmanaged>	
        /// <unmanaged-short>ID2D1ImageBrush::GetImage</unmanaged-short>	
        internal void GetImage(out SharpDX.Direct2D1.Image image)
        {
            unsafe
            {
                IntPtr image_ = IntPtr.Zero;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &image_, ((void**)(*(void**)_nativePointer))[13]);
                image = (image_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.Image(image_);
            }
        }

        /// <summary>	
        /// <p>Gets the extend mode of the image brush on the x-axis.</p>	
        /// </summary>	
        /// <returns><p>This method returns the x-extend mode.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush::GetExtendModeX']/*"/>	
        /// <msdn-id>hh446805</msdn-id>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1ImageBrush::GetExtendModeX()</unmanaged>	
        /// <unmanaged-short>ID2D1ImageBrush::GetExtendModeX</unmanaged-short>	
        internal SharpDX.Direct2D1.ExtendMode GetExtendModeX()
        {
            unsafe
            {
                SharpDX.Direct2D1.ExtendMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1ExtendMode(_nativePointer, ((void**)(*(void**)_nativePointer))[14]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the extend mode of the image brush on the y-axis of the image.</p>	
        /// </summary>	
        /// <returns><p>This method returns the  y-extend mode.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush::GetExtendModeY']/*"/>	
        /// <msdn-id>hh446806</msdn-id>	
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1ImageBrush::GetExtendModeY()</unmanaged>	
        /// <unmanaged-short>ID2D1ImageBrush::GetExtendModeY</unmanaged-short>	
        internal SharpDX.Direct2D1.ExtendMode GetExtendModeY()
        {
            unsafe
            {
                SharpDX.Direct2D1.ExtendMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1ExtendMode(_nativePointer, ((void**)(*(void**)_nativePointer))[15]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the interpolation mode of the image brush.</p>	
        /// </summary>	
        /// <returns><p>This method returns the  interpolation mode.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush::GetInterpolationMode']/*"/>	
        /// <msdn-id>hh446808</msdn-id>	
        /// <unmanaged>D2D1_INTERPOLATION_MODE ID2D1ImageBrush::GetInterpolationMode()</unmanaged>	
        /// <unmanaged-short>ID2D1ImageBrush::GetInterpolationMode</unmanaged-short>	
        internal SharpDX.Direct2D1.InterpolationMode GetInterpolationMode()
        {
            unsafe
            {
                SharpDX.Direct2D1.InterpolationMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1InterpolationMode(_nativePointer, ((void**)(*(void**)_nativePointer))[16]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the rectangle that will be used as the bounds of the image when drawn as an image brush.</p>	
        /// </summary>	
        /// <param name="sourceRectangle"><dd>  <p>When this method returns, contains the address of the output source rectangle.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageBrush::GetSourceRectangle']/*"/>	
        /// <msdn-id>hh446809</msdn-id>	
        /// <unmanaged>void ID2D1ImageBrush::GetSourceRectangle([Out] D2D_RECT_F* sourceRectangle)</unmanaged>	
        /// <unmanaged-short>ID2D1ImageBrush::GetSourceRectangle</unmanaged-short>	
        internal void GetSourceRectangle(out SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle)
        {
            unsafe
            {
                sourceRectangle = new SharpDX.Mathematics.Interop.RawRectangleF();
                fixed (void* sourceRectangle_ = &sourceRectangle)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, sourceRectangle_, ((void**)(*(void**)_nativePointer))[17]);
            }
        }
    }
    /// <summary>	
    /// <p>Represents a producer of pixels that can fill an arbitrary 2D plane.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageSource']/*"/>	
    /// <msdn-id>dn900413</msdn-id>	
    /// <unmanaged>ID2D1ImageSource</unmanaged>	
    /// <unmanaged-short>ID2D1ImageSource</unmanaged-short>	
    [Guid("c9b664e5-74a1-4378-9ac2-eefc37a3f4d8")]
    public partial class ImageSource : SharpDX.Direct2D1.Image
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.ImageSource"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ImageSource(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.ImageSource"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.ImageSource(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.ImageSource(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageSource::OfferResources']/*"/>	
        /// <unmanaged>HRESULT ID2D1ImageSource::OfferResources()</unmanaged>	
        /// <unmanaged-short>ID2D1ImageSource::OfferResources</unmanaged-short>	
        public void OfferResources()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Restores access to resources that were previously offered by calling <strong>OfferResources</strong>. </p>	
        /// </summary>	
        /// <param name="resourcesDiscarded">No documentation.</param>	
        /// <returns><p><strong>ReclaimResources</strong> returns: </p><ul> <li><strong><see cref="SharpDX.Result.Ok"/></strong> if resources were successfully reclaimed </li> <li><strong>E_INVALIDARG</strong> if the resources are invalid </li> </ul></returns>	
        /// <remarks>	
        /// <p> After you call <strong>OfferResources</strong> to offer one or more resources, 	
        /// you must call <strong>TryReclaimResources</strong> before you can use those resources again. 	
        /// You must check the value in the <strong>resourcesDiscarded</strong> to determine whether the resource?s content was discarded. 	
        /// If a resource?s content was discarded while it was offered, its current content is undefined. Therefore, you must overwrite the resource?s content before you use the resource. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageSource::TryReclaimResources']/*"/>	
        /// <msdn-id>dn952190</msdn-id>	
        /// <unmanaged>HRESULT ID2D1ImageSource::TryReclaimResources([Out] BOOL* resourcesDiscarded)</unmanaged>	
        /// <unmanaged-short>ID2D1ImageSource::TryReclaimResources</unmanaged-short>	
        public void TryReclaimResources(out SharpDX.Mathematics.Interop.RawBool resourcesDiscarded)
        {
            unsafe
            {
                resourcesDiscarded = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* resourcesDiscarded_ = &resourcesDiscarded)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, resourcesDiscarded_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Produces 2D pixel data that has been sourced from WIC.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> Create an an instance of <see cref="SharpDX.Direct2D1.ImageSourceFromWic"/>  using <strong><see cref="SharpDX.Direct2D1.DeviceContext2.CreateImageSourceFromWic"/></strong>. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageSourceFromWic']/*"/>	
    /// <msdn-id>dn900414</msdn-id>	
    /// <unmanaged>ID2D1ImageSourceFromWic</unmanaged>	
    /// <unmanaged-short>ID2D1ImageSourceFromWic</unmanaged-short>	
    [Guid("77395441-1c8f-4555-8683-f50dab0fe792")]
    public partial class ImageSourceFromWic : SharpDX.Direct2D1.ImageSource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.ImageSourceFromWic"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ImageSourceFromWic(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.ImageSourceFromWic"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.ImageSourceFromWic(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.ImageSourceFromWic(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves the underlying bitmap image source from the Windows Imaging Component (WIC).</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageSourceFromWic::GetSource']/*"/>	
        /// <msdn-id>dn900422</msdn-id>	
        /// <unmanaged>GetSource</unmanaged>	
        /// <unmanaged-short>GetSource</unmanaged-short>	
        /// <unmanaged>void ID2D1ImageSourceFromWic::GetSource([Out, Optional] IWICBitmapSource** wicBitmapSource)</unmanaged>
        public SharpDX.WIC.BitmapSource Source
        {
            get { SharpDX.WIC.BitmapSource __output__; GetSource(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Ensures that a specified region of the image source cache is populated. This method can be used to minimize glitches by performing expensive work to populate caches outside of a rendering loop. This method can also be used to speculatively load image data before it is needed by drawing routines. </p>	
        /// </summary>	
        /// <param name="rectangleToFill"><dd>  <p>Specifies the region of the image, in pixels, that should be populated in the cache. By default, this is the entire extent of the image.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This API loads image data into caches of image sources, if that data was not already cached.  It does not trim pre-existing caches, if any.   More areas within the cache can be populated than actually requested.</p><p> ? </p><p>The provided region must be constructed to include the scale with which the image source will subsequently be drawn.   These coordinates must be provided in local coordinates.   This means that they must be adjusted prior to calling the API according to the DPI and other relevant transforms, which can include the world transform and brush transforms.</p><p>This operation is only supported when the image source has been initialized using the <see cref="SharpDX.Direct2D1.ImageSourceLoadingOptions.CacheOnDemand"/> option.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageSourceFromWic::EnsureCached']/*"/>	
        /// <msdn-id>dn900420</msdn-id>	
        /// <unmanaged>HRESULT ID2D1ImageSourceFromWic::EnsureCached([In, Optional] const D2D_RECT_U* rectangleToFill)</unmanaged>	
        /// <unmanaged-short>ID2D1ImageSourceFromWic::EnsureCached</unmanaged-short>	
        public void EnsureCached(SharpDX.Mathematics.Interop.RawRectangle? rectangleToFill)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangle rectangleToFill_;
                if (rectangleToFill.HasValue)
                    rectangleToFill_ = rectangleToFill.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (rectangleToFill.HasValue) ? &rectangleToFill_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>This method trims the populated regions of the image source cache to just the specified rectangle.</p>	
        /// </summary>	
        /// <param name="rectangleToPreserve"><dd>  <p>Specifies the region of the image, in pixels, which should be preserved in the image source cache.  Regions which are outside of the rectangle are evicted from the cache. By default, this is an empty rectangle,  meaning that the entire image is evicted from the cache.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The provided region must be constructed to include the scale at which the image source will be drawn at.  These coordinates must be provided in local coordinates.   This means that they must be adjusted prior to calling the API according to the DPI and other relevant transforms, which can include the world transform and brush transforms.</p><p> ? </p><p>This method will fail if on-demand caching was not requested when the image source was created.</p><p> ? </p><p>As with <strong><see cref="SharpDX.Direct2D1.Device.ClearResources"/></strong>, the caller can need to subsequently issue a D3D flush before memory usage is reduced.</p><p>This operation is only supported when the image source has been initialized using the <see cref="SharpDX.Direct2D1.ImageSourceLoadingOptions.CacheOnDemand"/> option.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageSourceFromWic::TrimCache']/*"/>	
        /// <msdn-id>dn900424</msdn-id>	
        /// <unmanaged>HRESULT ID2D1ImageSourceFromWic::TrimCache([In, Optional] const D2D_RECT_U* rectangleToPreserve)</unmanaged>	
        /// <unmanaged-short>ID2D1ImageSourceFromWic::TrimCache</unmanaged-short>	
        public void TrimCache(SharpDX.Mathematics.Interop.RawRectangle? rectangleToPreserve)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangle rectangleToPreserve_;
                if (rectangleToPreserve.HasValue)
                    rectangleToPreserve_ = rectangleToPreserve.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (rectangleToPreserve.HasValue) ? &rectangleToPreserve_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Retrieves the underlying bitmap image source from the Windows Imaging Component (WIC).</p>	
        /// </summary>	
        /// <param name="wicBitmapSource"><dd>  <p>On return contains the bitmap image source.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ImageSourceFromWic::GetSource']/*"/>	
        /// <msdn-id>dn900422</msdn-id>	
        /// <unmanaged>void ID2D1ImageSourceFromWic::GetSource([Out, Optional] IWICBitmapSource** wicBitmapSource)</unmanaged>	
        /// <unmanaged-short>ID2D1ImageSourceFromWic::GetSource</unmanaged-short>	
        internal void GetSource(out SharpDX.WIC.BitmapSource wicBitmapSource)
        {
            unsafe
            {
                IntPtr wicBitmapSource_ = IntPtr.Zero;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &wicBitmapSource_, ((void**)(*(void**)_nativePointer))[8]);
                wicBitmapSource = (wicBitmapSource_ == IntPtr.Zero) ? null : new SharpDX.WIC.BitmapSource(wicBitmapSource_);
            }
        }
    }
    /// <summary>	
    /// <p>Represents a single continuous stroke of variable-width ink, as defined by a series of Bezier segments and widths.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Ink']/*"/>	
    /// <msdn-id>dn900426</msdn-id>	
    /// <unmanaged>ID2D1Ink</unmanaged>	
    /// <unmanaged-short>ID2D1Ink</unmanaged-short>	
    [Guid("b499923b-7029-478f-a8b3-432c7c5f5312")]
    public partial class Ink : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Ink"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Ink(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Ink"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Ink(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Ink(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves or sets the starting point for this ink object.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Ink::GetStartPoint']/*"/>	
        /// <msdn-id>dn900438</msdn-id>	
        /// <unmanaged>GetStartPoint / SetStartPoint</unmanaged>	
        /// <unmanaged-short>GetStartPoint</unmanaged-short>	
        /// <unmanaged>D2D1_INK_POINT ID2D1Ink::GetStartPoint()</unmanaged>
        public SharpDX.Direct2D1.InkPoint StartPoint
        {
            get { return GetStartPoint(); }
            set { SetStartPoint(value); }
        }

        /// <summary>	
        /// <p>Updates the last segment in this ink object with new control points.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Ink::SetSegmentAtEnd']/*"/>	
        /// <msdn-id>dn900441</msdn-id>	
        /// <unmanaged>SetSegmentAtEnd</unmanaged>	
        /// <unmanaged-short>SetSegmentAtEnd</unmanaged-short>	
        /// <unmanaged>HRESULT ID2D1Ink::SetSegmentAtEnd([In] const D2D1_INK_BEZIER_SEGMENT* segment)</unmanaged>
        public SharpDX.Direct2D1.InkBezierSegment SegmentAtEnd
        {
            set { SetSegmentAtEnd(ref value); }
        }

        /// <summary>	
        /// <p>Returns the number of segments in this ink object.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Ink::GetSegmentCount']/*"/>	
        /// <msdn-id>dn900436</msdn-id>	
        /// <unmanaged>GetSegmentCount</unmanaged>	
        /// <unmanaged-short>GetSegmentCount</unmanaged-short>	
        /// <unmanaged>unsigned int ID2D1Ink::GetSegmentCount()</unmanaged>
        public int SegmentCount
        {
            get { return GetSegmentCount(); }
        }

        /// <summary>	
        /// <p>Sets the starting point for this ink object. This determines where this ink object will start rendering.</p>	
        /// </summary>	
        /// <param name="startPoint"><dd>  <p>The new starting point for this ink object.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Ink::SetStartPoint']/*"/>	
        /// <msdn-id>dn900446</msdn-id>	
        /// <unmanaged>void ID2D1Ink::SetStartPoint([In] const D2D1_INK_POINT* startPoint)</unmanaged>	
        /// <unmanaged-short>ID2D1Ink::SetStartPoint</unmanaged-short>	
        internal void SetStartPoint(SharpDX.Direct2D1.InkPoint startPoint)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &startPoint, ((void**)(*(void**)_nativePointer))[4]);
            }
        }

        /// <summary>	
        /// <p>Retrieves the starting point for this ink object.</p>	
        /// </summary>	
        /// <returns><p>The starting point for this ink object.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Ink::GetStartPoint']/*"/>	
        /// <msdn-id>dn900438</msdn-id>	
        /// <unmanaged>D2D1_INK_POINT ID2D1Ink::GetStartPoint()</unmanaged>	
        /// <unmanaged-short>ID2D1Ink::GetStartPoint</unmanaged-short>	
        internal SharpDX.Direct2D1.InkPoint GetStartPoint()
        {
            unsafe
            {
                SharpDX.Direct2D1.InkPoint __result__;
                SharpDX.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, (void*)&__result__, ((void**)(*(void**)_nativePointer))[5]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Adds the given segments to the end of this ink object.</p>	
        /// </summary>	
        /// <param name="segments"><dd>  <p>A reference to an array of segments to be added to this ink object.</p> </dd></param>	
        /// <param name="segmentsCount"><dd>  <p>The number of segments to be added to this ink object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Ink::AddSegments']/*"/>	
        /// <msdn-id>dn900434</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Ink::AddSegments([In, Buffer] const D2D1_INK_BEZIER_SEGMENT* segments,[In] unsigned int segmentsCount)</unmanaged>	
        /// <unmanaged-short>ID2D1Ink::AddSegments</unmanaged-short>	
        public void AddSegments(SharpDX.Direct2D1.InkBezierSegment[] segments, int segmentsCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* segments_ = segments)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, segments_, segmentsCount, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Removes the given number of segments from the end of this ink object.</p>	
        /// </summary>	
        /// <param name="segmentsCount"><dd>  <p>The number of segments to be removed from the end of this ink object. Note that segmentsCount must be less or equal to the number of segments in the ink object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Ink::RemoveSegmentsAtEnd']/*"/>	
        /// <msdn-id>dn900439</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Ink::RemoveSegmentsAtEnd([In] unsigned int segmentsCount)</unmanaged>	
        /// <unmanaged-short>ID2D1Ink::RemoveSegmentsAtEnd</unmanaged-short>	
        public void RemoveSegmentsAtEnd(int segmentsCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, segmentsCount, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Updates the specified segments in this ink object with new control points.</p>	
        /// </summary>	
        /// <param name="startSegment"><dd>  <p>The index of the first segment in this ink object to update.</p> </dd></param>	
        /// <param name="segments"><dd>  <p>A reference to the array of segment data to be used in the update.</p> </dd></param>	
        /// <param name="segmentsCount"><dd>  <p>The number of segments in this ink object that will be updated with new data. Note that segmentsCount must be less than or equal to the number of segments in the ink object minus startSegment.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Ink::SetSegments']/*"/>	
        /// <msdn-id>dn900443</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Ink::SetSegments([In] unsigned int startSegment,[In, Buffer] const D2D1_INK_BEZIER_SEGMENT* segments,[In] unsigned int segmentsCount)</unmanaged>	
        /// <unmanaged-short>ID2D1Ink::SetSegments</unmanaged-short>	
        public void SetSegments(int startSegment, SharpDX.Direct2D1.InkBezierSegment[] segments, int segmentsCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* segments_ = segments)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, startSegment, segments_, segmentsCount, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Updates the last segment in this ink object with new control points.</p>	
        /// </summary>	
        /// <param name="segment"><dd>  <p>A reference to the segment data with which to overwrite this ink object's last segment.  Note that if there are currently no segments in the ink object, SetSegmentsAtEnd will return an error.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Ink::SetSegmentAtEnd']/*"/>	
        /// <msdn-id>dn900441</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Ink::SetSegmentAtEnd([In] const D2D1_INK_BEZIER_SEGMENT* segment)</unmanaged>	
        /// <unmanaged-short>ID2D1Ink::SetSegmentAtEnd</unmanaged-short>	
        internal void SetSegmentAtEnd(ref SharpDX.Direct2D1.InkBezierSegment segment)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* segment_ = &segment)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, segment_, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Returns the number of segments in this ink object.</p>	
        /// </summary>	
        /// <returns><p>Returns the number of segments in this ink object.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Ink::GetSegmentCount']/*"/>	
        /// <msdn-id>dn900436</msdn-id>	
        /// <unmanaged>unsigned int ID2D1Ink::GetSegmentCount()</unmanaged>	
        /// <unmanaged-short>ID2D1Ink::GetSegmentCount</unmanaged-short>	
        internal int GetSegmentCount()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[10]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Retrieves the specified subset of segments stored in this ink object.</p>	
        /// </summary>	
        /// <param name="startSegment"><dd>  <p>The index of the first segment in this ink object to retrieve.</p> </dd></param>	
        /// <param name="segments"><dd>  <p>When this method returns, contains a reference to an array of retrieved segments.</p> </dd></param>	
        /// <param name="segmentsCount"><dd>  <p>The number of segments to retrieve. Note that segmentsCount must be less than or equal to the number of segments in the ink object minus startSegment.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Ink::GetSegments']/*"/>	
        /// <msdn-id>dn900437</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Ink::GetSegments([In] unsigned int startSegment,[Out, Buffer] D2D1_INK_BEZIER_SEGMENT* segments,[In] unsigned int segmentsCount)</unmanaged>	
        /// <unmanaged-short>ID2D1Ink::GetSegments</unmanaged-short>	
        public void GetSegments(int startSegment, SharpDX.Direct2D1.InkBezierSegment[] segments, int segmentsCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* segments_ = segments)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, startSegment, segments_, segmentsCount, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Retrieves a geometric representation of this ink object.</p>	
        /// </summary>	
        /// <param name="inkStyle"><dd>  <p>The ink style to be used in determining the geometric representation.</p> </dd></param>	
        /// <param name="worldTransform"><dd>  <p>The world transform to be used in determining the geometric representation.</p> </dd></param>	
        /// <param name="flatteningTolerance"><dd>  <p>The geometry sink to which the geometry representation will be streamed.</p> </dd></param>	
        /// <param name="geometrySink"><dd>  <p>The geometry sink to which the geometry representation will be streamed.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Ink::StreamAsGeometry']/*"/>	
        /// <msdn-id>dn900450</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Ink::StreamAsGeometry([In, Optional] ID2D1InkStyle* inkStyle,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>	
        /// <unmanaged-short>ID2D1Ink::StreamAsGeometry</unmanaged-short>	
        internal void StreamAsGeometry_(SharpDX.Direct2D1.InkStyle inkStyle, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, float flatteningTolerance, System.IntPtr geometrySink)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((inkStyle == null) ? IntPtr.Zero : inkStyle.NativePointer), (worldTransform.HasValue) ? &worldTransform_ : (void*)IntPtr.Zero, flatteningTolerance, (void*)geometrySink, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Retrieve the bounds of the geometry, with an optional applied transform.</p>	
        /// </summary>	
        /// <param name="inkStyle"><dd>  <p>The ink style to be used in determining the bounds of this ink object.</p> </dd></param>	
        /// <param name="worldTransform"><dd>  <p>The world transform to be used in determining the bounds of this ink object.</p> </dd></param>	
        /// <param name="bounds"><dd>  <p>When this method returns, contains the bounds of this ink object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Ink::GetBounds']/*"/>	
        /// <msdn-id>dn900435</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Ink::GetBounds([In, Optional] ID2D1InkStyle* inkStyle,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[Out] D2D_RECT_F* bounds)</unmanaged>	
        /// <unmanaged-short>ID2D1Ink::GetBounds</unmanaged-short>	
        public void GetBounds(SharpDX.Direct2D1.InkStyle inkStyle, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, out SharpDX.Mathematics.Interop.RawRectangleF bounds)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;
                bounds = new SharpDX.Mathematics.Interop.RawRectangleF();
                SharpDX.Result __result__;
                fixed (void* bounds_ = &bounds)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((inkStyle == null) ? IntPtr.Zero : inkStyle.NativePointer), (worldTransform.HasValue) ? &worldTransform_ : (void*)IntPtr.Zero, bounds_, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Represents a collection of style properties to be used by methods like <strong><see cref="SharpDX.Direct2D1.DeviceContext2.DrawInk"/></strong> when rendering ink. The ink style defines the nib (pen tip) shape and transform. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1InkStyle']/*"/>	
    /// <msdn-id>dn900427</msdn-id>	
    /// <unmanaged>ID2D1InkStyle</unmanaged>	
    /// <unmanaged-short>ID2D1InkStyle</unmanaged-short>	
    [Guid("bae8b344-23fc-4071-8cb5-d05d6f073848")]
    public partial class InkStyle : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.InkStyle"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public InkStyle(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.InkStyle"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.InkStyle(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.InkStyle(nativePointer);
        }


        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1InkStyle::GetNibTransform']/*"/>	
        /// <unmanaged>GetNibTransform / SetNibTransform</unmanaged>	
        /// <unmanaged-short>GetNibTransform</unmanaged-short>	
        /// <unmanaged>void ID2D1InkStyle::GetNibTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 NibTransform
        {
            get { SharpDX.Mathematics.Interop.RawMatrix3x2 __output__; GetNibTransform(out __output__); return __output__; }
            set { SetNibTransform(ref value); }
        }

        /// <summary>	
        /// <p>Retrieves or sets the pre-transform nib shape for this style.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1InkStyle::GetNibShape']/*"/>	
        /// <msdn-id>dn900428</msdn-id>	
        /// <unmanaged>GetNibShape / SetNibShape</unmanaged>	
        /// <unmanaged-short>GetNibShape</unmanaged-short>	
        /// <unmanaged>D2D1_INK_NIB_SHAPE ID2D1InkStyle::GetNibShape()</unmanaged>
        public SharpDX.Direct2D1.InkNibShape NibShape
        {
            get { return GetNibShape(); }
            set { SetNibShape(value); }
        }

        /// <summary>	
        /// <p>Sets the transform to apply to this style's nib shape.</p>	
        /// </summary>	
        /// <param name="transform"><dd>  <p>The transform to apply to this style?s nib shape. Note that the translation components of the transform matrix are ignored for the purposes of rendering.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1InkStyle::SetNibTransform']/*"/>	
        /// <msdn-id>dn900431</msdn-id>	
        /// <unmanaged>void ID2D1InkStyle::SetNibTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>	
        /// <unmanaged-short>ID2D1InkStyle::SetNibTransform</unmanaged-short>	
        internal void SetNibTransform(ref SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            unsafe
            {
                fixed (void* transform_ = &transform)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, transform_, ((void**)(*(void**)_nativePointer))[4]);
            }
        }

        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="transform">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1InkStyle::GetNibTransform']/*"/>	
        /// <unmanaged>void ID2D1InkStyle::GetNibTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>	
        /// <unmanaged-short>ID2D1InkStyle::GetNibTransform</unmanaged-short>	
        internal void GetNibTransform(out SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            unsafe
            {
                transform = new SharpDX.Mathematics.Interop.RawMatrix3x2();
                fixed (void* transform_ = &transform)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, transform_, ((void**)(*(void**)_nativePointer))[5]);
            }
        }

        /// <summary>	
        /// <p>Sets the pre-transform nib shape for this style.</p>	
        /// </summary>	
        /// <param name="nibShape"><dd>  <p>The pre-transform nib shape to use in this style.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1InkStyle::SetNibShape']/*"/>	
        /// <msdn-id>dn900430</msdn-id>	
        /// <unmanaged>void ID2D1InkStyle::SetNibShape([In] D2D1_INK_NIB_SHAPE nibShape)</unmanaged>	
        /// <unmanaged-short>ID2D1InkStyle::SetNibShape</unmanaged-short>	
        internal void SetNibShape(SharpDX.Direct2D1.InkNibShape nibShape)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)nibShape), ((void**)(*(void**)_nativePointer))[6]);
            }
        }

        /// <summary>	
        /// <p>Retrieves the pre-transform nib shape for this style.</p>	
        /// </summary>	
        /// <returns><p>Returns the pre-transform nib shape for this style.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1InkStyle::GetNibShape']/*"/>	
        /// <msdn-id>dn900428</msdn-id>	
        /// <unmanaged>D2D1_INK_NIB_SHAPE ID2D1InkStyle::GetNibShape()</unmanaged>	
        /// <unmanaged-short>ID2D1InkStyle::GetNibShape</unmanaged-short>	
        internal SharpDX.Direct2D1.InkNibShape GetNibShape()
        {
            unsafe
            {
                SharpDX.Direct2D1.InkNibShape __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1InkNibShape(_nativePointer, ((void**)(*(void**)_nativePointer))[7]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Represents the backing store required to render a layer. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To create a layer, call the <strong>CreateLayer</strong> method of the render target where the layer will be used. To draw to a layer, push the layer to the render target stack by calling the <strong>PushLayer</strong> method. After you have finished drawing to the layer, call the <strong>PopLayer</strong> method.</p><p>Between  <strong>PushLayer</strong> and <strong>PopLayer</strong> calls, the layer is in use and cannot be used by another render target. </p><p>If the size of the layer is not specified, the corresponding <strong>PushLayer</strong> call determines the minimum layer size, based on the layer content bounds and the geometric mask. The layer resource can be larger than the size required by <strong>PushLayer</strong> without any rendering artifacts.</p><p>If the size of a layer is specified, or if the layer has been used and the required backing store size as calculated during <strong>PushLayer</strong> is larger than the layer, then the layer resource is expanded on each axis monotonically to ensure that it is large enough. The layer resource never shrinks in size.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Layer']/*"/>	
    /// <msdn-id>dd371483</msdn-id>	
    /// <unmanaged>ID2D1Layer</unmanaged>	
    /// <unmanaged-short>ID2D1Layer</unmanaged-short>	
    [Guid("2cd9069b-12e2-11dc-9fed-001143a055f9")]
    public partial class Layer : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Layer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Layer(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Layer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Layer(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Layer(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the size of the layer in device-independent pixels. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Layer::GetSize']/*"/>	
        /// <msdn-id>dd371485</msdn-id>	
        /// <unmanaged>GetSize</unmanaged>	
        /// <unmanaged-short>GetSize</unmanaged-short>	
        /// <unmanaged>D2D_SIZE_F ID2D1Layer::GetSize()</unmanaged>
        public SharpDX.Size2F Size
        {
            get { return GetSize(); }
        }

        /// <summary>	
        /// <p>Gets the size of the layer in device-independent pixels. </p>	
        /// </summary>	
        /// <returns><p>The size of the layer in device-independent pixels.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Layer::GetSize']/*"/>	
        /// <msdn-id>dd371485</msdn-id>	
        /// <unmanaged>D2D_SIZE_F ID2D1Layer::GetSize()</unmanaged>	
        /// <unmanaged-short>ID2D1Layer::GetSize</unmanaged-short>	
        internal SharpDX.Size2F GetSize()
        {
            unsafe
            {
                SharpDX.Size2F __result__;
                SharpDX.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, (void*)&__result__, ((void**)(*(void**)_nativePointer))[4]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Paints an area with a linear gradient.  </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An <strong><see cref="SharpDX.Direct2D1.LinearGradientBrush"/></strong> paints an area with a linear gradient along a line between the brush start point and end   point. The gradient, defined by the brush <strong><see cref="SharpDX.Direct2D1.GradientStopCollection"/></strong>, is extruded perpendicular to this line, and then transformed by a brush transform (if specified).  </p><p>The start point and end   point are described in the brush space and are mappped to the render target when the brush is used. Note the starting and ending coordinates are absolute, not relative to the render target size. A value of (0, 0) maps to the upper-left corner of the render target, while a value of (1, 1) maps one pixel diagonally away from (0, 0). If there is a nonidentity brush transform or render target transform, the brush start point and end point are also transformed.  </p><p>It is possible to specify a gradient axis that does not completely fill the area that is being painted. When this occurs, the <strong><see cref="SharpDX.Direct2D1.ExtendMode"/></strong>, specified by the   <strong><see cref="SharpDX.Direct2D1.GradientStopCollection"/></strong>, determines how the remaining area is painted. 	
    /// </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1LinearGradientBrush']/*"/>	
    /// <msdn-id>dd371488</msdn-id>	
    /// <unmanaged>ID2D1LinearGradientBrush</unmanaged>	
    /// <unmanaged-short>ID2D1LinearGradientBrush</unmanaged-short>	
    [Guid("2cd906ab-12e2-11dc-9fed-001143a055f9")]
    public partial class LinearGradientBrush : SharpDX.Direct2D1.Brush
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.LinearGradientBrush"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public LinearGradientBrush(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.LinearGradientBrush"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.LinearGradientBrush(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.LinearGradientBrush(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves or sets the starting coordinates of the linear gradient. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1LinearGradientBrush::GetStartPoint']/*"/>	
        /// <msdn-id>dd371497</msdn-id>	
        /// <unmanaged>GetStartPoint / SetStartPoint</unmanaged>	
        /// <unmanaged-short>GetStartPoint</unmanaged-short>	
        /// <unmanaged>D2D_POINT_2F ID2D1LinearGradientBrush::GetStartPoint()</unmanaged>
        public SharpDX.Mathematics.Interop.RawVector2 StartPoint
        {
            get { return GetStartPoint(); }
            set { SetStartPoint(value); }
        }

        /// <summary>	
        /// <p>Retrieves or sets the ending coordinates of the linear gradient. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1LinearGradientBrush::GetEndPoint']/*"/>	
        /// <msdn-id>dd371492</msdn-id>	
        /// <unmanaged>GetEndPoint / SetEndPoint</unmanaged>	
        /// <unmanaged-short>GetEndPoint</unmanaged-short>	
        /// <unmanaged>D2D_POINT_2F ID2D1LinearGradientBrush::GetEndPoint()</unmanaged>
        public SharpDX.Mathematics.Interop.RawVector2 EndPoint
        {
            get { return GetEndPoint(); }
            set { SetEndPoint(value); }
        }

        /// <summary>	
        /// <p> Retrieves the <strong><see cref="SharpDX.Direct2D1.GradientStopCollection"/></strong> associated with this linear gradient brush.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> <strong><see cref="SharpDX.Direct2D1.GradientStopCollection"/></strong> contains an array of <strong><see cref="SharpDX.Direct2D1.GradientStop"/></strong> structures and information, such as the extend mode and the color interpolation mode.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1LinearGradientBrush::GetGradientStopCollection']/*"/>	
        /// <msdn-id>dd371496</msdn-id>	
        /// <unmanaged>GetGradientStopCollection</unmanaged>	
        /// <unmanaged-short>GetGradientStopCollection</unmanaged-short>	
        /// <unmanaged>void ID2D1LinearGradientBrush::GetGradientStopCollection([Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
        public SharpDX.Direct2D1.GradientStopCollection GradientStopCollection
        {
            get { SharpDX.Direct2D1.GradientStopCollection __output__; GetGradientStopCollection(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Sets the starting coordinates of the linear gradient in the brush's coordinate space.  </p>	
        /// </summary>	
        /// <param name="startPoint"><dd>  <p>The starting two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</p> </dd></param>	
        /// <remarks>	
        /// <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1LinearGradientBrush::SetStartPoint']/*"/>	
        /// <msdn-id>dd371505</msdn-id>	
        /// <unmanaged>void ID2D1LinearGradientBrush::SetStartPoint([In] D2D_POINT_2F startPoint)</unmanaged>	
        /// <unmanaged-short>ID2D1LinearGradientBrush::SetStartPoint</unmanaged-short>	
        internal void SetStartPoint(SharpDX.Mathematics.Interop.RawVector2 startPoint)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid42(_nativePointer, startPoint, ((void**)(*(void**)_nativePointer))[8]);
            }
        }

        /// <summary>	
        /// <p>Sets the ending coordinates of the linear gradient in the brush's coordinate space.</p>	
        /// </summary>	
        /// <param name="endPoint"><dd>  <p>The ending two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</p> </dd></param>	
        /// <remarks>	
        /// <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1LinearGradientBrush::SetEndPoint']/*"/>	
        /// <msdn-id>dd371501</msdn-id>	
        /// <unmanaged>void ID2D1LinearGradientBrush::SetEndPoint([In] D2D_POINT_2F endPoint)</unmanaged>	
        /// <unmanaged-short>ID2D1LinearGradientBrush::SetEndPoint</unmanaged-short>	
        internal void SetEndPoint(SharpDX.Mathematics.Interop.RawVector2 endPoint)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid42(_nativePointer, endPoint, ((void**)(*(void**)_nativePointer))[9]);
            }
        }

        /// <summary>	
        /// <p>Retrieves the starting coordinates of the linear gradient. </p>	
        /// </summary>	
        /// <returns><p>The starting two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</p></returns>	
        /// <remarks>	
        /// <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1LinearGradientBrush::GetStartPoint']/*"/>	
        /// <msdn-id>dd371497</msdn-id>	
        /// <unmanaged>D2D_POINT_2F ID2D1LinearGradientBrush::GetStartPoint()</unmanaged>	
        /// <unmanaged-short>ID2D1LinearGradientBrush::GetStartPoint</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawVector2 GetStartPoint()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawVector2 __result__;
                SharpDX.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, (void*)&__result__, ((void**)(*(void**)_nativePointer))[10]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Retrieves the ending coordinates of the linear gradient. </p>	
        /// </summary>	
        /// <returns><p>The ending two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</p></returns>	
        /// <remarks>	
        /// <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1LinearGradientBrush::GetEndPoint']/*"/>	
        /// <msdn-id>dd371492</msdn-id>	
        /// <unmanaged>D2D_POINT_2F ID2D1LinearGradientBrush::GetEndPoint()</unmanaged>	
        /// <unmanaged-short>ID2D1LinearGradientBrush::GetEndPoint</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawVector2 GetEndPoint()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawVector2 __result__;
                SharpDX.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, (void*)&__result__, ((void**)(*(void**)_nativePointer))[11]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Retrieves the <strong><see cref="SharpDX.Direct2D1.GradientStopCollection"/></strong> associated with this linear gradient brush.</p>	
        /// </summary>	
        /// <param name="gradientStopCollection">No documentation.</param>	
        /// <remarks>	
        /// <p> <strong><see cref="SharpDX.Direct2D1.GradientStopCollection"/></strong> contains an array of <strong><see cref="SharpDX.Direct2D1.GradientStop"/></strong> structures and information, such as the extend mode and the color interpolation mode.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1LinearGradientBrush::GetGradientStopCollection']/*"/>	
        /// <msdn-id>dd371496</msdn-id>	
        /// <unmanaged>void ID2D1LinearGradientBrush::GetGradientStopCollection([Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>	
        /// <unmanaged-short>ID2D1LinearGradientBrush::GetGradientStopCollection</unmanaged-short>	
        internal void GetGradientStopCollection(out SharpDX.Direct2D1.GradientStopCollection gradientStopCollection)
        {
            unsafe
            {
                IntPtr gradientStopCollection_ = IntPtr.Zero;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &gradientStopCollection_, ((void**)(*(void**)_nativePointer))[12]);
                gradientStopCollection = (gradientStopCollection_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.GradientStopCollection(gradientStopCollection_);
            }
        }
    }
    /// <summary>	
    /// <p>A container for 3D lookup table data that can be passed to the LookupTable3D effect.</p><p>An ID2DLookupTable3D instance is created using <strong><see cref="SharpDX.Direct2D1.DeviceContext2.CreateLookupTable3D"/></strong> or <see cref="SharpDX.Direct2D1.EffectContext1.CreateLookupTable3D"/>.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1LookupTable3D']/*"/>	
    /// <msdn-id>dn900453</msdn-id>	
    /// <unmanaged>ID2D1LookupTable3D</unmanaged>	
    /// <unmanaged-short>ID2D1LookupTable3D</unmanaged-short>	
    [Guid("53dd9855-a3b0-4d5b-82e1-26e25c5e5797")]
    public partial class LookupTable3D : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.LookupTable3D"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public LookupTable3D(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.LookupTable3D"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.LookupTable3D(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.LookupTable3D(nativePointer);
        }

    }
    /// <summary>	
    /// <p>Represents a set of vertices that form a list of triangles.  </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Mesh']/*"/>	
    /// <msdn-id>dd371508</msdn-id>	
    /// <unmanaged>ID2D1Mesh</unmanaged>	
    /// <unmanaged-short>ID2D1Mesh</unmanaged-short>	
    [Guid("2cd906c2-12e2-11dc-9fed-001143a055f9")]
    public partial class Mesh : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Mesh"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Mesh(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Mesh"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Mesh(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Mesh(nativePointer);
        }


        /// <summary>	
        /// <p>Opens the mesh for population.</p>	
        /// </summary>	
        /// <param name="tessellationSink"><dd>  <p>When this method returns, contains a reference to a reference to an <strong><see cref="SharpDX.Direct2D1.TessellationSink"/></strong> that is used to populate the mesh. This parameter is passed uninitialized.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Mesh::Open']/*"/>	
        /// <msdn-id>dd371510</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Mesh::Open([Out] ID2D1TessellationSink** tessellationSink)</unmanaged>	
        /// <unmanaged-short>ID2D1Mesh::Open</unmanaged-short>	
        internal void Open_(out SharpDX.Direct2D1.TessellationSink tessellationSink)
        {
            unsafe
            {
                IntPtr tessellationSink_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &tessellationSink_, ((void**)(*(void**)_nativePointer))[4]);
                tessellationSink = (tessellationSink_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.TessellationSinkNative(tessellationSink_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A  locking mechanism from a Direct2D factory that Direct2D uses to control exclusive resource access in an app that is uses multiple threads.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>You can get an <strong>ID2D1MultiThread</strong> object by querying for it from an <strong><see cref="SharpDX.Direct2D1.Factory"/></strong> object.</p><p> You should use this lock while doing any operation on a Direct3D/DXGI surface. Direct2D will wait on any call until you leave the critical section.</p><p><strong>Note</strong>??Normal rendering is guarded automatically by an internal Direct2D lock.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Multithread']/*"/>	
    /// <msdn-id>hh997713</msdn-id>	
    /// <unmanaged>ID2D1Multithread</unmanaged>	
    /// <unmanaged-short>ID2D1Multithread</unmanaged-short>	
    [Guid("31e6e7bc-e0ff-4d46-8c64-a0a8c41c15d3")]
    public partial class Multithread : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Multithread"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Multithread(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Multithread"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Multithread(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Multithread(nativePointer);
        }


        /// <summary>	
        /// <p>Returns whether the Direct2D factory was created with      the <strong><see cref="SharpDX.Direct2D1.FactoryType.MultiThreaded"/></strong> flag.  </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Multithread::GetMultithreadProtected']/*"/>	
        /// <msdn-id>hh997715</msdn-id>	
        /// <unmanaged>GetMultithreadProtected</unmanaged>	
        /// <unmanaged-short>GetMultithreadProtected</unmanaged-short>	
        /// <unmanaged>BOOL ID2D1Multithread::GetMultithreadProtected()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool MultithreadProtected
        {
            get { return GetMultithreadProtected(); }
        }

        /// <summary>	
        /// <p>Returns whether the Direct2D factory was created with      the <strong><see cref="SharpDX.Direct2D1.FactoryType.MultiThreaded"/></strong> flag.  </p>	
        /// </summary>	
        /// <returns><p>Returns true if the Direct2D factory was created as multi-threaded, or false if it was created as single-threaded.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Multithread::GetMultithreadProtected']/*"/>	
        /// <msdn-id>hh997715</msdn-id>	
        /// <unmanaged>BOOL ID2D1Multithread::GetMultithreadProtected()</unmanaged>	
        /// <unmanaged-short>ID2D1Multithread::GetMultithreadProtected</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool GetMultithreadProtected()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Enters the Direct2D API critical section, if it exists. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Multithread::Enter']/*"/>	
        /// <msdn-id>hh997714</msdn-id>	
        /// <unmanaged>void ID2D1Multithread::Enter()</unmanaged>	
        /// <unmanaged-short>ID2D1Multithread::Enter</unmanaged-short>	
        public void Enter()
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
            }
        }

        /// <summary>	
        /// <p>Leaves the Direct2D API critical section, if it exists.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Multithread::Leave']/*"/>	
        /// <msdn-id>hh997716</msdn-id>	
        /// <unmanaged>void ID2D1Multithread::Leave()</unmanaged>	
        /// <unmanaged-short>ID2D1Multithread::Leave</unmanaged-short>	
        public void Leave()
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
            }
        }
    }
    /// <summary>	
    /// <p>Instructs the effect-rendering system to offset an input bitmap without inserting a rendering pass.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Because a rendering pass is not required, the interface derives from a transform node. This allows it to be inserted into a graph but does not allow an output buffer to be specified.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1OffsetTransform']/*"/>	
    /// <msdn-id>hh446820</msdn-id>	
    /// <unmanaged>ID2D1OffsetTransform</unmanaged>	
    /// <unmanaged-short>ID2D1OffsetTransform</unmanaged-short>	
    [Guid("3fe6adea-7643-4f53-bd14-a0ce63f24042")]
    public partial class OffsetTransform : SharpDX.Direct2D1.TransformNodeNative
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.OffsetTransform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public OffsetTransform(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.OffsetTransform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.OffsetTransform(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.OffsetTransform(nativePointer);
        }


        /// <summary>	
        /// <p>Sets the offset in the current offset transform.</p>	
        /// </summary>	
        /// <param name="offset"><dd>  <p>The new offset to apply to the offset transform.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1OffsetTransform::SetOffset']/*"/>	
        /// <msdn-id>hh446824</msdn-id>	
        /// <unmanaged>void ID2D1OffsetTransform::SetOffset([In] POINT offset)</unmanaged>	
        /// <unmanaged-short>ID2D1OffsetTransform::SetOffset</unmanaged-short>	
        public void SetOffset(SharpDX.Mathematics.Interop.RawPoint offset)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid120(_nativePointer, offset, ((void**)(*(void**)_nativePointer))[4]);
            }
        }

        /// <summary>	
        /// <p>Gets the offset currently in the offset transform.</p>	
        /// </summary>	
        /// <returns><p>The current transform offset.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1OffsetTransform::GetOffset']/*"/>	
        /// <msdn-id>hh446822</msdn-id>	
        /// <unmanaged>POINT ID2D1OffsetTransform::GetOffset()</unmanaged>	
        /// <unmanaged-short>ID2D1OffsetTransform::GetOffset</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawPoint GetOffset()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawPoint __result__;
                SharpDX.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, (void*)&__result__, ((void**)(*(void**)_nativePointer))[5]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Represents a complex shape that may be composed of arcs, curves, and lines.  </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An <strong><see cref="SharpDX.Direct2D1.PathGeometry"/></strong> object enables you to describe a geometric path. To describe an <strong><see cref="SharpDX.Direct2D1.PathGeometry"/></strong> object's path, use the object's  <strong>Open</strong> method to retrieve an <strong><see cref="SharpDX.Direct2D1.GeometrySink"/></strong>. Use the sink to populate the path geometry with figures and segments. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1PathGeometry']/*"/>	
    /// <msdn-id>dd371512</msdn-id>	
    /// <unmanaged>ID2D1PathGeometry</unmanaged>	
    /// <unmanaged-short>ID2D1PathGeometry</unmanaged-short>	
    [Guid("2cd906a5-12e2-11dc-9fed-001143a055f9")]
    public partial class PathGeometry : SharpDX.Direct2D1.Geometry
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.PathGeometry"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PathGeometry(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.PathGeometry"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.PathGeometry(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.PathGeometry(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves the number of segments in the path geometry. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1PathGeometry::GetSegmentCount']/*"/>	
        /// <msdn-id>dd371520</msdn-id>	
        /// <unmanaged>GetSegmentCount</unmanaged>	
        /// <unmanaged-short>GetSegmentCount</unmanaged-short>	
        /// <unmanaged>HRESULT ID2D1PathGeometry::GetSegmentCount([Out] unsigned int* count)</unmanaged>
        public int SegmentCount
        {
            get { int __output__; GetSegmentCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Retrieves the number of figures in the path geometry. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1PathGeometry::GetFigureCount']/*"/>	
        /// <msdn-id>dd371515</msdn-id>	
        /// <unmanaged>GetFigureCount</unmanaged>	
        /// <unmanaged-short>GetFigureCount</unmanaged-short>	
        /// <unmanaged>HRESULT ID2D1PathGeometry::GetFigureCount([Out] unsigned int* count)</unmanaged>
        public int FigureCount
        {
            get { int __output__; GetFigureCount(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Retrieves the geometry sink that is used to populate the path geometry with figures and segments. </p>	
        /// </summary>	
        /// <returns><dd>  <p>When this method returns, <em>geometrySink</em> contains the address of a reference to the geometry sink that is used to populate the path geometry with figures and segments. This parameter is passed uninitialized.</p> </dd></returns>	
        /// <remarks>	
        /// <p>Because path geometries are immutable and can only be populated once, it is an error to call <strong>Open</strong> on a path geometry more than once.</p><p>Note that the fill mode defaults to <strong><see cref="SharpDX.Direct2D1.FillMode.Alternate"/></strong>. To set the fill mode, call <strong>SetFillMode</strong> before the first call to <strong>BeginFigure</strong>. Failure to do so will put the geometry sink in an error state. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1PathGeometry::Open']/*"/>	
        /// <msdn-id>dd371522</msdn-id>	
        /// <unmanaged>HRESULT ID2D1PathGeometry::Open([Out] ID2D1GeometrySink** geometrySink)</unmanaged>	
        /// <unmanaged-short>ID2D1PathGeometry::Open</unmanaged-short>	
        public SharpDX.Direct2D1.GeometrySink Open()
        {
            unsafe
            {
                SharpDX.Direct2D1.GeometrySink geometrySink;
                IntPtr geometrySink_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &geometrySink_, ((void**)(*(void**)_nativePointer))[17]);
                geometrySink = (geometrySink_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.GeometrySinkNative(geometrySink_);
                __result__.CheckError();
                return geometrySink;
            }
        }

        /// <summary>	
        /// <p>Copies the contents of the path geometry to the specified <strong><see cref="SharpDX.Direct2D1.GeometrySink"/></strong>.</p>	
        /// </summary>	
        /// <param name="geometrySink">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1PathGeometry::Stream']/*"/>	
        /// <msdn-id>dd371525</msdn-id>	
        /// <unmanaged>HRESULT ID2D1PathGeometry::Stream([In] ID2D1GeometrySink* geometrySink)</unmanaged>	
        /// <unmanaged-short>ID2D1PathGeometry::Stream</unmanaged-short>	
        internal void Stream_(System.IntPtr geometrySink)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)geometrySink, ((void**)(*(void**)_nativePointer))[18]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Retrieves the number of segments in the path geometry. </p>	
        /// </summary>	
        /// <param name="count"><dd>  <p>A reference that receives the number of segments in the path geometry when this method returns. You must allocate storage for this parameter.   </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1PathGeometry::GetSegmentCount']/*"/>	
        /// <msdn-id>dd371520</msdn-id>	
        /// <unmanaged>HRESULT ID2D1PathGeometry::GetSegmentCount([Out] unsigned int* count)</unmanaged>	
        /// <unmanaged-short>ID2D1PathGeometry::GetSegmentCount</unmanaged-short>	
        internal void GetSegmentCount(out int count)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* count_ = &count)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, count_, ((void**)(*(void**)_nativePointer))[19]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Retrieves the number of figures in the path geometry. </p>	
        /// </summary>	
        /// <param name="count"><dd>  <p>A reference that receives the number of figures in the path geometry when this method returns. You must allocate storage for this parameter.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1PathGeometry::GetFigureCount']/*"/>	
        /// <msdn-id>dd371515</msdn-id>	
        /// <unmanaged>HRESULT ID2D1PathGeometry::GetFigureCount([Out] unsigned int* count)</unmanaged>	
        /// <unmanaged-short>ID2D1PathGeometry::GetFigureCount</unmanaged-short>	
        internal void GetFigureCount(out int count)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* count_ = &count)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, count_, ((void**)(*(void**)_nativePointer))[20]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.Direct2D1.PathGeometry1"/></strong> interface adds functionality to <strong><see cref="SharpDX.Direct2D1.PathGeometry"/></strong>. In particular, it provides the path geometry-specific <strong>ComputePointAndSegmentAtLength</strong> method.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface adds functionality to <strong><see cref="SharpDX.Direct2D1.PathGeometry"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1PathGeometry1']/*"/>	
    /// <msdn-id>hh446826</msdn-id>	
    /// <unmanaged>ID2D1PathGeometry1</unmanaged>	
    /// <unmanaged-short>ID2D1PathGeometry1</unmanaged-short>	
    [Guid("62baa2d2-ab54-41b7-b872-787e0106a421")]
    public partial class PathGeometry1 : SharpDX.Direct2D1.PathGeometry
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.PathGeometry1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PathGeometry1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.PathGeometry1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.PathGeometry1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.PathGeometry1(nativePointer);
        }


        /// <summary>	
        /// <p>Computes the point that exists at a given distance along the path geometry along with the index of the segment the point is on and the directional vector at that point.</p>	
        /// </summary>	
        /// <param name="length"><dd>  <p> The distance to walk along the path. </p> </dd></param>	
        /// <param name="startSegment"><dd>  <p> The index of the segment at which to begin walking. Note: This index is global to the entire path, not just a particular figure. </p> </dd></param>	
        /// <param name="worldTransform"><dd>  <p>The transform to apply to the path prior to walking.</p> </dd></param>	
        /// <param name="flatteningTolerance"><dd>  <p>The flattening tolerance to use when walking along an arc or Bezier segment. The flattening tolerance is the maximum error allowed when constructing a polygonal approximation of the geometry. No point in the polygonal representation will diverge from the original geometry by more than the flattening tolerance. Smaller values produce more accurate results but cause slower execution.</p> </dd></param>	
        /// <param name="ointDescriptionRef"><dd>  <p>When this method returns, contains a description of the point that can be found at the given location.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>One of the inputs was in an invalid range.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>A <em>length</em> that is less than 0 or is not a number is treated as if it were 0.</p><p>If <em>length</em> is greater than the total length of the path, then the end point of the path is returned.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1PathGeometry1::ComputePointAndSegmentAtLength']/*"/>	
        /// <msdn-id>hh446851</msdn-id>	
        /// <unmanaged>HRESULT ID2D1PathGeometry1::ComputePointAndSegmentAtLength([In] float length,[In] unsigned int startSegment,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] D2D1_POINT_DESCRIPTION* pointDescription)</unmanaged>	
        /// <unmanaged-short>ID2D1PathGeometry1::ComputePointAndSegmentAtLength</unmanaged-short>	
        public void ComputePointAndSegmentAtLength(float length, int startSegment, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, float flatteningTolerance, out SharpDX.Direct2D1.PointDescription ointDescriptionRef)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
                if (worldTransform.HasValue)
                    worldTransform_ = worldTransform.Value;
                ointDescriptionRef = new SharpDX.Direct2D1.PointDescription();
                SharpDX.Result __result__;
                fixed (void* ointDescriptionRef_ = &ointDescriptionRef)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, length, startSegment, (worldTransform.HasValue) ? &worldTransform_ : (void*)IntPtr.Zero, flatteningTolerance, ointDescriptionRef_, ((void**)(*(void**)_nativePointer))[21]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Converts Direct2D primitives stored in an <strong><see cref="SharpDX.Direct2D1.CommandList"/></strong> into a fixed page representation.  The print sub-system then consumes the primitives.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1PrintControl']/*"/>	
    /// <msdn-id>hh847997</msdn-id>	
    /// <unmanaged>ID2D1PrintControl</unmanaged>	
    /// <unmanaged-short>ID2D1PrintControl</unmanaged-short>	
    [Guid("2c1d867d-c290-41c8-ae7e-34a98702e9a5")]
    public partial class PrintControl : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.PrintControl"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PrintControl(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.PrintControl"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.PrintControl(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.PrintControl(nativePointer);
        }


        /// <summary>	
        /// <p>Converts Direct2D primitives in the passed-in command list into a fixed page representation for use  by the print subsystem. </p>	
        /// </summary>	
        /// <param name="commandList"><dd>  <p>The command list that contains the rendering operations.</p> </dd></param>	
        /// <param name="pageSize"><dd>  <p>The size of the page to add.</p> </dd></param>	
        /// <param name="agePrintTicketStreamRef"><dd>  <p>The print ticket stream.</p> </dd></param>	
        /// <param name="tag1"><dd>  <p>Contains the first label for subsequent drawing operations. This parameter is passed uninitialized. If <c>null</c> is specified, no value is retrieved for this parameter.</p> </dd></param>	
        /// <param name="tag2"><dd>  <p>Contains the second label for subsequent drawing operations. This parameter is passed uninitialized. If <c>null</c> is specified, no value is retrieved for this parameter.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> <tr><td><see cref="SharpDX.Direct2D1.ResultCode.PrintJobClosed"/></td><td>The print job is already finished.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1PrintControl::AddPage']/*"/>	
        /// <msdn-id>hh847998</msdn-id>	
        /// <unmanaged>HRESULT ID2D1PrintControl::AddPage([In] ID2D1CommandList* commandList,[In] D2D_SIZE_F pageSize,[In, Optional] IStream* pagePrintTicketStream,[Out, Optional] unsigned longlong* tag1,[Out, Optional] unsigned longlong* tag2)</unmanaged>	
        /// <unmanaged-short>ID2D1PrintControl::AddPage</unmanaged-short>	
        internal void AddPage_(SharpDX.Direct2D1.CommandList commandList, SharpDX.Size2F pageSize, System.IntPtr agePrintTicketStreamRef, out long tag1, out long tag2)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* tag1_ = &tag1)
                    fixed (void* tag2_ = &tag2)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint99(_nativePointer, (void*)((commandList == null) ? IntPtr.Zero : commandList.NativePointer), pageSize, (void*)agePrintTicketStreamRef, tag1_, tag2_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Passes all remaining resources to the print sub-system, then clean up and close the current print job. </p>	
        /// </summary>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> <tr><td><see cref="SharpDX.Direct2D1.ResultCode.PrintJobClosed"/></td><td>The print job is already finished.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1PrintControl::Close']/*"/>	
        /// <msdn-id>hh848001</msdn-id>	
        /// <unmanaged>HRESULT ID2D1PrintControl::Close()</unmanaged>	
        /// <unmanaged-short>ID2D1PrintControl::Close</unmanaged-short>	
        public void Close()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a set of run-time bindable and discoverable properties that allow a data-driven application to modify the state of a Direct2D effect.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface supports access through either indices or property names. In addition to top-level properties, each property in an <strong><see cref="SharpDX.Direct2D1.Properties"/></strong> object may contain an <strong><see cref="SharpDX.Direct2D1.Properties"/></strong> object, which stores metadata describing the parent property. </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Properties']/*"/>	
    /// <msdn-id>hh446854</msdn-id>	
    /// <unmanaged>ID2D1Properties</unmanaged>	
    /// <unmanaged-short>ID2D1Properties</unmanaged-short>	
    [Guid("483473d7-cd46-4f9d-9d3a-3112aa80159d")]
    public partial class Properties : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Properties"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Properties(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Properties"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Properties(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Properties(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the number of top-level properties. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method returns the number of custom properties on the <strong><see cref="SharpDX.Direct2D1.Properties"/></strong> interface. System properties and sub-properties are part of a closed set, and are enumerable by iterating over this closed set.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Properties::GetPropertyCount']/*"/>	
        /// <msdn-id>hh446857</msdn-id>	
        /// <unmanaged>GetPropertyCount</unmanaged>	
        /// <unmanaged-short>GetPropertyCount</unmanaged-short>	
        /// <unmanaged>unsigned int ID2D1Properties::GetPropertyCount()</unmanaged>
        public int PropertyCount
        {
            get { return GetPropertyCount(); }
        }

        /// <summary>	
        /// <p>Gets the number of top-level properties. </p>	
        /// </summary>	
        /// <returns><p>This method returns the number of custom (non-system) properties that can be accessed by the object.</p></returns>	
        /// <remarks>	
        /// <p>This method returns the number of custom properties on the <strong><see cref="SharpDX.Direct2D1.Properties"/></strong> interface. System properties and sub-properties are part of a closed set, and are enumerable by iterating over this closed set.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Properties::GetPropertyCount']/*"/>	
        /// <msdn-id>hh446857</msdn-id>	
        /// <unmanaged>unsigned int ID2D1Properties::GetPropertyCount()</unmanaged>	
        /// <unmanaged-short>ID2D1Properties::GetPropertyCount</unmanaged-short>	
        internal int GetPropertyCount()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the property name that corresponds to the given index. This is a template overload. See Remarks.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the property for which the name is being returned.</p> </dd></param>	
        /// <param name="name"><dd>  <p>When this method returns, contains the name being retrieved.</p> </dd></param>	
        /// <param name="nameCount"><dd>  <p>The number of characters in the <em>name</em> buffer.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>HRESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.InsufficientBuffer"/>)</td><td>The supplied buffer was too small to accomodate the data.</td></tr> <tr><td><see cref="SharpDX.Direct2D1.ResultCode.InvalidProperty"/></td><td>The specified property does not exist.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This method returns an empty string if <em>index</em> is invalid. If the method returns <strong>RESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.InsufficientBuffer"/>)</strong>, <em>name</em> will still be filled and truncated.</p><p> </p>template&lt;typename U&gt; <see cref="SharpDX.Result"/> GetPropertyName( U index, _Out_writes_(nameCount) PWSTR name, UINT32 nameCount ) CONST;	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Properties::GetPropertyName']/*"/>	
        /// <msdn-id>jj151732</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Properties::GetPropertyName([In] unsigned int index,[Out, Buffer] wchar_t* name,[In] unsigned int nameCount)</unmanaged>	
        /// <unmanaged-short>ID2D1Properties::GetPropertyName</unmanaged-short>	
        internal void GetPropertyName(int index, System.IntPtr name, int nameCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, index, (void*)name, nameCount, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets  the number of characters for the given property name.  This is a template overload. See Remarks.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the property name to retrieve.</p> </dd></param>	
        /// <returns><p>This method returns the size in characters of the name corresponding to the given property index, or zero if the property index does not exist. </p></returns>	
        /// <remarks>	
        /// <p>The value returned by this method can be used to ensure that the buffer size for <strong>GetPropertyName</strong> is appropriate. </p><p> </p>template&lt;typename U&gt; UINT32 GetPropertyNameLength( U index ) CONST;	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Properties::GetPropertyNameLength']/*"/>	
        /// <msdn-id>jj151733</msdn-id>	
        /// <unmanaged>unsigned int ID2D1Properties::GetPropertyNameLength([In] unsigned int index)</unmanaged>	
        /// <unmanaged-short>ID2D1Properties::GetPropertyNameLength</unmanaged-short>	
        internal int GetPropertyNameLength(int index)
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, index, ((void**)(*(void**)_nativePointer))[5]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the <strong><see cref="SharpDX.Direct2D1.PropertyType"/></strong> of the selected property. </p>	
        /// </summary>	
        /// <param name="index">No documentation.</param>	
        /// <returns><p>This method returns a <strong><see cref="SharpDX.Direct2D1.PropertyType"/></strong>-typed value for the type of the selected property.</p></returns>	
        /// <remarks>	
        /// <p>If the property does not exist, the method returns <strong><see cref="SharpDX.Direct2D1.PropertyType.Unknown"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Properties::GetType']/*"/>	
        /// <msdn-id>hh446873</msdn-id>	
        /// <unmanaged>D2D1_PROPERTY_TYPE ID2D1Properties::GetType([In] unsigned int index)</unmanaged>	
        /// <unmanaged-short>ID2D1Properties::GetType</unmanaged-short>	
        public SharpDX.Direct2D1.PropertyType GetTypeInfo(int index)
        {
            unsafe
            {
                SharpDX.Direct2D1.PropertyType __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1PropertyType(_nativePointer, index, ((void**)(*(void**)_nativePointer))[6]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the index corresponding to the given property name. </p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>The name of the property to retrieve.</p> </dd></param>	
        /// <returns><p>The index of the corresponding property name.</p></returns>	
        /// <remarks>	
        /// <p> If the property does not exist, this method returns <strong>D2D1_INVALID_PROPERTY_INDEX</strong>. This reserved value will never map to a valid index and will cause <strong><c>null</c></strong> or sentinel values to be returned from other parts of the property interface.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Properties::GetPropertyIndex']/*"/>	
        /// <msdn-id>hh446861</msdn-id>	
        /// <unmanaged>unsigned int ID2D1Properties::GetPropertyIndex([In] const wchar_t* name)</unmanaged>	
        /// <unmanaged-short>ID2D1Properties::GetPropertyIndex</unmanaged-short>	
        public int GetPropertyIndex(string name)
        {
            unsafe
            {
                IntPtr name_ = Utilities.StringToHGlobalUni(name);
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)name_, ((void**)(*(void**)_nativePointer))[7]);
                Marshal.FreeHGlobal(name_);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets the named property to the given value.  </p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>The name of the property to set.</p> </dd></param>	
        /// <param name="type"><dd>  <p>The data to set.</p> </dd></param>	
        /// <param name="data"><dd>  <p>The data to set.</p> </dd></param>	
        /// <param name="dataSize"><dd>  <p>The number of bytes in the data to set.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref="SharpDX.Direct2D1.ResultCode.InvalidProperty"/></td><td>The specified property does not exist.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Failed to allocate necessary memory.</td></tr> <tr><td>D3DERR_OUT_OF_VIDEO_MEMORY</td><td>Failed to allocate required video memory.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are invalid.</td></tr> <tr><td>E_FAIL</td><td>Unspecified failure.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the property does not exist, the request is ignored and the method returns <strong><see cref="SharpDX.Direct2D1.ResultCode.InvalidProperty"/></strong>.</p><p>Any error not in the standard set returned by a property implementation will be mapped into the standard error range.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Properties::SetValueByName']/*"/>	
        /// <msdn-id>hh446887</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>	
        /// <unmanaged-short>ID2D1Properties::SetValueByName</unmanaged-short>	
        public void SetValueByName(string name, SharpDX.Direct2D1.PropertyType type, System.IntPtr data, int dataSize)
        {
            unsafe
            {
                IntPtr name_ = Utilities.StringToHGlobalUni(name);
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)name_, unchecked((int)type), (void*)data, dataSize, ((void**)(*(void**)_nativePointer))[8]);
                Marshal.FreeHGlobal(name_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the corresponding  property by index.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the property to set.</p> </dd></param>	
        /// <param name="type"><dd>  <p>The data to set.</p> </dd></param>	
        /// <param name="data"><dd>  <p>The data to set.</p> </dd></param>	
        /// <param name="dataSize"><dd>  <p>The number of bytes in the data to set.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref="SharpDX.Direct2D1.ResultCode.InvalidProperty"/></td><td>The specified property does not exist.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Failed to allocate necessary memory.</td></tr> <tr><td>D3DERR_OUT_OF_VIDEO_MEMORY</td><td>Failed to allocate required video memory.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are invalid.</td></tr> <tr><td>E_FAIL</td><td>Unspecified failure.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If the property does not exist, the request is ignored and <strong><see cref="SharpDX.Direct2D1.ResultCode.InvalidProperty"/></strong> is returned.</p><p> Any error not in the standard set returned by a property implementation will be mapped into the standard error range. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Properties::SetValue']/*"/>	
        /// <msdn-id>hh446885</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Properties::SetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>	
        /// <unmanaged-short>ID2D1Properties::SetValue</unmanaged-short>	
        public void SetValue(int index, SharpDX.Direct2D1.PropertyType type, System.IntPtr data, int dataSize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, index, unchecked((int)type), (void*)data, dataSize, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the property value by name.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>The property name to get.</p> </dd></param>	
        /// <param name="type"><dd>  <p>When this method returns, contains the buffer with  the data value.</p> </dd></param>	
        /// <param name="data"><dd>  <p>When this method returns, contains the buffer with  the data value.</p> </dd></param>	
        /// <param name="dataSize"><dd>  <p>The number of bytes in the data to be retrieved.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref="SharpDX.Direct2D1.ResultCode.InvalidProperty"/></td><td>The specified property does not exist.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Failed to allocate necessary memory.</td></tr> <tr><td>D3DERR_OUT_OF_VIDEO_MEMORY</td><td>Failed to allocate required video memory.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are invalid.</td></tr> <tr><td>E_FAIL</td><td>Unspecified failure.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If <em>name</em> does not exist, no information is retrieved.</p><p>Any error not in the standard set returned by a property implementation will be mapped into the standard error range.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Properties::GetValueByName']/*"/>	
        /// <msdn-id>hh446879</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        /// <unmanaged-short>ID2D1Properties::GetValueByName</unmanaged-short>	
        public void GetValueByName(string name, SharpDX.Direct2D1.PropertyType type, System.IntPtr data, int dataSize)
        {
            unsafe
            {
                IntPtr name_ = Utilities.StringToHGlobalUni(name);
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)name_, unchecked((int)type), (void*)data, dataSize, ((void**)(*(void**)_nativePointer))[10]);
                Marshal.FreeHGlobal(name_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets  the value of the specified property by index.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the property from which the data is to be obtained.</p> </dd></param>	
        /// <param name="type"><dd>  <p>When this method returns, contains a reference to the data requested.</p> </dd></param>	
        /// <param name="data"><dd>  <p>When this method returns, contains a reference to the data requested.</p> </dd></param>	
        /// <param name="dataSize"><dd>  <p>The number of bytes in the data to be retrieved.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref="SharpDX.Direct2D1.ResultCode.InvalidProperty"/></td><td>The specified property does not exist.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Failed to allocate necessary memory.</td></tr> <tr><td>D3DERR_OUT_OF_VIDEO_MEMORY</td><td>Failed to allocate required video memory.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are invalid.</td></tr> <tr><td>E_FAIL</td><td>Unspecified failure.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Properties::GetValue']/*"/>	
        /// <msdn-id>hh446876</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        /// <unmanaged-short>ID2D1Properties::GetValue</unmanaged-short>	
        public void GetValue(int index, SharpDX.Direct2D1.PropertyType type, System.IntPtr data, int dataSize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, index, unchecked((int)type), (void*)data, dataSize, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the size of the property value in bytes, using the property index.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the property.</p> </dd></param>	
        /// <returns><p>This method returns size of the value in bytes, using the property index </p></returns>	
        /// <remarks>	
        /// <p>This method returns zero if <em>index</em> does not exist. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Properties::GetValueSize']/*"/>	
        /// <msdn-id>hh446882</msdn-id>	
        /// <unmanaged>unsigned int ID2D1Properties::GetValueSize([In] unsigned int index)</unmanaged>	
        /// <unmanaged-short>ID2D1Properties::GetValueSize</unmanaged-short>	
        public int GetValueSize(int index)
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, index, ((void**)(*(void**)_nativePointer))[12]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the sub-properties of the provided property by index.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The index of the  sub-properties to be retrieved.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains the address of a reference to the sub-properties.</p> </dd></returns>	
        /// <remarks>	
        /// <p>If there are no sub-properties, <em>subProperties</em> will be <strong><c>null</c></strong>, and <strong><see cref="SharpDX.Direct2D1.ResultCode.NoSubProperties"/></strong> will be returned.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Properties::GetSubProperties']/*"/>	
        /// <msdn-id>hh446870</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Properties::GetSubProperties([In] unsigned int index,[Out, Optional] ID2D1Properties** subProperties)</unmanaged>	
        /// <unmanaged-short>ID2D1Properties::GetSubProperties</unmanaged-short>	
        public SharpDX.Direct2D1.Properties GetSubProperties(int index)
        {
            unsafe
            {
                SharpDX.Direct2D1.Properties subProperties;
                IntPtr subProperties_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, index, &subProperties_, ((void**)(*(void**)_nativePointer))[13]);
                subProperties = (subProperties_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.Properties(subProperties_);
                __result__.CheckError();
                return subProperties;
            }
        }
    }
    /// <summary>	
    /// <p> Paints an area with a radial gradient.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct2D1.RadialGradientBrush"/></strong> is similar to the <strong><see cref="SharpDX.Direct2D1.LinearGradientBrush"/></strong> in that they both map a collection of gradient stops to a gradient. However, the linear gradient has a start and an end point to define the gradient vector, while the radial gradient uses an ellipse and a gradient origin to define its gradient behavior. To define the position and size of the ellipse, use the <strong>SetCenter</strong>, <strong>SetRadiusX</strong>, and <strong>SetRadiusY</strong> methods to specify the center, x-radius, and y-radius of the ellipse. The gradient origin is the center of the ellipse, unless a gradient offset is specified by using the <strong>SetGradientOriginOffset</strong> method.</p><p>The brush maps the gradient stop position 0.0f of the gradient origin, and the position 1.0f is mapped to the ellipse boundary. When the gradient origin is within the ellipse, the contents of the ellipse enclose the entire [0, 1] range of the brush gradient stops. If the gradient origin is outside the bounds of the ellipse, the brush still works, but its gradient is not well-defined.</p><p>The start point and end point are described in the brush space and are mappped to the render target when the brush is used. Note the starting and ending coordinates are absolute, not relative to the render target size. A value of (0, 0) maps to the upper-left corner of the render target, while a value of (1, 1) maps just one pixel diagonally away from (0, 0). If there is a nonidentity brush transform or render target transform, the brush ellipse and gradient origin are also transformed.</p><p>It is possible to specify an ellipse that does not completely fill area being painted. When this occurs,       the            <strong><see cref="SharpDX.Direct2D1.ExtendMode"/></strong> and  setting (specified by the  brush     <strong><see cref="SharpDX.Direct2D1.GradientStopCollection"/></strong>) determines how the remaining area is painted. 	
    /// </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RadialGradientBrush']/*"/>	
    /// <msdn-id>dd371529</msdn-id>	
    /// <unmanaged>ID2D1RadialGradientBrush</unmanaged>	
    /// <unmanaged-short>ID2D1RadialGradientBrush</unmanaged-short>	
    [Guid("2cd906ac-12e2-11dc-9fed-001143a055f9")]
    public partial class RadialGradientBrush : SharpDX.Direct2D1.Brush
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.RadialGradientBrush"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RadialGradientBrush(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.RadialGradientBrush"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.RadialGradientBrush(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.RadialGradientBrush(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves or sets the center of the gradient ellipse.  </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RadialGradientBrush::GetCenter']/*"/>	
        /// <msdn-id>dd371532</msdn-id>	
        /// <unmanaged>GetCenter / SetCenter</unmanaged>	
        /// <unmanaged-short>GetCenter</unmanaged-short>	
        /// <unmanaged>D2D_POINT_2F ID2D1RadialGradientBrush::GetCenter()</unmanaged>
        public SharpDX.Mathematics.Interop.RawVector2 Center
        {
            get { return GetCenter(); }
            set { SetCenter(value); }
        }

        /// <summary>	
        /// <p>Retrieves or sets the offset of the gradient origin relative to the gradient ellipse's center. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RadialGradientBrush::GetGradientOriginOffset']/*"/>	
        /// <msdn-id>dd371535</msdn-id>	
        /// <unmanaged>GetGradientOriginOffset / SetGradientOriginOffset</unmanaged>	
        /// <unmanaged-short>GetGradientOriginOffset</unmanaged-short>	
        /// <unmanaged>D2D_POINT_2F ID2D1RadialGradientBrush::GetGradientOriginOffset()</unmanaged>
        public SharpDX.Mathematics.Interop.RawVector2 GradientOriginOffset
        {
            get { return GetGradientOriginOffset(); }
            set { SetGradientOriginOffset(value); }
        }

        /// <summary>	
        /// <p>Retrieves or sets the x-radius of the gradient ellipse. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RadialGradientBrush::GetRadiusX']/*"/>	
        /// <msdn-id>dd371542</msdn-id>	
        /// <unmanaged>GetRadiusX / SetRadiusX</unmanaged>	
        /// <unmanaged-short>GetRadiusX</unmanaged-short>	
        /// <unmanaged>float ID2D1RadialGradientBrush::GetRadiusX()</unmanaged>
        public float RadiusX
        {
            get { return GetRadiusX(); }
            set { SetRadiusX(value); }
        }

        /// <summary>	
        /// <p>Retrieves or sets the y-radius of the gradient ellipse. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RadialGradientBrush::GetRadiusY']/*"/>	
        /// <msdn-id>dd371544</msdn-id>	
        /// <unmanaged>GetRadiusY / SetRadiusY</unmanaged>	
        /// <unmanaged-short>GetRadiusY</unmanaged-short>	
        /// <unmanaged>float ID2D1RadialGradientBrush::GetRadiusY()</unmanaged>
        public float RadiusY
        {
            get { return GetRadiusY(); }
            set { SetRadiusY(value); }
        }

        /// <summary>	
        /// <p>Retrieves the <strong><see cref="SharpDX.Direct2D1.GradientStopCollection"/></strong> associated with this radial gradient brush object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> <strong><see cref="SharpDX.Direct2D1.GradientStopCollection"/></strong> contains an array of <strong><see cref="SharpDX.Direct2D1.GradientStop"/></strong> structures and additional information, such as the extend mode and the color interpolation mode.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RadialGradientBrush::GetGradientStopCollection']/*"/>	
        /// <msdn-id>dd371539</msdn-id>	
        /// <unmanaged>GetGradientStopCollection</unmanaged>	
        /// <unmanaged-short>GetGradientStopCollection</unmanaged-short>	
        /// <unmanaged>void ID2D1RadialGradientBrush::GetGradientStopCollection([Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
        public SharpDX.Direct2D1.GradientStopCollection GradientStopCollection
        {
            get { SharpDX.Direct2D1.GradientStopCollection __output__; GetGradientStopCollection(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Specifies the center of the gradient ellipse in the brush's coordinate space. </p>	
        /// </summary>	
        /// <param name="center"><dd>  <p>The center of the gradient ellipse, in the brush's coordinate space.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RadialGradientBrush::SetCenter']/*"/>	
        /// <msdn-id>dd371547</msdn-id>	
        /// <unmanaged>void ID2D1RadialGradientBrush::SetCenter([In] D2D_POINT_2F center)</unmanaged>	
        /// <unmanaged-short>ID2D1RadialGradientBrush::SetCenter</unmanaged-short>	
        internal void SetCenter(SharpDX.Mathematics.Interop.RawVector2 center)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid42(_nativePointer, center, ((void**)(*(void**)_nativePointer))[8]);
            }
        }

        /// <summary>	
        /// <p>Specifies the offset of the gradient origin relative to the gradient ellipse's center.</p>	
        /// </summary>	
        /// <param name="gradientOriginOffset"><dd>  <p>The offset of the gradient origin from the center of the gradient ellipse.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RadialGradientBrush::SetGradientOriginOffset']/*"/>	
        /// <msdn-id>dd371550</msdn-id>	
        /// <unmanaged>void ID2D1RadialGradientBrush::SetGradientOriginOffset([In] D2D_POINT_2F gradientOriginOffset)</unmanaged>	
        /// <unmanaged-short>ID2D1RadialGradientBrush::SetGradientOriginOffset</unmanaged-short>	
        internal void SetGradientOriginOffset(SharpDX.Mathematics.Interop.RawVector2 gradientOriginOffset)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid42(_nativePointer, gradientOriginOffset, ((void**)(*(void**)_nativePointer))[9]);
            }
        }

        /// <summary>	
        /// <p> Specifies the x-radius of the gradient ellipse, in the brush's coordinate space.</p>	
        /// </summary>	
        /// <param name="radiusX"><dd>  <p>The x-radius of the gradient ellipse. This value is in the brush's coordinate space.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RadialGradientBrush::SetRadiusX']/*"/>	
        /// <msdn-id>dd371553</msdn-id>	
        /// <unmanaged>void ID2D1RadialGradientBrush::SetRadiusX([In] float radiusX)</unmanaged>	
        /// <unmanaged-short>ID2D1RadialGradientBrush::SetRadiusX</unmanaged-short>	
        internal void SetRadiusX(float radiusX)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, radiusX, ((void**)(*(void**)_nativePointer))[10]);
            }
        }

        /// <summary>	
        /// <p>Specifies the y-radius of the gradient ellipse, in the brush's coordinate space. </p>	
        /// </summary>	
        /// <param name="radiusY"><dd>  <p>The y-radius of the gradient ellipse. This value is in the brush's coordinate space.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RadialGradientBrush::SetRadiusY']/*"/>	
        /// <msdn-id>dd371557</msdn-id>	
        /// <unmanaged>void ID2D1RadialGradientBrush::SetRadiusY([In] float radiusY)</unmanaged>	
        /// <unmanaged-short>ID2D1RadialGradientBrush::SetRadiusY</unmanaged-short>	
        internal void SetRadiusY(float radiusY)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, radiusY, ((void**)(*(void**)_nativePointer))[11]);
            }
        }

        /// <summary>	
        /// <p>Retrieves the center of the gradient ellipse.  </p>	
        /// </summary>	
        /// <returns><p>The center of the gradient ellipse. This value is expressed in the brush's coordinate space.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RadialGradientBrush::GetCenter']/*"/>	
        /// <msdn-id>dd371532</msdn-id>	
        /// <unmanaged>D2D_POINT_2F ID2D1RadialGradientBrush::GetCenter()</unmanaged>	
        /// <unmanaged-short>ID2D1RadialGradientBrush::GetCenter</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawVector2 GetCenter()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawVector2 __result__;
                SharpDX.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, (void*)&__result__, ((void**)(*(void**)_nativePointer))[12]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Retrieves the offset of the gradient origin relative to the gradient ellipse's center. </p>	
        /// </summary>	
        /// <returns><p>The offset of the gradient origin from the center of the gradient ellipse. This value is expressed in the brush's coordinate space.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RadialGradientBrush::GetGradientOriginOffset']/*"/>	
        /// <msdn-id>dd371535</msdn-id>	
        /// <unmanaged>D2D_POINT_2F ID2D1RadialGradientBrush::GetGradientOriginOffset()</unmanaged>	
        /// <unmanaged-short>ID2D1RadialGradientBrush::GetGradientOriginOffset</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawVector2 GetGradientOriginOffset()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawVector2 __result__;
                SharpDX.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, (void*)&__result__, ((void**)(*(void**)_nativePointer))[13]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Retrieves the x-radius of the gradient ellipse. </p>	
        /// </summary>	
        /// <returns><p>The x-radius of the gradient ellipse. This value is expressed in the brush's coordinate space.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RadialGradientBrush::GetRadiusX']/*"/>	
        /// <msdn-id>dd371542</msdn-id>	
        /// <unmanaged>float ID2D1RadialGradientBrush::GetRadiusX()</unmanaged>	
        /// <unmanaged-short>ID2D1RadialGradientBrush::GetRadiusX</unmanaged-short>	
        internal float GetRadiusX()
        {
            unsafe
            {
                float __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callifloat(_nativePointer, ((void**)(*(void**)_nativePointer))[14]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Retrieves the y-radius of the gradient ellipse. </p>	
        /// </summary>	
        /// <returns><p>The y-radius of the gradient ellipse. This value is expressed in the brush's coordinate space.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RadialGradientBrush::GetRadiusY']/*"/>	
        /// <msdn-id>dd371544</msdn-id>	
        /// <unmanaged>float ID2D1RadialGradientBrush::GetRadiusY()</unmanaged>	
        /// <unmanaged-short>ID2D1RadialGradientBrush::GetRadiusY</unmanaged-short>	
        internal float GetRadiusY()
        {
            unsafe
            {
                float __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callifloat(_nativePointer, ((void**)(*(void**)_nativePointer))[15]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Retrieves the <strong><see cref="SharpDX.Direct2D1.GradientStopCollection"/></strong> associated with this radial gradient brush object.</p>	
        /// </summary>	
        /// <param name="gradientStopCollection">No documentation.</param>	
        /// <remarks>	
        /// <p> <strong><see cref="SharpDX.Direct2D1.GradientStopCollection"/></strong> contains an array of <strong><see cref="SharpDX.Direct2D1.GradientStop"/></strong> structures and additional information, such as the extend mode and the color interpolation mode.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RadialGradientBrush::GetGradientStopCollection']/*"/>	
        /// <msdn-id>dd371539</msdn-id>	
        /// <unmanaged>void ID2D1RadialGradientBrush::GetGradientStopCollection([Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>	
        /// <unmanaged-short>ID2D1RadialGradientBrush::GetGradientStopCollection</unmanaged-short>	
        internal void GetGradientStopCollection(out SharpDX.Direct2D1.GradientStopCollection gradientStopCollection)
        {
            unsafe
            {
                IntPtr gradientStopCollection_ = IntPtr.Zero;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &gradientStopCollection_, ((void**)(*(void**)_nativePointer))[16]);
                gradientStopCollection = (gradientStopCollection_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.GradientStopCollection(gradientStopCollection_);
            }
        }
    }
    /// <summary>	
    /// <p>Describes a two-dimensional rectangle.  </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RectangleGeometry']/*"/>	
    /// <msdn-id>dd371561</msdn-id>	
    /// <unmanaged>ID2D1RectangleGeometry</unmanaged>	
    /// <unmanaged-short>ID2D1RectangleGeometry</unmanaged-short>	
    [Guid("2cd906a2-12e2-11dc-9fed-001143a055f9")]
    public partial class RectangleGeometry : SharpDX.Direct2D1.Geometry
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.RectangleGeometry"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RectangleGeometry(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.RectangleGeometry"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.RectangleGeometry(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.RectangleGeometry(nativePointer);
        }


        /// <summary>	
        /// <p> Retrieves the rectangle that describes the rectangle geometry's dimensions.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RectangleGeometry::GetRect']/*"/>	
        /// <msdn-id>dd371762</msdn-id>	
        /// <unmanaged>GetRect</unmanaged>	
        /// <unmanaged-short>GetRect</unmanaged-short>	
        /// <unmanaged>void ID2D1RectangleGeometry::GetRect([Out] D2D_RECT_F* rect)</unmanaged>
        public SharpDX.Mathematics.Interop.RawRectangleF Rectangle
        {
            get { SharpDX.Mathematics.Interop.RawRectangleF __output__; GetRectangle(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Retrieves the rectangle that describes the rectangle geometry's dimensions.</p>	
        /// </summary>	
        /// <param name="rect"><dd>  <p>Contains a reference to a rectangle that describes the rectangle geometry's dimensions when this method returns. You must allocate storage for this parameter. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RectangleGeometry::GetRect']/*"/>	
        /// <msdn-id>dd371762</msdn-id>	
        /// <unmanaged>void ID2D1RectangleGeometry::GetRect([Out] D2D_RECT_F* rect)</unmanaged>	
        /// <unmanaged-short>ID2D1RectangleGeometry::GetRect</unmanaged-short>	
        internal void GetRectangle(out SharpDX.Mathematics.Interop.RawRectangleF rect)
        {
            unsafe
            {
                rect = new SharpDX.Mathematics.Interop.RawRectangleF();
                fixed (void* rect_ = &rect)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, rect_, ((void**)(*(void**)_nativePointer))[17]);
            }
        }
    }
    /// <summary>	
    /// <p>Describes the render information common to all of the various transform implementations.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is used by a transform implementation to first describe and then indicate changes to the rendering pass that corresponds to the transform.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderInfo']/*"/>	
    /// <msdn-id>hh446890</msdn-id>	
    /// <unmanaged>ID2D1RenderInfo</unmanaged>	
    /// <unmanaged-short>ID2D1RenderInfo</unmanaged-short>	
    [Guid("519ae1bd-d19a-420d-b849-364f594776b7")]
    public partial class RenderInformation : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.RenderInformation"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RenderInformation(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.RenderInformation"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.RenderInformation(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.RenderInformation(nativePointer);
        }


        /// <summary>	
        /// <p>Specifies that the output of the transform in which the render information is encapsulated is or is not cached.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderInfo::SetCached']/*"/>	
        /// <msdn-id>hh446891</msdn-id>	
        /// <unmanaged>SetCached</unmanaged>	
        /// <unmanaged-short>SetCached</unmanaged-short>	
        /// <unmanaged>void ID2D1RenderInfo::SetCached([In] BOOL isCached)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool Cached
        {
            set { SetCached(value); }
        }

        /// <summary>	
        /// <p>Provides an estimated hint of shader execution cost to D2D.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The instruction count may be set according to the number of instructions in the shader.  This information is used as a hint when rendering extremely large images.  Calling this API is optional, but it may  improve performance if you provide an accurate number. </p><p><strong>Note</strong>??Instructions that occur in a loop should be counted according to the number of loop iterations.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderInfo::SetInstructionCountHint']/*"/>	
        /// <msdn-id>hh871466</msdn-id>	
        /// <unmanaged>SetInstructionCountHint</unmanaged>	
        /// <unmanaged-short>SetInstructionCountHint</unmanaged-short>	
        /// <unmanaged>void ID2D1RenderInfo::SetInstructionCountHint([In] unsigned int instructionCount)</unmanaged>
        public int InstructionCountHint
        {
            set { SetInstructionCountHint(value); }
        }

        /// <summary>	
        /// <p>Sets how a specific input to the transform should be handled by the renderer in terms of sampling.</p>	
        /// </summary>	
        /// <param name="inputIndex"><dd>  <p>The index of the input that will have the input description applied.</p> </dd></param>	
        /// <param name="inputDescription"><dd>  <p>The description of the input to be applied to the transform.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The input description must be matched correctly by the effect shader code.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderInfo::SetInputDescription']/*"/>	
        /// <msdn-id>hh446892</msdn-id>	
        /// <unmanaged>HRESULT ID2D1RenderInfo::SetInputDescription([In] unsigned int inputIndex,[In] D2D1_INPUT_DESCRIPTION inputDescription)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderInfo::SetInputDescription</unmanaged-short>	
        public void SetInputDescription(int inputIndex, SharpDX.Direct2D1.InputDescription inputDescription)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint112(_nativePointer, inputIndex, inputDescription, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Allows a caller to control the output precision and channel-depth of the transform in which the render information is encapsulated.</p>	
        /// </summary>	
        /// <param name="bufferPrecision"><dd>  <p>The type of buffer that should be used as an output from this transform.</p> </dd></param>	
        /// <param name="channelDepth"><dd>  <p>The number of channels that will be used on the output buffer. </p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> If the output precision of the transform is not specified, then it will default to the precision specified on the Direct2D device context. The maximum of 16bpc <strong>UNORM</strong> and 16bpc <strong>FLOAT</strong> is 32bpc <strong>FLOAT</strong>.</p><p>The output channel depth will match the maximum of the input channel depths if the channel depth is <strong><see cref="SharpDX.Direct2D1.ChannelDepth.Default"/></strong>.</p><p>There is no global output channel depth, this is always left to the control of the transforms. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderInfo::SetOutputBuffer']/*"/>	
        /// <msdn-id>hh446893</msdn-id>	
        /// <unmanaged>HRESULT ID2D1RenderInfo::SetOutputBuffer([In] D2D1_BUFFER_PRECISION bufferPrecision,[In] D2D1_CHANNEL_DEPTH channelDepth)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderInfo::SetOutputBuffer</unmanaged-short>	
        public void SetOutputBuffer(SharpDX.Direct2D1.BufferPrecision bufferPrecision, SharpDX.Direct2D1.ChannelDepth channelDepth)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)bufferPrecision), unchecked((int)channelDepth), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Specifies that the output of the transform in which the render information is encapsulated is or is not cached.</p>	
        /// </summary>	
        /// <param name="isCached"><dd>  <p><strong>TRUE</strong> if the output of the transform is cached; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderInfo::SetCached']/*"/>	
        /// <msdn-id>hh446891</msdn-id>	
        /// <unmanaged>void ID2D1RenderInfo::SetCached([In] BOOL isCached)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderInfo::SetCached</unmanaged-short>	
        internal void SetCached(SharpDX.Mathematics.Interop.RawBool isCached)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid113(_nativePointer, isCached, ((void**)(*(void**)_nativePointer))[5]);
            }
        }

        /// <summary>	
        /// <p>Provides an estimated hint of shader execution cost to D2D.</p>	
        /// </summary>	
        /// <param name="instructionCount"><dd>  <p>An approximate instruction count of the associated shader.</p> </dd></param>	
        /// <remarks>	
        /// <p>The instruction count may be set according to the number of instructions in the shader.  This information is used as a hint when rendering extremely large images.  Calling this API is optional, but it may  improve performance if you provide an accurate number. </p><p><strong>Note</strong>??Instructions that occur in a loop should be counted according to the number of loop iterations.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderInfo::SetInstructionCountHint']/*"/>	
        /// <msdn-id>hh871466</msdn-id>	
        /// <unmanaged>void ID2D1RenderInfo::SetInstructionCountHint([In] unsigned int instructionCount)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderInfo::SetInstructionCountHint</unmanaged-short>	
        internal void SetInstructionCountHint(int instructionCount)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, instructionCount, ((void**)(*(void**)_nativePointer))[6]);
            }
        }
    }
    /// <summary>	
    /// <p>Represents an object that can receive drawing commands. Interfaces that inherit from <strong><see cref="SharpDX.Direct2D1.RenderTarget"/></strong> render the drawing commands they receive in different ways. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Your application should create render targets once and hold onto them for the life of the application or until the render target's  <strong>EndDraw</strong> method returns the <strong><see cref="SharpDX.Direct2D1.ResultCode.RecreateTarget"/></strong> error. When you receive this error, you need to recreate the render target (and any resources it created). </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget']/*"/>	
    /// <msdn-id>dd371766</msdn-id>	
    /// <unmanaged>ID2D1RenderTarget</unmanaged>	
    /// <unmanaged-short>ID2D1RenderTarget</unmanaged-short>	
    [Guid("2cd90694-12e2-11dc-9fed-001143a055f9")]
    public partial class RenderTarget : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.RenderTarget"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RenderTarget(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.RenderTarget"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.RenderTarget(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.RenderTarget(nativePointer);
        }


        /// <summary>	
        /// <p>Gets or sets the current transform of the render target. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetTransform']/*"/>	
        /// <msdn-id>dd316845</msdn-id>	
        /// <unmanaged>GetTransform / SetTransform</unmanaged>	
        /// <unmanaged-short>GetTransform</unmanaged-short>	
        /// <unmanaged>void ID2D1RenderTarget::GetTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 Transform
        {
            get { SharpDX.Mathematics.Interop.RawMatrix3x2 __output__; GetTransform(out __output__); return __output__; }
            set { SetTransform(ref value); }
        }

        /// <summary>	
        /// <p>Retrieves or sets the current antialiasing mode for nontext drawing operations.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetAntialiasMode']/*"/>	
        /// <msdn-id>dd316805</msdn-id>	
        /// <unmanaged>GetAntialiasMode / SetAntialiasMode</unmanaged>	
        /// <unmanaged-short>GetAntialiasMode</unmanaged-short>	
        /// <unmanaged>D2D1_ANTIALIAS_MODE ID2D1RenderTarget::GetAntialiasMode()</unmanaged>
        public SharpDX.Direct2D1.AntialiasMode AntialiasMode
        {
            get { return GetAntialiasMode(); }
            set { SetAntialiasMode(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the current antialiasing mode for text and glyph drawing operations. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetTextAntialiasMode']/*"/>	
        /// <msdn-id>dd316835</msdn-id>	
        /// <unmanaged>GetTextAntialiasMode / SetTextAntialiasMode</unmanaged>	
        /// <unmanaged-short>GetTextAntialiasMode</unmanaged-short>	
        /// <unmanaged>D2D1_TEXT_ANTIALIAS_MODE ID2D1RenderTarget::GetTextAntialiasMode()</unmanaged>
        public SharpDX.Direct2D1.TextAntialiasMode TextAntialiasMode
        {
            get { return GetTextAntialiasMode(); }
            set { SetTextAntialiasMode(value); }
        }

        /// <summary>	
        /// <p>Retrieves or sets the render target's current text rendering options. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If the settings specified by  <em>textRenderingParams</em> are incompatible with the render target's text antialiasing mode (specified by <strong>SetTextAntialiasMode</strong>), subsequent text and glyph drawing operations will fail and put the render target into an error state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetTextRenderingParams']/*"/>	
        /// <msdn-id>dd316841</msdn-id>	
        /// <unmanaged>GetTextRenderingParams / SetTextRenderingParams</unmanaged>	
        /// <unmanaged-short>GetTextRenderingParams</unmanaged-short>	
        /// <unmanaged>void ID2D1RenderTarget::GetTextRenderingParams([Out, Optional] IDWriteRenderingParams** textRenderingParams)</unmanaged>
        public SharpDX.DirectWrite.RenderingParams TextRenderingParams
        {
            get { SharpDX.DirectWrite.RenderingParams __output__; GetTextRenderingParams(out __output__); return __output__; }
            set { SetTextRenderingParams(value); }
        }

        /// <summary>	
        /// <p>Retrieves the pixel format and alpha mode of the render target. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetPixelFormat']/*"/>	
        /// <msdn-id>dd316814</msdn-id>	
        /// <unmanaged>GetPixelFormat</unmanaged>	
        /// <unmanaged-short>GetPixelFormat</unmanaged-short>	
        /// <unmanaged>D2D1_PIXEL_FORMAT ID2D1RenderTarget::GetPixelFormat()</unmanaged>
        public SharpDX.Direct2D1.PixelFormat PixelFormat
        {
            get { return GetPixelFormat(); }
        }

        /// <summary>	
        /// <p>Returns the size of the render target in device-independent pixels.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetSize']/*"/>	
        /// <msdn-id>dd316823</msdn-id>	
        /// <unmanaged>GetSize</unmanaged>	
        /// <unmanaged-short>GetSize</unmanaged-short>	
        /// <unmanaged>D2D_SIZE_F ID2D1RenderTarget::GetSize()</unmanaged>
        public SharpDX.Size2F Size
        {
            get { return GetSize(); }
        }

        /// <summary>	
        /// <p>Returns the size of the render target in device pixels.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetPixelSize']/*"/>	
        /// <msdn-id>dd316820</msdn-id>	
        /// <unmanaged>GetPixelSize</unmanaged>	
        /// <unmanaged-short>GetPixelSize</unmanaged-short>	
        /// <unmanaged>D2D_SIZE_U ID2D1RenderTarget::GetPixelSize()</unmanaged>
        public SharpDX.Size2 PixelSize
        {
            get { return GetPixelSize(); }
        }

        /// <summary>	
        /// <p>Gets the maximum size, in device-dependent units (pixels), of  any one bitmap dimension supported by the render target.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method returns the maximum texture size of the Direct3D device.</p><p><strong>Note</strong>??The software renderer and WARP devices return the value of 16 megapixels (16*1024*1024).  You can create a Direct2D texture that is this size, but not a Direct3D texture that is this size.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetMaximumBitmapSize']/*"/>	
        /// <msdn-id>dd742853</msdn-id>	
        /// <unmanaged>GetMaximumBitmapSize</unmanaged>	
        /// <unmanaged-short>GetMaximumBitmapSize</unmanaged-short>	
        /// <unmanaged>unsigned int ID2D1RenderTarget::GetMaximumBitmapSize()</unmanaged>
        public int MaximumBitmapSize
        {
            get { return GetMaximumBitmapSize(); }
        }

        /// <summary>	
        /// <p>Creates a Direct2D bitmap from a reference to in-memory source data.</p>	
        /// </summary>	
        /// <param name="size"><dd>  <p>The dimension of the bitmap to create in pixels.</p> </dd></param>	
        /// <param name="srcData"><dd>  <p>A reference to the memory location of the image data, or <strong><c>null</c></strong> to create an uninitialized bitmap.</p> </dd></param>	
        /// <param name="pitch"><dd>  <p>The byte count of each scanline, which is equal to (the image width in pixels ? the number of bytes per pixel) + memory padding. If <em>srcData</em> is <strong><c>null</c></strong>, this value is ignored. (Note that pitch is also sometimes called <em>stride</em>.)</p> </dd></param>	
        /// <param name="bitmapProperties"><dd>  <p>The pixel format and dots per inch (DPI) of the bitmap to create.</p> </dd></param>	
        /// <param name="bitmap"><dd>  <p>When this method returns, contains a reference to a reference to the new bitmap. This parameter is passed uninitialized.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::CreateBitmap']/*"/>	
        /// <msdn-id>dd371800</msdn-id>	
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmap([In] D2D_SIZE_U size,[In, Optional] const void* srcData,[In] unsigned int pitch,[In] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::CreateBitmap</unmanaged-short>	
        internal void CreateBitmap(SharpDX.Size2 size, System.IntPtr srcData, int pitch, SharpDX.Direct2D1.BitmapProperties bitmapProperties, SharpDX.Direct2D1.Bitmap bitmap)
        {
            unsafe
            {
                IntPtr bitmap_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint25(_nativePointer, size, (void*)srcData, pitch, &bitmapProperties, &bitmap_, ((void**)(*(void**)_nativePointer))[4]);
                ((SharpDX.Direct2D1.Bitmap)bitmap).NativePointer = bitmap_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.Direct2D1.Bitmap"/></strong> by copying the specified Microsoft Windows Imaging Component (WIC)   bitmap.</p>	
        /// </summary>	
        /// <param name="wicBitmapSource">No documentation.</param>	
        /// <param name="bitmapProperties">No documentation.</param>	
        /// <param name="bitmap">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Before Direct2D can load a WIC bitmap, that bitmap must be converted to a supported pixel format and alpha mode. For a list of supported pixel formats and alpha modes, see Supported Pixel Formats and Alpha Modes. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::CreateBitmapFromWicBitmap']/*"/>	
        /// <msdn-id>dd371797</msdn-id>	
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmapFromWicBitmap([In] IWICBitmapSource* wicBitmapSource,[In, Optional] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out] ID2D1Bitmap** bitmap)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::CreateBitmapFromWicBitmap</unmanaged-short>	
        internal void CreateBitmapFromWicBitmap(SharpDX.WIC.BitmapSource wicBitmapSource, SharpDX.Direct2D1.BitmapProperties? bitmapProperties, out SharpDX.Direct2D1.Bitmap bitmap)
        {
            unsafe
            {
                SharpDX.Direct2D1.BitmapProperties bitmapProperties_;
                if (bitmapProperties.HasValue)
                    bitmapProperties_ = bitmapProperties.Value;
                IntPtr bitmap_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((wicBitmapSource == null) ? IntPtr.Zero : wicBitmapSource.NativePointer), (bitmapProperties.HasValue) ? &bitmapProperties_ : (void*)IntPtr.Zero, &bitmap_, ((void**)(*(void**)_nativePointer))[5]);
                bitmap = (bitmap_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.Bitmap(bitmap_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.Direct2D1.Bitmap"/></strong> whose data is shared with another resource.</p>	
        /// </summary>	
        /// <param name="riid">No documentation.</param>	
        /// <param name="data">No documentation.</param>	
        /// <param name="bitmapProperties">No documentation.</param>	
        /// <param name="bitmap">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <strong>CreateSharedBitmap</strong> method is useful for efficiently reusing bitmap data and can also be used to provide interoperability with Direct3D. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::CreateSharedBitmap']/*"/>	
        /// <msdn-id>dd371865</msdn-id>	
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateSharedBitmap([In] const GUID&amp; riid,[In] void* data,[In, Optional] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::CreateSharedBitmap</unmanaged-short>	
        internal void CreateSharedBitmap(System.Guid riid, System.IntPtr data, SharpDX.Direct2D1.BitmapProperties? bitmapProperties, SharpDX.Direct2D1.Bitmap bitmap)
        {
            unsafe
            {
                SharpDX.Direct2D1.BitmapProperties bitmapProperties_;
                if (bitmapProperties.HasValue)
                    bitmapProperties_ = bitmapProperties.Value;
                IntPtr bitmap_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &riid, (void*)data, (bitmapProperties.HasValue) ? &bitmapProperties_ : (void*)IntPtr.Zero, &bitmap_, ((void**)(*(void**)_nativePointer))[6]);
                ((SharpDX.Direct2D1.Bitmap)bitmap).NativePointer = bitmap_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.Direct2D1.BitmapBrush"/></strong> from the specified bitmap.</p>	
        /// </summary>	
        /// <param name="bitmap">No documentation.</param>	
        /// <param name="bitmapBrushProperties">No documentation.</param>	
        /// <param name="brushProperties">No documentation.</param>	
        /// <param name="bitmapBrush">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::CreateBitmapBrush']/*"/>	
        /// <msdn-id>dd371776</msdn-id>	
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmapBrush([In, Optional] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_BITMAP_BRUSH_PROPERTIES* bitmapBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1BitmapBrush** bitmapBrush)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::CreateBitmapBrush</unmanaged-short>	
        internal void CreateBitmapBrush(SharpDX.Direct2D1.Bitmap bitmap, SharpDX.Direct2D1.BitmapBrushProperties? bitmapBrushProperties, SharpDX.Direct2D1.BrushProperties? brushProperties, SharpDX.Direct2D1.BitmapBrush bitmapBrush)
        {
            unsafe
            {
                SharpDX.Direct2D1.BitmapBrushProperties bitmapBrushProperties_;
                if (bitmapBrushProperties.HasValue)
                    bitmapBrushProperties_ = bitmapBrushProperties.Value;
                SharpDX.Direct2D1.BrushProperties brushProperties_;
                if (brushProperties.HasValue)
                    brushProperties_ = brushProperties.Value;
                IntPtr bitmapBrush_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((bitmap == null) ? IntPtr.Zero : bitmap.NativePointer), (bitmapBrushProperties.HasValue) ? &bitmapBrushProperties_ : (void*)IntPtr.Zero, (brushProperties.HasValue) ? &brushProperties_ : (void*)IntPtr.Zero, &bitmapBrush_, ((void**)(*(void**)_nativePointer))[7]);
                ((SharpDX.Direct2D1.BitmapBrush)bitmapBrush).NativePointer = bitmapBrush_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a new <strong><see cref="SharpDX.Direct2D1.SolidColorBrush"/></strong> that has the specified color and a base opacity of 1.0f.  </p>	
        /// </summary>	
        /// <param name="color">No documentation.</param>	
        /// <param name="brushProperties">No documentation.</param>	
        /// <param name="solidColorBrush">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::CreateSolidColorBrush']/*"/>	
        /// <msdn-id>dd371871</msdn-id>	
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateSolidColorBrush([In] const D2D_COLOR_F* color,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1SolidColorBrush** solidColorBrush)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::CreateSolidColorBrush</unmanaged-short>	
        internal void CreateSolidColorBrush(SharpDX.Mathematics.Interop.RawColor4 color, SharpDX.Direct2D1.BrushProperties? brushProperties, SharpDX.Direct2D1.SolidColorBrush solidColorBrush)
        {
            unsafe
            {
                SharpDX.Direct2D1.BrushProperties brushProperties_;
                if (brushProperties.HasValue)
                    brushProperties_ = brushProperties.Value;
                IntPtr solidColorBrush_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &color, (brushProperties.HasValue) ? &brushProperties_ : (void*)IntPtr.Zero, &solidColorBrush_, ((void**)(*(void**)_nativePointer))[8]);
                ((SharpDX.Direct2D1.SolidColorBrush)solidColorBrush).NativePointer = solidColorBrush_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.Direct2D1.GradientStopCollection"/></strong> from the specified gradient stops, color interpolation gamma, and extend mode.  </p>	
        /// </summary>	
        /// <param name="gradientStops">No documentation.</param>	
        /// <param name="gradientStopsCount">No documentation.</param>	
        /// <param name="colorInterpolationGamma">No documentation.</param>	
        /// <param name="extendMode">No documentation.</param>	
        /// <param name="gradientStopCollection">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::CreateGradientStopCollection']/*"/>	
        /// <msdn-id>dd371830</msdn-id>	
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateGradientStopCollection([In, Buffer] const D2D1_GRADIENT_STOP* gradientStops,[In] unsigned int gradientStopsCount,[In] D2D1_GAMMA colorInterpolationGamma,[In] D2D1_EXTEND_MODE extendMode,[Out, Fast] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::CreateGradientStopCollection</unmanaged-short>	
        internal void CreateGradientStopCollection(SharpDX.Direct2D1.GradientStop[] gradientStops, int gradientStopsCount, SharpDX.Direct2D1.Gamma colorInterpolationGamma, SharpDX.Direct2D1.ExtendMode extendMode, SharpDX.Direct2D1.GradientStopCollection gradientStopCollection)
        {
            unsafe
            {
                IntPtr gradientStopCollection_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* gradientStops_ = gradientStops)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, gradientStops_, gradientStopsCount, unchecked((int)colorInterpolationGamma), unchecked((int)extendMode), &gradientStopCollection_, ((void**)(*(void**)_nativePointer))[9]);
                ((SharpDX.Direct2D1.GradientStopCollection)gradientStopCollection).NativePointer = gradientStopCollection_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.Direct2D1.LinearGradientBrush"/></strong> that contains the specified gradient stops and has the specified transform and base opacity. </p>	
        /// </summary>	
        /// <param name="linearGradientBrushProperties">No documentation.</param>	
        /// <param name="brushProperties">No documentation.</param>	
        /// <param name="gradientStopCollection">No documentation.</param>	
        /// <param name="linearGradientBrush">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::CreateLinearGradientBrush']/*"/>	
        /// <msdn-id>dd371842</msdn-id>	
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateLinearGradientBrush([In] const D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES* linearGradientBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[In] ID2D1GradientStopCollection* gradientStopCollection,[Out, Fast] ID2D1LinearGradientBrush** linearGradientBrush)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::CreateLinearGradientBrush</unmanaged-short>	
        internal void CreateLinearGradientBrush(SharpDX.Direct2D1.LinearGradientBrushProperties linearGradientBrushProperties, SharpDX.Direct2D1.BrushProperties? brushProperties, SharpDX.Direct2D1.GradientStopCollection gradientStopCollection, SharpDX.Direct2D1.LinearGradientBrush linearGradientBrush)
        {
            unsafe
            {
                SharpDX.Direct2D1.BrushProperties brushProperties_;
                if (brushProperties.HasValue)
                    brushProperties_ = brushProperties.Value;
                IntPtr linearGradientBrush_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &linearGradientBrushProperties, (brushProperties.HasValue) ? &brushProperties_ : (void*)IntPtr.Zero, (void*)((gradientStopCollection == null) ? IntPtr.Zero : gradientStopCollection.NativePointer), &linearGradientBrush_, ((void**)(*(void**)_nativePointer))[10]);
                ((SharpDX.Direct2D1.LinearGradientBrush)linearGradientBrush).NativePointer = linearGradientBrush_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.Direct2D1.RadialGradientBrush"/></strong> that contains the specified gradient stops, has no transform, and has a base opacity of 1.0. </p>	
        /// </summary>	
        /// <param name="radialGradientBrushProperties">No documentation.</param>	
        /// <param name="brushProperties">No documentation.</param>	
        /// <param name="gradientStopCollection">No documentation.</param>	
        /// <param name="radialGradientBrush">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::CreateRadialGradientBrush']/*"/>	
        /// <msdn-id>dd371859</msdn-id>	
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateRadialGradientBrush([In] const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES* radialGradientBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[In] ID2D1GradientStopCollection* gradientStopCollection,[Out, Fast] ID2D1RadialGradientBrush** radialGradientBrush)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::CreateRadialGradientBrush</unmanaged-short>	
        internal void CreateRadialGradientBrush(ref SharpDX.Direct2D1.RadialGradientBrushProperties radialGradientBrushProperties, SharpDX.Direct2D1.BrushProperties? brushProperties, SharpDX.Direct2D1.GradientStopCollection gradientStopCollection, SharpDX.Direct2D1.RadialGradientBrush radialGradientBrush)
        {
            unsafe
            {
                SharpDX.Direct2D1.BrushProperties brushProperties_;
                if (brushProperties.HasValue)
                    brushProperties_ = brushProperties.Value;
                IntPtr radialGradientBrush_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* radialGradientBrushProperties_ = &radialGradientBrushProperties)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, radialGradientBrushProperties_, (brushProperties.HasValue) ? &brushProperties_ : (void*)IntPtr.Zero, (void*)((gradientStopCollection == null) ? IntPtr.Zero : gradientStopCollection.NativePointer), &radialGradientBrush_, ((void**)(*(void**)_nativePointer))[11]);
                ((SharpDX.Direct2D1.RadialGradientBrush)radialGradientBrush).NativePointer = radialGradientBrush_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a new  bitmap render target for use during intermediate offscreen drawing that is compatible with the current render target and has the same pixel format (but not alpha mode) as the current render target. </p>	
        /// </summary>	
        /// <param name="desiredSize"><dd>  <p>The desired size of the new render target in device-independent pixels. The pixel size is computed from the desired size using the parent target DPI. If the <em>desiredSize</em> maps to a integer-pixel size, the DPI of the compatible render target is the same as the DPI of the parent target.  If <em>desiredSize</em> maps to a fractional-pixel size, the pixel size is rounded up to the nearest integer and the DPI for the compatible render target is slightly higher than the DPI of the parent render target. In all cases, the coordinate (<em>desiredSize</em>.width, <em>desiredSize</em>.height) maps to the lower-right corner of the compatible render target.</p> </dd></param>	
        /// <param name="desiredPixelSize"><dd>  <p>When this method returns, contains the address of  a reference to a new bitmap render target. This parameter is passed uninitialized.</p> </dd></param>	
        /// <param name="desiredFormat">No documentation.</param>	
        /// <param name="options">No documentation.</param>	
        /// <param name="bitmapRenderTarget"><dd>  <p>When this method returns, contains the address of  a reference to a new bitmap render target. This parameter is passed uninitialized.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The bitmap render target created by this method is not compatible with GDI. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::CreateCompatibleRenderTarget']/*"/>	
        /// <msdn-id>dd371819</msdn-id>	
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateCompatibleRenderTarget([In, Optional] const D2D_SIZE_F* desiredSize,[In, Optional] const D2D_SIZE_U* desiredPixelSize,[In, Optional] const D2D1_PIXEL_FORMAT* desiredFormat,[In] D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options,[Out, Fast] ID2D1BitmapRenderTarget** bitmapRenderTarget)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::CreateCompatibleRenderTarget</unmanaged-short>	
        internal void CreateCompatibleRenderTarget(SharpDX.Size2F? desiredSize, SharpDX.Size2? desiredPixelSize, SharpDX.Direct2D1.PixelFormat? desiredFormat, SharpDX.Direct2D1.CompatibleRenderTargetOptions options, SharpDX.Direct2D1.BitmapRenderTarget bitmapRenderTarget)
        {
            unsafe
            {
                SharpDX.Size2F desiredSize_;
                if (desiredSize.HasValue)
                    desiredSize_ = desiredSize.Value;
                SharpDX.Size2 desiredPixelSize_;
                if (desiredPixelSize.HasValue)
                    desiredPixelSize_ = desiredPixelSize.Value;
                SharpDX.Direct2D1.PixelFormat desiredFormat_;
                if (desiredFormat.HasValue)
                    desiredFormat_ = desiredFormat.Value;
                IntPtr bitmapRenderTarget_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (desiredSize.HasValue) ? &desiredSize_ : (void*)IntPtr.Zero, (desiredPixelSize.HasValue) ? &desiredPixelSize_ : (void*)IntPtr.Zero, (desiredFormat.HasValue) ? &desiredFormat_ : (void*)IntPtr.Zero, unchecked((int)options), &bitmapRenderTarget_, ((void**)(*(void**)_nativePointer))[12]);
                ((SharpDX.Direct2D1.BitmapRenderTarget)bitmapRenderTarget).NativePointer = bitmapRenderTarget_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a layer resource that can be used with this render target and its compatible render targets. The new layer has the specified initial size. </p>	
        /// </summary>	
        /// <param name="size"><dd>  <p>The initial size of the layer in device-independent pixels, or <strong><c>null</c></strong>. If <strong><c>null</c></strong> or (0, 0) is specified, no backing store is created behind the layer resource. The layer resource is allocated to the minimum size when <strong>PushLayer</strong> is called.</p> </dd></param>	
        /// <param name="layer"><dd>  <p>When the method returns, contains a reference to a reference to the new layer. This parameter is passed uninitialized.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Regardless of whether a size is initially specified, the layer automatically resizes as needed.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::CreateLayer']/*"/>	
        /// <msdn-id>dd371838</msdn-id>	
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateLayer([In, Optional] const D2D_SIZE_F* size,[Out, Fast] ID2D1Layer** layer)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::CreateLayer</unmanaged-short>	
        internal void CreateLayer(SharpDX.Size2F? size, SharpDX.Direct2D1.Layer layer)
        {
            unsafe
            {
                SharpDX.Size2F size_;
                if (size.HasValue)
                    size_ = size.Value;
                IntPtr layer_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (size.HasValue) ? &size_ : (void*)IntPtr.Zero, &layer_, ((void**)(*(void**)_nativePointer))[13]);
                ((SharpDX.Direct2D1.Layer)layer).NativePointer = layer_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Create a mesh that uses triangles to describe a shape.</p>	
        /// </summary>	
        /// <param name="mesh"><dd>  <p>When this method returns, contains a reference to a reference to the new mesh.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To populate a mesh, use its <strong>Open</strong> method to obtain an <strong><see cref="SharpDX.Direct2D1.TessellationSink"/></strong>. To draw the mesh, use the render target's <strong>FillMesh</strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::CreateMesh']/*"/>	
        /// <msdn-id>dd371851</msdn-id>	
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateMesh([Out, Fast] ID2D1Mesh** mesh)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::CreateMesh</unmanaged-short>	
        internal void CreateMesh(SharpDX.Direct2D1.Mesh mesh)
        {
            unsafe
            {
                IntPtr mesh_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &mesh_, ((void**)(*(void**)_nativePointer))[14]);
                ((SharpDX.Direct2D1.Mesh)mesh).NativePointer = mesh_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Draws a line between the specified points using the specified stroke style. </p>	
        /// </summary>	
        /// <param name="point0"><dd>  <p>The start point of the line, in device-independent pixels.</p> </dd></param>	
        /// <param name="point1"><dd>  <p>The end point of the line, in device-independent pixels.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush used to paint the line's stroke.</p> </dd></param>	
        /// <param name="strokeWidth"><dd>  <p>The width of the stroke, in device-independent pixels. The value must be greater than or equal to 0.0f. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</p> </dd></param>	
        /// <param name="strokeStyle"><dd>  <p>The style of stroke to paint, or <strong><c>null</c></strong> to paint a solid line.</p> </dd></param>	
        /// <remarks>	
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawLine</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::DrawLine']/*"/>	
        /// <msdn-id>dd371895</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::DrawLine([In] D2D_POINT_2F point0,[In] D2D_POINT_2F point1,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::DrawLine</unmanaged-short>	
        public void DrawLine(SharpDX.Mathematics.Interop.RawVector2 point0, SharpDX.Mathematics.Interop.RawVector2 point1, SharpDX.Direct2D1.Brush brush, float strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid29(_nativePointer, point0, point1, (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), strokeWidth, (void*)((strokeStyle == null) ? IntPtr.Zero : strokeStyle.NativePointer), ((void**)(*(void**)_nativePointer))[15]);
            }
        }

        /// <summary>	
        /// <p>Draws the outline of a rectangle that has the specified dimensions and stroke style. </p>	
        /// </summary>	
        /// <param name="rect"><dd>  <p>The dimensions of the rectangle to draw, in device-independent pixels.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush used to paint the rectangle's stroke.</p> </dd></param>	
        /// <param name="strokeWidth"><dd>  <p>The width of the stroke, in device-independent pixels. The value must be greater than or equal to 0.0f. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</p> </dd></param>	
        /// <param name="strokeStyle"><dd>  <p>The style of stroke to paint, or <strong><c>null</c></strong> to paint a solid stroke.</p> </dd></param>	
        /// <remarks>	
        /// <p>When this method fails, it does not return an error code. To determine whether a drawing method (such as <strong>DrawRectangle</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> method. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::DrawRectangle']/*"/>	
        /// <msdn-id>dd371902</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::DrawRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::DrawRectangle</unmanaged-short>	
        public void DrawRectangle(SharpDX.Mathematics.Interop.RawRectangleF rect, SharpDX.Direct2D1.Brush brush, float strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &rect, (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), strokeWidth, (void*)((strokeStyle == null) ? IntPtr.Zero : strokeStyle.NativePointer), ((void**)(*(void**)_nativePointer))[16]);
            }
        }

        /// <summary>	
        /// <p>Paints the interior of the specified rectangle. </p>	
        /// </summary>	
        /// <param name="rect"><dd>  <p>The dimension of the rectangle to paint, in device-independent pixels.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush used to paint the rectangle's interior.</p> </dd></param>	
        /// <remarks>	
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>FillRectangle</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::FillRectangle']/*"/>	
        /// <msdn-id>dd371954</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::FillRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::FillRectangle</unmanaged-short>	
        public void FillRectangle(SharpDX.Mathematics.Interop.RawRectangleF rect, SharpDX.Direct2D1.Brush brush)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &rect, (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), ((void**)(*(void**)_nativePointer))[17]);
            }
        }

        /// <summary>	
        /// <p> Draws the outline of the specified rounded rectangle using the specified stroke style.</p>	
        /// </summary>	
        /// <param name="roundedRect"><dd>  <p>The dimensions of the rounded rectangle to draw, in device-independent pixels.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush used to paint the rounded rectangle's outline. </p> </dd></param>	
        /// <param name="strokeWidth"><dd>  <p>The width of the stroke, in device-independent pixels. The value must be greater than or equal to 0.0f. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</p> </dd></param>	
        /// <param name="strokeStyle"><dd>  <p>The style of the rounded rectangle's stroke, or <strong><c>null</c></strong> to paint a solid stroke. The default value is <strong><c>null</c></strong>.</p> </dd></param>	
        /// <remarks>	
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawRoundedRectangle</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::DrawRoundedRectangle']/*"/>	
        /// <msdn-id>dd371908</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::DrawRoundedRectangle([In] const D2D1_ROUNDED_RECT* roundedRect,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::DrawRoundedRectangle</unmanaged-short>	
        public void DrawRoundedRectangle(ref SharpDX.Direct2D1.RoundedRectangle roundedRect, SharpDX.Direct2D1.Brush brush, float strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            unsafe
            {
                fixed (void* roundedRect_ = &roundedRect)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, roundedRect_, (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), strokeWidth, (void*)((strokeStyle == null) ? IntPtr.Zero : strokeStyle.NativePointer), ((void**)(*(void**)_nativePointer))[18]);
            }
        }

        /// <summary>	
        /// <p>Paints the interior of the specified rounded rectangle. </p>	
        /// </summary>	
        /// <param name="roundedRect"><dd>  <p>The dimensions of the rounded rectangle to paint, in device independent pixels.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush used to paint the interior of the rounded rectangle.</p> </dd></param>	
        /// <remarks>	
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>FillRoundedRectangle</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::FillRoundedRectangle']/*"/>	
        /// <msdn-id>dd316795</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::FillRoundedRectangle([In] const D2D1_ROUNDED_RECT* roundedRect,[In] ID2D1Brush* brush)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::FillRoundedRectangle</unmanaged-short>	
        public void FillRoundedRectangle(ref SharpDX.Direct2D1.RoundedRectangle roundedRect, SharpDX.Direct2D1.Brush brush)
        {
            unsafe
            {
                fixed (void* roundedRect_ = &roundedRect)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, roundedRect_, (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), ((void**)(*(void**)_nativePointer))[19]);
            }
        }

        /// <summary>	
        /// <p>Draws the outline of the specified ellipse using the specified stroke style. </p>	
        /// </summary>	
        /// <param name="ellipse"><dd>  <p>The position and radius of the ellipse to draw, in device-independent pixels.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush used to paint the ellipse's outline.</p> </dd></param>	
        /// <param name="strokeWidth"><dd>  <p>The width of the stroke, in device-independent pixels. The value must be greater than or equal to 0.0f. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</p> </dd></param>	
        /// <param name="strokeStyle"><dd>  <p>The style of stroke to apply to the ellipse's outline, or <strong><c>null</c></strong> to paint a solid stroke.</p> </dd></param>	
        /// <remarks>	
        /// <p>The <strong>DrawEllipse</strong> method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawEllipse</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::DrawEllipse']/*"/>	
        /// <msdn-id>dd371886</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::DrawEllipse([In] const D2D1_ELLIPSE* ellipse,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::DrawEllipse</unmanaged-short>	
        public void DrawEllipse(SharpDX.Direct2D1.Ellipse ellipse, SharpDX.Direct2D1.Brush brush, float strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &ellipse, (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), strokeWidth, (void*)((strokeStyle == null) ? IntPtr.Zero : strokeStyle.NativePointer), ((void**)(*(void**)_nativePointer))[20]);
            }
        }

        /// <summary>	
        /// <p>Paints the interior of the specified ellipse. </p>	
        /// </summary>	
        /// <param name="ellipse"><dd>  <p>The position and radius, in device-independent pixels, of the ellipse to paint.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush used to paint the interior of the ellipse.</p> </dd></param>	
        /// <remarks>	
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>FillEllipse</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::FillEllipse']/*"/>	
        /// <msdn-id>dd371928</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::FillEllipse([In] const D2D1_ELLIPSE* ellipse,[In] ID2D1Brush* brush)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::FillEllipse</unmanaged-short>	
        public void FillEllipse(SharpDX.Direct2D1.Ellipse ellipse, SharpDX.Direct2D1.Brush brush)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &ellipse, (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), ((void**)(*(void**)_nativePointer))[21]);
            }
        }

        /// <summary>	
        /// <p>Draws the outline of the specified geometry using the specified stroke style. </p>	
        /// </summary>	
        /// <param name="geometry"><dd>  <p>The geometry to draw.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush used to paint the geometry's stroke.</p> </dd></param>	
        /// <param name="strokeWidth"><dd>  <p>The width of the stroke, in device-independent pixels. The value must be greater than or equal to 0.0f. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</p> </dd></param>	
        /// <param name="strokeStyle"><dd>  <p>The style of stroke to apply to the geometry's outline, or <strong><c>null</c></strong> to paint a solid stroke.</p> </dd></param>	
        /// <remarks>	
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawGeometry</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::DrawGeometry']/*"/>	
        /// <msdn-id>dd371890</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::DrawGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::DrawGeometry</unmanaged-short>	
        public void DrawGeometry(SharpDX.Direct2D1.Geometry geometry, SharpDX.Direct2D1.Brush brush, float strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((geometry == null) ? IntPtr.Zero : geometry.NativePointer), (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), strokeWidth, (void*)((strokeStyle == null) ? IntPtr.Zero : strokeStyle.NativePointer), ((void**)(*(void**)_nativePointer))[22]);
            }
        }

        /// <summary>	
        /// <p>Paints the interior of the specified geometry. </p>	
        /// </summary>	
        /// <param name="geometry"><dd>  <p>The geometry to paint.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush used to paint the geometry's interior.</p> </dd></param>	
        /// <param name="opacityBrush"><dd>  <p>The opacity mask to apply to the geometry, or <strong><c>null</c></strong> for no opacity mask. If an opacity mask (the <em>opacityBrush</em> parameter) is specified, <em>brush</em> must be an <strong><see cref="SharpDX.Direct2D1.BitmapBrush"/></strong> that has   its x- and y-extend modes set to <strong><see cref="SharpDX.Direct2D1.ExtendMode.Clamp"/></strong>. For more information, see the Remarks section. </p> </dd></param>	
        /// <remarks>	
        /// <p>If the <em>opacityBrush</em> parameter is not <strong><c>null</c></strong>, the alpha value of each pixel of the mapped <em>opacityBrush</em> is used to determine the resulting opacity of each corresponding pixel of the geometry. Only the alpha value of each color in the brush is used for this processing; all other color information is ignored.  The alpha value specified by the brush is multiplied by the alpha value of the geometry after the geometry has been painted by <em>brush</em>.  	
        /// </p><p>When this method fails, it does not return an error code. To determine whether a drawing operation (such as <strong>FillGeometry</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> method. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::FillGeometry']/*"/>	
        /// <msdn-id>dd371933</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::FillGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In, Optional] ID2D1Brush* opacityBrush)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::FillGeometry</unmanaged-short>	
        public void FillGeometry(SharpDX.Direct2D1.Geometry geometry, SharpDX.Direct2D1.Brush brush, SharpDX.Direct2D1.Brush opacityBrush)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((geometry == null) ? IntPtr.Zero : geometry.NativePointer), (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), (void*)((opacityBrush == null) ? IntPtr.Zero : opacityBrush.NativePointer), ((void**)(*(void**)_nativePointer))[23]);
            }
        }

        /// <summary>	
        /// <p> Paints the interior of the specified mesh.</p>	
        /// </summary>	
        /// <param name="mesh"><dd>  <p>The mesh to paint.</p> </dd></param>	
        /// <param name="brush"><dd>  <p>The brush used to paint the mesh.</p> </dd></param>	
        /// <remarks>	
        /// <p>The current antialias mode of the render target must be <strong><see cref="SharpDX.Direct2D1.AntialiasMode.Aliased"/></strong> when <strong>FillMesh</strong> is called. To change the render target's antialias mode, use the <strong>SetAntialiasMode</strong> method.</p><p><strong>FillMesh</strong> does not expect a particular winding order for the triangles in the <strong><see cref="SharpDX.Direct2D1.Mesh"/></strong>; both clockwise and counter-clockwise will work. </p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>FillMesh</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::FillMesh']/*"/>	
        /// <msdn-id>dd371939</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::FillMesh([In] ID2D1Mesh* mesh,[In] ID2D1Brush* brush)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::FillMesh</unmanaged-short>	
        public void FillMesh(SharpDX.Direct2D1.Mesh mesh, SharpDX.Direct2D1.Brush brush)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((mesh == null) ? IntPtr.Zero : mesh.NativePointer), (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), ((void**)(*(void**)_nativePointer))[24]);
            }
        }

        /// <summary>	
        /// Applies the opacity mask described by the specified bitmap to a brush and uses that brush to paint a region of the render target.	
        /// </summary>	
        /// <param name="opacityMask">No documentation.</param>	
        /// <param name="brush">No documentation.</param>	
        /// <param name="content">No documentation.</param>	
        /// <param name="destinationRectangle">No documentation.</param>	
        /// <param name="sourceRectangle">No documentation.</param>	
        /// <remarks>	
        /// <p>For this method to work properly, the render target must be using the <strong><see cref="SharpDX.Direct2D1.AntialiasMode.Aliased"/></strong> antialiasing mode. You can set the antialiasing mode by calling the <strong><see cref="SharpDX.Direct2D1.RenderTarget.SetAntialiasMode"/></strong> method.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>FillOpacityMask</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::FillOpacityMask']/*"/>	
        /// <msdn-id>dd742850</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[In] D2D1_OPACITY_MASK_CONTENT content,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::FillOpacityMask</unmanaged-short>	
        public void FillOpacityMask(SharpDX.Direct2D1.Bitmap opacityMask, SharpDX.Direct2D1.Brush brush, SharpDX.Direct2D1.OpacityMaskContent content, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
                if (destinationRectangle.HasValue)
                    destinationRectangle_ = destinationRectangle.Value;
                SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
                if (sourceRectangle.HasValue)
                    sourceRectangle_ = sourceRectangle.Value;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((opacityMask == null) ? IntPtr.Zero : opacityMask.NativePointer), (void*)((brush == null) ? IntPtr.Zero : brush.NativePointer), unchecked((int)content), (destinationRectangle.HasValue) ? &destinationRectangle_ : (void*)IntPtr.Zero, (sourceRectangle.HasValue) ? &sourceRectangle_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[25]);
            }
        }

        /// <summary>	
        /// <p>Draws the specified bitmap after scaling it to the size of the specified rectangle. </p>	
        /// </summary>	
        /// <param name="bitmap"><dd>  <p>The bitmap to render.</p> </dd></param>	
        /// <param name="destinationRectangle"><dd>  <p>The size and position, in device-independent pixels in the render target's coordinate space, of the area to which the bitmap is drawn. If the rectangle is not well-ordered, nothing is drawn, but the render target does not enter an error state.</p> </dd></param>	
        /// <param name="opacity"><dd>  <p>A value between 0.0f and 1.0f, inclusive, that specifies the opacity value to be applied to the bitmap; this value is multiplied against the alpha values of the bitmap's contents.  Default is 1.0f.</p> </dd></param>	
        /// <param name="interpolationMode"><dd>  <p>The interpolation mode to use if the bitmap is scaled or rotated by the drawing operation. The default value is <strong><see cref="SharpDX.Direct2D1.BitmapInterpolationMode.Linear"/></strong>. </p> </dd></param>	
        /// <param name="sourceRectangle"><dd>  <p>The size and position, in device-independent pixels in the bitmap's coordinate space, of the area within the bitmap to draw; <strong><c>null</c></strong> to draw the entire bitmap.</p> </dd></param>	
        /// <remarks>	
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawBitmap</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::DrawBitmap']/*"/>	
        /// <msdn-id>dd371878</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::DrawBitmap</unmanaged-short>	
        public void DrawBitmap(SharpDX.Direct2D1.Bitmap bitmap, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, float opacity, SharpDX.Direct2D1.BitmapInterpolationMode interpolationMode, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
                if (destinationRectangle.HasValue)
                    destinationRectangle_ = destinationRectangle.Value;
                SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
                if (sourceRectangle.HasValue)
                    sourceRectangle_ = sourceRectangle.Value;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((bitmap == null) ? IntPtr.Zero : bitmap.NativePointer), (destinationRectangle.HasValue) ? &destinationRectangle_ : (void*)IntPtr.Zero, opacity, unchecked((int)interpolationMode), (sourceRectangle.HasValue) ? &sourceRectangle_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[26]);
            }
        }

        /// <summary>	
        /// <p>Draws the specified text using the format information provided by an <strong><see cref="SharpDX.DirectWrite.TextFormat"/></strong> object.</p>	
        /// </summary>	
        /// <param name="text">No documentation.</param>	
        /// <param name="stringLength">No documentation.</param>	
        /// <param name="textFormat">No documentation.</param>	
        /// <param name="layoutRect">No documentation.</param>	
        /// <param name="defaultForegroundBrush">No documentation.</param>	
        /// <param name="options">No documentation.</param>	
        /// <param name="measuringMode">No documentation.</param>	
        /// <remarks>	
        /// <p>To create an <strong><see cref="SharpDX.DirectWrite.TextFormat"/></strong> object, create an <strong><see cref="SharpDX.DirectWrite.Factory"/></strong> and call its <strong>CreateTextFormat</strong> method.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawText</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::DrawTextW']/*"/>	
        /// <msdn-id>dd371919</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::DrawTextW([In, Buffer] const wchar_t* string,[In] unsigned int stringLength,[In] IDWriteTextFormat* textFormat,[In] const D2D_RECT_F* layoutRect,[In] ID2D1Brush* defaultForegroundBrush,[In] D2D1_DRAW_TEXT_OPTIONS options,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::DrawTextW</unmanaged-short>	
        public void DrawText(string text, int stringLength, SharpDX.DirectWrite.TextFormat textFormat, SharpDX.Mathematics.Interop.RawRectangleF layoutRect, SharpDX.Direct2D1.Brush defaultForegroundBrush, SharpDX.Direct2D1.DrawTextOptions options, SharpDX.Direct2D1.MeasuringMode measuringMode)
        {
            unsafe
            {
                IntPtr text_ = Utilities.StringToHGlobalUni(text);
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)text_, stringLength, (void*)((textFormat == null) ? IntPtr.Zero : textFormat.NativePointer), &layoutRect, (void*)((defaultForegroundBrush == null) ? IntPtr.Zero : defaultForegroundBrush.NativePointer), unchecked((int)options), unchecked((int)measuringMode), ((void**)(*(void**)_nativePointer))[27]);
                Marshal.FreeHGlobal(text_);
            }
        }

        /// <summary>	
        /// <p>Draws the formatted text described by the specified <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> object.</p>	
        /// </summary>	
        /// <param name="origin">No documentation.</param>	
        /// <param name="textLayout">No documentation.</param>	
        /// <param name="defaultForegroundBrush">No documentation.</param>	
        /// <param name="options">No documentation.</param>	
        /// <remarks>	
        /// <p>When drawing the same text repeatedly, using the <strong>DrawTextLayout</strong> method is more efficient than using the <strong>DrawText</strong> method because the text doesn't need to be formatted and the layout processed with each call.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawTextLayout</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::DrawTextLayout']/*"/>	
        /// <msdn-id>dd371913</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::DrawTextLayout([In] D2D_POINT_2F origin,[In] IDWriteTextLayout* textLayout,[In] ID2D1Brush* defaultForegroundBrush,[In] D2D1_DRAW_TEXT_OPTIONS options)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::DrawTextLayout</unmanaged-short>	
        public void DrawTextLayout(SharpDX.Mathematics.Interop.RawVector2 origin, SharpDX.DirectWrite.TextLayout textLayout, SharpDX.Direct2D1.Brush defaultForegroundBrush, SharpDX.Direct2D1.DrawTextOptions options)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid35(_nativePointer, origin, (void*)((textLayout == null) ? IntPtr.Zero : textLayout.NativePointer), (void*)((defaultForegroundBrush == null) ? IntPtr.Zero : defaultForegroundBrush.NativePointer), unchecked((int)options), ((void**)(*(void**)_nativePointer))[28]);
            }
        }

        /// <summary>	
        /// <p>Draws the specified glyphs. </p>	
        /// </summary>	
        /// <param name="baselineOrigin"><dd>  <p>The origin, in device-independent pixels, of the glyphs' baseline.</p> </dd></param>	
        /// <param name="glyphRun"><dd>  <p>The glyphs to render.</p> </dd></param>	
        /// <param name="foregroundBrush"><dd>  <p>The brush used to paint the specified glyphs.</p> </dd></param>	
        /// <param name="measuringMode"><dd>  <p>A value that indicates how glyph metrics are used to measure text when it is formatted.  The default value is <strong><see cref="SharpDX.Direct2D1.MeasuringMode.Natural"/></strong>. </p> </dd></param>	
        /// <remarks>	
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawGlyphRun</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::DrawGlyphRun']/*"/>	
        /// <msdn-id>dd371893</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::DrawGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] ID2D1Brush* foregroundBrush,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::DrawGlyphRun</unmanaged-short>	
        public void DrawGlyphRun(SharpDX.Mathematics.Interop.RawVector2 baselineOrigin, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.Direct2D1.Brush foregroundBrush, SharpDX.Direct2D1.MeasuringMode measuringMode)
        {
            unsafe
            {
                var glyphRun_ = new SharpDX.DirectWrite.GlyphRun.__Native();
                glyphRun.__MarshalTo(ref glyphRun_);
                SharpDX.Direct2D1.LocalInterop.Callivoid35(_nativePointer, baselineOrigin, &glyphRun_, (void*)((foregroundBrush == null) ? IntPtr.Zero : foregroundBrush.NativePointer), unchecked((int)measuringMode), ((void**)(*(void**)_nativePointer))[29]);
                glyphRun.__MarshalFree(ref glyphRun_);
            }
        }

        /// <summary>	
        /// Applies the specified transform to the render target, replacing the existing transformation. All subsequent drawing operations occur in the transformed space.	
        /// </summary>	
        /// <param name="transform">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::SetTransform']/*"/>	
        /// <msdn-id>dd742857</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::SetTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::SetTransform</unmanaged-short>	
        internal void SetTransform(ref SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            unsafe
            {
                fixed (void* transform_ = &transform)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, transform_, ((void**)(*(void**)_nativePointer))[30]);
            }
        }

        /// <summary>	
        /// <p>Gets the current transform of the render target. </p>	
        /// </summary>	
        /// <param name="transform"><dd>  <p>When this returns, contains the current transform of the render target. This parameter is passed uninitialized.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetTransform']/*"/>	
        /// <msdn-id>dd316845</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::GetTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::GetTransform</unmanaged-short>	
        internal void GetTransform(out SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            unsafe
            {
                transform = new SharpDX.Mathematics.Interop.RawMatrix3x2();
                fixed (void* transform_ = &transform)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, transform_, ((void**)(*(void**)_nativePointer))[31]);
            }
        }

        /// <summary>	
        /// <p>Sets the antialiasing mode of the render target. The antialiasing mode applies to all subsequent drawing operations, excluding text and glyph drawing operations. </p>	
        /// </summary>	
        /// <param name="antialiasMode"><dd>  <p>The antialiasing mode for future drawing operations. </p> </dd></param>	
        /// <remarks>	
        /// <p>To specify the antialiasing mode for text and glyph operations, use the <strong>SetTextAntialiasMode</strong> method. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::SetAntialiasMode']/*"/>	
        /// <msdn-id>dd316881</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::SetAntialiasMode([In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::SetAntialiasMode</unmanaged-short>	
        internal void SetAntialiasMode(SharpDX.Direct2D1.AntialiasMode antialiasMode)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)antialiasMode), ((void**)(*(void**)_nativePointer))[32]);
            }
        }

        /// <summary>	
        /// <p> Retrieves the current antialiasing mode for nontext drawing operations.</p>	
        /// </summary>	
        /// <returns><p>The current antialiasing mode for nontext drawing operations. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetAntialiasMode']/*"/>	
        /// <msdn-id>dd316805</msdn-id>	
        /// <unmanaged>D2D1_ANTIALIAS_MODE ID2D1RenderTarget::GetAntialiasMode()</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::GetAntialiasMode</unmanaged-short>	
        internal SharpDX.Direct2D1.AntialiasMode GetAntialiasMode()
        {
            unsafe
            {
                SharpDX.Direct2D1.AntialiasMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1AntialiasMode(_nativePointer, ((void**)(*(void**)_nativePointer))[33]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Specifies the antialiasing mode to use for subsequent text and glyph drawing operations. </p>	
        /// </summary>	
        /// <param name="textAntialiasMode"><dd>  <p>The antialiasing mode to use for subsequent text and glyph drawing operations.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::SetTextAntialiasMode']/*"/>	
        /// <msdn-id>dd316897</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::SetTextAntialiasMode([In] D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::SetTextAntialiasMode</unmanaged-short>	
        internal void SetTextAntialiasMode(SharpDX.Direct2D1.TextAntialiasMode textAntialiasMode)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)textAntialiasMode), ((void**)(*(void**)_nativePointer))[34]);
            }
        }

        /// <summary>	
        /// <p>Gets the current antialiasing mode for text and glyph drawing operations. </p>	
        /// </summary>	
        /// <returns><p>The current antialiasing mode for text and glyph drawing operations. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetTextAntialiasMode']/*"/>	
        /// <msdn-id>dd316835</msdn-id>	
        /// <unmanaged>D2D1_TEXT_ANTIALIAS_MODE ID2D1RenderTarget::GetTextAntialiasMode()</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::GetTextAntialiasMode</unmanaged-short>	
        internal SharpDX.Direct2D1.TextAntialiasMode GetTextAntialiasMode()
        {
            unsafe
            {
                SharpDX.Direct2D1.TextAntialiasMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1TextAntialiasMode(_nativePointer, ((void**)(*(void**)_nativePointer))[35]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Specifies text rendering options to be applied to all subsequent text and glyph drawing operations. </p>	
        /// </summary>	
        /// <param name="textRenderingParams"><dd>  <p>The text rendering options to be applied to all subsequent text and glyph drawing operations; <strong><c>null</c></strong> to clear current text rendering options. </p> </dd></param>	
        /// <remarks>	
        /// <p>If the settings specified by  <em>textRenderingParams</em> are incompatible with the render target's text antialiasing mode (specified by <strong>SetTextAntialiasMode</strong>), subsequent text and glyph drawing operations will fail and put the render target into an error state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::SetTextRenderingParams']/*"/>	
        /// <msdn-id>dd316898</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::SetTextRenderingParams([In, Optional] IDWriteRenderingParams* textRenderingParams)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::SetTextRenderingParams</unmanaged-short>	
        internal void SetTextRenderingParams(SharpDX.DirectWrite.RenderingParams textRenderingParams)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((textRenderingParams == null) ? IntPtr.Zero : textRenderingParams.NativePointer), ((void**)(*(void**)_nativePointer))[36]);
            }
        }

        /// <summary>	
        /// <p>Retrieves the render target's current text rendering options. </p>	
        /// </summary>	
        /// <param name="textRenderingParams"><dd>  <p> When this method returns, <em>textRenderingParams</em>contains the address  of a reference to the render target's current text rendering options. </p> </dd></param>	
        /// <remarks>	
        /// <p>If the settings specified by  <em>textRenderingParams</em> are incompatible with the render target's text antialiasing mode (specified by <strong>SetTextAntialiasMode</strong>), subsequent text and glyph drawing operations will fail and put the render target into an error state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetTextRenderingParams']/*"/>	
        /// <msdn-id>dd316841</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::GetTextRenderingParams([Out, Optional] IDWriteRenderingParams** textRenderingParams)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::GetTextRenderingParams</unmanaged-short>	
        internal void GetTextRenderingParams(out SharpDX.DirectWrite.RenderingParams textRenderingParams)
        {
            unsafe
            {
                IntPtr textRenderingParams_ = IntPtr.Zero;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &textRenderingParams_, ((void**)(*(void**)_nativePointer))[37]);
                textRenderingParams = (textRenderingParams_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.RenderingParams(textRenderingParams_);
            }
        }

        /// <summary>	
        /// <p>Specifies a label for subsequent drawing operations.   </p>	
        /// </summary>	
        /// <param name="tag1"><dd>  <p>A label to apply to subsequent drawing operations.</p> </dd></param>	
        /// <param name="tag2"><dd>  <p>A label to apply to subsequent drawing operations.</p> </dd></param>	
        /// <remarks>	
        /// <p>The labels specified by this method are printed by debug error messages. If no tag is set, the default value for each tag is 0.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::SetTags']/*"/>	
        /// <msdn-id>dd316892</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::SetTags([In] unsigned longlong tag1,[In] unsigned longlong tag2)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::SetTags</unmanaged-short>	
        public void SetTags(long tag1, long tag2)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, tag1, tag2, ((void**)(*(void**)_nativePointer))[38]);
            }
        }

        /// <summary>	
        /// <p>Gets the label for subsequent drawing operations. </p>	
        /// </summary>	
        /// <param name="tag1"><dd>  <p>When this method returns, contains the first label for subsequent drawing operations. This parameter is passed uninitialized. If <strong><c>null</c></strong> is specified, no value is retrieved for this parameter. </p> </dd></param>	
        /// <param name="tag2"><dd>  <p>When this method returns, contains the second label for subsequent drawing operations. This parameter is passed uninitialized. If <strong><c>null</c></strong> is specified, no value is retrieved for this parameter.</p> </dd></param>	
        /// <remarks>	
        /// <p>If the same address is passed for both parameters, both parameters receive the value of the second tag. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetTags']/*"/>	
        /// <msdn-id>dd316830</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::GetTags([Out, Optional] unsigned longlong* tag1,[Out, Optional] unsigned longlong* tag2)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::GetTags</unmanaged-short>	
        public void GetTags(out long tag1, out long tag2)
        {
            unsafe
            {
                fixed (void* tag1_ = &tag1)
                    fixed (void* tag2_ = &tag2)
                        SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, tag1_, tag2_, ((void**)(*(void**)_nativePointer))[39]);
            }
        }

        /// <summary>	
        /// <p>Adds the specified layer to the render target so that it receives all subsequent drawing operations until <strong>PopLayer</strong> is called. </p>	
        /// </summary>	
        /// <param name="layerParameters">No documentation.</param>	
        /// <param name="layer">No documentation.</param>	
        /// <remarks>	
        /// <p>The <strong>PushLayer</strong> method allows a caller to begin redirecting rendering to a layer. All rendering operations are valid in a layer. The location of the layer is affected by the world transform set on the render target. </p><p>Each <strong>PushLayer</strong> must have a matching <strong>PopLayer</strong> call. If there are more <strong>PopLayer</strong> calls than <strong>PushLayer</strong> calls, the render target is placed into an error state. If <strong>Flush</strong> is called before all outstanding layers are popped, the render target is placed into an error state, and an error is returned. The error state can be cleared by a call to <strong>EndDraw</strong>.</p><p>A particular <strong><see cref="SharpDX.Direct2D1.Layer"/></strong> resource can be active only at one time. In other words, you cannot call a <strong>PushLayer</strong> method, and then immediately follow  with another <strong>PushLayer</strong> method with the same layer resource. Instead, you must call the second <strong>PushLayer</strong> method with different layer resources. 	
        /// </p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>PushLayer</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::PushLayer']/*"/>	
        /// <msdn-id>dd316869</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::PushLayer([In] const D2D1_LAYER_PARAMETERS* layerParameters,[In, Optional] ID2D1Layer* layer)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::PushLayer</unmanaged-short>	
        public void PushLayer(ref SharpDX.Direct2D1.LayerParameters layerParameters, SharpDX.Direct2D1.Layer layer)
        {
            unsafe
            {
                fixed (void* layerParameters_ = &layerParameters)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, layerParameters_, (void*)((layer == null) ? IntPtr.Zero : layer.NativePointer), ((void**)(*(void**)_nativePointer))[40]);
            }
        }

        /// <summary>	
        /// <p>Stops redirecting drawing operations to the layer that is specified by the last <strong>PushLayer</strong> call. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>A <strong>PopLayer</strong> must match a previous <strong>PushLayer</strong> call.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>PopLayer</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::PopLayer']/*"/>	
        /// <msdn-id>dd316852</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::PopLayer()</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::PopLayer</unmanaged-short>	
        public void PopLayer()
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[41]);
            }
        }

        /// <summary>	
        /// <p>Executes all pending drawing commands. </p>	
        /// </summary>	
        /// <param name="tag1"><dd>  <p>When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</p> </dd></param>	
        /// <param name="tag2"><dd>  <p>When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code and sets <em>tag1</em> and <em>tag2</em> to the tags that were active when the error occurred. If no error occurred, this method sets the error tag state to be (0,0).</p></returns>	
        /// <remarks>	
        /// <p>This command does not flush the device that is associated with the render target.  </p><p>Calling this method resets the error state of the render target.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::Flush']/*"/>	
        /// <msdn-id>dd316801</msdn-id>	
        /// <unmanaged>HRESULT ID2D1RenderTarget::Flush([Out, Optional] unsigned longlong* tag1,[Out, Optional] unsigned longlong* tag2)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::Flush</unmanaged-short>	
        public void Flush(out long tag1, out long tag2)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* tag1_ = &tag1)
                    fixed (void* tag2_ = &tag2)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, tag1_, tag2_, ((void**)(*(void**)_nativePointer))[42]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Saves the current drawing state to the specified <strong><see cref="SharpDX.Direct2D1.DrawingStateBlock"/></strong>.</p>	
        /// </summary>	
        /// <param name="drawingStateBlock">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::SaveDrawingState']/*"/>	
        /// <msdn-id>dd316876</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::SaveDrawingState([InOut] ID2D1DrawingStateBlock* drawingStateBlock)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::SaveDrawingState</unmanaged-short>	
        public void SaveDrawingState(SharpDX.Direct2D1.DrawingStateBlock drawingStateBlock)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((drawingStateBlock == null) ? IntPtr.Zero : drawingStateBlock.NativePointer), ((void**)(*(void**)_nativePointer))[43]);
            }
        }

        /// <summary>	
        /// <p>Sets the render target's drawing state to that of the specified <strong><see cref="SharpDX.Direct2D1.DrawingStateBlock"/></strong>.</p>	
        /// </summary>	
        /// <param name="drawingStateBlock">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::RestoreDrawingState']/*"/>	
        /// <msdn-id>dd316872</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::RestoreDrawingState([In] ID2D1DrawingStateBlock* drawingStateBlock)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::RestoreDrawingState</unmanaged-short>	
        public void RestoreDrawingState(SharpDX.Direct2D1.DrawingStateBlock drawingStateBlock)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)((drawingStateBlock == null) ? IntPtr.Zero : drawingStateBlock.NativePointer), ((void**)(*(void**)_nativePointer))[44]);
            }
        }

        /// <summary>	
        /// <p>Specifies a rectangle to which all subsequent drawing operations are clipped. </p>	
        /// </summary>	
        /// <param name="clipRect"><dd>  <p>The size and position of the clipping area, in device-independent pixels.</p> </dd></param>	
        /// <param name="antialiasMode"><dd>  <p>The antialiasing mode that is used to draw the edges of clip rects that have subpixel boundaries, and to blend the clip with the scene contents. The blending is performed once when the <strong>PopAxisAlignedClip</strong> method is called, and does not apply to each primitive within the layer. </p> </dd></param>	
        /// <remarks>	
        /// <p>The <em>clipRect</em> is transformed by the current world transform set on the render target. After the transform is applied to the <em>clipRect</em> that is passed in, the axis-aligned bounding box for the <em>clipRect</em> is computed.  For efficiency, the contents are clipped to this axis-aligned bounding box and not to the original <em>clipRect</em> that is passed in. </p><p>The following diagrams show how a rotation transform is applied to the render target, the resulting <em>clipRect</em>, and  a calculated axis-aligned bounding box.</p><ol> <li> <p>Assume the rectangle in the following illustration is a render target that is aligned to the screen pixels.</p> <p></p> </li> <li> <p>Apply a rotation transform to the render target. In the following illustration, the black rectangle represents the original render target and the red dashed rectangle represents the transformed render target.</p> <p></p> </li> <li> <p>After calling <strong>PushAxisAlignedClip</strong>, the rotation transform is applied to the <em>clipRect</em>. In the following illustration, the blue rectangle represents the transformed <em>clipRect</em>.</p> <p></p> </li> <li> <p>The axis-aligned bounding box is calculated. The green dashed rectangle represents the bounding box in the following illustration. All contents are clipped to this axis-aligned bounding box.</p> <p></p> </li> </ol><p><strong>Note</strong>??If rendering operations fail or if <strong>PopAxisAlignedClip</strong> is not called, clip rects may cause some artifacts on the render target. <strong>PopAxisAlignedClip</strong> can be considered a drawing operation that is designed to fix the borders of a clipping region. Without this call, the borders of a clipped area may be not antialiased or otherwise corrected.</p><p>The <strong>PushAxisAlignedClip</strong> and <strong>PopAxisAlignedClip</strong> must match. Otherwise, the error state is set. For the render target to continue receiving new commands, you can call <strong>Flush</strong> to clear the error. </p><p>A           <strong>PushAxisAlignedClip</strong> and <strong>PopAxisAlignedClip</strong> pair can occur around or within a PushLayer and PopLayer, but cannot overlap. For example, the sequence of <strong>PushAxisAlignedClip</strong>, <strong>PushLayer</strong>, <strong>PopLayer</strong>, <strong>PopAxisAlignedClip</strong> is valid, but the sequence of <strong>PushAxisAlignedClip</strong>, <strong>PushLayer</strong>, <strong>PopAxisAlignedClip</strong>, <strong>PopLayer</strong> is invalid.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>PushAxisAlignedClip</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::PushAxisAlignedClip']/*"/>	
        /// <msdn-id>dd316860</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::PushAxisAlignedClip([In] const D2D_RECT_F* clipRect,[In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::PushAxisAlignedClip</unmanaged-short>	
        public void PushAxisAlignedClip(SharpDX.Mathematics.Interop.RawRectangleF clipRect, SharpDX.Direct2D1.AntialiasMode antialiasMode)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &clipRect, unchecked((int)antialiasMode), ((void**)(*(void**)_nativePointer))[45]);
            }
        }

        /// <summary>	
        /// <p>Removes the last axis-aligned clip from the render target. After this method is called, the clip is no longer applied to subsequent drawing operations. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>A <strong>PushAxisAlignedClip</strong>/<strong>PopAxisAlignedClip</strong> pair can occur around or within a <strong>PushLayer</strong>/<strong>PopLayer</strong> pair, but may not overlap. For example, a <strong>PushAxisAlignedClip</strong>, <strong>PushLayer</strong>, <strong>PopLayer</strong>, <strong>PopAxisAlignedClip</strong> sequence is valid, but a <strong>PushAxisAlignedClip</strong>, <strong>PushLayer</strong>, <strong>PopAxisAlignedClip</strong>, <strong>PopLayer</strong> sequence is not. </p><p><strong>PopAxisAlignedClip</strong> must be called once for every call to <strong>PushAxisAlignedClip</strong>.</p><p>For an example, see How to Clip with an Axis-Aligned Clip Rectangle.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>PopAxisAlignedClip</strong>) failed, check the result returned by the <strong><see cref="SharpDX.Direct2D1.RenderTarget.EndDraw"/></strong> or <strong><see cref="SharpDX.Direct2D1.RenderTarget.Flush"/></strong> methods. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::PopAxisAlignedClip']/*"/>	
        /// <msdn-id>dd316850</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::PopAxisAlignedClip()</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::PopAxisAlignedClip</unmanaged-short>	
        public void PopAxisAlignedClip()
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[46]);
            }
        }

        /// <summary>	
        /// <p>Clears the drawing area to the specified color. </p>	
        /// </summary>	
        /// <param name="clearColor"><dd>  <p>The color to which the drawing area is cleared, or <strong><c>null</c></strong> for transparent black.</p> </dd></param>	
        /// <remarks>	
        /// <p>Direct2D interprets the <em>clearColor</em> as straight alpha (not premultiplied).  If the render target's alpha mode is <strong><see cref="SharpDX.Direct2D1.AlphaMode.Ignore"/></strong>, the alpha channel of <em>clearColor</em> is ignored and replaced with 1.0f (fully opaque).</p><p>If the render target has an active clip (specified by <strong>PushAxisAlignedClip</strong>), the clear command is applied only to the area within the clip region.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::Clear']/*"/>	
        /// <msdn-id>dd371769</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::Clear([In, Optional] const D2D_COLOR_F* clearColor)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::Clear</unmanaged-short>	
        public void Clear(SharpDX.Mathematics.Interop.RawColor4? clearColor)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawColor4 clearColor_;
                if (clearColor.HasValue)
                    clearColor_ = clearColor.Value;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (clearColor.HasValue) ? &clearColor_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[47]);
            }
        }

        /// <summary>	
        /// <p>Initiates drawing on this render target. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Drawing operations can only be issued between a <strong>BeginDraw</strong> and <strong>EndDraw</strong> call.</p><p>BeginDraw and EndDraw are used to indicate that a render target is in use by the Direct2D system. Different implementations of <strong><see cref="SharpDX.Direct2D1.RenderTarget"/></strong> might behave differently when <strong>BeginDraw</strong> is called. An <strong><see cref="SharpDX.Direct2D1.BitmapRenderTarget"/></strong> may be locked between <strong>BeginDraw</strong>/<strong>EndDraw</strong> calls, a DXGI surface render target might be acquired on <strong>BeginDraw</strong> and released on <strong>EndDraw</strong>, while an <strong><see cref="SharpDX.Direct2D1.WindowRenderTarget"/></strong> may begin batching at <strong>BeginDraw</strong> and may present on <strong>EndDraw</strong>, for example.</p><p> The BeginDraw method must be called before rendering operations can be called, though state-setting and state-retrieval operations can be performed even outside of <strong>BeginDraw</strong>/<strong>EndDraw</strong>. </p><p>After <strong>BeginDraw</strong> is called, a render target will normally build up a batch of rendering commands, but defer processing of these commands until either an internal buffer is full, the <strong>Flush</strong> method is called, or until <strong>EndDraw</strong> is called. The <strong>EndDraw</strong> method causes any batched drawing operations to complete, and then returns an <see cref="SharpDX.Result"/> indicating the success of the operations and, optionally, the tag state of the render target at the time the error occurred. The <strong>EndDraw</strong> method always succeeds: it should not be called twice even if a previous <strong>EndDraw</strong> resulted in a failing <see cref="SharpDX.Result"/>. </p><p>If <strong>EndDraw</strong> is called without a matched call to <strong>BeginDraw</strong>, it returns an error indicating that <strong>BeginDraw</strong> must be called before <strong>EndDraw</strong>. Calling <strong>BeginDraw</strong> twice on a render target puts the target into an error state where nothing further is drawn, and returns an appropriate <see cref="SharpDX.Result"/> and error information when <strong>EndDraw</strong> is called.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::BeginDraw']/*"/>	
        /// <msdn-id>dd371768</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::BeginDraw()</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::BeginDraw</unmanaged-short>	
        public void BeginDraw()
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[48]);
            }
        }

        /// <summary>	
        /// <p>Ends drawing operations  on the render target and indicates the current error state and associated tags. </p>	
        /// </summary>	
        /// <param name="tag1"><dd>  <p>When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</p> </dd></param>	
        /// <param name="tag2"><dd>  <p>When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code and sets <em>tag1</em> and <em>tag2</em> to the tags that were active when the error occurred. </p></returns>	
        /// <remarks>	
        /// <p>Drawing operations can only be issued between a <strong>BeginDraw</strong> and <strong>EndDraw</strong> call.</p><p> <strong>BeginDraw</strong> and <strong>EndDraw</strong> are use to indicate that a render target is in use by the Direct2D system. Different implementations of <strong><see cref="SharpDX.Direct2D1.RenderTarget"/></strong> might behave differently when <strong>BeginDraw</strong> is called. An <strong><see cref="SharpDX.Direct2D1.BitmapRenderTarget"/></strong> may be locked between <strong>BeginDraw</strong>/<strong>EndDraw</strong> calls, a DXGI surface render target might be acquired on <strong>BeginDraw</strong> and released on <strong>EndDraw</strong>, while an <strong><see cref="SharpDX.Direct2D1.WindowRenderTarget"/></strong> may begin batching at <strong>BeginDraw</strong> and may present on <strong>EndDraw</strong>, for example.</p><p> The <strong>BeginDraw</strong> method must be called before rendering operations can be called, though state-setting and state-retrieval operations can be performed even outside of <strong>BeginDraw</strong>/<strong>EndDraw</strong>. </p><p>After <strong>BeginDraw</strong> is called, a render target will normally build up a batch of rendering commands, but defer processing of these commands until either an internal buffer is full, the <strong>Flush</strong> method is called, or until <strong>EndDraw</strong> is called. The <strong>EndDraw</strong> method causes any batched drawing operations to complete, and then returns an <strong><see cref="SharpDX.Result"/></strong> indicating the success of the operations and, optionally, the tag state of the render target at the time the error occurred. The <strong>EndDraw</strong> method always succeeds: it should not be called twice even if a previous <strong>EndDraw</strong> resulted in a failing <strong><see cref="SharpDX.Result"/></strong>. </p><p>If <strong>EndDraw</strong> is called without a matched call to <strong>BeginDraw</strong>, it returns an error indicating that <strong>BeginDraw</strong> must be called before <strong>EndDraw</strong>. Calling <strong>BeginDraw</strong> twice on a render target puts the target into an error state where nothing further is drawn, and returns an appropriate <strong><see cref="SharpDX.Result"/></strong> and error information when <strong>EndDraw</strong> is called.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::EndDraw']/*"/>	
        /// <msdn-id>dd371924</msdn-id>	
        /// <unmanaged>HRESULT ID2D1RenderTarget::EndDraw([Out, Optional] unsigned longlong* tag1,[Out, Optional] unsigned longlong* tag2)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::EndDraw</unmanaged-short>	
        public void EndDraw(out long tag1, out long tag2)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* tag1_ = &tag1)
                    fixed (void* tag2_ = &tag2)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, tag1_, tag2_, ((void**)(*(void**)_nativePointer))[49]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Retrieves the pixel format and alpha mode of the render target. </p>	
        /// </summary>	
        /// <returns><p>The pixel format and alpha mode of the render target.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetPixelFormat']/*"/>	
        /// <msdn-id>dd316814</msdn-id>	
        /// <unmanaged>D2D1_PIXEL_FORMAT ID2D1RenderTarget::GetPixelFormat()</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::GetPixelFormat</unmanaged-short>	
        internal SharpDX.Direct2D1.PixelFormat GetPixelFormat()
        {
            unsafe
            {
                SharpDX.Direct2D1.PixelFormat __result__;
                SharpDX.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, (void*)&__result__, ((void**)(*(void**)_nativePointer))[50]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets the dots per inch (DPI) of the render target. </p>	
        /// </summary>	
        /// <param name="dpiX"><dd>  <p>A value greater than or equal to zero that specifies the horizontal DPI of the render target.</p> </dd></param>	
        /// <param name="dpiY"><dd>  <p>A value greater than or equal to zero that specifies the vertical DPI of the render target.</p> </dd></param>	
        /// <remarks>	
        /// <p>This method specifies the mapping from pixel space to device-independent space  for the render target.  If both <em>dpiX</em> and <em>dpiY</em> are 0, the factory-read system DPI is chosen. If one parameter is zero and the other unspecified, the DPI is not changed.</p><p>For <strong><see cref="SharpDX.Direct2D1.WindowRenderTarget"/></strong>, the DPI defaults to the most recently factory-read system DPI. The default value for all other render targets is 96 DPI.  </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::SetDpi']/*"/>	
        /// <msdn-id>dd316887</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::SetDpi([In] float dpiX,[In] float dpiY)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::SetDpi</unmanaged-short>	
        internal void SetDpi(float dpiX, float dpiY)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, dpiX, dpiY, ((void**)(*(void**)_nativePointer))[51]);
            }
        }

        /// <summary>	
        /// <p>Return the render target's dots per inch (DPI).</p>	
        /// </summary>	
        /// <param name="dpiX"><dd>  <p>When this method returns, contains the horizontal DPI of the render target. This parameter is passed uninitialized.</p> </dd></param>	
        /// <param name="dpiY"><dd>  <p>When this method returns, contains the vertical DPI of the render target. This parameter is passed uninitialized.</p> </dd></param>	
        /// <remarks>	
        /// <p>This method indicates the mapping from pixel space to device-independent space  for the render target.  </p><p>For <strong><see cref="SharpDX.Direct2D1.WindowRenderTarget"/></strong>, the DPI defaults to the most recently factory-read system DPI. The default value for all other render targets is 96 DPI.  </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetDpi']/*"/>	
        /// <msdn-id>dd316809</msdn-id>	
        /// <unmanaged>void ID2D1RenderTarget::GetDpi([Out] float* dpiX,[Out] float* dpiY)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::GetDpi</unmanaged-short>	
        internal void GetDpi(out float dpiX, out float dpiY)
        {
            unsafe
            {
                fixed (void* dpiX_ = &dpiX)
                    fixed (void* dpiY_ = &dpiY)
                        SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, dpiX_, dpiY_, ((void**)(*(void**)_nativePointer))[52]);
            }
        }

        /// <summary>	
        /// <p>Returns the size of the render target in device-independent pixels.</p>	
        /// </summary>	
        /// <returns><p>The current size of the render target in device-independent pixels.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetSize']/*"/>	
        /// <msdn-id>dd316823</msdn-id>	
        /// <unmanaged>D2D_SIZE_F ID2D1RenderTarget::GetSize()</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::GetSize</unmanaged-short>	
        internal SharpDX.Size2F GetSize()
        {
            unsafe
            {
                SharpDX.Size2F __result__;
                SharpDX.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, (void*)&__result__, ((void**)(*(void**)_nativePointer))[53]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Returns the size of the render target in device pixels.</p>	
        /// </summary>	
        /// <returns><p>The size of the render target in device pixels.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetPixelSize']/*"/>	
        /// <msdn-id>dd316820</msdn-id>	
        /// <unmanaged>D2D_SIZE_U ID2D1RenderTarget::GetPixelSize()</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::GetPixelSize</unmanaged-short>	
        internal SharpDX.Size2 GetPixelSize()
        {
            unsafe
            {
                SharpDX.Size2 __result__;
                SharpDX.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, (void*)&__result__, ((void**)(*(void**)_nativePointer))[54]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the maximum size, in device-dependent units (pixels), of  any one bitmap dimension supported by the render target.</p>	
        /// </summary>	
        /// <returns><p> The maximum size, in pixels, of  any one bitmap dimension supported by the render target.</p></returns>	
        /// <remarks>	
        /// <p>This method returns the maximum texture size of the Direct3D device.</p><p><strong>Note</strong>??The software renderer and WARP devices return the value of 16 megapixels (16*1024*1024).  You can create a Direct2D texture that is this size, but not a Direct3D texture that is this size.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::GetMaximumBitmapSize']/*"/>	
        /// <msdn-id>dd742853</msdn-id>	
        /// <unmanaged>unsigned int ID2D1RenderTarget::GetMaximumBitmapSize()</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::GetMaximumBitmapSize</unmanaged-short>	
        internal int GetMaximumBitmapSize()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[55]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Indicates whether the render target supports the specified properties.</p>	
        /// </summary>	
        /// <param name="renderTargetProperties"><dd>  <p>The render target properties to test.</p> </dd></param>	
        /// <returns><p><strong>TRUE</strong> if the specified render target properties are supported by this render target; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>This method does not evaluate the DPI settings specified by the <em>renderTargetProperties</em> parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RenderTarget::IsSupported']/*"/>	
        /// <msdn-id>dd742854</msdn-id>	
        /// <unmanaged>BOOL ID2D1RenderTarget::IsSupported([In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties)</unmanaged>	
        /// <unmanaged-short>ID2D1RenderTarget::IsSupported</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool IsSupported(ref SharpDX.Direct2D1.RenderTargetProperties renderTargetProperties)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                fixed (void* renderTargetProperties_ = &renderTargetProperties)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, renderTargetProperties_, ((void**)(*(void**)_nativePointer))[56]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Represents a Direct2D drawing resource.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Resource']/*"/>	
    /// <msdn-id>dd316908</msdn-id>	
    /// <unmanaged>ID2D1Resource</unmanaged>	
    /// <unmanaged-short>ID2D1Resource</unmanaged-short>	
    [Guid("2cd90691-12e2-11dc-9fed-001143a055f9")]
    public partial class Resource : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.Resource"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Resource(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.Resource"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.Resource(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.Resource(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves the factory associated with this resource.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Resource::GetFactory']/*"/>	
        /// <msdn-id>dd316911</msdn-id>	
        /// <unmanaged>GetFactory</unmanaged>	
        /// <unmanaged-short>GetFactory</unmanaged-short>	
        /// <unmanaged>void ID2D1Resource::GetFactory([Out] ID2D1Factory** factory)</unmanaged>
        public SharpDX.Direct2D1.Factory Factory
        {
            get { SharpDX.Direct2D1.Factory __output__; GetFactory(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Retrieves the factory associated with this resource.</p>	
        /// </summary>	
        /// <param name="factory"><dd>  <p>When this method returns, contains a reference to a reference to the factory that created this resource. This parameter is passed uninitialized.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Resource::GetFactory']/*"/>	
        /// <msdn-id>dd316911</msdn-id>	
        /// <unmanaged>void ID2D1Resource::GetFactory([Out] ID2D1Factory** factory)</unmanaged>	
        /// <unmanaged-short>ID2D1Resource::GetFactory</unmanaged-short>	
        internal void GetFactory(out SharpDX.Direct2D1.Factory factory)
        {
            unsafe
            {
                IntPtr factory_ = IntPtr.Zero;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &factory_, ((void**)(*(void**)_nativePointer))[3]);
                factory = (factory_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.Factory(factory_);
            }
        }
    }
    /// <summary>	
    /// <p>Tracks a transform-created resource texture.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ResourceTexture']/*"/>	
    /// <msdn-id>hh446904</msdn-id>	
    /// <unmanaged>ID2D1ResourceTexture</unmanaged>	
    /// <unmanaged-short>ID2D1ResourceTexture</unmanaged-short>	
    [Guid("688d15c3-02b0-438d-b13a-d1b44c32c39a")]
    public partial class ResourceTexture : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.ResourceTexture"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ResourceTexture(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.ResourceTexture"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.ResourceTexture(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.ResourceTexture(nativePointer);
        }


        /// <summary>	
        /// <p>Updates the specific resource texture inside the specific range or box using the supplied data.</p>	
        /// </summary>	
        /// <param name="minimumExtents"><dd>  <p>The "left" extent of the updates if specified; if <strong><c>null</c></strong>, the entire texture is updated.</p> </dd></param>	
        /// <param name="maximimumExtents"><dd>  <p>The "right" extent of the updates if specified; if <strong><c>null</c></strong>, the entire texture is updated.</p> </dd></param>	
        /// <param name="strides"><dd>  <p>The stride to advance through the input data, according to dimension.</p> </dd></param>	
        /// <param name="dimensions"><dd>  <p>The number of dimensions in the resource texture. This must match the number used to load the texture.</p> </dd></param>	
        /// <param name="data"><dd>  <p>The data to be placed into the resource texture.</p> </dd></param>	
        /// <param name="dataCount"><dd>  <p>The size of the data buffer to be used to update the resource texture.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td> E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The number of dimensions in the update must match those of the created texture.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1ResourceTexture::Update']/*"/>	
        /// <msdn-id>hh446906</msdn-id>	
        /// <unmanaged>HRESULT ID2D1ResourceTexture::Update([In, Buffer, Optional] const unsigned int* minimumExtents,[In, Buffer, Optional] const unsigned int* maximimumExtents,[In, Buffer, Optional] const unsigned int* strides,[In] unsigned int dimensions,[In, Buffer] const unsigned char* data,[In] unsigned int dataCount)</unmanaged>	
        /// <unmanaged-short>ID2D1ResourceTexture::Update</unmanaged-short>	
        public void Update(int[] minimumExtents, int[] maximimumExtents, int[] strides, int dimensions, byte[] data, int dataCount)
        {
            unsafe
            {
                int[] minimumExtents__ = minimumExtents;
                int[] maximimumExtents__ = maximimumExtents;
                int[] strides__ = strides;
                SharpDX.Result __result__;
                fixed (void* minimumExtents_ = minimumExtents__)
                    fixed (void* maximimumExtents_ = maximimumExtents__)
                        fixed (void* strides_ = strides__)
                            fixed (void* data_ = data)
                                __result__ =
                                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, minimumExtents_, maximimumExtents_, strides_, dimensions, data_, dataCount, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Describes a rounded rectangle. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RoundedRectangleGeometry']/*"/>	
    /// <msdn-id>dd316914</msdn-id>	
    /// <unmanaged>ID2D1RoundedRectangleGeometry</unmanaged>	
    /// <unmanaged-short>ID2D1RoundedRectangleGeometry</unmanaged-short>	
    [Guid("2cd906a3-12e2-11dc-9fed-001143a055f9")]
    public partial class RoundedRectangleGeometry : SharpDX.Direct2D1.Geometry
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.RoundedRectangleGeometry"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RoundedRectangleGeometry(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.RoundedRectangleGeometry"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.RoundedRectangleGeometry(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.RoundedRectangleGeometry(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves a rounded rectangle that describes this rounded rectangle geometry. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RoundedRectangleGeometry::GetRoundedRect']/*"/>	
        /// <msdn-id>dd316917</msdn-id>	
        /// <unmanaged>GetRoundedRect</unmanaged>	
        /// <unmanaged-short>GetRoundedRect</unmanaged-short>	
        /// <unmanaged>void ID2D1RoundedRectangleGeometry::GetRoundedRect([Out] D2D1_ROUNDED_RECT* roundedRect)</unmanaged>
        public SharpDX.Direct2D1.RoundedRectangle RoundedRect
        {
            get { SharpDX.Direct2D1.RoundedRectangle __output__; GetRoundedRect(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Retrieves a rounded rectangle that describes this rounded rectangle geometry. </p>	
        /// </summary>	
        /// <param name="roundedRect"><dd>  <p>A reference that receives a rounded rectangle that describes this rounded rectangle geometry. You must allocate storage for this parameter. </p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1RoundedRectangleGeometry::GetRoundedRect']/*"/>	
        /// <msdn-id>dd316917</msdn-id>	
        /// <unmanaged>void ID2D1RoundedRectangleGeometry::GetRoundedRect([Out] D2D1_ROUNDED_RECT* roundedRect)</unmanaged>	
        /// <unmanaged-short>ID2D1RoundedRectangleGeometry::GetRoundedRect</unmanaged-short>	
        internal void GetRoundedRect(out SharpDX.Direct2D1.RoundedRectangle roundedRect)
        {
            unsafe
            {
                roundedRect = new SharpDX.Direct2D1.RoundedRectangle();
                fixed (void* roundedRect_ = &roundedRect)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, roundedRect_, ((void**)(*(void**)_nativePointer))[17]);
            }
        }
    }
    /// <summary>	
    /// <p> Describes a geometric path that does not contain quadratic bezier curves or arcs. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A geometry sink consists of one or more figures. Each figure is made up of one or more line or Bezier curve segments. To create a figure, call the <strong>BeginFigure</strong> method and specify the figure's start point, then use <strong>AddLines</strong> and <strong>AddBeziers</strong> to add line and Bezier segments. When you are finished adding segments, call the <strong>EndFigure</strong> method. You can repeat this sequence to create additional figures. When you are finished creating figures, call the <strong>Close</strong> method.</p><p>To create geometry paths that can contain arcs and quadratic Bezier curves, use an <strong><see cref="SharpDX.Direct2D1.GeometrySink"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink']/*"/>	
    /// <msdn-id>dd316919</msdn-id>	
    /// <unmanaged>ID2D1SimplifiedGeometrySink</unmanaged>	
    /// <unmanaged-short>ID2D1SimplifiedGeometrySink</unmanaged-short>	
    [Guid("2cd9069e-12e2-11dc-9fed-001143a055f9")]
    public partial interface SimplifiedGeometrySink : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p>Specifies the method used to determine which points are inside the geometry described by this geometry sink  and which points are outside.  </p>	
        /// </summary>	
        /// <param name="fillMode"><dd>  <p>The method used to determine whether a given point is part of the geometry.</p> </dd></param>	
        /// <remarks>	
        /// <p>The fill mode defaults to <see cref="SharpDX.Direct2D1.FillMode.Alternate"/>. To set the fill mode, call <strong>SetFillMode</strong> before the first call to <strong>BeginFigure</strong>. Not doing will put the geometry sink in an error state. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink::SetFillMode']/*"/>	
        /// <msdn-id>dd316937</msdn-id>	
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::SetFillMode([In] D2D1_FILL_MODE fillMode)</unmanaged>	
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::SetFillMode</unmanaged-short>	
        /* public void SetFillMode(SharpDX.Direct2D1.FillMode fillMode) */

        /// <summary>	
        /// <p>Specifies stroke and join options to be applied to new segments added to the geometry sink. </p>	
        /// </summary>	
        /// <param name="vertexFlags"><dd>  <p>Stroke and join options to be applied to new segments added to the geometry sink.</p> </dd></param>	
        /// <remarks>	
        /// <p>After this method is called, the specified segment flags are applied to each segment subsequently added to the sink. The segment flags are applied to every additional segment until this method is called again and a different set of segment flags is specified.     </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink::SetSegmentFlags']/*"/>	
        /// <msdn-id>dd316939</msdn-id>	
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::SetSegmentFlags([In] D2D1_PATH_SEGMENT vertexFlags)</unmanaged>	
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::SetSegmentFlags</unmanaged-short>	
        /* public void SetSegmentFlags(SharpDX.Direct2D1.PathSegment vertexFlags) */

        /// <summary>	
        /// <p>Starts a new figure at the specified point. </p>	
        /// </summary>	
        /// <param name="startPoint"><dd>  <p>The point at which to begin the new figure.</p> </dd></param>	
        /// <param name="figureBegin"><dd>  <p>Whether the new figure should be hollow or filled.</p> </dd></param>	
        /// <remarks>	
        /// <p>If this method is called while a figure is currently in progress, the interface is invalidated and all future methods will fail.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink::BeginFigure']/*"/>	
        /// <msdn-id>dd316929</msdn-id>	
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::BeginFigure([In] D2D_POINT_2F startPoint,[In] D2D1_FIGURE_BEGIN figureBegin)</unmanaged>	
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::BeginFigure</unmanaged-short>	
        /* public void BeginFigure(SharpDX.Mathematics.Interop.RawVector2 startPoint, SharpDX.Direct2D1.FigureBegin figureBegin) */

        /// <summary>	
        /// <p> Creates a sequence of lines using the specified points and adds them to the geometry sink.</p>	
        /// </summary>	
        /// <param name="ointsRef"><dd>  <p>A reference to an array of one or more points that describe the lines to draw. A line is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by <strong>BeginFigure</strong>) to the first point in the array. if the array contains additional points, a line is drawn from the first point to the second point in the array, from the second point to the third point, and so on.   </p> </dd></param>	
        /// <param name="pointsCount"><dd>  <p>The number of points in the <em>points</em> array.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink::AddLines']/*"/>	
        /// <msdn-id>dd316925</msdn-id>	
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::AddLines([In, Buffer] const D2D_POINT_2F* points,[In] unsigned int pointsCount)</unmanaged>	
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::AddLines</unmanaged-short>	
        /* public void AddLines(SharpDX.Mathematics.Interop.RawVector2[] ointsRef, int pointsCount) */

        /// <summary>	
        /// <p>Creates a sequence of cubic Bezier curves and adds them to the geometry sink. </p>	
        /// </summary>	
        /// <param name="beziers"><dd>  <p>A reference to an array of Bezier segments that describes the Bezier curves to create. A curve is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by <strong>BeginFigure</strong>) to the end point of the first Bezier segment in the array. if the array contains additional Bezier segments, each subsequent Bezier segment uses the end point of the preceding Bezier segment as its start point.</p> </dd></param>	
        /// <param name="beziersCount"><dd>  <p>The number of Bezier segments in the <em>beziers</em> array.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink::AddBeziers']/*"/>	
        /// <msdn-id>dd316922</msdn-id>	
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::AddBeziers([In, Buffer] const D2D1_BEZIER_SEGMENT* beziers,[In] unsigned int beziersCount)</unmanaged>	
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::AddBeziers</unmanaged-short>	
        /* public void AddBeziers(SharpDX.Direct2D1.BezierSegment[] beziers, int beziersCount) */

        /// <summary>	
        /// <p> Ends the current figure; optionally, closes it.</p>	
        /// </summary>	
        /// <param name="figureEnd"><dd>  <p>A value that indicates whether the current figure is closed. If the figure is closed, a line is drawn between the current point and the start point specified by <strong>BeginFigure</strong>.</p> </dd></param>	
        /// <remarks>	
        /// <p>Calling this method without a matching call to <strong>BeginFigure</strong> places the geometry sink in an error state; subsequent calls are ignored, and the overall failure will be returned when the <strong>Close</strong> method is called.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink::EndFigure']/*"/>	
        /// <msdn-id>dd316934</msdn-id>	
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::EndFigure([In] D2D1_FIGURE_END figureEnd)</unmanaged>	
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::EndFigure</unmanaged-short>	
        /* public void EndFigure(SharpDX.Direct2D1.FigureEnd figureEnd) */

        /// <summary>	
        /// <p>Closes the geometry sink, indicates whether it is in an error state, and resets the sink's error state. </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Do not close the geometry sink while a figure is still in progress; doing so puts the geometry sink in an error state. For the close operation to be successful, there must be one <strong>EndFigure</strong> call for each call to <strong>BeginFigure</strong>.</p><p>After calling this method, the geometry sink might not be usable. Direct2D implementations of this interface do not allow the geometry sink to be modified after it is closed, but other implementations might not impose this restriction.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink::Close']/*"/>	
        /// <msdn-id>dd316932</msdn-id>	
        /// <unmanaged>HRESULT ID2D1SimplifiedGeometrySink::Close()</unmanaged>	
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::Close</unmanaged-short>	
        /* public void Close() */
    }
    /// <summary>	
    /// <p> Describes a geometric path that does not contain quadratic bezier curves or arcs. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A geometry sink consists of one or more figures. Each figure is made up of one or more line or Bezier curve segments. To create a figure, call the <strong>BeginFigure</strong> method and specify the figure's start point, then use <strong>AddLines</strong> and <strong>AddBeziers</strong> to add line and Bezier segments. When you are finished adding segments, call the <strong>EndFigure</strong> method. You can repeat this sequence to create additional figures. When you are finished creating figures, call the <strong>Close</strong> method.</p><p>To create geometry paths that can contain arcs and quadratic Bezier curves, use an <strong><see cref="SharpDX.Direct2D1.GeometrySink"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink']/*"/>	
    /// <msdn-id>dd316919</msdn-id>	
    /// <unmanaged>ID2D1SimplifiedGeometrySink</unmanaged>	
    /// <unmanaged-short>ID2D1SimplifiedGeometrySink</unmanaged-short>	
    [Guid("2cd9069e-12e2-11dc-9fed-001143a055f9")]
    internal partial class SimplifiedGeometrySinkNative : SharpDX.ComObjectCallback, SharpDX.Direct2D1.SimplifiedGeometrySink
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.SimplifiedGeometrySinkNative"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SimplifiedGeometrySinkNative(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.SimplifiedGeometrySinkNative"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.SimplifiedGeometrySinkNative(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.SimplifiedGeometrySinkNative(nativePointer);
        }


        /// <summary>	
        /// <p>Specifies the method used to determine which points are inside the geometry described by this geometry sink  and which points are outside.  </p>	
        /// </summary>	
        /// <param name="fillMode"><dd>  <p>The method used to determine whether a given point is part of the geometry.</p> </dd></param>	
        /// <remarks>	
        /// <p>The fill mode defaults to <see cref="SharpDX.Direct2D1.FillMode.Alternate"/>. To set the fill mode, call <strong>SetFillMode</strong> before the first call to <strong>BeginFigure</strong>. Not doing will put the geometry sink in an error state. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink::SetFillMode']/*"/>	
        /// <msdn-id>dd316937</msdn-id>	
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::SetFillMode([In] D2D1_FILL_MODE fillMode)</unmanaged>	
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::SetFillMode</unmanaged-short>	
        internal void SetFillMode_(SharpDX.Direct2D1.FillMode fillMode)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)fillMode), ((void**)(*(void**)_nativePointer))[3]);
            }
        }

        /// <summary>	
        /// <p>Specifies stroke and join options to be applied to new segments added to the geometry sink. </p>	
        /// </summary>	
        /// <param name="vertexFlags"><dd>  <p>Stroke and join options to be applied to new segments added to the geometry sink.</p> </dd></param>	
        /// <remarks>	
        /// <p>After this method is called, the specified segment flags are applied to each segment subsequently added to the sink. The segment flags are applied to every additional segment until this method is called again and a different set of segment flags is specified.     </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink::SetSegmentFlags']/*"/>	
        /// <msdn-id>dd316939</msdn-id>	
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::SetSegmentFlags([In] D2D1_PATH_SEGMENT vertexFlags)</unmanaged>	
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::SetSegmentFlags</unmanaged-short>	
        internal void SetSegmentFlags_(SharpDX.Direct2D1.PathSegment vertexFlags)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)vertexFlags), ((void**)(*(void**)_nativePointer))[4]);
            }
        }

        /// <summary>	
        /// <p>Starts a new figure at the specified point. </p>	
        /// </summary>	
        /// <param name="startPoint"><dd>  <p>The point at which to begin the new figure.</p> </dd></param>	
        /// <param name="figureBegin"><dd>  <p>Whether the new figure should be hollow or filled.</p> </dd></param>	
        /// <remarks>	
        /// <p>If this method is called while a figure is currently in progress, the interface is invalidated and all future methods will fail.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink::BeginFigure']/*"/>	
        /// <msdn-id>dd316929</msdn-id>	
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::BeginFigure([In] D2D_POINT_2F startPoint,[In] D2D1_FIGURE_BEGIN figureBegin)</unmanaged>	
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::BeginFigure</unmanaged-short>	
        internal void BeginFigure_(SharpDX.Mathematics.Interop.RawVector2 startPoint, SharpDX.Direct2D1.FigureBegin figureBegin)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid14(_nativePointer, startPoint, unchecked((int)figureBegin), ((void**)(*(void**)_nativePointer))[5]);
            }
        }

        /// <summary>	
        /// <p> Creates a sequence of lines using the specified points and adds them to the geometry sink.</p>	
        /// </summary>	
        /// <param name="ointsRef"><dd>  <p>A reference to an array of one or more points that describe the lines to draw. A line is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by <strong>BeginFigure</strong>) to the first point in the array. if the array contains additional points, a line is drawn from the first point to the second point in the array, from the second point to the third point, and so on.   </p> </dd></param>	
        /// <param name="pointsCount"><dd>  <p>The number of points in the <em>points</em> array.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink::AddLines']/*"/>	
        /// <msdn-id>dd316925</msdn-id>	
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::AddLines([In, Buffer] const D2D_POINT_2F* points,[In] unsigned int pointsCount)</unmanaged>	
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::AddLines</unmanaged-short>	
        internal void AddLines_(SharpDX.Mathematics.Interop.RawVector2[] ointsRef, int pointsCount)
        {
            unsafe
            {
                fixed (void* ointsRef_ = ointsRef)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, ointsRef_, pointsCount, ((void**)(*(void**)_nativePointer))[6]);
            }
        }

        /// <summary>	
        /// <p>Creates a sequence of cubic Bezier curves and adds them to the geometry sink. </p>	
        /// </summary>	
        /// <param name="beziers"><dd>  <p>A reference to an array of Bezier segments that describes the Bezier curves to create. A curve is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by <strong>BeginFigure</strong>) to the end point of the first Bezier segment in the array. if the array contains additional Bezier segments, each subsequent Bezier segment uses the end point of the preceding Bezier segment as its start point.</p> </dd></param>	
        /// <param name="beziersCount"><dd>  <p>The number of Bezier segments in the <em>beziers</em> array.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink::AddBeziers']/*"/>	
        /// <msdn-id>dd316922</msdn-id>	
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::AddBeziers([In, Buffer] const D2D1_BEZIER_SEGMENT* beziers,[In] unsigned int beziersCount)</unmanaged>	
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::AddBeziers</unmanaged-short>	
        internal void AddBeziers_(SharpDX.Direct2D1.BezierSegment[] beziers, int beziersCount)
        {
            unsafe
            {
                fixed (void* beziers_ = beziers)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, beziers_, beziersCount, ((void**)(*(void**)_nativePointer))[7]);
            }
        }

        /// <summary>	
        /// <p> Ends the current figure; optionally, closes it.</p>	
        /// </summary>	
        /// <param name="figureEnd"><dd>  <p>A value that indicates whether the current figure is closed. If the figure is closed, a line is drawn between the current point and the start point specified by <strong>BeginFigure</strong>.</p> </dd></param>	
        /// <remarks>	
        /// <p>Calling this method without a matching call to <strong>BeginFigure</strong> places the geometry sink in an error state; subsequent calls are ignored, and the overall failure will be returned when the <strong>Close</strong> method is called.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink::EndFigure']/*"/>	
        /// <msdn-id>dd316934</msdn-id>	
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::EndFigure([In] D2D1_FIGURE_END figureEnd)</unmanaged>	
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::EndFigure</unmanaged-short>	
        internal void EndFigure_(SharpDX.Direct2D1.FigureEnd figureEnd)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, unchecked((int)figureEnd), ((void**)(*(void**)_nativePointer))[8]);
            }
        }

        /// <summary>	
        /// <p>Closes the geometry sink, indicates whether it is in an error state, and resets the sink's error state. </p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Do not close the geometry sink while a figure is still in progress; doing so puts the geometry sink in an error state. For the close operation to be successful, there must be one <strong>EndFigure</strong> call for each call to <strong>BeginFigure</strong>.</p><p>After calling this method, the geometry sink might not be usable. Direct2D implementations of this interface do not allow the geometry sink to be modified after it is closed, but other implementations might not impose this restriction.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SimplifiedGeometrySink::Close']/*"/>	
        /// <msdn-id>dd316932</msdn-id>	
        /// <unmanaged>HRESULT ID2D1SimplifiedGeometrySink::Close()</unmanaged>	
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::Close</unmanaged-short>	
        internal void Close_()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Paints an area with a solid color. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SolidColorBrush']/*"/>	
    /// <msdn-id>dd372207</msdn-id>	
    /// <unmanaged>ID2D1SolidColorBrush</unmanaged>	
    /// <unmanaged-short>ID2D1SolidColorBrush</unmanaged-short>	
    [Guid("2cd906a9-12e2-11dc-9fed-001143a055f9")]
    public partial class SolidColorBrush : SharpDX.Direct2D1.Brush
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.SolidColorBrush"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SolidColorBrush(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.SolidColorBrush"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.SolidColorBrush(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.SolidColorBrush(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves or sets the color of the solid color brush.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SolidColorBrush::GetColor']/*"/>	
        /// <msdn-id>dd372209</msdn-id>	
        /// <unmanaged>GetColor / SetColor</unmanaged>	
        /// <unmanaged-short>GetColor</unmanaged-short>	
        /// <unmanaged>D2D_COLOR_F ID2D1SolidColorBrush::GetColor()</unmanaged>
        public SharpDX.Mathematics.Interop.RawColor4 Color
        {
            get { return GetColor(); }
            set { SetColor(value); }
        }

        /// <summary>	
        /// <p> Specifies the color of this solid-color brush. </p>	
        /// </summary>	
        /// <param name="color"><dd>  <p>The color of this solid-color brush.</p> </dd></param>	
        /// <remarks>	
        /// <p>To help create colors, Direct2D provides the <strong>ColorF</strong> class. It offers several helper methods for creating colors and provides a set or predefined colors. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SolidColorBrush::SetColor']/*"/>	
        /// <msdn-id>dd372215</msdn-id>	
        /// <unmanaged>void ID2D1SolidColorBrush::SetColor([In] const D2D_COLOR_F* color)</unmanaged>	
        /// <unmanaged-short>ID2D1SolidColorBrush::SetColor</unmanaged-short>	
        internal void SetColor(SharpDX.Mathematics.Interop.RawColor4 color)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &color, ((void**)(*(void**)_nativePointer))[8]);
            }
        }

        /// <summary>	
        /// <p> Retrieves the color of the solid color brush.</p>	
        /// </summary>	
        /// <returns><p>The color of this solid color brush.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SolidColorBrush::GetColor']/*"/>	
        /// <msdn-id>dd372209</msdn-id>	
        /// <unmanaged>D2D_COLOR_F ID2D1SolidColorBrush::GetColor()</unmanaged>	
        /// <unmanaged-short>ID2D1SolidColorBrush::GetColor</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawColor4 GetColor()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawColor4 __result__;
                SharpDX.Direct2D1.LocalInterop.CallivoidPtr(_nativePointer, (void*)&__result__, ((void**)(*(void**)_nativePointer))[9]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Represents a CPU-based rasterization stage in the transform  pipeline graph.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong><see cref="SharpDX.Direct2D1.SourceTransform"/></strong> specializes an implementation of the Shantzis calculations to a transform implemented as the source of an effect graph with the data being provided from sytem memory.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SourceTransform']/*"/>	
    /// <msdn-id>hh446908</msdn-id>	
    /// <unmanaged>ID2D1SourceTransform</unmanaged>	
    /// <unmanaged-short>ID2D1SourceTransform</unmanaged-short>	
    [Guid("db1800dd-0c34-4cf9-be90-31cc0a5653e1")]
    public partial interface SourceTransform : SharpDX.Direct2D1.Transform
    {


        /// <summary>	
        /// <p>Sets the render information for the transform.</p>	
        /// </summary>	
        /// <param name="renderInfo"><dd>  <p>The interface supplied to the transform to allow specifying the CPU based transform pass.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Provides a render information interface to the source transform to allow it to specify state to the rendering system.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SourceTransform::SetRenderInfo']/*"/>	
        /// <msdn-id>hh446912</msdn-id>	
        /// <unmanaged>HRESULT ID2D1SourceTransform::SetRenderInfo([In] ID2D1RenderInfo* renderInfo)</unmanaged>	
        /// <unmanaged-short>ID2D1SourceTransform::SetRenderInfo</unmanaged-short>	
        /* public void SetRenderInfo(SharpDX.Direct2D1.RenderInformation renderInfo) */

        /// <summary>	
        /// <p>Draws the transform to the graphics processing unit (GPU)?based Direct2D pipeline.</p>	
        /// </summary>	
        /// <param name="target"><dd>  <p>The target to which the transform should be written.</p> </dd></param>	
        /// <param name="drawRect"><dd>  <p>The area within the source from which the image should be drawn.</p> </dd></param>	
        /// <param name="targetOrigin"><dd>  <p>The origin within the target bitmap to which the source data should be drawn.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The implementation of the rasterizer guarantees that adding the <em>renderRect</em> to the <em>targetOrigin</em> does not exceed the bounds of the bitmap.</p><p>When implementing this method you must update the bitmap in this way: </p><ol> <li>Call the <strong>ID2D1Bitmap::Map</strong> method with the  <see cref="SharpDX.Direct2D1.MapOptions.Discard"/> and <see cref="SharpDX.Direct2D1.MapOptions.Write"/>	
        /// flags.</li> <li>Update the buffer this method returns.</li> <li>Call the <strong>ID2D1Bitmap::Unmap</strong> method.</li> </ol><p>If you  set the buffer precision manually on the associated <strong><see cref="SharpDX.Direct2D1.RenderInformation"/></strong> object, it must handle different pixel formats in this method by calling <strong><see cref="SharpDX.Direct2D1.Bitmap.GetPixelFormat"/></strong>.  If you set the buffer precision manually, then you can rely on that format always being the one you provided.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SourceTransform::Draw']/*"/>	
        /// <msdn-id>hh446910</msdn-id>	
        /// <unmanaged>HRESULT ID2D1SourceTransform::Draw([In] ID2D1Bitmap1* target,[In] const RECT* drawRect,[In] D2D_POINT_2U targetOrigin)</unmanaged>	
        /// <unmanaged-short>ID2D1SourceTransform::Draw</unmanaged-short>	
        /* public void Draw(SharpDX.Direct2D1.Bitmap1 target, SharpDX.Mathematics.Interop.RawRectangle drawRect, SharpDX.Mathematics.Interop.RawPoint targetOrigin) */
    }
    /// <summary>	
    /// <p>Represents a CPU-based rasterization stage in the transform  pipeline graph.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong><see cref="SharpDX.Direct2D1.SourceTransform"/></strong> specializes an implementation of the Shantzis calculations to a transform implemented as the source of an effect graph with the data being provided from sytem memory.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SourceTransform']/*"/>	
    /// <msdn-id>hh446908</msdn-id>	
    /// <unmanaged>ID2D1SourceTransform</unmanaged>	
    /// <unmanaged-short>ID2D1SourceTransform</unmanaged-short>	
    [Guid("db1800dd-0c34-4cf9-be90-31cc0a5653e1")]
    public partial class SourceTransformNative : SharpDX.Direct2D1.TransformNative, SharpDX.Direct2D1.SourceTransform
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.SourceTransformNative"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SourceTransformNative(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.SourceTransformNative"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.SourceTransformNative(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.SourceTransformNative(nativePointer);
        }


        /// <summary>	
        /// <p>Sets the render information for the transform.</p>	
        /// </summary>	
        /// <param name="renderInfo"><dd>  <p>The interface supplied to the transform to allow specifying the CPU based transform pass.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Provides a render information interface to the source transform to allow it to specify state to the rendering system.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SourceTransform::SetRenderInfo']/*"/>	
        /// <msdn-id>hh446912</msdn-id>	
        /// <unmanaged>HRESULT ID2D1SourceTransform::SetRenderInfo([In] ID2D1RenderInfo* renderInfo)</unmanaged>	
        /// <unmanaged-short>ID2D1SourceTransform::SetRenderInfo</unmanaged-short>	
        internal void SetRenderInfo_(SharpDX.Direct2D1.RenderInformation renderInfo)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((renderInfo == null) ? IntPtr.Zero : renderInfo.NativePointer), ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Draws the transform to the graphics processing unit (GPU)?based Direct2D pipeline.</p>	
        /// </summary>	
        /// <param name="target"><dd>  <p>The target to which the transform should be written.</p> </dd></param>	
        /// <param name="drawRect"><dd>  <p>The area within the source from which the image should be drawn.</p> </dd></param>	
        /// <param name="targetOrigin"><dd>  <p>The origin within the target bitmap to which the source data should be drawn.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The implementation of the rasterizer guarantees that adding the <em>renderRect</em> to the <em>targetOrigin</em> does not exceed the bounds of the bitmap.</p><p>When implementing this method you must update the bitmap in this way: </p><ol> <li>Call the <strong>ID2D1Bitmap::Map</strong> method with the  <see cref="SharpDX.Direct2D1.MapOptions.Discard"/> and <see cref="SharpDX.Direct2D1.MapOptions.Write"/>	
        /// flags.</li> <li>Update the buffer this method returns.</li> <li>Call the <strong>ID2D1Bitmap::Unmap</strong> method.</li> </ol><p>If you  set the buffer precision manually on the associated <strong><see cref="SharpDX.Direct2D1.RenderInformation"/></strong> object, it must handle different pixel formats in this method by calling <strong><see cref="SharpDX.Direct2D1.Bitmap.GetPixelFormat"/></strong>.  If you set the buffer precision manually, then you can rely on that format always being the one you provided.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1SourceTransform::Draw']/*"/>	
        /// <msdn-id>hh446910</msdn-id>	
        /// <unmanaged>HRESULT ID2D1SourceTransform::Draw([In] ID2D1Bitmap1* target,[In] const RECT* drawRect,[In] D2D_POINT_2U targetOrigin)</unmanaged>	
        /// <unmanaged-short>ID2D1SourceTransform::Draw</unmanaged-short>	
        internal void Draw_(SharpDX.Direct2D1.Bitmap1 target, SharpDX.Mathematics.Interop.RawRectangle drawRect, SharpDX.Mathematics.Interop.RawPoint targetOrigin)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint121(_nativePointer, (void*)((target == null) ? IntPtr.Zero : target.NativePointer), &drawRect, targetOrigin, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Describes the caps, miter limit, line join, and dash information for a stroke.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle']/*"/>	
    /// <msdn-id>dd372217</msdn-id>	
    /// <unmanaged>ID2D1StrokeStyle</unmanaged>	
    /// <unmanaged-short>ID2D1StrokeStyle</unmanaged-short>	
    [Guid("2cd9069d-12e2-11dc-9fed-001143a055f9")]
    public partial class StrokeStyle : SharpDX.Direct2D1.Resource
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.StrokeStyle"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public StrokeStyle(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.StrokeStyle"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.StrokeStyle(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.StrokeStyle(nativePointer);
        }


        /// <summary>	
        /// <p> Retrieves the type of shape used at the beginning of a stroke.  </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetStartCap']/*"/>	
        /// <msdn-id>dd372244</msdn-id>	
        /// <unmanaged>GetStartCap</unmanaged>	
        /// <unmanaged-short>GetStartCap</unmanaged-short>	
        /// <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetStartCap()</unmanaged>
        public SharpDX.Direct2D1.CapStyle StartCap
        {
            get { return GetStartCap(); }
        }

        /// <summary>	
        /// <p>Retrieves the type of shape used at the end of a stroke. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetEndCap']/*"/>	
        /// <msdn-id>dd372238</msdn-id>	
        /// <unmanaged>GetEndCap</unmanaged>	
        /// <unmanaged-short>GetEndCap</unmanaged-short>	
        /// <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetEndCap()</unmanaged>
        public SharpDX.Direct2D1.CapStyle EndCap
        {
            get { return GetEndCap(); }
        }

        /// <summary>	
        /// <p>Gets a value that specifies how the ends of each dash are drawn. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetDashCap']/*"/>	
        /// <msdn-id>dd372218</msdn-id>	
        /// <unmanaged>GetDashCap</unmanaged>	
        /// <unmanaged-short>GetDashCap</unmanaged-short>	
        /// <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetDashCap()</unmanaged>
        public SharpDX.Direct2D1.CapStyle DashCap
        {
            get { return GetDashCap(); }
        }

        /// <summary>	
        /// <p>Retrieves the limit on the ratio of the miter length to half the stroke's thickness. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetMiterLimit']/*"/>	
        /// <msdn-id>dd372242</msdn-id>	
        /// <unmanaged>GetMiterLimit</unmanaged>	
        /// <unmanaged-short>GetMiterLimit</unmanaged-short>	
        /// <unmanaged>float ID2D1StrokeStyle::GetMiterLimit()</unmanaged>
        public float MiterLimit
        {
            get { return GetMiterLimit(); }
        }

        /// <summary>	
        /// <p>Retrieves the type of joint used at the vertices of a shape's outline.  </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetLineJoin']/*"/>	
        /// <msdn-id>dd372240</msdn-id>	
        /// <unmanaged>GetLineJoin</unmanaged>	
        /// <unmanaged-short>GetLineJoin</unmanaged-short>	
        /// <unmanaged>D2D1_LINE_JOIN ID2D1StrokeStyle::GetLineJoin()</unmanaged>
        public SharpDX.Direct2D1.LineJoin LineJoin
        {
            get { return GetLineJoin(); }
        }

        /// <summary>	
        /// <p>Retrieves a value that specifies how far in the dash sequence the stroke will start.  </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetDashOffset']/*"/>	
        /// <msdn-id>dd372234</msdn-id>	
        /// <unmanaged>GetDashOffset</unmanaged>	
        /// <unmanaged-short>GetDashOffset</unmanaged-short>	
        /// <unmanaged>float ID2D1StrokeStyle::GetDashOffset()</unmanaged>
        public float DashOffset
        {
            get { return GetDashOffset(); }
        }

        /// <summary>	
        /// <p>Gets a value that describes the stroke's dash pattern. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If a custom dash style is specified, the dash pattern is described by the dashes array, which can be retrieved by calling the <strong>GetDashes</strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetDashStyle']/*"/>	
        /// <msdn-id>dd372236</msdn-id>	
        /// <unmanaged>GetDashStyle</unmanaged>	
        /// <unmanaged-short>GetDashStyle</unmanaged-short>	
        /// <unmanaged>D2D1_DASH_STYLE ID2D1StrokeStyle::GetDashStyle()</unmanaged>
        public SharpDX.Direct2D1.DashStyle DashStyle
        {
            get { return GetDashStyle(); }
        }

        /// <summary>	
        /// <p>Retrieves the number of entries in the dashes array. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetDashesCount']/*"/>	
        /// <msdn-id>dd372232</msdn-id>	
        /// <unmanaged>GetDashesCount</unmanaged>	
        /// <unmanaged-short>GetDashesCount</unmanaged-short>	
        /// <unmanaged>unsigned int ID2D1StrokeStyle::GetDashesCount()</unmanaged>
        public int DashesCount
        {
            get { return GetDashesCount(); }
        }

        /// <summary>	
        /// <p> Retrieves the type of shape used at the beginning of a stroke.  </p>	
        /// </summary>	
        /// <returns><p>The type of shape used at the beginning of a stroke.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetStartCap']/*"/>	
        /// <msdn-id>dd372244</msdn-id>	
        /// <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetStartCap()</unmanaged>	
        /// <unmanaged-short>ID2D1StrokeStyle::GetStartCap</unmanaged-short>	
        internal SharpDX.Direct2D1.CapStyle GetStartCap()
        {
            unsafe
            {
                SharpDX.Direct2D1.CapStyle __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1CapStyle(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Retrieves the type of shape used at the end of a stroke. </p>	
        /// </summary>	
        /// <returns><p>The type of shape used at the end of a stroke.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetEndCap']/*"/>	
        /// <msdn-id>dd372238</msdn-id>	
        /// <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetEndCap()</unmanaged>	
        /// <unmanaged-short>ID2D1StrokeStyle::GetEndCap</unmanaged-short>	
        internal SharpDX.Direct2D1.CapStyle GetEndCap()
        {
            unsafe
            {
                SharpDX.Direct2D1.CapStyle __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1CapStyle(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets a value that specifies how the ends of each dash are drawn. </p>	
        /// </summary>	
        /// <returns><p>A value that specifies how the ends of each dash are drawn.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetDashCap']/*"/>	
        /// <msdn-id>dd372218</msdn-id>	
        /// <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetDashCap()</unmanaged>	
        /// <unmanaged-short>ID2D1StrokeStyle::GetDashCap</unmanaged-short>	
        internal SharpDX.Direct2D1.CapStyle GetDashCap()
        {
            unsafe
            {
                SharpDX.Direct2D1.CapStyle __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1CapStyle(_nativePointer, ((void**)(*(void**)_nativePointer))[6]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Retrieves the limit on the ratio of the miter length to half the stroke's thickness. </p>	
        /// </summary>	
        /// <returns><p>A positive number greater than or equal to 1.0f that describes the limit on the ratio of the miter length to half the stroke's thickness.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetMiterLimit']/*"/>	
        /// <msdn-id>dd372242</msdn-id>	
        /// <unmanaged>float ID2D1StrokeStyle::GetMiterLimit()</unmanaged>	
        /// <unmanaged-short>ID2D1StrokeStyle::GetMiterLimit</unmanaged-short>	
        internal float GetMiterLimit()
        {
            unsafe
            {
                float __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callifloat(_nativePointer, ((void**)(*(void**)_nativePointer))[7]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Retrieves the type of joint used at the vertices of a shape's outline.  </p>	
        /// </summary>	
        /// <returns><p>A value that specifies the type of joint used at the vertices of a shape's outline.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetLineJoin']/*"/>	
        /// <msdn-id>dd372240</msdn-id>	
        /// <unmanaged>D2D1_LINE_JOIN ID2D1StrokeStyle::GetLineJoin()</unmanaged>	
        /// <unmanaged-short>ID2D1StrokeStyle::GetLineJoin</unmanaged-short>	
        internal SharpDX.Direct2D1.LineJoin GetLineJoin()
        {
            unsafe
            {
                SharpDX.Direct2D1.LineJoin __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1LineJoin(_nativePointer, ((void**)(*(void**)_nativePointer))[8]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Retrieves a value that specifies how far in the dash sequence the stroke will start.  </p>	
        /// </summary>	
        /// <returns><p>A value that specifies how far in the dash sequence the stroke will start. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetDashOffset']/*"/>	
        /// <msdn-id>dd372234</msdn-id>	
        /// <unmanaged>float ID2D1StrokeStyle::GetDashOffset()</unmanaged>	
        /// <unmanaged-short>ID2D1StrokeStyle::GetDashOffset</unmanaged-short>	
        internal float GetDashOffset()
        {
            unsafe
            {
                float __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callifloat(_nativePointer, ((void**)(*(void**)_nativePointer))[9]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets a value that describes the stroke's dash pattern. </p>	
        /// </summary>	
        /// <returns><p>A value that describes the predefined dash pattern used, or <strong><see cref="SharpDX.Direct2D1.DashStyle.Custom"/></strong> if a custom dash style is used.</p></returns>	
        /// <remarks>	
        /// <p>If a custom dash style is specified, the dash pattern is described by the dashes array, which can be retrieved by calling the <strong>GetDashes</strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetDashStyle']/*"/>	
        /// <msdn-id>dd372236</msdn-id>	
        /// <unmanaged>D2D1_DASH_STYLE ID2D1StrokeStyle::GetDashStyle()</unmanaged>	
        /// <unmanaged-short>ID2D1StrokeStyle::GetDashStyle</unmanaged-short>	
        internal SharpDX.Direct2D1.DashStyle GetDashStyle()
        {
            unsafe
            {
                SharpDX.Direct2D1.DashStyle __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1DashStyle(_nativePointer, ((void**)(*(void**)_nativePointer))[10]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Retrieves the number of entries in the dashes array. </p>	
        /// </summary>	
        /// <returns><p>The number of entries in the dashes array if the stroke is dashed; otherwise, 0.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetDashesCount']/*"/>	
        /// <msdn-id>dd372232</msdn-id>	
        /// <unmanaged>unsigned int ID2D1StrokeStyle::GetDashesCount()</unmanaged>	
        /// <unmanaged-short>ID2D1StrokeStyle::GetDashesCount</unmanaged-short>	
        internal int GetDashesCount()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[11]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Copies the dash pattern to the specified array. </p>	
        /// </summary>	
        /// <param name="dashes"><dd>  <p>A reference to an array that will receive the dash pattern. The array must be able to contain at least as many elements as specified by <em>dashesCount</em>. You must allocate storage for this array.</p> </dd></param>	
        /// <param name="dashesCount"><dd>  <p>The number of dashes to copy. If this value is less than the number of dashes in the stroke style's dashes array, the returned dashes are truncated to <em>dashesCount</em>. If this value is greater than the number of dashes in the stroke style's dashes array, the extra dashes are set to 0.0f. To obtain the actual number of dashes in the stroke style's dashes array, use the <strong>GetDashesCount</strong> method. </p> </dd></param>	
        /// <remarks>	
        /// <p>The dashes are specified in units that are a multiple of the stroke width, with subsequent members of the array indicating the dashes and gaps between dashes: the first entry indicates a filled dash, the second a gap, and so on. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle::GetDashes']/*"/>	
        /// <msdn-id>dd372230</msdn-id>	
        /// <unmanaged>void ID2D1StrokeStyle::GetDashes([Out, Buffer] float* dashes,[In] unsigned int dashesCount)</unmanaged>	
        /// <unmanaged-short>ID2D1StrokeStyle::GetDashes</unmanaged-short>	
        public void GetDashes(float[] dashes, int dashesCount)
        {
            unsafe
            {
                fixed (void* dashes_ = dashes)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, dashes_, dashesCount, ((void**)(*(void**)_nativePointer))[12]);
            }
        }
    }
    /// <summary>	
    /// <p>Describes the caps, miter limit, line join, and dash information for a stroke.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface adds functionality to <strong><see cref="SharpDX.Direct2D1.StrokeStyle"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle1']/*"/>	
    /// <msdn-id>hh446914</msdn-id>	
    /// <unmanaged>ID2D1StrokeStyle1</unmanaged>	
    /// <unmanaged-short>ID2D1StrokeStyle1</unmanaged-short>	
    [Guid("10a72a66-e91c-43f4-993f-ddf4b82b0b4a")]
    public partial class StrokeStyle1 : SharpDX.Direct2D1.StrokeStyle
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.StrokeStyle1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public StrokeStyle1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.StrokeStyle1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.StrokeStyle1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.StrokeStyle1(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the stroke transform type.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle1::GetStrokeTransformType']/*"/>	
        /// <msdn-id>hh446916</msdn-id>	
        /// <unmanaged>GetStrokeTransformType</unmanaged>	
        /// <unmanaged-short>GetStrokeTransformType</unmanaged-short>	
        /// <unmanaged>D2D1_STROKE_TRANSFORM_TYPE ID2D1StrokeStyle1::GetStrokeTransformType()</unmanaged>
        public SharpDX.Direct2D1.StrokeTransformType StrokeTransformType
        {
            get { return GetStrokeTransformType(); }
        }

        /// <summary>	
        /// <p>Gets the stroke transform type.</p>	
        /// </summary>	
        /// <returns><p>This method returns the stroke transform type.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1StrokeStyle1::GetStrokeTransformType']/*"/>	
        /// <msdn-id>hh446916</msdn-id>	
        /// <unmanaged>D2D1_STROKE_TRANSFORM_TYPE ID2D1StrokeStyle1::GetStrokeTransformType()</unmanaged>	
        /// <unmanaged-short>ID2D1StrokeStyle1::GetStrokeTransformType</unmanaged-short>	
        internal SharpDX.Direct2D1.StrokeTransformType GetStrokeTransformType()
        {
            unsafe
            {
                SharpDX.Direct2D1.StrokeTransformType __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1StrokeTransformType(_nativePointer, ((void**)(*(void**)_nativePointer))[13]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Populates an <strong><see cref="SharpDX.Direct2D1.Mesh"/></strong> object with triangles. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TessellationSink']/*"/>	
    /// <msdn-id>dd372245</msdn-id>	
    /// <unmanaged>ID2D1TessellationSink</unmanaged>	
    /// <unmanaged-short>ID2D1TessellationSink</unmanaged-short>	
    [Guid("2cd906c1-12e2-11dc-9fed-001143a055f9")]
    public partial interface TessellationSink : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p>Copies the specified triangles to the sink.  </p>	
        /// </summary>	
        /// <param name="triangles"><dd>  <p>An array of <strong><see cref="SharpDX.Direct2D1.Triangle"/></strong> structures that describe the triangles to add to the sink.</p> </dd></param>	
        /// <param name="trianglesCount"><dd>  <p>The number of triangles to copy from the <em>triangles</em> array.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TessellationSink::AddTriangles']/*"/>	
        /// <msdn-id>dd372248</msdn-id>	
        /// <unmanaged>void ID2D1TessellationSink::AddTriangles([In, Buffer] const D2D1_TRIANGLE* triangles,[In] unsigned int trianglesCount)</unmanaged>	
        /// <unmanaged-short>ID2D1TessellationSink::AddTriangles</unmanaged-short>	
        /* public void AddTriangles(SharpDX.Direct2D1.Triangle[] triangles, int trianglesCount) */

        /// <summary>	
        /// <p> Closes the sink and returns its error status.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TessellationSink::Close']/*"/>	
        /// <msdn-id>dd372250</msdn-id>	
        /// <unmanaged>HRESULT ID2D1TessellationSink::Close()</unmanaged>	
        /// <unmanaged-short>ID2D1TessellationSink::Close</unmanaged-short>	
        /* public void Close() */
    }
    /// <summary>	
    /// <p>Populates an <strong><see cref="SharpDX.Direct2D1.Mesh"/></strong> object with triangles. </p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TessellationSink']/*"/>	
    /// <msdn-id>dd372245</msdn-id>	
    /// <unmanaged>ID2D1TessellationSink</unmanaged>	
    /// <unmanaged-short>ID2D1TessellationSink</unmanaged-short>	
    [Guid("2cd906c1-12e2-11dc-9fed-001143a055f9")]
    internal partial class TessellationSinkNative : SharpDX.ComObjectCallback, SharpDX.Direct2D1.TessellationSink
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.TessellationSinkNative"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TessellationSinkNative(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.TessellationSinkNative"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.TessellationSinkNative(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.TessellationSinkNative(nativePointer);
        }


        /// <summary>	
        /// <p>Copies the specified triangles to the sink.  </p>	
        /// </summary>	
        /// <param name="triangles"><dd>  <p>An array of <strong><see cref="SharpDX.Direct2D1.Triangle"/></strong> structures that describe the triangles to add to the sink.</p> </dd></param>	
        /// <param name="trianglesCount"><dd>  <p>The number of triangles to copy from the <em>triangles</em> array.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TessellationSink::AddTriangles']/*"/>	
        /// <msdn-id>dd372248</msdn-id>	
        /// <unmanaged>void ID2D1TessellationSink::AddTriangles([In, Buffer] const D2D1_TRIANGLE* triangles,[In] unsigned int trianglesCount)</unmanaged>	
        /// <unmanaged-short>ID2D1TessellationSink::AddTriangles</unmanaged-short>	
        internal void AddTriangles_(SharpDX.Direct2D1.Triangle[] triangles, int trianglesCount)
        {
            unsafe
            {
                fixed (void* triangles_ = triangles)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, triangles_, trianglesCount, ((void**)(*(void**)_nativePointer))[3]);
            }
        }

        /// <summary>	
        /// <p> Closes the sink and returns its error status.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TessellationSink::Close']/*"/>	
        /// <msdn-id>dd372250</msdn-id>	
        /// <unmanaged>HRESULT ID2D1TessellationSink::Close()</unmanaged>	
        /// <unmanaged-short>ID2D1TessellationSink::Close</unmanaged-short>	
        internal void Close_()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents the base interface for all of the transforms implemented by the transform author.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Transforms are aggregated by effect authors. This interface  provides a common interface for implementing the Shantzis rectangle calculations which is the basis for all the transform processing in Direct2D imaging extensions.  These  calculations are described in the paper A model for efficient and flexible image computing.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Transform']/*"/>	
    /// <msdn-id>hh446919</msdn-id>	
    /// <unmanaged>ID2D1Transform</unmanaged>	
    /// <unmanaged-short>ID2D1Transform</unmanaged-short>	
    [Guid("ef1a287d-342a-4f76-8fdb-da0d6ea9f92b")]
    public partial interface Transform : SharpDX.Direct2D1.TransformNode
    {


        /// <summary>	
        /// <p>Allows a transform to state how it would map a rectangle requested on its output to a set of sample rectangles on its input.</p>	
        /// </summary>	
        /// <param name="outputRect"><dd>  <p>The output rectangle from which the inputs must be mapped.</p> </dd></param>	
        /// <param name="inputRects"><dd>  <p>The corresponding set of inputs. The inputs will directly correspond to the transform inputs.</p> </dd></param>	
        /// <param name="inputRectsCount"><dd>  <p>The number of inputs specified. Direct2D guarantees that this is equal to the number of inputs specified on the transform.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The transform implementation must ensure that any pixel shader or software callback implementation it provides honors this calculation.</p><p>The transform implementation must regard this method as purely functional. It can base the mapped input and output rectangles on its current state as specified by the encapsulating effect properties.    However, it must not change its own state in response to this method being invoked. The Direct2D renderer implementation reserves the right to call this method at any time and in any sequence.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Transform::MapOutputRectToInputRects']/*"/>	
        /// <msdn-id>hh446945</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Transform::MapOutputRectToInputRects([In] const RECT* outputRect,[Out, Buffer] RECT* inputRects,[In] unsigned int inputRectsCount)</unmanaged>	
        /// <unmanaged-short>ID2D1Transform::MapOutputRectToInputRects</unmanaged-short>	
        /* public void MapOutputRectToInputRects(SharpDX.Mathematics.Interop.RawRectangle outputRect, SharpDX.Mathematics.Interop.RawRectangle[] inputRects, int inputRectsCount) */

        /// <summary>	
        /// <p>Performs the inverse mapping to <strong>MapOutputRectToInputRects</strong>.</p>	
        /// </summary>	
        /// <param name="inputRects">No documentation.</param>	
        /// <param name="inputOpaqueSubRects">No documentation.</param>	
        /// <param name="inputRectCount">No documentation.</param>	
        /// <param name="outputOpaqueSubRect">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <remarks>	
        /// <p>The transform implementation must ensure that any pixel shader or software callback implementation it provides honors this calculation.</p><p>Unlike the <strong>MapOutputRectToInputRects</strong> and <strong>MapInvalidRect</strong> functions, this method is explicitly called by the renderer at a determined place in its rendering algorithm. The transform implementation may change its state based on the input rectangles and use this information to control its rendering information. This method is always called before the <strong>MapInvalidRect</strong> and <strong>MapOutputRectToInputRects</strong> methods of the transform.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Transform::MapInputRectsToOutputRect']/*"/>	
        /// <msdn-id>hh446943</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Transform::MapInputRectsToOutputRect([In, Buffer] const RECT* inputRects,[In, Buffer] const RECT* inputOpaqueSubRects,[In] unsigned int inputRectCount,[Out] RECT* outputRect,[Out] RECT* outputOpaqueSubRect)</unmanaged>	
        /// <unmanaged-short>ID2D1Transform::MapInputRectsToOutputRect</unmanaged-short>	
        /* public SharpDX.Mathematics.Interop.RawRectangle MapInputRectsToOutputRect(SharpDX.Mathematics.Interop.RawRectangle[] inputRects, SharpDX.Mathematics.Interop.RawRectangle[] inputOpaqueSubRects, int inputRectCount, out SharpDX.Mathematics.Interop.RawRectangle outputOpaqueSubRect) */

        /// <summary>	
        /// <p>Sets the input rectangles for this rendering pass into the transform.</p>	
        /// </summary>	
        /// <param name="inputIndex"><dd>  <p>The index of the input rectangle.</p> </dd></param>	
        /// <param name="invalidInputRect"><dd>  <p>The invalid input rectangle.</p> </dd></param>	
        /// <returns><dd>  <p>The output rectangle to which the input rectangle must be mapped.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The transform implementation must regard <strong>MapInvalidRect</strong> as purely functional. The transform implementation can base the mapped input rectangle on the transform implementation's current state as specified by the encapsulating effect properties. But the transform implementation can't change its own state in response to a call to <strong>MapInvalidRect</strong>. Direct2D can call this method at any time and in any sequence following a call to the <strong>MapInputRectsToOutputRect</strong> method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Transform::MapInvalidRect']/*"/>	
        /// <msdn-id>hh446946</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Transform::MapInvalidRect([In] unsigned int inputIndex,[In] RECT invalidInputRect,[Out] RECT* invalidOutputRect)</unmanaged>	
        /// <unmanaged-short>ID2D1Transform::MapInvalidRect</unmanaged-short>	
        /* public SharpDX.Mathematics.Interop.RawRectangle MapInvalidRect(int inputIndex, SharpDX.Mathematics.Interop.RawRectangle invalidInputRect) */
    }
    /// <summary>	
    /// <p>Represents a geometry that has been transformed. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Using an <strong><see cref="SharpDX.Direct2D1.TransformedGeometry"/></strong> rather than transforming a geometry by using a render target's transform enables you to transform a geometry without transforming its stroke.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformedGeometry']/*"/>	
    /// <msdn-id>dd372252</msdn-id>	
    /// <unmanaged>ID2D1TransformedGeometry</unmanaged>	
    /// <unmanaged-short>ID2D1TransformedGeometry</unmanaged-short>	
    [Guid("2cd906bb-12e2-11dc-9fed-001143a055f9")]
    public partial class TransformedGeometry : SharpDX.Direct2D1.Geometry
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.TransformedGeometry"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TransformedGeometry(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.TransformedGeometry"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.TransformedGeometry(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.TransformedGeometry(nativePointer);
        }


        /// <summary>	
        /// <p>Retrieves the source geometry of this transformed geometry object. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformedGeometry::GetSourceGeometry']/*"/>	
        /// <msdn-id>dd372255</msdn-id>	
        /// <unmanaged>GetSourceGeometry</unmanaged>	
        /// <unmanaged-short>GetSourceGeometry</unmanaged-short>	
        /// <unmanaged>void ID2D1TransformedGeometry::GetSourceGeometry([Out] ID2D1Geometry** sourceGeometry)</unmanaged>
        public SharpDX.Direct2D1.Geometry SourceGeometry
        {
            get { SharpDX.Direct2D1.Geometry __output__; GetSourceGeometry(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Retrieves the matrix used to transform the <strong><see cref="SharpDX.Direct2D1.TransformedGeometry"/></strong> object's source geometry. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformedGeometry::GetTransform']/*"/>	
        /// <msdn-id>dd372256</msdn-id>	
        /// <unmanaged>GetTransform</unmanaged>	
        /// <unmanaged-short>GetTransform</unmanaged-short>	
        /// <unmanaged>void ID2D1TransformedGeometry::GetTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 Transform
        {
            get { SharpDX.Mathematics.Interop.RawMatrix3x2 __output__; GetTransform(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Retrieves the source geometry of this transformed geometry object. </p>	
        /// </summary>	
        /// <param name="sourceGeometry"><dd>  <p>When this method returns, contains a reference to a reference to the source geometry for this transformed geometry object. This parameter is passed uninitialized.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformedGeometry::GetSourceGeometry']/*"/>	
        /// <msdn-id>dd372255</msdn-id>	
        /// <unmanaged>void ID2D1TransformedGeometry::GetSourceGeometry([Out] ID2D1Geometry** sourceGeometry)</unmanaged>	
        /// <unmanaged-short>ID2D1TransformedGeometry::GetSourceGeometry</unmanaged-short>	
        internal void GetSourceGeometry(out SharpDX.Direct2D1.Geometry sourceGeometry)
        {
            unsafe
            {
                IntPtr sourceGeometry_ = IntPtr.Zero;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &sourceGeometry_, ((void**)(*(void**)_nativePointer))[17]);
                sourceGeometry = (sourceGeometry_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.Geometry(sourceGeometry_);
            }
        }

        /// <summary>	
        /// <p>Retrieves the matrix used to transform the <strong><see cref="SharpDX.Direct2D1.TransformedGeometry"/></strong> object's source geometry. </p>	
        /// </summary>	
        /// <param name="transform">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformedGeometry::GetTransform']/*"/>	
        /// <msdn-id>dd372256</msdn-id>	
        /// <unmanaged>void ID2D1TransformedGeometry::GetTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>	
        /// <unmanaged-short>ID2D1TransformedGeometry::GetTransform</unmanaged-short>	
        internal void GetTransform(out SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            unsafe
            {
                transform = new SharpDX.Mathematics.Interop.RawMatrix3x2();
                fixed (void* transform_ = &transform)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, transform_, ((void**)(*(void**)_nativePointer))[18]);
            }
        }
    }
    /// <summary>	
    /// <p>Represents an image source which shares resources with an original image source.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformedImageSource']/*"/>	
    /// <msdn-id>dn952305</msdn-id>	
    /// <unmanaged>ID2D1TransformedImageSource</unmanaged>	
    /// <unmanaged-short>ID2D1TransformedImageSource</unmanaged-short>	
    [Guid("7f1f79e5-2796-416c-8f55-700f911445e5")]
    public partial class TransformedImageSource : SharpDX.Direct2D1.Image
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.TransformedImageSource"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TransformedImageSource(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.TransformedImageSource"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.TransformedImageSource(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.TransformedImageSource(nativePointer);
        }


        /// <summary>	
        /// <p> Retrieves the source image used to create the transformed image source. This value corresponds to the value passed to <strong>CreateTransformedImageSource</strong>. </p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformedImageSource::GetSource']/*"/>	
        /// <msdn-id>dn952307</msdn-id>	
        /// <unmanaged>GetSource</unmanaged>	
        /// <unmanaged-short>GetSource</unmanaged-short>	
        /// <unmanaged>void ID2D1TransformedImageSource::GetSource([Out, Optional] ID2D1ImageSource** imageSource)</unmanaged>
        public SharpDX.Direct2D1.ImageSource Source
        {
            get { SharpDX.Direct2D1.ImageSource __output__; GetSource(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Represents an image source which shares resources with an original image source.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformedImageSource::GetProperties']/*"/>	
        /// <msdn-id>dn952305</msdn-id>	
        /// <unmanaged>GetProperties</unmanaged>	
        /// <unmanaged-short>GetProperties</unmanaged-short>	
        /// <unmanaged>void ID2D1TransformedImageSource::GetProperties([Out] D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES* properties)</unmanaged>
        public SharpDX.Direct2D1.TransformedImageSourceProperties Properties
        {
            get { SharpDX.Direct2D1.TransformedImageSourceProperties __output__; GetProperties(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Retrieves the source image used to create the transformed image source. This value corresponds to the value passed to <strong>CreateTransformedImageSource</strong>. </p>	
        /// </summary>	
        /// <param name="imageSource">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformedImageSource::GetSource']/*"/>	
        /// <msdn-id>dn952307</msdn-id>	
        /// <unmanaged>void ID2D1TransformedImageSource::GetSource([Out, Optional] ID2D1ImageSource** imageSource)</unmanaged>	
        /// <unmanaged-short>ID2D1TransformedImageSource::GetSource</unmanaged-short>	
        internal void GetSource(out SharpDX.Direct2D1.ImageSource imageSource)
        {
            unsafe
            {
                IntPtr imageSource_ = IntPtr.Zero;
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &imageSource_, ((void**)(*(void**)_nativePointer))[4]);
                imageSource = (imageSource_ == IntPtr.Zero) ? null : new SharpDX.Direct2D1.ImageSource(imageSource_);
            }
        }

        /// <summary>	
        /// <p>Represents an image source which shares resources with an original image source.</p>	
        /// </summary>	
        /// <param name="ropertiesRef">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformedImageSource::GetProperties']/*"/>	
        /// <msdn-id>dn952305</msdn-id>	
        /// <unmanaged>void ID2D1TransformedImageSource::GetProperties([Out] D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES* properties)</unmanaged>	
        /// <unmanaged-short>ID2D1TransformedImageSource::GetProperties</unmanaged-short>	
        internal void GetProperties(out SharpDX.Direct2D1.TransformedImageSourceProperties ropertiesRef)
        {
            unsafe
            {
                ropertiesRef = new SharpDX.Direct2D1.TransformedImageSourceProperties();
                fixed (void* ropertiesRef_ = &ropertiesRef)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, ropertiesRef_, ((void**)(*(void**)_nativePointer))[5]);
            }
        }
    }
    /// <summary>	
    /// <p>Represents a graph of transform nodes.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface allows a graph of transform nodes to be specified. This interface is passed to <strong><see cref="SharpDX.Direct2D1.CustomEffect.Initialize"/></strong> to allow an effect implementation to specify a graph of transforms or a single transform.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformGraph']/*"/>	
    /// <msdn-id>hh446920</msdn-id>	
    /// <unmanaged>ID2D1TransformGraph</unmanaged>	
    /// <unmanaged-short>ID2D1TransformGraph</unmanaged-short>	
    [Guid("13d29038-c3e6-4034-9081-13b53a417992")]
    public partial class TransformGraph : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.TransformGraph"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TransformGraph(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.TransformGraph"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.TransformGraph(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.TransformGraph(nativePointer);
        }


        /// <summary>	
        /// <p>Returns the number of inputs to the transform graph.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformGraph::GetInputCount']/*"/>	
        /// <msdn-id>hh871467</msdn-id>	
        /// <unmanaged>GetInputCount</unmanaged>	
        /// <unmanaged-short>GetInputCount</unmanaged-short>	
        /// <unmanaged>unsigned int ID2D1TransformGraph::GetInputCount()</unmanaged>
        public int InputCount
        {
            get { return GetInputCount(); }
        }

        /// <summary>	
        /// <p>Returns the number of inputs to the transform graph.</p>	
        /// </summary>	
        /// <returns><p>The number of inputs to this transform graph.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformGraph::GetInputCount']/*"/>	
        /// <msdn-id>hh871467</msdn-id>	
        /// <unmanaged>unsigned int ID2D1TransformGraph::GetInputCount()</unmanaged>	
        /// <unmanaged-short>ID2D1TransformGraph::GetInputCount</unmanaged-short>	
        internal int GetInputCount()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets a single transform node as being equivalent to the whole graph.</p>	
        /// </summary>	
        /// <param name="node"><dd>  <p>The node to be set.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This equivalent to calling <strong><see cref="SharpDX.Direct2D1.TransformGraph.Clear"/></strong>, adding a single node, connecting all of the node inputs to the effect inputs in order, and setting the transform not as the graph output.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformGraph::SetSingleTransformNode']/*"/>	
        /// <msdn-id>hh446935</msdn-id>	
        /// <unmanaged>HRESULT ID2D1TransformGraph::SetSingleTransformNode([In] ID2D1TransformNode* node)</unmanaged>	
        /// <unmanaged-short>ID2D1TransformGraph::SetSingleTransformNode</unmanaged-short>	
        internal void SetSingleTransformNode_(System.IntPtr node)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)node, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Adds the provided node to the transform graph.</p>	
        /// </summary>	
        /// <param name="node"><dd>  <p>The node that will be added to the transform graph.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This adds a transform node to the transform graph. A node must be added to the transform graph before it can be interconnected in any way.	
        /// </p><p>A transform graph cannot be directly added to another transform graph. 	
        /// Only interfaces derived from <strong><see cref="SharpDX.Direct2D1.TransformNode"/></strong> can be added to the transform graph.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformGraph::AddNode']/*"/>	
        /// <msdn-id>hh446922</msdn-id>	
        /// <unmanaged>HRESULT ID2D1TransformGraph::AddNode([In] ID2D1TransformNode* node)</unmanaged>	
        /// <unmanaged-short>ID2D1TransformGraph::AddNode</unmanaged-short>	
        internal void AddNode_(System.IntPtr node)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)node, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Removes the provided node from the transform graph.</p>	
        /// </summary>	
        /// <param name="node"><dd>  <p>The node that will be removed from the transform graph.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>D2DERR_NOT_FOUND = (HRESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.NotFound"/>))</td><td>Direct2D could not locate the specified node.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The node must already exist in the graph; otherwise, the call fails with <strong>D2DERR_NOT_FOUND</strong>.</p><p>Any connections to this node will be removed when the node is removed.</p><p>After the node is removed, it cannot be used by the interface until it has been added to the graph by <strong>AddNode</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformGraph::RemoveNode']/*"/>	
        /// <msdn-id>hh446931</msdn-id>	
        /// <unmanaged>HRESULT ID2D1TransformGraph::RemoveNode([In] ID2D1TransformNode* node)</unmanaged>	
        /// <unmanaged-short>ID2D1TransformGraph::RemoveNode</unmanaged-short>	
        internal void RemoveNode_(System.IntPtr node)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)node, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the output node for the transform graph.</p>	
        /// </summary>	
        /// <param name="node"><dd>  <p>The node that will be considered the output of the transform node.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>D2DERR_NOT_FOUND = (HRESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.NotFound"/>))</td><td>Direct2D could not locate the specified node.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The node must already exist in the graph; otherwise, the call fails with <strong>D2DERR_NOT_FOUND</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformGraph::SetOutputNode']/*"/>	
        /// <msdn-id>hh446932</msdn-id>	
        /// <unmanaged>HRESULT ID2D1TransformGraph::SetOutputNode([In] ID2D1TransformNode* node)</unmanaged>	
        /// <unmanaged-short>ID2D1TransformGraph::SetOutputNode</unmanaged-short>	
        internal void SetOutputNode_(System.IntPtr node)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)node, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Connects two nodes inside the transform graph.</p>	
        /// </summary>	
        /// <param name="fromNode"><dd>  <p>The node from which the connection will be made.</p> </dd></param>	
        /// <param name="toNode"><dd>  <p>The node to which the connection will be made.</p> </dd></param>	
        /// <param name="toNodeInputIndex"><dd>  <p>The node input that will be connected.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>D2DERR_NOT_FOUND = (HRESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.NotFound"/>))</td><td>Direct2D could not locate the specified node.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Both nodes must already exist in the graph; otherwise, the call fails with <strong>D2DERR_NOT_FOUND</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformGraph::ConnectNode']/*"/>	
        /// <msdn-id>hh446926</msdn-id>	
        /// <unmanaged>HRESULT ID2D1TransformGraph::ConnectNode([In] ID2D1TransformNode* fromNode,[In] ID2D1TransformNode* toNode,[In] unsigned int toNodeInputIndex)</unmanaged>	
        /// <unmanaged-short>ID2D1TransformGraph::ConnectNode</unmanaged-short>	
        internal void ConnectNode__(System.IntPtr fromNode, System.IntPtr toNode, int toNodeInputIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)fromNode, (void*)toNode, toNodeInputIndex, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Connects a transform node inside the graph to the corresponding effect input of the encapsulating effect.</p>	
        /// </summary>	
        /// <param name="toEffectInputIndex"><dd>  <p>The effect input to which the transform node will be bound.</p> </dd></param>	
        /// <param name="node"><dd>  <p>The node to which the connection will be made.</p> </dd></param>	
        /// <param name="toNodeInputIndex"><dd>  <p>The node input that will be connected.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>D2DERR_NOT_FOUND = (HRESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.NotFound"/>))</td><td>Direct2D could not locate the specified node.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformGraph::ConnectToEffectInput']/*"/>	
        /// <msdn-id>hh446928</msdn-id>	
        /// <unmanaged>HRESULT ID2D1TransformGraph::ConnectToEffectInput([In] unsigned int toEffectInputIndex,[In] ID2D1TransformNode* node,[In] unsigned int toNodeInputIndex)</unmanaged>	
        /// <unmanaged-short>ID2D1TransformGraph::ConnectToEffectInput</unmanaged-short>	
        internal void ConnectToEffectInput_(int toEffectInputIndex, System.IntPtr node, int toNodeInputIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, toEffectInputIndex, (void*)node, toNodeInputIndex, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Clears the transform nodes and all connections from the transform graph.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Used when enough changes to transfoms would make  editing of the transform graph inefficient.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformGraph::Clear']/*"/>	
        /// <msdn-id>hh446924</msdn-id>	
        /// <unmanaged>void ID2D1TransformGraph::Clear()</unmanaged>	
        /// <unmanaged-short>ID2D1TransformGraph::Clear</unmanaged-short>	
        public void Clear()
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, ((void**)(*(void**)_nativePointer))[10]);
            }
        }

        /// <summary>	
        /// <p>Uses the specified input as the effect output.</p>	
        /// </summary>	
        /// <param name="effectInputIndex"><dd> <p>The index of the input to the effect.</p> </dd></param>	
        /// <returns><p>The method returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>D2DERR_NOT_FOUND = (HRESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.NotFound"/>))</td><td>Direct2D could not locate the specified node.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformGraph::SetPassthroughGraph']/*"/>	
        /// <msdn-id>hh997720</msdn-id>	
        /// <unmanaged>HRESULT ID2D1TransformGraph::SetPassthroughGraph([In] unsigned int effectInputIndex)</unmanaged>	
        /// <unmanaged-short>ID2D1TransformGraph::SetPassthroughGraph</unmanaged-short>	
        public void SetPassthroughGraph(int effectInputIndex)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, effectInputIndex, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents the base interface for all of the transforms implemented by the transform author.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Transforms are aggregated by effect authors. This interface  provides a common interface for implementing the Shantzis rectangle calculations which is the basis for all the transform processing in Direct2D imaging extensions.  These  calculations are described in the paper A model for efficient and flexible image computing.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Transform']/*"/>	
    /// <msdn-id>hh446919</msdn-id>	
    /// <unmanaged>ID2D1Transform</unmanaged>	
    /// <unmanaged-short>ID2D1Transform</unmanaged-short>	
    [Guid("ef1a287d-342a-4f76-8fdb-da0d6ea9f92b")]
    public partial class TransformNative : SharpDX.Direct2D1.TransformNodeNative, SharpDX.Direct2D1.Transform
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.TransformNative"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TransformNative(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.TransformNative"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.TransformNative(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.TransformNative(nativePointer);
        }


        /// <summary>	
        /// <p>Allows a transform to state how it would map a rectangle requested on its output to a set of sample rectangles on its input.</p>	
        /// </summary>	
        /// <param name="outputRect"><dd>  <p>The output rectangle from which the inputs must be mapped.</p> </dd></param>	
        /// <param name="inputRects"><dd>  <p>The corresponding set of inputs. The inputs will directly correspond to the transform inputs.</p> </dd></param>	
        /// <param name="inputRectsCount"><dd>  <p>The number of inputs specified. Direct2D guarantees that this is equal to the number of inputs specified on the transform.</p> </dd></param>	
        /// <returns><p>If the method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The transform implementation must ensure that any pixel shader or software callback implementation it provides honors this calculation.</p><p>The transform implementation must regard this method as purely functional. It can base the mapped input and output rectangles on its current state as specified by the encapsulating effect properties.    However, it must not change its own state in response to this method being invoked. The Direct2D renderer implementation reserves the right to call this method at any time and in any sequence.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Transform::MapOutputRectToInputRects']/*"/>	
        /// <msdn-id>hh446945</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Transform::MapOutputRectToInputRects([In] const RECT* outputRect,[Out, Buffer] RECT* inputRects,[In] unsigned int inputRectsCount)</unmanaged>	
        /// <unmanaged-short>ID2D1Transform::MapOutputRectToInputRects</unmanaged-short>	
        internal void MapOutputRectToInputRects_(SharpDX.Mathematics.Interop.RawRectangle outputRect, SharpDX.Mathematics.Interop.RawRectangle[] inputRects, int inputRectsCount)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* inputRects_ = inputRects)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &outputRect, inputRects_, inputRectsCount, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Performs the inverse mapping to <strong>MapOutputRectToInputRects</strong>.</p>	
        /// </summary>	
        /// <param name="inputRects">No documentation.</param>	
        /// <param name="inputOpaqueSubRects">No documentation.</param>	
        /// <param name="inputRectCount">No documentation.</param>	
        /// <param name="outputOpaqueSubRect">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <remarks>	
        /// <p>The transform implementation must ensure that any pixel shader or software callback implementation it provides honors this calculation.</p><p>Unlike the <strong>MapOutputRectToInputRects</strong> and <strong>MapInvalidRect</strong> functions, this method is explicitly called by the renderer at a determined place in its rendering algorithm. The transform implementation may change its state based on the input rectangles and use this information to control its rendering information. This method is always called before the <strong>MapInvalidRect</strong> and <strong>MapOutputRectToInputRects</strong> methods of the transform.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Transform::MapInputRectsToOutputRect']/*"/>	
        /// <msdn-id>hh446943</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Transform::MapInputRectsToOutputRect([In, Buffer] const RECT* inputRects,[In, Buffer] const RECT* inputOpaqueSubRects,[In] unsigned int inputRectCount,[Out] RECT* outputRect,[Out] RECT* outputOpaqueSubRect)</unmanaged>	
        /// <unmanaged-short>ID2D1Transform::MapInputRectsToOutputRect</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawRectangle MapInputRectsToOutputRect_(SharpDX.Mathematics.Interop.RawRectangle[] inputRects, SharpDX.Mathematics.Interop.RawRectangle[] inputOpaqueSubRects, int inputRectCount, out SharpDX.Mathematics.Interop.RawRectangle outputOpaqueSubRect)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangle outputRect;
                outputRect = new SharpDX.Mathematics.Interop.RawRectangle();
                outputOpaqueSubRect = new SharpDX.Mathematics.Interop.RawRectangle();
                SharpDX.Result __result__;
                fixed (void* inputRects_ = inputRects)
                    fixed (void* inputOpaqueSubRects_ = inputOpaqueSubRects)
                        fixed (void* outputOpaqueSubRect_ = &outputOpaqueSubRect)
                            __result__ =
                            SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, inputRects_, inputOpaqueSubRects_, inputRectCount, &outputRect, outputOpaqueSubRect_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
                return outputRect;
            }
        }

        /// <summary>	
        /// <p>Sets the input rectangles for this rendering pass into the transform.</p>	
        /// </summary>	
        /// <param name="inputIndex"><dd>  <p>The index of the input rectangle.</p> </dd></param>	
        /// <param name="invalidInputRect"><dd>  <p>The invalid input rectangle.</p> </dd></param>	
        /// <returns><dd>  <p>The output rectangle to which the input rectangle must be mapped.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The transform implementation must regard <strong>MapInvalidRect</strong> as purely functional. The transform implementation can base the mapped input rectangle on the transform implementation's current state as specified by the encapsulating effect properties. But the transform implementation can't change its own state in response to a call to <strong>MapInvalidRect</strong>. Direct2D can call this method at any time and in any sequence following a call to the <strong>MapInputRectsToOutputRect</strong> method.	
        /// </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1Transform::MapInvalidRect']/*"/>	
        /// <msdn-id>hh446946</msdn-id>	
        /// <unmanaged>HRESULT ID2D1Transform::MapInvalidRect([In] unsigned int inputIndex,[In] RECT invalidInputRect,[Out] RECT* invalidOutputRect)</unmanaged>	
        /// <unmanaged-short>ID2D1Transform::MapInvalidRect</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawRectangle MapInvalidRect_(int inputIndex, SharpDX.Mathematics.Interop.RawRectangle invalidInputRect)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangle invalidOutputRect;
                invalidOutputRect = new SharpDX.Mathematics.Interop.RawRectangle();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint116(_nativePointer, inputIndex, invalidInputRect, &invalidOutputRect, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
                return invalidOutputRect;
            }
        }
    }
    /// <summary>	
    /// <p>Describes a node in a transform topology.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Transform nodes are type-less and only define the notion of an object that accepts a number of inputs and is an output. This interface limits a topology to single output nodes.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformNode']/*"/>	
    /// <msdn-id>hh446939</msdn-id>	
    /// <unmanaged>ID2D1TransformNode</unmanaged>	
    /// <unmanaged-short>ID2D1TransformNode</unmanaged-short>	
    [Guid("b2efe1e7-729f-4102-949f-505fa21bf666")]
    public partial interface TransformNode : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p>Gets the number of inputs to the transform node.</p>	
        /// </summary>	
        /// <returns><p>This method returns the number of inputs to this transform node.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformNode::GetInputCount']/*"/>	
        /// <msdn-id>hh446940</msdn-id>	
        /// <unmanaged>unsigned int ID2D1TransformNode::GetInputCount()</unmanaged>	
        /// <unmanaged-short>ID2D1TransformNode::GetInputCount</unmanaged-short>	
        /* public int GetInputCount() */
    }
    /// <summary>	
    /// <p>Describes a node in a transform topology.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Transform nodes are type-less and only define the notion of an object that accepts a number of inputs and is an output. This interface limits a topology to single output nodes.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformNode']/*"/>	
    /// <msdn-id>hh446939</msdn-id>	
    /// <unmanaged>ID2D1TransformNode</unmanaged>	
    /// <unmanaged-short>ID2D1TransformNode</unmanaged-short>	
    [Guid("b2efe1e7-729f-4102-949f-505fa21bf666")]
    public partial class TransformNodeNative : SharpDX.ComObjectCallback, SharpDX.Direct2D1.TransformNode
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.TransformNodeNative"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TransformNodeNative(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.TransformNodeNative"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.TransformNodeNative(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.TransformNodeNative(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the number of inputs to the transform node.</p>	
        /// </summary>	
        /// <returns><p>This method returns the number of inputs to this transform node.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1TransformNode::GetInputCount']/*"/>	
        /// <msdn-id>hh446940</msdn-id>	
        /// <unmanaged>unsigned int ID2D1TransformNode::GetInputCount()</unmanaged>	
        /// <unmanaged-short>ID2D1TransformNode::GetInputCount</unmanaged-short>	
        internal int GetInputCount_()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Defines a mappable single-dimensional vertex buffer.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1VertexBuffer']/*"/>	
    /// <msdn-id>hh446949</msdn-id>	
    /// <unmanaged>ID2D1VertexBuffer</unmanaged>	
    /// <unmanaged-short>ID2D1VertexBuffer</unmanaged-short>	
    [Guid("9b8b1336-00a5-4668-92b7-ced5d8bf9b7b")]
    public partial class VertexBuffer : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.VertexBuffer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VertexBuffer(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.VertexBuffer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.VertexBuffer(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.VertexBuffer(nativePointer);
        }


        /// <summary>	
        /// <p>Maps the provided data into user memory.</p>	
        /// </summary>	
        /// <param name="data"><dd>  <p>When this method returns, contains the address of a reference to the available buffer.</p> </dd></param>	
        /// <param name="bufferSize"><dd>  <p>The desired size of the buffer.</p> </dd></param>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> <tr><td>D3DERR_DEVICELOST</td><td>The device has been lost but cannot be reset at this time.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>If <em>data</em> is larger than <em>bufferSize</em>, this method fails.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1VertexBuffer::Map']/*"/>	
        /// <msdn-id>hh446951</msdn-id>	
        /// <unmanaged>HRESULT ID2D1VertexBuffer::Map([Out, Buffer] unsigned char** data,[In] unsigned int bufferSize)</unmanaged>	
        /// <unmanaged-short>ID2D1VertexBuffer::Map</unmanaged-short>	
        public void Map(byte[] data, int bufferSize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* data_ = data)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, data_, bufferSize, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Unmaps the vertex buffer.</p>	
        /// </summary>	
        /// <returns><p>The method returns an <see cref="SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref="SharpDX.Direct2D1.ResultCode.WrongState"/></td><td>The object was not in the correct state to process the method.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>After this method returns, the mapped memory from the vertex buffer is no longer accessible by the effect.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1VertexBuffer::Unmap']/*"/>	
        /// <msdn-id>hh446967</msdn-id>	
        /// <unmanaged>HRESULT ID2D1VertexBuffer::Unmap()</unmanaged>	
        /// <unmanaged-short>ID2D1VertexBuffer::Unmap</unmanaged-short>	
        public void Unmap()
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Renders drawing instructions to a window.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>As is the case with other render targets, you must call <strong>BeginDraw</strong> before issuing drawing commands. After you've finished drawing, call <strong>EndDraw</strong> to indicate that drawing is finished and to release access to the buffer backing the render target. For <strong><see cref="SharpDX.Direct2D1.WindowRenderTarget"/></strong>, the only side effect of <strong>BeginDraw</strong> is changing the state of the render target to allow drawing commands to be issued. <strong>EndDraw</strong> flushes any batched drawing commands. If no errors have occurred, then it also presents the buffer, causing it to appear on the associated window. Finally, <strong>EndDraw</strong> returns the <see cref="SharpDX.Result"/> of the first error that occurred in drawing or presenting, as well as the tag state at the time the error occurred.</p><p><strong><see cref="SharpDX.Direct2D1.WindowRenderTarget"/></strong> objects are double buffered, so drawing commands issued do not appear immediately, but rather are performed on an offscreen surface. When <strong>EndDraw</strong> is called, if there have been no rendering errors, the offscreen buffer is presented. If there have been rendering errors in the batch flushed by <strong>EndDraw</strong>, then the buffer is not presented, and the application must call <strong>BeginDraw</strong> and re-draw the frame. <strong>Flush</strong> can be used to check for errors before calling <strong>EndDraw</strong> if an application wants the frame to be presented regardless of errors. </p><p>A hardware render target's back-buffer is the size specified by <strong>GetPixelSize</strong>. If <strong>EndDraw</strong> presents the buffer, this bitmap is stretched to cover the surface where it is presented: the entire client area of the window. This stretch is performed using bilinear filtering if the render target is rendering in hardware and using nearest-neighbor filtering if the rendering target is using software. (Typically, an application will call <strong>Resize</strong> to ensure the pixel size of the render target and the pixel size of the destination match, and no scaling is necessary, though this is not a requirement.) </p><p>In the case where a window straddles adapters, Direct2D ensures that the portion of the off-screen render target is copied from the adapter where rendering is occurring to the adapter that needs to display the contents. If the adapter a render target is on has been removed or the driver upgraded while the application is running, this is returned as an error in the <strong>EndDraw</strong> call. In this case, the application should create a new render target and resources as necessary.	
    /// </p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1HwndRenderTarget']/*"/>	
    /// <msdn-id>dd371461</msdn-id>	
    /// <unmanaged>ID2D1HwndRenderTarget</unmanaged>	
    /// <unmanaged-short>ID2D1HwndRenderTarget</unmanaged-short>	
    [Guid("2cd90698-12e2-11dc-9fed-001143a055f9")]
    public partial class WindowRenderTarget : SharpDX.Direct2D1.RenderTarget
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct2D1.WindowRenderTarget"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public WindowRenderTarget(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct2D1.WindowRenderTarget"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.Direct2D1.WindowRenderTarget(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct2D1.WindowRenderTarget(nativePointer);
        }


        /// <summary>	
        /// <p> Returns the <see cref="System.IntPtr"/> associated with this render target.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1HwndRenderTarget::GetHwnd']/*"/>	
        /// <msdn-id>dd371470</msdn-id>	
        /// <unmanaged>GetHwnd</unmanaged>	
        /// <unmanaged-short>GetHwnd</unmanaged-short>	
        /// <unmanaged>HWND ID2D1HwndRenderTarget::GetHwnd()</unmanaged>
        public System.IntPtr Hwnd
        {
            get { return GetHwnd(); }
        }

        /// <summary>	
        /// <p>Indicates whether the <see cref="System.IntPtr"/> associated with this render target is occluded. </p>	
        /// </summary>	
        /// <returns><p>A value that indicates whether the <see cref="System.IntPtr"/> associated with this render target is occluded.</p></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??If the window was occluded the last time  that <strong>EndDraw</strong> was called, the next time that the render target calls <strong>CheckWindowState</strong>, it will return <strong><see cref="SharpDX.Direct2D1.WindowState.Occluded"/></strong> regardless of the current window state. If you want to use <strong>CheckWindowState</strong> to determine the current window state, you should call <strong>CheckWindowState</strong> after every <strong>EndDraw</strong> call and ignore its return value. This call will ensure that your next call to <strong>CheckWindowState</strong> state will return the actual window state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1HwndRenderTarget::CheckWindowState']/*"/>	
        /// <msdn-id>dd371466</msdn-id>	
        /// <unmanaged>D2D1_WINDOW_STATE ID2D1HwndRenderTarget::CheckWindowState()</unmanaged>	
        /// <unmanaged-short>ID2D1HwndRenderTarget::CheckWindowState</unmanaged-short>	
        public SharpDX.Direct2D1.WindowState CheckWindowState()
        {
            unsafe
            {
                SharpDX.Direct2D1.WindowState __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirect2D1WindowState(_nativePointer, ((void**)(*(void**)_nativePointer))[57]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Changes the size of the render target to the specified pixel size. </p>	
        /// </summary>	
        /// <param name="ixelSizeRef"><dd>  <p>The new size of the render target in device pixels.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>After this method is called, the contents of the render target's back-buffer are not defined, even if the <strong><see cref="SharpDX.Direct2D1.PresentOptions.RetainContents"/></strong> option was specified when the render target was created.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1HwndRenderTarget::Resize']/*"/>	
        /// <msdn-id>dd371479</msdn-id>	
        /// <unmanaged>HRESULT ID2D1HwndRenderTarget::Resize([In] const D2D_SIZE_U* pixelSize)</unmanaged>	
        /// <unmanaged-short>ID2D1HwndRenderTarget::Resize</unmanaged-short>	
        public void Resize(SharpDX.Size2 ixelSizeRef)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &ixelSizeRef, ((void**)(*(void**)_nativePointer))[58]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Returns the <see cref="System.IntPtr"/> associated with this render target.</p>	
        /// </summary>	
        /// <returns><p>The <see cref="System.IntPtr"/> associated with this render target.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID2D1HwndRenderTarget::GetHwnd']/*"/>	
        /// <msdn-id>dd371470</msdn-id>	
        /// <unmanaged>HWND ID2D1HwndRenderTarget::GetHwnd()</unmanaged>	
        /// <unmanaged-short>ID2D1HwndRenderTarget::GetHwnd</unmanaged-short>	
        internal System.IntPtr GetHwnd()
        {
            unsafe
            {
                System.IntPtr __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSystemIntPtr(_nativePointer, ((void**)(*(void**)_nativePointer))[59]);
                return __result__;
            }
        }
    }
}
