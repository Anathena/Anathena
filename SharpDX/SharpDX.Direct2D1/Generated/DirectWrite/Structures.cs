// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.DirectWrite namespace.
//     This code was generated by a tool.
//     Date : 6/25/2016 10:38:09 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.DirectWrite {

#pragma warning disable 282
#pragma warning disable 649
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
    
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.DirectWrite.CaretMetrics"/></strong> structure specifies the metrics for caret placement in a font.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_CARET_METRICS']/*"/>	
    /// <msdn-id>jj126258</msdn-id>	
    /// <unmanaged>DWRITE_CARET_METRICS</unmanaged>	
    /// <unmanaged-short>DWRITE_CARET_METRICS</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct CaretMetrics {	
        
        /// <summary>	
        /// <dd> <p>Vertical rise of the caret. Rise / Run yields the caret angle. Rise = 1 for perfectly upright fonts (non-italic).</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_CARET_METRICS::slopeRise']/*"/>	
        /// <msdn-id>jj126258</msdn-id>	
        /// <unmanaged>short slopeRise</unmanaged>	
        /// <unmanaged-short>short slopeRise</unmanaged-short>	
        public short SlopeRise;
        
        /// <summary>	
        /// <dd> <p>Horizontal run of the caret. Rise / Run yields the caret angle. Run = 0 for perfectly upright fonts (non-italic).</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_CARET_METRICS::slopeRun']/*"/>	
        /// <msdn-id>jj126258</msdn-id>	
        /// <unmanaged>short slopeRun</unmanaged>	
        /// <unmanaged-short>short slopeRun</unmanaged-short>	
        public short SlopeRun;
        
        /// <summary>	
        /// <dd> <p>Horizontal offset of the caret along the baseline for good appearance. Offset = 0 for perfectly upright fonts (non-italic).</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_CARET_METRICS::offset']/*"/>	
        /// <msdn-id>jj126258</msdn-id>	
        /// <unmanaged>short offset</unmanaged>	
        /// <unmanaged-short>short offset</unmanaged-short>	
        public short Offset;
    }
    
    /// <summary>	
    /// <p>Contains information about a glyph cluster.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_CLUSTER_METRICS']/*"/>	
    /// <msdn-id>dd368054</msdn-id>	
    /// <unmanaged>DWRITE_CLUSTER_METRICS</unmanaged>	
    /// <unmanaged-short>DWRITE_CLUSTER_METRICS</unmanaged-short>	
    [StructLayout(LayoutKind.Explicit)]
    public  partial struct ClusterMetrics {	
        
        /// <summary>	
        /// <dd> <p>The total advance width of all glyphs in the cluster.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_CLUSTER_METRICS::width']/*"/>	
        /// <msdn-id>dd368054</msdn-id>	
        /// <unmanaged>float width</unmanaged>	
        /// <unmanaged-short>float width</unmanaged-short>	
        [FieldOffset(0)]
        public float Width;
        
        /// <summary>	
        /// <dd> <p>The number of text positions in the cluster.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_CLUSTER_METRICS::length']/*"/>	
        /// <msdn-id>dd368054</msdn-id>	
        /// <unmanaged>unsigned short length</unmanaged>	
        /// <unmanaged-short>unsigned short length</unmanaged-short>	
        [FieldOffset(4)]
        public short Length;
        
        /// <summary>	
        /// <dd> <p>Indicates whether a line can be broken right after the cluster.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_CLUSTER_METRICS::canWrapLineAfter']/*"/>	
        /// <msdn-id>dd368054</msdn-id>	
        /// <unmanaged>unsigned short canWrapLineAfter</unmanaged>	
        /// <unmanaged-short>unsigned short canWrapLineAfter</unmanaged-short>	
        public bool  CanWrapLineAfter { 
            get { 
                return 0 != ((_CanWrapLineAfter >> 0)  &  1);
            }
            set { 
                _CanWrapLineAfter = (short)((_CanWrapLineAfter & ~( 1 << 0)) | ( ( (value?1:0) & 1) << 0));
            }
        }
        [FieldOffset(6)]
        internal short _CanWrapLineAfter;
		
        
        /// <summary>	
        /// <dd> <p>Indicates whether the cluster corresponds to a whitespace character.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_CLUSTER_METRICS::isWhitespace']/*"/>	
        /// <msdn-id>dd368054</msdn-id>	
        /// <unmanaged>unsigned short isWhitespace</unmanaged>	
        /// <unmanaged-short>unsigned short isWhitespace</unmanaged-short>	
        public bool  IsWhitespace { 
            get { 
                return 0 != ((_IsWhitespace >> 1)  &  1);
            }
            set { 
                _IsWhitespace = (short)((_IsWhitespace & ~( 1 << 1)) | ( ( (value?1:0) & 1) << 1));
            }
        }
        [FieldOffset(6)]
        internal short _IsWhitespace;
		
        
        /// <summary>	
        /// <dd> <p>Indicates whether the cluster corresponds to a newline character.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_CLUSTER_METRICS::isNewline']/*"/>	
        /// <msdn-id>dd368054</msdn-id>	
        /// <unmanaged>unsigned short isNewline</unmanaged>	
        /// <unmanaged-short>unsigned short isNewline</unmanaged-short>	
        public bool  IsNewline { 
            get { 
                return 0 != ((_IsNewline >> 2)  &  1);
            }
            set { 
                _IsNewline = (short)((_IsNewline & ~( 1 << 2)) | ( ( (value?1:0) & 1) << 2));
            }
        }
        [FieldOffset(6)]
        internal short _IsNewline;
		
        
        /// <summary>	
        /// <dd> <p>Indicates whether the cluster corresponds to a soft hyphen character.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_CLUSTER_METRICS::isSoftHyphen']/*"/>	
        /// <msdn-id>dd368054</msdn-id>	
        /// <unmanaged>unsigned short isSoftHyphen</unmanaged>	
        /// <unmanaged-short>unsigned short isSoftHyphen</unmanaged-short>	
        public bool  IsSoftHyphen { 
            get { 
                return 0 != ((_IsSoftHyphen >> 3)  &  1);
            }
            set { 
                _IsSoftHyphen = (short)((_IsSoftHyphen & ~( 1 << 3)) | ( ( (value?1:0) & 1) << 3));
            }
        }
        [FieldOffset(6)]
        internal short _IsSoftHyphen;
		
        
        /// <summary>	
        /// <dd> <p>Indicates whether the cluster is read from right to left.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_CLUSTER_METRICS::isRightToLeft']/*"/>	
        /// <msdn-id>dd368054</msdn-id>	
        /// <unmanaged>unsigned short isRightToLeft</unmanaged>	
        /// <unmanaged-short>unsigned short isRightToLeft</unmanaged-short>	
        public bool  IsRightToLeft { 
            get { 
                return 0 != ((_IsRightToLeft >> 4)  &  1);
            }
            set { 
                _IsRightToLeft = (short)((_IsRightToLeft & ~( 1 << 4)) | ( ( (value?1:0) & 1) << 4));
            }
        }
        [FieldOffset(6)]
        internal short _IsRightToLeft;
		
        
        /// <summary>	
        /// <dd> <p>Reserved for future use.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_CLUSTER_METRICS::padding']/*"/>	
        /// <msdn-id>dd368054</msdn-id>	
        /// <unmanaged>unsigned short padding</unmanaged>	
        /// <unmanaged-short>unsigned short padding</unmanaged-short>	
        internal short  Padding { 
            get { 
                return (short)((_Padding >> 5)  &  2047);
            }
            set { 
                _Padding = (short)((_Padding & ~( 2047 << 5)) | ( (value & 2047) << 5));
            }
        }
        [FieldOffset(6)]
        internal short _Padding;
		
    }
    
    /// <summary>	
    /// <p>Specifies properties used to identify and execute typographic features in the current font face.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A non-zero value generally enables the feature execution, while the zero value disables it. A feature requiring a selector uses this value to indicate the selector index.</p><p>The OpenType standard provides access to typographic features available in the font by means of a feature tag with the associated parameters. The OpenType feature tag is a 4-byte identifier of the registered name of a feature. For example, the 'kern' feature name tag is used to identify the 'Kerning' feature in OpenType font. Similarly, the OpenType feature tag for 'Standard Ligatures' and 'Fractions' is 'liga' and 'frac' respectively. Since a single run can be associated with more than one typographic features, the Text String API accepts typographic settings for a run as a list of features and are executed in the order they are specified.</p><p>The value of the tag member represents the OpenType name tag of the feature, while the param value represents additional parameter for the execution of the feature referred by the tag member. Both <strong>nameTag</strong> and <strong>parameter</strong> are stored as little endian, the same convention followed by GDI.  Most features treat the Param value as a binary value that indicates whether to turn the execution of the feature on or off, with it being off by default in the majority of cases. Some features, however, treat this value as an integral value representing the integer index to the list of alternate results it may produce during the execution; for instance, the feature 'Stylistic Alternates' or 'salt' uses the <strong>parameter</strong> value as an index to the list of alternate substituting glyphs it could produce for a specified glyph. </p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_FEATURE']/*"/>	
    /// <msdn-id>dd368066</msdn-id>	
    /// <unmanaged>DWRITE_FONT_FEATURE</unmanaged>	
    /// <unmanaged-short>DWRITE_FONT_FEATURE</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct FontFeature {	
        
        /// <summary>	
        /// <dd> <p>The feature OpenType name identifier.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_FEATURE::nameTag']/*"/>	
        /// <msdn-id>dd368066</msdn-id>	
        /// <unmanaged>DWRITE_FONT_FEATURE_TAG nameTag</unmanaged>	
        /// <unmanaged-short>DWRITE_FONT_FEATURE_TAG nameTag</unmanaged-short>	
        public SharpDX.DirectWrite.FontFeatureTag NameTag;
        
        /// <summary>	
        /// <dd> <p>The execution parameter of the feature.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_FEATURE::parameter']/*"/>	
        /// <msdn-id>dd368066</msdn-id>	
        /// <unmanaged>unsigned int parameter</unmanaged>	
        /// <unmanaged-short>unsigned int parameter</unmanaged-short>	
        public int Parameter;
    }
    
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.DirectWrite.FontMetrics"/></strong> structure specifies the metrics that are applicable to all glyphs within the font face.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS']/*"/>	
    /// <msdn-id>dd368074</msdn-id>	
    /// <unmanaged>DWRITE_FONT_METRICS</unmanaged>	
    /// <unmanaged-short>DWRITE_FONT_METRICS</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct FontMetrics {	
        
        /// <summary>	
        /// <dd> <p>The number of font design units per em unit. Font files use their own coordinate system of font design units. A font design unit is the smallest measurable unit in the em square, an imaginary square that is used to size and align glyphs. The concept of em square is used as a reference scale factor when defining font size and device transformation semantics. The size of one em square is also commonly used to compute the paragraph identation value.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS::designUnitsPerEm']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>unsigned short designUnitsPerEm</unmanaged>	
        /// <unmanaged-short>unsigned short designUnitsPerEm</unmanaged-short>	
        public short DesignUnitsPerEm;
        
        /// <summary>	
        /// <dd> <p>The ascent value of the font face in font design units. Ascent is the distance from the top of font character alignment box to the English baseline.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS::ascent']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>unsigned short ascent</unmanaged>	
        /// <unmanaged-short>unsigned short ascent</unmanaged-short>	
        public short Ascent;
        
        /// <summary>	
        /// <dd> <p>The descent value of the font face in font design units. Descent is the distance from the bottom of font character alignment box to the English baseline.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS::descent']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>unsigned short descent</unmanaged>	
        /// <unmanaged-short>unsigned short descent</unmanaged-short>	
        public short Descent;
        
        /// <summary>	
        /// <dd> <p>The line gap in font design units. Recommended additional white space to add between lines to improve legibility. The recommended line spacing (baseline-to-baseline distance) is  the sum of <strong>ascent</strong>, <strong>descent</strong>, and <strong>lineGap</strong>. The line gap is usually positive or zero but can be negative, in which case the recommended line spacing is less than the height of the character alignment box.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS::lineGap']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>short lineGap</unmanaged>	
        /// <unmanaged-short>short lineGap</unmanaged-short>	
        public short LineGap;
        
        /// <summary>	
        /// <dd> <p>The cap height value of the font face in font design units. Cap height is the distance from the English baseline to the top of a typical English capital. Capital "H" is often used as a reference character for the purpose of calculating the cap height value.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS::capHeight']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>unsigned short capHeight</unmanaged>	
        /// <unmanaged-short>unsigned short capHeight</unmanaged-short>	
        public short CapHeight;
        
        /// <summary>	
        /// <dd> <p>The x-height value of the font face in font design units. x-height is the distance from the English baseline to the top of lowercase letter "x", or a similar lowercase character.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS::xHeight']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>unsigned short xHeight</unmanaged>	
        /// <unmanaged-short>unsigned short xHeight</unmanaged-short>	
        public short XHeight;
        
        /// <summary>	
        /// <dd> <p>The underline position value of the font face in font design units. Underline position is the position of underline relative to the English baseline. The value is usually made negative in order to place the underline below the baseline.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS::underlinePosition']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>short underlinePosition</unmanaged>	
        /// <unmanaged-short>short underlinePosition</unmanaged-short>	
        public short UnderlinePosition;
        
        /// <summary>	
        /// <dd> <p>The suggested underline thickness value of the font face in font design units.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS::underlineThickness']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>unsigned short underlineThickness</unmanaged>	
        /// <unmanaged-short>unsigned short underlineThickness</unmanaged-short>	
        public short UnderlineThickness;
        
        /// <summary>	
        /// <dd> <p>The strikethrough position value of the font face in font design units. Strikethrough position is the position of strikethrough relative to the English baseline. The value is usually made positive in order to place the strikethrough above the baseline.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS::strikethroughPosition']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>short strikethroughPosition</unmanaged>	
        /// <unmanaged-short>short strikethroughPosition</unmanaged-short>	
        public short StrikethroughPosition;
        
        /// <summary>	
        /// <dd> <p>The suggested strikethrough thickness value of the font face in font design units.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS::strikethroughThickness']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>unsigned short strikethroughThickness</unmanaged>	
        /// <unmanaged-short>unsigned short strikethroughThickness</unmanaged-short>	
        public short StrikethroughThickness;
    }
    
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.DirectWrite.FontMetrics"/></strong> structure specifies the metrics that are applicable to all glyphs within the font face.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS1']/*"/>	
    /// <msdn-id>dd368074</msdn-id>	
    /// <unmanaged>DWRITE_FONT_METRICS1</unmanaged>	
    /// <unmanaged-short>DWRITE_FONT_METRICS1</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct FontMetrics1 {	
        
        /// <summary>	
        /// <dd> <p>The number of font design units per em unit. Font files use their own coordinate system of font design units. A font design unit is the smallest measurable unit in the em square, an imaginary square that is used to size and align glyphs. The concept of em square is used as a reference scale factor when defining font size and device transformation semantics. The size of one em square is also commonly used to compute the paragraph identation value.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS1::glyphBoxLeft']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>short glyphBoxLeft</unmanaged>	
        /// <unmanaged-short>short glyphBoxLeft</unmanaged-short>	
        public short GlyphBoxLeft;
        
        /// <summary>	
        /// <dd> <p>The ascent value of the font face in font design units. Ascent is the distance from the top of font character alignment box to the English baseline.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS1::glyphBoxTop']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>short glyphBoxTop</unmanaged>	
        /// <unmanaged-short>short glyphBoxTop</unmanaged-short>	
        public short GlyphBoxTop;
        
        /// <summary>	
        /// <dd> <p>The descent value of the font face in font design units. Descent is the distance from the bottom of font character alignment box to the English baseline.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS1::glyphBoxRight']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>short glyphBoxRight</unmanaged>	
        /// <unmanaged-short>short glyphBoxRight</unmanaged-short>	
        public short GlyphBoxRight;
        
        /// <summary>	
        /// <dd> <p>The line gap in font design units. Recommended additional white space to add between lines to improve legibility. The recommended line spacing (baseline-to-baseline distance) is  the sum of <strong>ascent</strong>, <strong>descent</strong>, and <strong>lineGap</strong>. The line gap is usually positive or zero but can be negative, in which case the recommended line spacing is less than the height of the character alignment box.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS1::glyphBoxBottom']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>short glyphBoxBottom</unmanaged>	
        /// <unmanaged-short>short glyphBoxBottom</unmanaged-short>	
        public short GlyphBoxBottom;
        
        /// <summary>	
        /// <dd> <p>The cap height value of the font face in font design units. Cap height is the distance from the English baseline to the top of a typical English capital. Capital "H" is often used as a reference character for the purpose of calculating the cap height value.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS1::subscriptPositionX']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>short subscriptPositionX</unmanaged>	
        /// <unmanaged-short>short subscriptPositionX</unmanaged-short>	
        public short SubscriptPositionX;
        
        /// <summary>	
        /// <dd> <p>The x-height value of the font face in font design units. x-height is the distance from the English baseline to the top of lowercase letter "x", or a similar lowercase character.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS1::subscriptPositionY']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>short subscriptPositionY</unmanaged>	
        /// <unmanaged-short>short subscriptPositionY</unmanaged-short>	
        public short SubscriptPositionY;
        
        /// <summary>	
        /// <dd> <p>The underline position value of the font face in font design units. Underline position is the position of underline relative to the English baseline. The value is usually made negative in order to place the underline below the baseline.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS1::subscriptSizeX']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>short subscriptSizeX</unmanaged>	
        /// <unmanaged-short>short subscriptSizeX</unmanaged-short>	
        public short SubscriptSizeX;
        
        /// <summary>	
        /// <dd> <p>The suggested underline thickness value of the font face in font design units.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS1::subscriptSizeY']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>short subscriptSizeY</unmanaged>	
        /// <unmanaged-short>short subscriptSizeY</unmanaged-short>	
        public short SubscriptSizeY;
        
        /// <summary>	
        /// <dd> <p>The strikethrough position value of the font face in font design units. Strikethrough position is the position of strikethrough relative to the English baseline. The value is usually made positive in order to place the strikethrough above the baseline.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS1::superscriptPositionX']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>short superscriptPositionX</unmanaged>	
        /// <unmanaged-short>short superscriptPositionX</unmanaged-short>	
        public short SuperscriptPositionX;
        
        /// <summary>	
        /// <dd> <p>The suggested strikethrough thickness value of the font face in font design units.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS1::superscriptPositionY']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>short superscriptPositionY</unmanaged>	
        /// <unmanaged-short>short superscriptPositionY</unmanaged-short>	
        public short SuperscriptPositionY;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS1::superscriptSizeX']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>short superscriptSizeX</unmanaged>	
        /// <unmanaged-short>short superscriptSizeX</unmanaged-short>	
        public short SuperscriptSizeX;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS1::superscriptSizeY']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>short superscriptSizeY</unmanaged>	
        /// <unmanaged-short>short superscriptSizeY</unmanaged-short>	
        public short SuperscriptSizeY;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_FONT_METRICS1::hasTypographicMetrics']/*"/>	
        /// <msdn-id>dd368074</msdn-id>	
        /// <unmanaged>BOOL hasTypographicMetrics</unmanaged>	
        /// <unmanaged-short>BOOL hasTypographicMetrics</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool HasTypographicMetrics;
    }
    
    /// <summary>	
    /// <p>Specifies the metrics of an individual glyph. The units depend on how the metrics are obtained.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_METRICS']/*"/>	
    /// <msdn-id>dd368084</msdn-id>	
    /// <unmanaged>DWRITE_GLYPH_METRICS</unmanaged>	
    /// <unmanaged-short>DWRITE_GLYPH_METRICS</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct GlyphMetrics {	
        
        /// <summary>	
        /// <dd> <p>Specifies the X offset from the glyph origin to the left edge of the black box. The glyph origin is the current horizontal writing position. A negative value means the black box extends to the left of the origin (often true for lowercase italic 'f').</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_METRICS::leftSideBearing']/*"/>	
        /// <msdn-id>dd368084</msdn-id>	
        /// <unmanaged>int leftSideBearing</unmanaged>	
        /// <unmanaged-short>int leftSideBearing</unmanaged-short>	
        public int LeftSideBearing;
        
        /// <summary>	
        /// <dd> <p>Specifies the X offset from the origin of the current glyph to the origin of the next glyph when writing horizontally.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_METRICS::advanceWidth']/*"/>	
        /// <msdn-id>dd368084</msdn-id>	
        /// <unmanaged>unsigned int advanceWidth</unmanaged>	
        /// <unmanaged-short>unsigned int advanceWidth</unmanaged-short>	
        public int AdvanceWidth;
        
        /// <summary>	
        /// <dd> <p>Specifies the X offset from the right edge of the black box to the origin of the next glyph when writing horizontally. The value is negative when the right edge of the black box overhangs the layout box.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_METRICS::rightSideBearing']/*"/>	
        /// <msdn-id>dd368084</msdn-id>	
        /// <unmanaged>int rightSideBearing</unmanaged>	
        /// <unmanaged-short>int rightSideBearing</unmanaged-short>	
        public int RightSideBearing;
        
        /// <summary>	
        /// <dd> <p>Specifies the vertical offset from the vertical origin to the top of the black box. Thus, a positive value adds whitespace whereas a negative value means the glyph overhangs the top of the layout box.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_METRICS::topSideBearing']/*"/>	
        /// <msdn-id>dd368084</msdn-id>	
        /// <unmanaged>int topSideBearing</unmanaged>	
        /// <unmanaged-short>int topSideBearing</unmanaged-short>	
        public int TopSideBearing;
        
        /// <summary>	
        /// <dd> <p>Specifies the Y offset from the vertical origin of the current glyph to the vertical origin of the next glyph when writing vertically. Note that the term "origin" by itself denotes the horizontal origin. The vertical origin is different. Its Y coordinate is specified by <strong>verticalOriginY</strong> value, and its X coordinate is half the <strong>advanceWidth</strong> to the right of the horizontal origin.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_METRICS::advanceHeight']/*"/>	
        /// <msdn-id>dd368084</msdn-id>	
        /// <unmanaged>unsigned int advanceHeight</unmanaged>	
        /// <unmanaged-short>unsigned int advanceHeight</unmanaged-short>	
        public int AdvanceHeight;
        
        /// <summary>	
        /// <dd> <p>Specifies the vertical distance from the bottom edge of the black box to the advance height. This is positive when the bottom edge of the black box is within the layout box, or negative when the bottom edge of black box overhangs the layout box.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_METRICS::bottomSideBearing']/*"/>	
        /// <msdn-id>dd368084</msdn-id>	
        /// <unmanaged>int bottomSideBearing</unmanaged>	
        /// <unmanaged-short>int bottomSideBearing</unmanaged-short>	
        public int BottomSideBearing;
        
        /// <summary>	
        /// <dd> <p>Specifies the Y coordinate of a glyph's vertical origin, in the font's design coordinate system. The y coordinate of a glyph's vertical origin is the sum of the glyph's top side bearing and the top (that is, yMax) of the glyph's bounding box.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_METRICS::verticalOriginY']/*"/>	
        /// <msdn-id>dd368084</msdn-id>	
        /// <unmanaged>int verticalOriginY</unmanaged>	
        /// <unmanaged-short>int verticalOriginY</unmanaged-short>	
        public int VerticalOriginY;
    }
    
    /// <summary>	
    /// <p>The optional adjustment to a glyph's position.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An glyph offset changes the position of a glyph without affecting the pen position. Offsets are in logical, pre-transform units.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_OFFSET']/*"/>	
    /// <msdn-id>dd368086</msdn-id>	
    /// <unmanaged>DWRITE_GLYPH_OFFSET</unmanaged>	
    /// <unmanaged-short>DWRITE_GLYPH_OFFSET</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct GlyphOffset {	
        
        /// <summary>	
        /// <dd> <p>The offset in the advance direction of the run. A positive advance offset moves the glyph to the right (in pre-transform coordinates) if the run is left-to-right or to the left if the run is right-to-left.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_OFFSET::advanceOffset']/*"/>	
        /// <msdn-id>dd368086</msdn-id>	
        /// <unmanaged>float advanceOffset</unmanaged>	
        /// <unmanaged-short>float advanceOffset</unmanaged-short>	
        public float AdvanceOffset;
        
        /// <summary>	
        /// <dd> <p>The offset in the ascent direction, that is, the direction ascenders point. A positive ascender offset moves the glyph up (in pre-transform coordinates).  A negative ascender offset moves the glyph down.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_OFFSET::ascenderOffset']/*"/>	
        /// <msdn-id>dd368086</msdn-id>	
        /// <unmanaged>float ascenderOffset</unmanaged>	
        /// <unmanaged-short>float ascenderOffset</unmanaged-short>	
        public float AscenderOffset;
    }
    
    /// <summary>	
    /// <p>Contains the information needed by renderers to draw glyph runs.  All coordinates are in device independent pixels (DIPs). </p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_RUN']/*"/>	
    /// <msdn-id>dd368089</msdn-id>	
    /// <unmanaged>DWRITE_GLYPH_RUN</unmanaged>	
    /// <unmanaged-short>DWRITE_GLYPH_RUN</unmanaged-short>	
    public  partial class GlyphRun {	
        
        /// <summary>	
        /// <dd> <p>The physical font face object to draw with.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_RUN::fontFace']/*"/>	
        /// <msdn-id>dd368089</msdn-id>	
        /// <unmanaged>IDWriteFontFace* fontFace</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace fontFace</unmanaged-short>	
        internal System.IntPtr FontFacePointer;
        
        /// <summary>	
        /// <dd> <p>The logical size of the font in DIPs (equals 1/96 inch), not points.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_RUN::fontEmSize']/*"/>	
        /// <msdn-id>dd368089</msdn-id>	
        /// <unmanaged>float fontEmSize</unmanaged>	
        /// <unmanaged-short>float fontEmSize</unmanaged-short>	
        public float FontSize;
        
        /// <summary>	
        /// <dd> <p>The number of glyphs in the glyph run.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_RUN::glyphCount']/*"/>	
        /// <msdn-id>dd368089</msdn-id>	
        /// <unmanaged>unsigned int glyphCount</unmanaged>	
        /// <unmanaged-short>unsigned int glyphCount</unmanaged-short>	
        internal int GlyphCount;
        
        /// <summary>	
        /// <dd> <p>A reference to an array of indices to render for the glyph run.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_RUN::glyphIndices']/*"/>	
        /// <msdn-id>dd368089</msdn-id>	
        /// <unmanaged>const unsigned short* glyphIndices</unmanaged>	
        /// <unmanaged-short>unsigned short glyphIndices</unmanaged-short>	
        internal System.IntPtr GlyphIndicesPointer;
        
        /// <summary>	
        /// <dd> <p>A reference to an array containing glyph advance widths for the glyph run.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_RUN::glyphAdvances']/*"/>	
        /// <msdn-id>dd368089</msdn-id>	
        /// <unmanaged>const float* glyphAdvances</unmanaged>	
        /// <unmanaged-short>float glyphAdvances</unmanaged-short>	
        internal System.IntPtr GlyphAdvancesPointer;
        
        /// <summary>	
        /// <dd> <p>A reference to an array containing glyph offsets for the glyph run.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_RUN::glyphOffsets']/*"/>	
        /// <msdn-id>dd368089</msdn-id>	
        /// <unmanaged>const DWRITE_GLYPH_OFFSET* glyphOffsets</unmanaged>	
        /// <unmanaged-short>DWRITE_GLYPH_OFFSET glyphOffsets</unmanaged-short>	
        internal System.IntPtr GlyphOffsetsPointer;
        
        /// <summary>	
        /// <dd> <p>If true, specifies that glyphs are rotated 90 degrees to the left and vertical metrics are used. Vertical writing is achieved by specifying <strong>isSideways</strong> = true and rotating the entire run 90 degrees to the right via a rotate transform.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_RUN::isSideways']/*"/>	
        /// <msdn-id>dd368089</msdn-id>	
        /// <unmanaged>BOOL isSideways</unmanaged>	
        /// <unmanaged-short>BOOL isSideways</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool IsSideways;
        
        /// <summary>	
        /// <dd> <p>The implicit resolved bidi level of the run. Odd levels indicate right-to-left languages like Hebrew and Arabic, while even levels indicate left-to-right languages like English and Japanese (when written horizontally). For right-to-left languages, the text origin is on the right, and text should be drawn to the left.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_RUN::bidiLevel']/*"/>	
        /// <msdn-id>dd368089</msdn-id>	
        /// <unmanaged>unsigned int bidiLevel</unmanaged>	
        /// <unmanaged-short>unsigned int bidiLevel</unmanaged-short>	
        public int BidiLevel;
    }
    
    /// <summary>	
    /// <p>Contains additional properties related to those in <strong><see cref="SharpDX.DirectWrite.GlyphRun"/></strong>.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_RUN_DESCRIPTION']/*"/>	
    /// <msdn-id>dd368091</msdn-id>	
    /// <unmanaged>DWRITE_GLYPH_RUN_DESCRIPTION</unmanaged>	
    /// <unmanaged-short>DWRITE_GLYPH_RUN_DESCRIPTION</unmanaged-short>	
    public  partial class GlyphRunDescription {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_RUN_DESCRIPTION::localeName']/*"/>	
        /// <msdn-id>dd368091</msdn-id>	
        /// <unmanaged>const wchar_t* localeName</unmanaged>	
        /// <unmanaged-short>wchar_t localeName</unmanaged-short>	
        public string LocaleName;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_RUN_DESCRIPTION::string']/*"/>	
        /// <msdn-id>dd368091</msdn-id>	
        /// <unmanaged>const wchar_t* string</unmanaged>	
        /// <unmanaged-short>wchar_t string</unmanaged-short>	
        public string Text;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_RUN_DESCRIPTION::stringLength']/*"/>	
        /// <msdn-id>dd368091</msdn-id>	
        /// <unmanaged>unsigned int stringLength</unmanaged>	
        /// <unmanaged-short>unsigned int stringLength</unmanaged-short>	
        internal int TextLength;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_RUN_DESCRIPTION::clusterMap']/*"/>	
        /// <msdn-id>dd368091</msdn-id>	
        /// <unmanaged>const unsigned short* clusterMap</unmanaged>	
        /// <unmanaged-short>unsigned short clusterMap</unmanaged-short>	
        public System.IntPtr ClusterMap;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_GLYPH_RUN_DESCRIPTION::textPosition']/*"/>	
        /// <msdn-id>dd368091</msdn-id>	
        /// <unmanaged>unsigned int textPosition</unmanaged>	
        /// <unmanaged-short>unsigned int textPosition</unmanaged-short>	
        public int TextPosition;
    }
    
    /// <summary>	
    /// <p>Describes the region obtained by a hit test.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_HIT_TEST_METRICS']/*"/>	
    /// <msdn-id>dd368092</msdn-id>	
    /// <unmanaged>DWRITE_HIT_TEST_METRICS</unmanaged>	
    /// <unmanaged-short>DWRITE_HIT_TEST_METRICS</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct HitTestMetrics {	
        
        /// <summary>	
        /// <dd> <p>The first text position within the hit region. </p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_HIT_TEST_METRICS::textPosition']/*"/>	
        /// <msdn-id>dd368092</msdn-id>	
        /// <unmanaged>unsigned int textPosition</unmanaged>	
        /// <unmanaged-short>unsigned int textPosition</unmanaged-short>	
        public int TextPosition;
        
        /// <summary>	
        /// <dd> <p>The number of text positions within the hit region. </p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_HIT_TEST_METRICS::length']/*"/>	
        /// <msdn-id>dd368092</msdn-id>	
        /// <unmanaged>unsigned int length</unmanaged>	
        /// <unmanaged-short>unsigned int length</unmanaged-short>	
        public int Length;
        
        /// <summary>	
        /// <dd> <p>The x-coordinate of the upper-left corner of the hit region.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_HIT_TEST_METRICS::left']/*"/>	
        /// <msdn-id>dd368092</msdn-id>	
        /// <unmanaged>float left</unmanaged>	
        /// <unmanaged-short>float left</unmanaged-short>	
        public float Left;
        
        /// <summary>	
        /// <dd> <p>The y-coordinate of the upper-left corner of the hit region.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_HIT_TEST_METRICS::top']/*"/>	
        /// <msdn-id>dd368092</msdn-id>	
        /// <unmanaged>float top</unmanaged>	
        /// <unmanaged-short>float top</unmanaged-short>	
        public float Top;
        
        /// <summary>	
        /// <dd> <p>The width of the hit region.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_HIT_TEST_METRICS::width']/*"/>	
        /// <msdn-id>dd368092</msdn-id>	
        /// <unmanaged>float width</unmanaged>	
        /// <unmanaged-short>float width</unmanaged-short>	
        public float Width;
        
        /// <summary>	
        /// <dd> <p>The height of the hit region.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_HIT_TEST_METRICS::height']/*"/>	
        /// <msdn-id>dd368092</msdn-id>	
        /// <unmanaged>float height</unmanaged>	
        /// <unmanaged-short>float height</unmanaged-short>	
        public float Height;
        
        /// <summary>	
        /// <dd> <p>The <strong>BIDI level</strong> of the text positions within the hit region.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_HIT_TEST_METRICS::bidiLevel']/*"/>	
        /// <msdn-id>dd368092</msdn-id>	
        /// <unmanaged>unsigned int bidiLevel</unmanaged>	
        /// <unmanaged-short>unsigned int bidiLevel</unmanaged-short>	
        public int BidiLevel;
        
        /// <summary>	
        /// <dd> <p>true if the hit region contains text; otherwise, false.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_HIT_TEST_METRICS::isText']/*"/>	
        /// <msdn-id>dd368092</msdn-id>	
        /// <unmanaged>BOOL isText</unmanaged>	
        /// <unmanaged-short>BOOL isText</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool IsText;
        
        /// <summary>	
        /// <dd> <p>true if the text range is trimmed; otherwise, false.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_HIT_TEST_METRICS::isTrimmed']/*"/>	
        /// <msdn-id>dd368092</msdn-id>	
        /// <unmanaged>BOOL isTrimmed</unmanaged>	
        /// <unmanaged-short>BOOL isTrimmed</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool IsTrimmed;
    }
    
    /// <summary>	
    /// <p>Contains properties describing the geometric measurement of an	
    /// application-defined inline object.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_INLINE_OBJECT_METRICS']/*"/>	
    /// <msdn-id>dd368096</msdn-id>	
    /// <unmanaged>DWRITE_INLINE_OBJECT_METRICS</unmanaged>	
    /// <unmanaged-short>DWRITE_INLINE_OBJECT_METRICS</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct InlineObjectMetrics {	
        
        /// <summary>	
        /// <dd> <p>The width of the inline object.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_INLINE_OBJECT_METRICS::width']/*"/>	
        /// <msdn-id>dd368096</msdn-id>	
        /// <unmanaged>float width</unmanaged>	
        /// <unmanaged-short>float width</unmanaged-short>	
        public float Width;
        
        /// <summary>	
        /// <dd> <p>The height of the inline object.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_INLINE_OBJECT_METRICS::height']/*"/>	
        /// <msdn-id>dd368096</msdn-id>	
        /// <unmanaged>float height</unmanaged>	
        /// <unmanaged-short>float height</unmanaged-short>	
        public float Height;
        
        /// <summary>	
        /// <dd> <p>The distance from the top of the object to the point where it is lined up with the adjacent text.  If the baseline is at the bottom, then <strong>baseline</strong> simply equals <strong>height</strong>.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_INLINE_OBJECT_METRICS::baseline']/*"/>	
        /// <msdn-id>dd368096</msdn-id>	
        /// <unmanaged>float baseline</unmanaged>	
        /// <unmanaged-short>float baseline</unmanaged-short>	
        public float Baseline;
        
        /// <summary>	
        /// <dd> <p>A Boolean flag that indicates whether the object is to be placed upright or alongside the text baseline for vertical text.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_INLINE_OBJECT_METRICS::supportsSideways']/*"/>	
        /// <msdn-id>dd368096</msdn-id>	
        /// <unmanaged>BOOL supportsSideways</unmanaged>	
        /// <unmanaged-short>BOOL supportsSideways</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool SupportsSideways;
    }
    
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.DirectWrite.JustificationOpportunity"/></strong> structure specifies justification info per glyph.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_JUSTIFICATION_OPPORTUNITY']/*"/>	
    /// <msdn-id>jj126261</msdn-id>	
    /// <unmanaged>DWRITE_JUSTIFICATION_OPPORTUNITY</unmanaged>	
    /// <unmanaged-short>DWRITE_JUSTIFICATION_OPPORTUNITY</unmanaged-short>	
    [StructLayout(LayoutKind.Explicit)]
    public  partial struct JustificationOpportunity {	
        
        /// <summary>	
        /// <dd> <p>Minimum amount of expansion to apply to the side of the glyph. This might vary from zero to infinity, typically being zero except for kashida.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_JUSTIFICATION_OPPORTUNITY::expansionMinimum']/*"/>	
        /// <msdn-id>jj126261</msdn-id>	
        /// <unmanaged>float expansionMinimum</unmanaged>	
        /// <unmanaged-short>float expansionMinimum</unmanaged-short>	
        [FieldOffset(0)]
        public float ExpansionMinimum;
        
        /// <summary>	
        /// <dd> <p>Maximum amount of expansion to apply to the side of the glyph. This might vary from zero to infinity, being zero for fixed-size characters and connected scripts, and non-zero for discrete scripts, and non-zero for cursive scripts at expansion points.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_JUSTIFICATION_OPPORTUNITY::expansionMaximum']/*"/>	
        /// <msdn-id>jj126261</msdn-id>	
        /// <unmanaged>float expansionMaximum</unmanaged>	
        /// <unmanaged-short>float expansionMaximum</unmanaged-short>	
        [FieldOffset(4)]
        public float ExpansionMaximum;
        
        /// <summary>	
        /// <dd> <p>Maximum amount of compression to apply to the side of the glyph. This might vary from zero up to the glyph cluster size.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_JUSTIFICATION_OPPORTUNITY::compressionMaximum']/*"/>	
        /// <msdn-id>jj126261</msdn-id>	
        /// <unmanaged>float compressionMaximum</unmanaged>	
        /// <unmanaged-short>float compressionMaximum</unmanaged-short>	
        [FieldOffset(8)]
        public float CompressionMaximum;
        
        /// <summary>	
        /// <dd> <p>Priority of this expansion point. Larger priorities are applied later, while priority zero does nothing.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_JUSTIFICATION_OPPORTUNITY::expansionPriority']/*"/>	
        /// <msdn-id>jj126261</msdn-id>	
        /// <unmanaged>unsigned int expansionPriority</unmanaged>	
        /// <unmanaged-short>unsigned int expansionPriority</unmanaged-short>	
        public int  ExpansionPriority { 
            get { 
                return (int)((_ExpansionPriority >> 0)  &  255);
            }
            set { 
                _ExpansionPriority = (int)((_ExpansionPriority & ~( 255 << 0)) | ( (value & 255) << 0));
            }
        }
        [FieldOffset(12)]
        internal int _ExpansionPriority;
		
        
        /// <summary>	
        /// <dd> <p>Priority of this compression point. Larger priorities are applied later, while priority zero does nothing.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_JUSTIFICATION_OPPORTUNITY::compressionPriority']/*"/>	
        /// <msdn-id>jj126261</msdn-id>	
        /// <unmanaged>unsigned int compressionPriority</unmanaged>	
        /// <unmanaged-short>unsigned int compressionPriority</unmanaged-short>	
        public int  CompressionPriority { 
            get { 
                return (int)((_CompressionPriority >> 8)  &  255);
            }
            set { 
                _CompressionPriority = (int)((_CompressionPriority & ~( 255 << 8)) | ( (value & 255) << 8));
            }
        }
        [FieldOffset(12)]
        internal int _CompressionPriority;
		
        
        /// <summary>	
        /// <dd> <p>Allow this expansion point to use up any remaining slack space even after all expansion priorities have been used up.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_JUSTIFICATION_OPPORTUNITY::allowResidualExpansion']/*"/>	
        /// <msdn-id>jj126261</msdn-id>	
        /// <unmanaged>unsigned int allowResidualExpansion</unmanaged>	
        /// <unmanaged-short>unsigned int allowResidualExpansion</unmanaged-short>	
        public bool  AllowResidualExpansion { 
            get { 
                return 0 != ((_AllowResidualExpansion >> 16)  &  1);
            }
            set { 
                _AllowResidualExpansion = (int)((_AllowResidualExpansion & ~( 1 << 16)) | ( ( (value?1:0) & 1) << 16));
            }
        }
        [FieldOffset(12)]
        internal int _AllowResidualExpansion;
		
        
        /// <summary>	
        /// <dd> <p>Allow this compression point to use up any remaining space even after all compression priorities have been used up.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_JUSTIFICATION_OPPORTUNITY::allowResidualCompression']/*"/>	
        /// <msdn-id>jj126261</msdn-id>	
        /// <unmanaged>unsigned int allowResidualCompression</unmanaged>	
        /// <unmanaged-short>unsigned int allowResidualCompression</unmanaged-short>	
        public bool  AllowResidualCompression { 
            get { 
                return 0 != ((_AllowResidualCompression >> 17)  &  1);
            }
            set { 
                _AllowResidualCompression = (int)((_AllowResidualCompression & ~( 1 << 17)) | ( ( (value?1:0) & 1) << 17));
            }
        }
        [FieldOffset(12)]
        internal int _AllowResidualCompression;
		
        
        /// <summary>	
        /// <dd> <p>Apply expansion and compression to the leading edge of the glyph. This bit is <strong><see cref="SharpDX.Result.False"/></strong> (0) for connected scripts, fixed-size characters, and diacritics. It is generally <strong><see cref="SharpDX.Result.False"/></strong> within a multi-glyph cluster, unless the script allows expansion of glyphs within a cluster, like Thai.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_JUSTIFICATION_OPPORTUNITY::applyToLeadingEdge']/*"/>	
        /// <msdn-id>jj126261</msdn-id>	
        /// <unmanaged>unsigned int applyToLeadingEdge</unmanaged>	
        /// <unmanaged-short>unsigned int applyToLeadingEdge</unmanaged-short>	
        public bool  ApplyToLeadingEdge { 
            get { 
                return 0 != ((_ApplyToLeadingEdge >> 18)  &  1);
            }
            set { 
                _ApplyToLeadingEdge = (int)((_ApplyToLeadingEdge & ~( 1 << 18)) | ( ( (value?1:0) & 1) << 18));
            }
        }
        [FieldOffset(12)]
        internal int _ApplyToLeadingEdge;
		
        
        /// <summary>	
        /// <dd> <p>Apply expansion and compression to the trailing edge of the glyph. This bit is <strong><see cref="SharpDX.Result.False"/></strong> (0) for connected scripts, fixed-size characters, and diacritics. It is generally <strong><see cref="SharpDX.Result.False"/></strong> within a multi-glyph cluster, unless the script allows expansion of glyphs within a cluster, like Thai.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_JUSTIFICATION_OPPORTUNITY::applyToTrailingEdge']/*"/>	
        /// <msdn-id>jj126261</msdn-id>	
        /// <unmanaged>unsigned int applyToTrailingEdge</unmanaged>	
        /// <unmanaged-short>unsigned int applyToTrailingEdge</unmanaged-short>	
        public bool  ApplyToTrailingEdge { 
            get { 
                return 0 != ((_ApplyToTrailingEdge >> 19)  &  1);
            }
            set { 
                _ApplyToTrailingEdge = (int)((_ApplyToTrailingEdge & ~( 1 << 19)) | ( ( (value?1:0) & 1) << 19));
            }
        }
        [FieldOffset(12)]
        internal int _ApplyToTrailingEdge;
		
        
        /// <summary>	
        /// <dd> <p>Reserved</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_JUSTIFICATION_OPPORTUNITY::reserved']/*"/>	
        /// <msdn-id>jj126261</msdn-id>	
        /// <unmanaged>unsigned int reserved</unmanaged>	
        /// <unmanaged-short>unsigned int reserved</unmanaged-short>	
        public int  Reserved { 
            get { 
                return (int)((_Reserved >> 20)  &  4095);
            }
            set { 
                _Reserved = (int)((_Reserved & ~( 4095 << 20)) | ( (value & 4095) << 20));
            }
        }
        [FieldOffset(12)]
        internal int _Reserved;
		
    }
    
    /// <summary>	
    /// <p>Line breakpoint characteristics of a character.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_LINE_BREAKPOINT']/*"/>	
    /// <msdn-id>dd368098</msdn-id>	
    /// <unmanaged>DWRITE_LINE_BREAKPOINT</unmanaged>	
    /// <unmanaged-short>DWRITE_LINE_BREAKPOINT</unmanaged-short>	
    [StructLayout(LayoutKind.Explicit)]
    public  partial struct LineBreakpoint {	
        
        /// <summary>	
        /// <dd> <p>Indicates a breaking condition before the character.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_LINE_BREAKPOINT::breakConditionBefore']/*"/>	
        /// <msdn-id>dd368098</msdn-id>	
        /// <unmanaged>unsigned char breakConditionBefore</unmanaged>	
        /// <unmanaged-short>unsigned char breakConditionBefore</unmanaged-short>	
        internal byte  BreakConditionBefore_ { 
            get { 
                return (byte)((_BreakConditionBefore_ >> 0)  &  3);
            }
            set { 
                _BreakConditionBefore_ = (byte)((_BreakConditionBefore_ & ~( 3 << 0)) | ( (value & 3) << 0));
            }
        }
        [FieldOffset(0)]
        internal byte _BreakConditionBefore_;
		
        
        /// <summary>	
        /// <dd> <p>Indicates a breaking condition after the character.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_LINE_BREAKPOINT::breakConditionAfter']/*"/>	
        /// <msdn-id>dd368098</msdn-id>	
        /// <unmanaged>unsigned char breakConditionAfter</unmanaged>	
        /// <unmanaged-short>unsigned char breakConditionAfter</unmanaged-short>	
        internal byte  BreakConditionAfter_ { 
            get { 
                return (byte)((_BreakConditionAfter_ >> 2)  &  3);
            }
            set { 
                _BreakConditionAfter_ = (byte)((_BreakConditionAfter_ & ~( 3 << 2)) | ( (value & 3) << 2));
            }
        }
        [FieldOffset(0)]
        internal byte _BreakConditionAfter_;
		
        
        /// <summary>	
        /// <dd> <p>Indicates that the character is some form of whitespace, which may be meaningful for justification.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_LINE_BREAKPOINT::isWhitespace']/*"/>	
        /// <msdn-id>dd368098</msdn-id>	
        /// <unmanaged>unsigned char isWhitespace</unmanaged>	
        /// <unmanaged-short>unsigned char isWhitespace</unmanaged-short>	
        public bool  IsWhitespace { 
            get { 
                return 0 != ((_IsWhitespace >> 4)  &  1);
            }
            set { 
                _IsWhitespace = (byte)((_IsWhitespace & ~( 1 << 4)) | ( ( (value?1:0) & 1) << 4));
            }
        }
        [FieldOffset(0)]
        internal byte _IsWhitespace;
		
        
        /// <summary>	
        /// <dd> <p>Indicates that the character is a soft hyphen, often used to indicate hyphenation points inside words.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_LINE_BREAKPOINT::isSoftHyphen']/*"/>	
        /// <msdn-id>dd368098</msdn-id>	
        /// <unmanaged>unsigned char isSoftHyphen</unmanaged>	
        /// <unmanaged-short>unsigned char isSoftHyphen</unmanaged-short>	
        public bool  IsSoftHyphen { 
            get { 
                return 0 != ((_IsSoftHyphen >> 5)  &  1);
            }
            set { 
                _IsSoftHyphen = (byte)((_IsSoftHyphen & ~( 1 << 5)) | ( ( (value?1:0) & 1) << 5));
            }
        }
        [FieldOffset(0)]
        internal byte _IsSoftHyphen;
		
        
        /// <summary>	
        /// <dd> <p>Reserved for future use.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_LINE_BREAKPOINT::padding']/*"/>	
        /// <msdn-id>dd368098</msdn-id>	
        /// <unmanaged>unsigned char padding</unmanaged>	
        /// <unmanaged-short>unsigned char padding</unmanaged-short>	
        internal byte  Padding { 
            get { 
                return (byte)((_Padding >> 6)  &  3);
            }
            set { 
                _Padding = (byte)((_Padding & ~( 3 << 6)) | ( (value & 3) << 6));
            }
        }
        [FieldOffset(0)]
        internal byte _Padding;
		
    }
    
    /// <summary>	
    /// <p>Contains information about a formatted line of text.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_LINE_METRICS']/*"/>	
    /// <msdn-id>dd368099</msdn-id>	
    /// <unmanaged>DWRITE_LINE_METRICS</unmanaged>	
    /// <unmanaged-short>DWRITE_LINE_METRICS</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct LineMetrics {	
        
        /// <summary>	
        /// <dd> <p>The number of text positions in the text line.  This includes any trailing whitespace and newline characters.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_LINE_METRICS::length']/*"/>	
        /// <msdn-id>dd368099</msdn-id>	
        /// <unmanaged>unsigned int length</unmanaged>	
        /// <unmanaged-short>unsigned int length</unmanaged-short>	
        public int Length;
        
        /// <summary>	
        /// <dd> <p>The number of whitespace positions at the end of the text line.  Newline sequences are considered whitespace.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_LINE_METRICS::trailingWhitespaceLength']/*"/>	
        /// <msdn-id>dd368099</msdn-id>	
        /// <unmanaged>unsigned int trailingWhitespaceLength</unmanaged>	
        /// <unmanaged-short>unsigned int trailingWhitespaceLength</unmanaged-short>	
        public int TrailingWhitespaceLength;
        
        /// <summary>	
        /// <dd> <p>The number of characters in the newline sequence at the end of the text line.  If the count is zero, then the text line was either wrapped or it is the end of the text.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_LINE_METRICS::newlineLength']/*"/>	
        /// <msdn-id>dd368099</msdn-id>	
        /// <unmanaged>unsigned int newlineLength</unmanaged>	
        /// <unmanaged-short>unsigned int newlineLength</unmanaged-short>	
        public int NewlineLength;
        
        /// <summary>	
        /// <dd> <p>The height of the text line.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_LINE_METRICS::height']/*"/>	
        /// <msdn-id>dd368099</msdn-id>	
        /// <unmanaged>float height</unmanaged>	
        /// <unmanaged-short>float height</unmanaged-short>	
        public float Height;
        
        /// <summary>	
        /// <dd> <p>The distance from the top of the text line to its baseline.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_LINE_METRICS::baseline']/*"/>	
        /// <msdn-id>dd368099</msdn-id>	
        /// <unmanaged>float baseline</unmanaged>	
        /// <unmanaged-short>float baseline</unmanaged-short>	
        public float Baseline;
        
        /// <summary>	
        /// <dd> <p>The line is trimmed.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_LINE_METRICS::isTrimmed']/*"/>	
        /// <msdn-id>dd368099</msdn-id>	
        /// <unmanaged>BOOL isTrimmed</unmanaged>	
        /// <unmanaged-short>BOOL isTrimmed</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool IsTrimmed;
    }
    
    /// <summary>	
    /// <p>Indicates how much any visible DIPs (device independent pixels) overshoot each side of the layout or inline objects.</p><p>Positive overhangs indicate that the visible area extends outside the layout box or inline object, while negative values mean there is whitespace inside. The returned values are unaffected by rendering transforms or pixel snapping.  Additionally, they may not exactly match the final target's pixel bounds after applying grid fitting and hinting.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_OVERHANG_METRICS']/*"/>	
    /// <msdn-id>dd368109</msdn-id>	
    /// <unmanaged>DWRITE_OVERHANG_METRICS</unmanaged>	
    /// <unmanaged-short>DWRITE_OVERHANG_METRICS</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct OverhangMetrics {	
        
        /// <summary>	
        /// <dd> <p>The distance from the left-most visible DIP to its  left-alignment edge.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_OVERHANG_METRICS::left']/*"/>	
        /// <msdn-id>dd368109</msdn-id>	
        /// <unmanaged>float left</unmanaged>	
        /// <unmanaged-short>float left</unmanaged-short>	
        public float Left;
        
        /// <summary>	
        /// <dd> <p>The distance from the top-most visible DIP to its  top alignment edge.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_OVERHANG_METRICS::top']/*"/>	
        /// <msdn-id>dd368109</msdn-id>	
        /// <unmanaged>float top</unmanaged>	
        /// <unmanaged-short>float top</unmanaged-short>	
        public float Top;
        
        /// <summary>	
        /// <dd> <p>The distance from the right-most visible DIP to its  right-alignment edge.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_OVERHANG_METRICS::right']/*"/>	
        /// <msdn-id>dd368109</msdn-id>	
        /// <unmanaged>float right</unmanaged>	
        /// <unmanaged-short>float right</unmanaged-short>	
        public float Right;
        
        /// <summary>	
        /// <dd> <p>The distance from the bottom-most visible DIP to its lower-alignment edge.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_OVERHANG_METRICS::bottom']/*"/>	
        /// <msdn-id>dd368109</msdn-id>	
        /// <unmanaged>float bottom</unmanaged>	
        /// <unmanaged-short>float bottom</unmanaged-short>	
        public float Bottom;
    }
    
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.DirectWrite.PanoseCharacterRanges"/></strong> enumeration contains values that specify the type of characters available in the font.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE']/*"/>	
    /// <msdn-id>hh997724</msdn-id>	
    /// <unmanaged>DWRITE_PANOSE</unmanaged>	
    /// <unmanaged-short>DWRITE_PANOSE</unmanaged-short>	
    public  partial struct Panose {	
        
        /// <summary>	
        /// <dd> <p>Any range.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE::values']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char values[10]</unmanaged>	
        /// <unmanaged-short>unsigned char values</unmanaged-short>	
        public byte[] Values { 
            get { return _Values ?? (_Values = new byte[10]);}
        }
        internal byte[] _Values;
        
        /// <summary>	
        /// <dd> <p>No fit for range.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE::familyKind']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char familyKind</unmanaged>	
        /// <unmanaged-short>unsigned char familyKind</unmanaged-short>	
        public byte FamilyKind;
        
        /// <summary>	
        /// <dd> <p>The range includes extended collection.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE::text']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>DWRITE_PANOSE_INNER_0 text</unmanaged>	
        /// <unmanaged-short>DWRITE_PANOSE_INNER_0 text</unmanaged-short>	
        public SharpDX.DirectWrite.PanoseText Text;
        
        /// <summary>	
        /// <dd> <p>The range includes literals.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE::script']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>DWRITE_PANOSE_INNER_1 script</unmanaged>	
        /// <unmanaged-short>DWRITE_PANOSE_INNER_1 script</unmanaged-short>	
        public SharpDX.DirectWrite.PanoseScript Script;
        
        /// <summary>	
        /// <dd> <p>The range doesn't include lower case.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE::decorative']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>DWRITE_PANOSE_INNER_2 decorative</unmanaged>	
        /// <unmanaged-short>DWRITE_PANOSE_INNER_2 decorative</unmanaged-short>	
        public SharpDX.DirectWrite.PanoseDecorative Decorative;
        
        /// <summary>	
        /// <dd> <p>The range includes small capitals.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE::symbol']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>DWRITE_PANOSE_INNER_3 symbol</unmanaged>	
        /// <unmanaged-short>DWRITE_PANOSE_INNER_3 symbol</unmanaged-short>	
        public SharpDX.DirectWrite.PanoseSymbol Symbol;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Explicit)]
        internal partial struct __Native {	
            [FieldOffset(0)]
            public byte Values;
            [FieldOffset(1)]
            byte __Values1;
            [FieldOffset(2)]
            byte __Values2;
            [FieldOffset(3)]
            byte __Values3;
            [FieldOffset(4)]
            byte __Values4;
            [FieldOffset(5)]
            byte __Values5;
            [FieldOffset(6)]
            byte __Values6;
            [FieldOffset(7)]
            byte __Values7;
            [FieldOffset(8)]
            byte __Values8;
            [FieldOffset(9)]
            byte __Values9;
            [FieldOffset(0)]
            public byte FamilyKind;
            [FieldOffset(0)]
            public SharpDX.DirectWrite.PanoseText Text;
            [FieldOffset(0)]
            public SharpDX.DirectWrite.PanoseScript Script;
            [FieldOffset(0)]
            public SharpDX.DirectWrite.PanoseDecorative Decorative;
            [FieldOffset(0)]
            public SharpDX.DirectWrite.PanoseSymbol Symbol;
		    // Method to free unmanaged allocation
            internal unsafe void __MarshalFree()
            {   
            }
        }
		
		// Method to free unmanaged allocation
        internal unsafe void __MarshalFree(ref __Native @ref)
        {   
            @ref.__MarshalFree();
        }
		
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            fixed (void* __to = &this.Values[0]) fixed (void* __from = &@ref.Values) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 10*sizeof ( byte));
            this.FamilyKind = @ref.FamilyKind;
            this.Text = @ref.Text;
            this.Script = @ref.Script;
            this.Decorative = @ref.Decorative;
            this.Symbol = @ref.Symbol;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            fixed (void* __to = &@ref.Values) fixed (void* __from = &this.Values[0]) SharpDX.Utilities.CopyMemory((IntPtr) __to, (IntPtr) __from, 10*sizeof ( byte));
            @ref.FamilyKind = this.FamilyKind;
            @ref.Text = this.Text;
            @ref.Script = this.Script;
            @ref.Decorative = this.Decorative;
            @ref.Symbol = this.Symbol;
		
		}
    }
    
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.DirectWrite.PanoseCharacterRanges"/></strong> enumeration contains values that specify the type of characters available in the font.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_2']/*"/>	
    /// <msdn-id>hh997724</msdn-id>	
    /// <unmanaged>DWRITE_PANOSE_INNER_2</unmanaged>	
    /// <unmanaged-short>DWRITE_PANOSE_INNER_2</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct PanoseDecorative {	
        
        /// <summary>	
        /// <dd> <p>Any range.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_2::familyKind']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char familyKind</unmanaged>	
        /// <unmanaged-short>unsigned char familyKind</unmanaged-short>	
        public byte FamilyKind;
        
        /// <summary>	
        /// <dd> <p>No fit for range.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_2::decorativeClass']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char decorativeClass</unmanaged>	
        /// <unmanaged-short>unsigned char decorativeClass</unmanaged-short>	
        public byte DecorativeClass;
        
        /// <summary>	
        /// <dd> <p>The range includes extended collection.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_2::weight']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char weight</unmanaged>	
        /// <unmanaged-short>unsigned char weight</unmanaged-short>	
        public byte Weight;
        
        /// <summary>	
        /// <dd> <p>The range includes literals.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_2::aspect']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char aspect</unmanaged>	
        /// <unmanaged-short>unsigned char aspect</unmanaged-short>	
        public byte Aspect;
        
        /// <summary>	
        /// <dd> <p>The range doesn't include lower case.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_2::contrast']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char contrast</unmanaged>	
        /// <unmanaged-short>unsigned char contrast</unmanaged-short>	
        public byte Contrast;
        
        /// <summary>	
        /// <dd> <p>The range includes small capitals.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_2::serifVariant']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char serifVariant</unmanaged>	
        /// <unmanaged-short>unsigned char serifVariant</unmanaged-short>	
        public byte SerifVariant;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_2::fill']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char fill</unmanaged>	
        /// <unmanaged-short>unsigned char fill</unmanaged-short>	
        public byte Fill;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_2::lining']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char lining</unmanaged>	
        /// <unmanaged-short>unsigned char lining</unmanaged-short>	
        public byte Lining;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_2::decorativeTopology']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char decorativeTopology</unmanaged>	
        /// <unmanaged-short>unsigned char decorativeTopology</unmanaged-short>	
        public byte DecorativeTopology;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_2::characterRange']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char characterRange</unmanaged>	
        /// <unmanaged-short>unsigned char characterRange</unmanaged-short>	
        public byte CharacterRange;
    }
    
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.DirectWrite.PanoseCharacterRanges"/></strong> enumeration contains values that specify the type of characters available in the font.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_1']/*"/>	
    /// <msdn-id>hh997724</msdn-id>	
    /// <unmanaged>DWRITE_PANOSE_INNER_1</unmanaged>	
    /// <unmanaged-short>DWRITE_PANOSE_INNER_1</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct PanoseScript {	
        
        /// <summary>	
        /// <dd> <p>Any range.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_1::familyKind']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char familyKind</unmanaged>	
        /// <unmanaged-short>unsigned char familyKind</unmanaged-short>	
        public byte FamilyKind;
        
        /// <summary>	
        /// <dd> <p>No fit for range.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_1::toolKind']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char toolKind</unmanaged>	
        /// <unmanaged-short>unsigned char toolKind</unmanaged-short>	
        public byte ToolKind;
        
        /// <summary>	
        /// <dd> <p>The range includes extended collection.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_1::weight']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char weight</unmanaged>	
        /// <unmanaged-short>unsigned char weight</unmanaged-short>	
        public byte Weight;
        
        /// <summary>	
        /// <dd> <p>The range includes literals.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_1::spacing']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char spacing</unmanaged>	
        /// <unmanaged-short>unsigned char spacing</unmanaged-short>	
        public byte Spacing;
        
        /// <summary>	
        /// <dd> <p>The range doesn't include lower case.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_1::aspectRatio']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char aspectRatio</unmanaged>	
        /// <unmanaged-short>unsigned char aspectRatio</unmanaged-short>	
        public byte AspectRatio;
        
        /// <summary>	
        /// <dd> <p>The range includes small capitals.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_1::contrast']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char contrast</unmanaged>	
        /// <unmanaged-short>unsigned char contrast</unmanaged-short>	
        public byte Contrast;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_1::scriptTopology']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char scriptTopology</unmanaged>	
        /// <unmanaged-short>unsigned char scriptTopology</unmanaged-short>	
        public byte ScriptTopology;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_1::scriptForm']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char scriptForm</unmanaged>	
        /// <unmanaged-short>unsigned char scriptForm</unmanaged-short>	
        public byte ScriptForm;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_1::finials']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char finials</unmanaged>	
        /// <unmanaged-short>unsigned char finials</unmanaged-short>	
        public byte Finials;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_1::xAscent']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char xAscent</unmanaged>	
        /// <unmanaged-short>unsigned char xAscent</unmanaged-short>	
        public byte XAscent;
    }
    
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.DirectWrite.PanoseCharacterRanges"/></strong> enumeration contains values that specify the type of characters available in the font.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_3']/*"/>	
    /// <msdn-id>hh997724</msdn-id>	
    /// <unmanaged>DWRITE_PANOSE_INNER_3</unmanaged>	
    /// <unmanaged-short>DWRITE_PANOSE_INNER_3</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct PanoseSymbol {	
        
        /// <summary>	
        /// <dd> <p>Any range.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_3::familyKind']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char familyKind</unmanaged>	
        /// <unmanaged-short>unsigned char familyKind</unmanaged-short>	
        public byte FamilyKind;
        
        /// <summary>	
        /// <dd> <p>No fit for range.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_3::symbolKind']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char symbolKind</unmanaged>	
        /// <unmanaged-short>unsigned char symbolKind</unmanaged-short>	
        public byte SymbolKind;
        
        /// <summary>	
        /// <dd> <p>The range includes extended collection.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_3::weight']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char weight</unmanaged>	
        /// <unmanaged-short>unsigned char weight</unmanaged-short>	
        public byte Weight;
        
        /// <summary>	
        /// <dd> <p>The range includes literals.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_3::spacing']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char spacing</unmanaged>	
        /// <unmanaged-short>unsigned char spacing</unmanaged-short>	
        public byte Spacing;
        
        /// <summary>	
        /// <dd> <p>The range doesn't include lower case.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_3::aspectRatioAndContrast']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char aspectRatioAndContrast</unmanaged>	
        /// <unmanaged-short>unsigned char aspectRatioAndContrast</unmanaged-short>	
        public byte AspectRatioAndContrast;
        
        /// <summary>	
        /// <dd> <p>The range includes small capitals.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_3::aspectRatio94']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char aspectRatio94</unmanaged>	
        /// <unmanaged-short>unsigned char aspectRatio94</unmanaged-short>	
        public byte AspectRatio94;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_3::aspectRatio119']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char aspectRatio119</unmanaged>	
        /// <unmanaged-short>unsigned char aspectRatio119</unmanaged-short>	
        public byte AspectRatio119;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_3::aspectRatio157']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char aspectRatio157</unmanaged>	
        /// <unmanaged-short>unsigned char aspectRatio157</unmanaged-short>	
        public byte AspectRatio157;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_3::aspectRatio163']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char aspectRatio163</unmanaged>	
        /// <unmanaged-short>unsigned char aspectRatio163</unmanaged-short>	
        public byte AspectRatio163;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_3::aspectRatio211']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char aspectRatio211</unmanaged>	
        /// <unmanaged-short>unsigned char aspectRatio211</unmanaged-short>	
        public byte AspectRatio211;
    }
    
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.DirectWrite.PanoseCharacterRanges"/></strong> enumeration contains values that specify the type of characters available in the font.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_0']/*"/>	
    /// <msdn-id>hh997724</msdn-id>	
    /// <unmanaged>DWRITE_PANOSE_INNER_0</unmanaged>	
    /// <unmanaged-short>DWRITE_PANOSE_INNER_0</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct PanoseText {	
        
        /// <summary>	
        /// <dd> <p>Any range.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_0::familyKind']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char familyKind</unmanaged>	
        /// <unmanaged-short>unsigned char familyKind</unmanaged-short>	
        public byte FamilyKind;
        
        /// <summary>	
        /// <dd> <p>No fit for range.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_0::serifStyle']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char serifStyle</unmanaged>	
        /// <unmanaged-short>unsigned char serifStyle</unmanaged-short>	
        public byte SerifStyle;
        
        /// <summary>	
        /// <dd> <p>The range includes extended collection.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_0::weight']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char weight</unmanaged>	
        /// <unmanaged-short>unsigned char weight</unmanaged-short>	
        public byte Weight;
        
        /// <summary>	
        /// <dd> <p>The range includes literals.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_0::proportion']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char proportion</unmanaged>	
        /// <unmanaged-short>unsigned char proportion</unmanaged-short>	
        public byte Proportion;
        
        /// <summary>	
        /// <dd> <p>The range doesn't include lower case.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_0::contrast']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char contrast</unmanaged>	
        /// <unmanaged-short>unsigned char contrast</unmanaged-short>	
        public byte Contrast;
        
        /// <summary>	
        /// <dd> <p>The range includes small capitals.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_0::strokeVariation']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char strokeVariation</unmanaged>	
        /// <unmanaged-short>unsigned char strokeVariation</unmanaged-short>	
        public byte StrokeVariation;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_0::armStyle']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char armStyle</unmanaged>	
        /// <unmanaged-short>unsigned char armStyle</unmanaged-short>	
        public byte ArmStyle;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_0::letterform']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char letterform</unmanaged>	
        /// <unmanaged-short>unsigned char letterform</unmanaged-short>	
        public byte Letterform;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_0::midline']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char midline</unmanaged>	
        /// <unmanaged-short>unsigned char midline</unmanaged-short>	
        public byte Midline;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_PANOSE_INNER_0::xHeight']/*"/>	
        /// <msdn-id>hh997724</msdn-id>	
        /// <unmanaged>unsigned char xHeight</unmanaged>	
        /// <unmanaged-short>unsigned char xHeight</unmanaged-short>	
        public byte XHeight;
    }
    
    /// <summary>	
    /// <p>Stores the association of text and its writing system script, as well as some display attributes.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_ANALYSIS']/*"/>	
    /// <msdn-id>dd368120</msdn-id>	
    /// <unmanaged>DWRITE_SCRIPT_ANALYSIS</unmanaged>	
    /// <unmanaged-short>DWRITE_SCRIPT_ANALYSIS</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct ScriptAnalysis {	
        
        /// <summary>	
        /// <dd> <p>The zero-based index representation of writing system script.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_ANALYSIS::script']/*"/>	
        /// <msdn-id>dd368120</msdn-id>	
        /// <unmanaged>unsigned short script</unmanaged>	
        /// <unmanaged-short>unsigned short script</unmanaged-short>	
        public short Script;
        
        /// <summary>	
        /// <dd> <p>A value that indicates additional shaping requirement of text.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_ANALYSIS::shapes']/*"/>	
        /// <msdn-id>dd368120</msdn-id>	
        /// <unmanaged>DWRITE_SCRIPT_SHAPES shapes</unmanaged>	
        /// <unmanaged-short>DWRITE_SCRIPT_SHAPES shapes</unmanaged-short>	
        public SharpDX.DirectWrite.ScriptShapes Shapes;
    }
    
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.DirectWrite.ScriptProperties"/></strong> structure specifies script properties for caret navigation and justification.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_PROPERTIES']/*"/>	
    /// <msdn-id>jj126264</msdn-id>	
    /// <unmanaged>DWRITE_SCRIPT_PROPERTIES</unmanaged>	
    /// <unmanaged-short>DWRITE_SCRIPT_PROPERTIES</unmanaged-short>	
    [StructLayout(LayoutKind.Explicit)]
    public  partial struct ScriptProperties {	
        
        /// <summary>	
        /// <dd> <p>The standardized four character code for the given script. </p> <p><strong>Note</strong>??These only include the general Unicode scripts, not any additional ISO 15924 scripts for bibliographic distinction (for example, Fraktur Latin versus Gaelic Latin).</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_PROPERTIES::isoScriptCode']/*"/>	
        /// <msdn-id>jj126264</msdn-id>	
        /// <unmanaged>unsigned int isoScriptCode</unmanaged>	
        /// <unmanaged-short>unsigned int isoScriptCode</unmanaged-short>	
        [FieldOffset(0)]
        public int IsoScriptCode;
        
        /// <summary>	
        /// <dd> <p>The standardized numeric code, ranging 0-999.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_PROPERTIES::isoScriptNumber']/*"/>	
        /// <msdn-id>jj126264</msdn-id>	
        /// <unmanaged>unsigned int isoScriptNumber</unmanaged>	
        /// <unmanaged-short>unsigned int isoScriptNumber</unmanaged-short>	
        [FieldOffset(4)]
        public int IsoScriptNumber;
        
        /// <summary>	
        /// <dd> <p>Number of characters to estimate look-ahead for complex scripts. Latin and all Kana are generally 1. Indic scripts are up to 15, and most others are 8.</p> <p><strong>Note</strong>??Combining marks and variation selectors can produce clusters that are longer than these look-aheads, so this estimate is considered typical language use. Diacritics must be tested explicitly separately.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_PROPERTIES::clusterLookahead']/*"/>	
        /// <msdn-id>jj126264</msdn-id>	
        /// <unmanaged>unsigned int clusterLookahead</unmanaged>	
        /// <unmanaged-short>unsigned int clusterLookahead</unmanaged-short>	
        [FieldOffset(8)]
        public int ClusterLookahead;
        
        /// <summary>	
        /// <dd> <p>Appropriate character to elongate the given script for justification. For example:</p> <ul> <li>Arabic    - U+0640 Tatweel</li> <li>Ogham     - U+1680 Ogham Space Mark</li> </ul> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_PROPERTIES::justificationCharacter']/*"/>	
        /// <msdn-id>jj126264</msdn-id>	
        /// <unmanaged>unsigned int justificationCharacter</unmanaged>	
        /// <unmanaged-short>unsigned int justificationCharacter</unmanaged-short>	
        [FieldOffset(12)]
        public int JustificationCharacter;
        
        /// <summary>	
        /// <dd> <p>Restrict the caret to whole clusters, like Thai and Devanagari. Scripts such as Arabic by default allow navigation between clusters. Others like Thai always navigate across whole clusters.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_PROPERTIES::restrictCaretToClusters']/*"/>	
        /// <msdn-id>jj126264</msdn-id>	
        /// <unmanaged>unsigned int restrictCaretToClusters</unmanaged>	
        /// <unmanaged-short>unsigned int restrictCaretToClusters</unmanaged-short>	
        public bool  RestrictCaretToClusters { 
            get { 
                return 0 != ((_RestrictCaretToClusters >> 0)  &  1);
            }
            set { 
                _RestrictCaretToClusters = (int)((_RestrictCaretToClusters & ~( 1 << 0)) | ( ( (value?1:0) & 1) << 0));
            }
        }
        [FieldOffset(16)]
        internal int _RestrictCaretToClusters;
		
        
        /// <summary>	
        /// <dd> <p>The language uses dividers between words, such as spaces between Latin or the Ethiopic wordspace. Examples include Latin, Greek, Devanagari, and Ethiopic. Chinese, Korean, and Thai are excluded.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_PROPERTIES::usesWordDividers']/*"/>	
        /// <msdn-id>jj126264</msdn-id>	
        /// <unmanaged>unsigned int usesWordDividers</unmanaged>	
        /// <unmanaged-short>unsigned int usesWordDividers</unmanaged-short>	
        public bool  UsesWordDividers { 
            get { 
                return 0 != ((_UsesWordDividers >> 1)  &  1);
            }
            set { 
                _UsesWordDividers = (int)((_UsesWordDividers & ~( 1 << 1)) | ( ( (value?1:0) & 1) << 1));
            }
        }
        [FieldOffset(16)]
        internal int _UsesWordDividers;
		
        
        /// <summary>	
        /// <dd> <p>The characters are discrete units from each other. This includes both block scripts and clustered scripts. Examples include Latin, Greek, Cyrillic, Hebrew, Chinese, and Thai.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_PROPERTIES::isDiscreteWriting']/*"/>	
        /// <msdn-id>jj126264</msdn-id>	
        /// <unmanaged>unsigned int isDiscreteWriting</unmanaged>	
        /// <unmanaged-short>unsigned int isDiscreteWriting</unmanaged-short>	
        public bool  IsDiscreteWriting { 
            get { 
                return 0 != ((_IsDiscreteWriting >> 2)  &  1);
            }
            set { 
                _IsDiscreteWriting = (int)((_IsDiscreteWriting & ~( 1 << 2)) | ( ( (value?1:0) & 1) << 2));
            }
        }
        [FieldOffset(16)]
        internal int _IsDiscreteWriting;
		
        
        /// <summary>	
        /// <dd> <p>The language is a block script, expanding between characters. Examples include Chinese, Japanese, Korean, and Bopomofo.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_PROPERTIES::isBlockWriting']/*"/>	
        /// <msdn-id>jj126264</msdn-id>	
        /// <unmanaged>unsigned int isBlockWriting</unmanaged>	
        /// <unmanaged-short>unsigned int isBlockWriting</unmanaged-short>	
        public bool  IsBlockWriting { 
            get { 
                return 0 != ((_IsBlockWriting >> 3)  &  1);
            }
            set { 
                _IsBlockWriting = (int)((_IsBlockWriting & ~( 1 << 3)) | ( ( (value?1:0) & 1) << 3));
            }
        }
        [FieldOffset(16)]
        internal int _IsBlockWriting;
		
        
        /// <summary>	
        /// <dd> <p>The language is justified within glyph clusters, not just between glyph clusters, such as the character sequence of Thai Lu and Sara Am (U+E026, U+E033), which form a single cluster but still expand between them. Examples include Thai, Lao, and Khmer.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_PROPERTIES::isDistributedWithinCluster']/*"/>	
        /// <msdn-id>jj126264</msdn-id>	
        /// <unmanaged>unsigned int isDistributedWithinCluster</unmanaged>	
        /// <unmanaged-short>unsigned int isDistributedWithinCluster</unmanaged-short>	
        public bool  IsDistributedWithinCluster { 
            get { 
                return 0 != ((_IsDistributedWithinCluster >> 4)  &  1);
            }
            set { 
                _IsDistributedWithinCluster = (int)((_IsDistributedWithinCluster & ~( 1 << 4)) | ( ( (value?1:0) & 1) << 4));
            }
        }
        [FieldOffset(16)]
        internal int _IsDistributedWithinCluster;
		
        
        /// <summary>	
        /// <dd> <p>The script's clusters are connected to each other (such as the baseline-linked Devanagari), and no separation is added between characters.</p> <p><strong>Note</strong>??Cursively linked scripts like Arabic are also connected (but not all connected scripts are cursive). </p> <p>Examples include Devanagari, Arabic, Syriac, Bengali, Gurmukhi, and Ogham. Latin, Chinese, and Thaana are excluded.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_PROPERTIES::isConnectedWriting']/*"/>	
        /// <msdn-id>jj126264</msdn-id>	
        /// <unmanaged>unsigned int isConnectedWriting</unmanaged>	
        /// <unmanaged-short>unsigned int isConnectedWriting</unmanaged-short>	
        public bool  IsConnectedWriting { 
            get { 
                return 0 != ((_IsConnectedWriting >> 5)  &  1);
            }
            set { 
                _IsConnectedWriting = (int)((_IsConnectedWriting & ~( 1 << 5)) | ( ( (value?1:0) & 1) << 5));
            }
        }
        [FieldOffset(16)]
        internal int _IsConnectedWriting;
		
        
        /// <summary>	
        /// <dd> <p>The script is naturally cursive (Arabic and Syriac), meaning it uses other justification methods like kashida extension rather than inter-character spacing.</p> <p><strong>Note</strong>?? Although other scripts like Latin and Japanese might actually support handwritten cursive forms, they are not considered cursive scripts.</p> <p>Examples include Arabic, Syriac, and Mongolian. Thaana, Devanagari, Latin, and Chinese are excluded.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_PROPERTIES::isCursiveWriting']/*"/>	
        /// <msdn-id>jj126264</msdn-id>	
        /// <unmanaged>unsigned int isCursiveWriting</unmanaged>	
        /// <unmanaged-short>unsigned int isCursiveWriting</unmanaged-short>	
        public bool  IsCursiveWriting { 
            get { 
                return 0 != ((_IsCursiveWriting >> 6)  &  1);
            }
            set { 
                _IsCursiveWriting = (int)((_IsCursiveWriting & ~( 1 << 6)) | ( ( (value?1:0) & 1) << 6));
            }
        }
        [FieldOffset(16)]
        internal int _IsCursiveWriting;
		
        
        /// <summary>	
        /// <dd> <p>Reserved</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SCRIPT_PROPERTIES::reserved']/*"/>	
        /// <msdn-id>jj126264</msdn-id>	
        /// <unmanaged>unsigned int reserved</unmanaged>	
        /// <unmanaged-short>unsigned int reserved</unmanaged-short>	
        public int  Reserved { 
            get { 
                return (int)((_Reserved >> 7)  &  33554431);
            }
            set { 
                _Reserved = (int)((_Reserved & ~( 33554431 << 7)) | ( (value & 33554431) << 7));
            }
        }
        [FieldOffset(16)]
        internal int _Reserved;
		
    }
    
    /// <summary>	
    /// <p>Contains shaping output properties for an output glyph.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SHAPING_GLYPH_PROPERTIES']/*"/>	
    /// <msdn-id>dd368123</msdn-id>	
    /// <unmanaged>DWRITE_SHAPING_GLYPH_PROPERTIES</unmanaged>	
    /// <unmanaged-short>DWRITE_SHAPING_GLYPH_PROPERTIES</unmanaged-short>	
    [StructLayout(LayoutKind.Explicit)]
    public  partial struct ShapingGlyphProperties {	
        
        /// <summary>	
        /// <dd> <p>Indicates that the glyph has justification applied.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SHAPING_GLYPH_PROPERTIES::justification']/*"/>	
        /// <msdn-id>dd368123</msdn-id>	
        /// <unmanaged>unsigned short justification</unmanaged>	
        /// <unmanaged-short>unsigned short justification</unmanaged-short>	
        internal short  Justification_ { 
            get { 
                return (short)((_Justification_ >> 0)  &  15);
            }
            set { 
                _Justification_ = (short)((_Justification_ & ~( 15 << 0)) | ( (value & 15) << 0));
            }
        }
        [FieldOffset(0)]
        internal short _Justification_;
		
        
        /// <summary>	
        /// <dd> <p>Indicates that the glyph is the start of a cluster.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SHAPING_GLYPH_PROPERTIES::isClusterStart']/*"/>	
        /// <msdn-id>dd368123</msdn-id>	
        /// <unmanaged>unsigned short isClusterStart</unmanaged>	
        /// <unmanaged-short>unsigned short isClusterStart</unmanaged-short>	
        public bool  IsClusterStart { 
            get { 
                return 0 != ((_IsClusterStart >> 4)  &  1);
            }
            set { 
                _IsClusterStart = (short)((_IsClusterStart & ~( 1 << 4)) | ( ( (value?1:0) & 1) << 4));
            }
        }
        [FieldOffset(0)]
        internal short _IsClusterStart;
		
        
        /// <summary>	
        /// <dd> <p>Indicates that the glyph is a diacritic mark.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SHAPING_GLYPH_PROPERTIES::isDiacritic']/*"/>	
        /// <msdn-id>dd368123</msdn-id>	
        /// <unmanaged>unsigned short isDiacritic</unmanaged>	
        /// <unmanaged-short>unsigned short isDiacritic</unmanaged-short>	
        public bool  IsDiacritic { 
            get { 
                return 0 != ((_IsDiacritic >> 5)  &  1);
            }
            set { 
                _IsDiacritic = (short)((_IsDiacritic & ~( 1 << 5)) | ( ( (value?1:0) & 1) << 5));
            }
        }
        [FieldOffset(0)]
        internal short _IsDiacritic;
		
        
        /// <summary>	
        /// <dd> <p>Indicates that the glyph is a word boundary with no visible space.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SHAPING_GLYPH_PROPERTIES::isZeroWidthSpace']/*"/>	
        /// <msdn-id>dd368123</msdn-id>	
        /// <unmanaged>unsigned short isZeroWidthSpace</unmanaged>	
        /// <unmanaged-short>unsigned short isZeroWidthSpace</unmanaged-short>	
        public bool  IsZeroWidthSpace { 
            get { 
                return 0 != ((_IsZeroWidthSpace >> 6)  &  1);
            }
            set { 
                _IsZeroWidthSpace = (short)((_IsZeroWidthSpace & ~( 1 << 6)) | ( ( (value?1:0) & 1) << 6));
            }
        }
        [FieldOffset(0)]
        internal short _IsZeroWidthSpace;
		
        
        /// <summary>	
        /// <dd> <p>Reserved for future use.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SHAPING_GLYPH_PROPERTIES::reserved']/*"/>	
        /// <msdn-id>dd368123</msdn-id>	
        /// <unmanaged>unsigned short reserved</unmanaged>	
        /// <unmanaged-short>unsigned short reserved</unmanaged-short>	
        internal short  Reserved { 
            get { 
                return (short)((_Reserved >> 7)  &  511);
            }
            set { 
                _Reserved = (short)((_Reserved & ~( 511 << 7)) | ( (value & 511) << 7));
            }
        }
        [FieldOffset(0)]
        internal short _Reserved;
		
    }
    
    /// <summary>	
    /// <p>Shaping output properties for an output glyph.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SHAPING_TEXT_PROPERTIES']/*"/>	
    /// <msdn-id>dd368125</msdn-id>	
    /// <unmanaged>DWRITE_SHAPING_TEXT_PROPERTIES</unmanaged>	
    /// <unmanaged-short>DWRITE_SHAPING_TEXT_PROPERTIES</unmanaged-short>	
    [StructLayout(LayoutKind.Explicit)]
    public  partial struct ShapingTextProperties {	
        
        /// <summary>	
        /// <dd> <p>Indicates that the glyph is shaped alone.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SHAPING_TEXT_PROPERTIES::isShapedAlone']/*"/>	
        /// <msdn-id>dd368125</msdn-id>	
        /// <unmanaged>unsigned short isShapedAlone</unmanaged>	
        /// <unmanaged-short>unsigned short isShapedAlone</unmanaged-short>	
        public bool  IsShapedAlone { 
            get { 
                return 0 != ((_IsShapedAlone >> 0)  &  1);
            }
            set { 
                _IsShapedAlone = (short)((_IsShapedAlone & ~( 1 << 0)) | ( ( (value?1:0) & 1) << 0));
            }
        }
        [FieldOffset(0)]
        internal short _IsShapedAlone;
		
        
        /// <summary>	
        /// <dd> <p>Reserved for future use.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_SHAPING_TEXT_PROPERTIES::reserved']/*"/>	
        /// <msdn-id>dd368125</msdn-id>	
        /// <unmanaged>unsigned short reserved</unmanaged>	
        /// <unmanaged-short>unsigned short reserved</unmanaged-short>	
        internal short  Reserved { 
            get { 
                return (short)((_Reserved >> 1)  &  32767);
            }
            set { 
                _Reserved = (short)((_Reserved & ~( 32767 << 1)) | ( (value & 32767) << 1));
            }
        }
        [FieldOffset(0)]
        internal short _Reserved;
		
    }
    
    /// <summary>	
    /// <p>Contains information regarding the size and placement of strikethroughs. All coordinates are in device independent pixels (DIPs).</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_STRIKETHROUGH']/*"/>	
    /// <msdn-id>dd368126</msdn-id>	
    /// <unmanaged>DWRITE_STRIKETHROUGH</unmanaged>	
    /// <unmanaged-short>DWRITE_STRIKETHROUGH</unmanaged-short>	
    public  partial struct Strikethrough {	
        
        /// <summary>	
        /// <dd> <p>A value that indicates the width of the strikethrough, measured parallel to the baseline.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_STRIKETHROUGH::width']/*"/>	
        /// <msdn-id>dd368126</msdn-id>	
        /// <unmanaged>float width</unmanaged>	
        /// <unmanaged-short>float width</unmanaged-short>	
        public float Width;
        
        /// <summary>	
        /// <dd> <p>A value that indicates the thickness of the strikethrough, measured perpendicular to the baseline.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_STRIKETHROUGH::thickness']/*"/>	
        /// <msdn-id>dd368126</msdn-id>	
        /// <unmanaged>float thickness</unmanaged>	
        /// <unmanaged-short>float thickness</unmanaged-short>	
        public float Thickness;
        
        /// <summary>	
        /// <dd> <p>A value that indicates the offset of the strikethrough from the baseline.  A positive offset represents a position below the baseline and  a negative offset is above.  Typically, the offset will be negative.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_STRIKETHROUGH::offset']/*"/>	
        /// <msdn-id>dd368126</msdn-id>	
        /// <unmanaged>float offset</unmanaged>	
        /// <unmanaged-short>float offset</unmanaged-short>	
        public float Offset;
        
        /// <summary>	
        /// <dd> <p>Reading direction of the text associated with the strikethrough.  This value is used to interpret whether the width value runs horizontally  or vertically.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_STRIKETHROUGH::readingDirection']/*"/>	
        /// <msdn-id>dd368126</msdn-id>	
        /// <unmanaged>DWRITE_READING_DIRECTION readingDirection</unmanaged>	
        /// <unmanaged-short>DWRITE_READING_DIRECTION readingDirection</unmanaged-short>	
        public SharpDX.DirectWrite.ReadingDirection ReadingDirection;
        
        /// <summary>	
        /// <dd> <p>Flow direction of the text associated with the strikethrough.  This value is used to interpret whether the thickness value advances top to  bottom, left to right, or right to left.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_STRIKETHROUGH::flowDirection']/*"/>	
        /// <msdn-id>dd368126</msdn-id>	
        /// <unmanaged>DWRITE_FLOW_DIRECTION flowDirection</unmanaged>	
        /// <unmanaged-short>DWRITE_FLOW_DIRECTION flowDirection</unmanaged-short>	
        public SharpDX.DirectWrite.FlowDirection FlowDirection;
        
        /// <summary>	
        /// <dd> <p>An array of characters containing the locale of the  text that is the strikethrough is being drawn over. </p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_STRIKETHROUGH::localeName']/*"/>	
        /// <msdn-id>dd368126</msdn-id>	
        /// <unmanaged>const wchar_t* localeName</unmanaged>	
        /// <unmanaged-short>wchar_t localeName</unmanaged-short>	
        public string LocaleName;
        
        /// <summary>	
        /// <dd> <p>The measuring mode can be useful to the renderer to determine how underlines are rendered, such as rounding the thickness to a whole pixel in GDI-compatible modes.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_STRIKETHROUGH::measuringMode']/*"/>	
        /// <msdn-id>dd368126</msdn-id>	
        /// <unmanaged>DWRITE_MEASURING_MODE measuringMode</unmanaged>	
        /// <unmanaged-short>DWRITE_MEASURING_MODE measuringMode</unmanaged-short>	
        public SharpDX.Direct2D1.MeasuringMode MeasuringMode;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential)]
        internal partial struct __Native {	
            public float Width;
            public float Thickness;
            public float Offset;
            public SharpDX.DirectWrite.ReadingDirection ReadingDirection;
            public SharpDX.DirectWrite.FlowDirection FlowDirection;
            public System.IntPtr LocaleName;
            public SharpDX.Direct2D1.MeasuringMode MeasuringMode;
		    // Method to free unmanaged allocation
            internal unsafe void __MarshalFree()
            {   
                if (this.LocaleName != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.LocaleName);		
            }
        }
		
		// Method to free unmanaged allocation
        internal unsafe void __MarshalFree(ref __Native @ref)
        {   
            @ref.__MarshalFree();
        }
		
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Width = @ref.Width;
            this.Thickness = @ref.Thickness;
            this.Offset = @ref.Offset;
            this.ReadingDirection = @ref.ReadingDirection;
            this.FlowDirection = @ref.FlowDirection;
            this.LocaleName = ( @ref.LocaleName == IntPtr.Zero )?null:Marshal.PtrToStringUni(@ref.LocaleName);
            this.MeasuringMode = @ref.MeasuringMode;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Width = this.Width;
            @ref.Thickness = this.Thickness;
            @ref.Offset = this.Offset;
            @ref.ReadingDirection = this.ReadingDirection;
            @ref.FlowDirection = this.FlowDirection;
            @ref.LocaleName = ( this.LocaleName == null )?IntPtr.Zero : Utilities.StringToHGlobalUni(this.LocaleName);
            @ref.MeasuringMode = this.MeasuringMode;
		
		}
    }
    
    /// <summary>	
    /// <p>Contains the metrics associated with text after layout.  All coordinates are in device independent pixels (DIPs).</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TEXT_METRICS']/*"/>	
    /// <msdn-id>dd368135</msdn-id>	
    /// <unmanaged>DWRITE_TEXT_METRICS</unmanaged>	
    /// <unmanaged-short>DWRITE_TEXT_METRICS</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct TextMetrics {	
        
        /// <summary>	
        /// <dd> <p>A value that indicates the left-most point of formatted text relative to the layout box,  while excluding any glyph overhang.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TEXT_METRICS::left']/*"/>	
        /// <msdn-id>dd368135</msdn-id>	
        /// <unmanaged>float left</unmanaged>	
        /// <unmanaged-short>float left</unmanaged-short>	
        public float Left;
        
        /// <summary>	
        /// <dd> <p>A value that indicates the top-most point of formatted text relative to the layout box, while excluding any glyph overhang.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TEXT_METRICS::top']/*"/>	
        /// <msdn-id>dd368135</msdn-id>	
        /// <unmanaged>float top</unmanaged>	
        /// <unmanaged-short>float top</unmanaged-short>	
        public float Top;
        
        /// <summary>	
        /// <dd> <p>A value that indicates the width of the formatted text, while ignoring trailing whitespace  at the end of each line.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TEXT_METRICS::width']/*"/>	
        /// <msdn-id>dd368135</msdn-id>	
        /// <unmanaged>float width</unmanaged>	
        /// <unmanaged-short>float width</unmanaged-short>	
        public float Width;
        
        /// <summary>	
        /// <dd> <p>The width of the formatted text, taking into account the  trailing whitespace at the end of each line.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TEXT_METRICS::widthIncludingTrailingWhitespace']/*"/>	
        /// <msdn-id>dd368135</msdn-id>	
        /// <unmanaged>float widthIncludingTrailingWhitespace</unmanaged>	
        /// <unmanaged-short>float widthIncludingTrailingWhitespace</unmanaged-short>	
        public float WidthIncludingTrailingWhitespace;
        
        /// <summary>	
        /// <dd> <p>The height of the formatted text. The height of an empty string  is set to the same value as that of the default font.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TEXT_METRICS::height']/*"/>	
        /// <msdn-id>dd368135</msdn-id>	
        /// <unmanaged>float height</unmanaged>	
        /// <unmanaged-short>float height</unmanaged-short>	
        public float Height;
        
        /// <summary>	
        /// <dd> <p>The initial width given to the layout. It can be either larger or smaller than the  text content width, depending on whether the text  was wrapped.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TEXT_METRICS::layoutWidth']/*"/>	
        /// <msdn-id>dd368135</msdn-id>	
        /// <unmanaged>float layoutWidth</unmanaged>	
        /// <unmanaged-short>float layoutWidth</unmanaged-short>	
        public float LayoutWidth;
        
        /// <summary>	
        /// <dd> <p>Initial height given to the layout. Depending on the length of the text, it may be larger or smaller than the text content height.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TEXT_METRICS::layoutHeight']/*"/>	
        /// <msdn-id>dd368135</msdn-id>	
        /// <unmanaged>float layoutHeight</unmanaged>	
        /// <unmanaged-short>float layoutHeight</unmanaged-short>	
        public float LayoutHeight;
        
        /// <summary>	
        /// <dd> <p>The maximum reordering count of any line of text, used  to calculate the most number of hit-testing boxes needed.  If the layout has no bidirectional text, or no text at all,  the minimum level is 1.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TEXT_METRICS::maxBidiReorderingDepth']/*"/>	
        /// <msdn-id>dd368135</msdn-id>	
        /// <unmanaged>unsigned int maxBidiReorderingDepth</unmanaged>	
        /// <unmanaged-short>unsigned int maxBidiReorderingDepth</unmanaged-short>	
        public int MaxBidiReorderingDepth;
        
        /// <summary>	
        /// <dd> <p>Total number of lines.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TEXT_METRICS::lineCount']/*"/>	
        /// <msdn-id>dd368135</msdn-id>	
        /// <unmanaged>unsigned int lineCount</unmanaged>	
        /// <unmanaged-short>unsigned int lineCount</unmanaged-short>	
        public int LineCount;
    }
    
    /// <summary>	
    /// <p>Specifies a range of text positions where format is applied in the text represented by an <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> object.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TEXT_RANGE']/*"/>	
    /// <msdn-id>dd368137</msdn-id>	
    /// <unmanaged>DWRITE_TEXT_RANGE</unmanaged>	
    /// <unmanaged-short>DWRITE_TEXT_RANGE</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct TextRange {	
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TEXT_RANGE::startPosition']/*"/>	
        /// <msdn-id>dd368137</msdn-id>	
        /// <unmanaged>unsigned int startPosition</unmanaged>	
        /// <unmanaged-short>unsigned int startPosition</unmanaged-short>	
        public int StartPosition;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TEXT_RANGE::length']/*"/>	
        /// <msdn-id>dd368137</msdn-id>	
        /// <unmanaged>unsigned int length</unmanaged>	
        /// <unmanaged-short>unsigned int length</unmanaged-short>	
        public int Length;
    }
    
    /// <summary>	
    /// <p>Specifies the trimming option for text overflowing the layout box. </p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TRIMMING']/*"/>	
    /// <msdn-id>dd368139</msdn-id>	
    /// <unmanaged>DWRITE_TRIMMING</unmanaged>	
    /// <unmanaged-short>DWRITE_TRIMMING</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct Trimming {	
        
        /// <summary>	
        /// <dd> <p>A value that specifies  the text granularity used to trim text overflowing the layout box.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TRIMMING::granularity']/*"/>	
        /// <msdn-id>dd368139</msdn-id>	
        /// <unmanaged>DWRITE_TRIMMING_GRANULARITY granularity</unmanaged>	
        /// <unmanaged-short>DWRITE_TRIMMING_GRANULARITY granularity</unmanaged-short>	
        public SharpDX.DirectWrite.TrimmingGranularity Granularity;
        
        /// <summary>	
        /// <dd> <p>A character code used as the delimiter that signals the beginning of the portion of text to be preserved. Most useful for path ellipsis, where the delimiter would be a slash.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TRIMMING::delimiter']/*"/>	
        /// <msdn-id>dd368139</msdn-id>	
        /// <unmanaged>unsigned int delimiter</unmanaged>	
        /// <unmanaged-short>unsigned int delimiter</unmanaged-short>	
        public int Delimiter;
        
        /// <summary>	
        /// <dd> <p>A value that indicates how many occurrences of the delimiter to step back.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TRIMMING::delimiterCount']/*"/>	
        /// <msdn-id>dd368139</msdn-id>	
        /// <unmanaged>unsigned int delimiterCount</unmanaged>	
        /// <unmanaged-short>unsigned int delimiterCount</unmanaged-short>	
        public int DelimiterCount;
    }
    
    /// <summary>	
    /// <p>Contains a set of typographic features to be applied during text shaping.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TYPOGRAPHIC_FEATURES']/*"/>	
    /// <msdn-id>dd368143</msdn-id>	
    /// <unmanaged>DWRITE_TYPOGRAPHIC_FEATURES</unmanaged>	
    /// <unmanaged-short>DWRITE_TYPOGRAPHIC_FEATURES</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    internal  partial struct TypographicFeatures {	
        
        /// <summary>	
        /// <dd> <p>A reference to a structure that specifies properties used to identify and execute typographic features in the font.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TYPOGRAPHIC_FEATURES::features']/*"/>	
        /// <msdn-id>dd368143</msdn-id>	
        /// <unmanaged>DWRITE_FONT_FEATURE* features</unmanaged>	
        /// <unmanaged-short>DWRITE_FONT_FEATURE features</unmanaged-short>	
        public System.IntPtr Features;
        
        /// <summary>	
        /// <dd> <p>A value that indicates the number of features being applied to a font face.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_TYPOGRAPHIC_FEATURES::featureCount']/*"/>	
        /// <msdn-id>dd368143</msdn-id>	
        /// <unmanaged>unsigned int featureCount</unmanaged>	
        /// <unmanaged-short>unsigned int featureCount</unmanaged-short>	
        public int FeatureCount;
    }
    
    /// <summary>	
    /// <p>Contains information about the width, thickness, offset, run height, reading direction, and flow direction of an underline. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>All coordinates are in device independent pixels (DIPs).</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_UNDERLINE']/*"/>	
    /// <msdn-id>dd368145</msdn-id>	
    /// <unmanaged>DWRITE_UNDERLINE</unmanaged>	
    /// <unmanaged-short>DWRITE_UNDERLINE</unmanaged-short>	
    public  partial struct Underline {	
        
        /// <summary>	
        /// <dd> <p>A value that indicates the width of the underline, measured parallel to the baseline.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_UNDERLINE::width']/*"/>	
        /// <msdn-id>dd368145</msdn-id>	
        /// <unmanaged>float width</unmanaged>	
        /// <unmanaged-short>float width</unmanaged-short>	
        public float Width;
        
        /// <summary>	
        /// <dd> <p>A value that indicates the thickness of the underline, measured perpendicular to the baseline.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_UNDERLINE::thickness']/*"/>	
        /// <msdn-id>dd368145</msdn-id>	
        /// <unmanaged>float thickness</unmanaged>	
        /// <unmanaged-short>float thickness</unmanaged-short>	
        public float Thickness;
        
        /// <summary>	
        /// <dd> <p>A value that indicates the offset of the underline from the baseline. A positive offset represents a position below the baseline (away from the text) and a negative offset is above (toward the text).</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_UNDERLINE::offset']/*"/>	
        /// <msdn-id>dd368145</msdn-id>	
        /// <unmanaged>float offset</unmanaged>	
        /// <unmanaged-short>float offset</unmanaged-short>	
        public float Offset;
        
        /// <summary>	
        /// <dd> <p>A value that indicates the height of the tallest run where the underline is applied.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_UNDERLINE::runHeight']/*"/>	
        /// <msdn-id>dd368145</msdn-id>	
        /// <unmanaged>float runHeight</unmanaged>	
        /// <unmanaged-short>float runHeight</unmanaged-short>	
        public float RunHeight;
        
        /// <summary>	
        /// <dd> <p>A value that indicates the reading direction of the text associated with the underline. This value is used to interpret whether the width value runs horizontally or vertically.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_UNDERLINE::readingDirection']/*"/>	
        /// <msdn-id>dd368145</msdn-id>	
        /// <unmanaged>DWRITE_READING_DIRECTION readingDirection</unmanaged>	
        /// <unmanaged-short>DWRITE_READING_DIRECTION readingDirection</unmanaged-short>	
        public SharpDX.DirectWrite.ReadingDirection ReadingDirection;
        
        /// <summary>	
        /// <dd> <p>A value that indicates the flow direction of the text associated with the underline. This value is used to interpret whether the thickness value advances top to bottom, left to right, or right to left.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_UNDERLINE::flowDirection']/*"/>	
        /// <msdn-id>dd368145</msdn-id>	
        /// <unmanaged>DWRITE_FLOW_DIRECTION flowDirection</unmanaged>	
        /// <unmanaged-short>DWRITE_FLOW_DIRECTION flowDirection</unmanaged-short>	
        public SharpDX.DirectWrite.FlowDirection FlowDirection;
        
        /// <summary>	
        /// <dd> <p>An array of characters which contains the locale of the text that the underline is being drawn under.  For example, in vertical text, the underline belongs on the left for Chinese but on the right for Japanese. </p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_UNDERLINE::localeName']/*"/>	
        /// <msdn-id>dd368145</msdn-id>	
        /// <unmanaged>const wchar_t* localeName</unmanaged>	
        /// <unmanaged-short>wchar_t localeName</unmanaged-short>	
        public string LocaleName;
        
        /// <summary>	
        /// <dd> <p>The measuring mode can be useful to the renderer to determine how underlines are rendered, such as rounding the thickness to a whole pixel in GDI-compatible modes.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_UNDERLINE::measuringMode']/*"/>	
        /// <msdn-id>dd368145</msdn-id>	
        /// <unmanaged>DWRITE_MEASURING_MODE measuringMode</unmanaged>	
        /// <unmanaged-short>DWRITE_MEASURING_MODE measuringMode</unmanaged-short>	
        public SharpDX.Direct2D1.MeasuringMode MeasuringMode;

        // Internal native struct used for marshalling
        [StructLayout(LayoutKind.Sequential)]
        internal partial struct __Native {	
            public float Width;
            public float Thickness;
            public float Offset;
            public float RunHeight;
            public SharpDX.DirectWrite.ReadingDirection ReadingDirection;
            public SharpDX.DirectWrite.FlowDirection FlowDirection;
            public System.IntPtr LocaleName;
            public SharpDX.Direct2D1.MeasuringMode MeasuringMode;
		    // Method to free unmanaged allocation
            internal unsafe void __MarshalFree()
            {   
                if (this.LocaleName != IntPtr.Zero)
                    Marshal.FreeHGlobal(this.LocaleName);		
            }
        }
		
		// Method to free unmanaged allocation
        internal unsafe void __MarshalFree(ref __Native @ref)
        {   
            @ref.__MarshalFree();
        }
		
		// Method to marshal from native to managed struct
        internal unsafe void __MarshalFrom(ref __Native @ref)
        {            
            this.Width = @ref.Width;
            this.Thickness = @ref.Thickness;
            this.Offset = @ref.Offset;
            this.RunHeight = @ref.RunHeight;
            this.ReadingDirection = @ref.ReadingDirection;
            this.FlowDirection = @ref.FlowDirection;
            this.LocaleName = ( @ref.LocaleName == IntPtr.Zero )?null:Marshal.PtrToStringUni(@ref.LocaleName);
            this.MeasuringMode = @ref.MeasuringMode;
        }
        // Method to marshal from managed struct tot native
        internal unsafe void __MarshalTo(ref __Native @ref)
        {
            @ref.Width = this.Width;
            @ref.Thickness = this.Thickness;
            @ref.Offset = this.Offset;
            @ref.RunHeight = this.RunHeight;
            @ref.ReadingDirection = this.ReadingDirection;
            @ref.FlowDirection = this.FlowDirection;
            @ref.LocaleName = ( this.LocaleName == null )?IntPtr.Zero : Utilities.StringToHGlobalUni(this.LocaleName);
            @ref.MeasuringMode = this.MeasuringMode;
		
		}
    }
    
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.DirectWrite.UnicodeRange"/></strong> structure specifies the range of Unicode code points.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_UNICODE_RANGE']/*"/>	
    /// <msdn-id>jj126265</msdn-id>	
    /// <unmanaged>DWRITE_UNICODE_RANGE</unmanaged>	
    /// <unmanaged-short>DWRITE_UNICODE_RANGE</unmanaged-short>	
    [StructLayout(LayoutKind.Sequential)]
    public  partial struct UnicodeRange {	
        
        /// <summary>	
        /// <dd> <p>The first code point in the Unicode range.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_UNICODE_RANGE::first']/*"/>	
        /// <msdn-id>jj126265</msdn-id>	
        /// <unmanaged>unsigned int first</unmanaged>	
        /// <unmanaged-short>unsigned int first</unmanaged-short>	
        public int First;
        
        /// <summary>	
        /// <dd> <p>The last code point in the Unicode range.</p> </dd>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='DWRITE_UNICODE_RANGE::last']/*"/>	
        /// <msdn-id>jj126265</msdn-id>	
        /// <unmanaged>unsigned int last</unmanaged>	
        /// <unmanaged-short>unsigned int last</unmanaged-short>	
        public int Last;
    }
}
