// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.DirectWrite namespace.
//     This code was generated by a tool.
//     Date : 6/25/2016 10:38:12 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
namespace SharpDX.DirectWrite
{

    // Disable warning : XML comment is not placed on a valid language element
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
    /// <summary>	
    /// <p> Encapsulates a 32-bit device independent bitmap and device context, which can be used for rendering glyphs.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>You create an <strong><see cref="SharpDX.DirectWrite.BitmapRenderTarget"/></strong> by using the <strong><see cref="SharpDX.DirectWrite.GdiInterop.CreateBitmapRenderTarget"/></strong> method, as shown in the following code.</p><pre>if (SUCCEEDED(hr))	
    /// { hr = g_pGdiInterop-&gt;CreateBitmapRenderTarget(hdc, r.right, r.bottom, &amp;g_pBitmapRenderTarget);	
    /// }	
    /// </pre><p> <strong><see cref="SharpDX.DirectWrite.GdiInterop.CreateBitmapRenderTarget"/></strong> takes a handle to a DC and the desired width and height.  In the above example, the width and height given are the size of the window rect.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget']/*"/>	
    /// <msdn-id>dd368165</msdn-id>	
    /// <unmanaged>IDWriteBitmapRenderTarget</unmanaged>	
    /// <unmanaged-short>IDWriteBitmapRenderTarget</unmanaged-short>	
    [Guid("5e5a32a3-8dff-4773-9ff6-0696eab77267")]
    public partial class BitmapRenderTarget : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.BitmapRenderTarget"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapRenderTarget(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.BitmapRenderTarget"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.BitmapRenderTarget(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.BitmapRenderTarget(nativePointer);
        }


        /// <summary>	
        /// <p> Gets a handle to the memory device context. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p> An application can use the device context to draw using GDI functions. An application can obtain the bitmap handle (<see cref="System.IntPtr"/>) by calling <strong>GetCurrentObject</strong>. An application that wants information about the underlying bitmap, including a reference to the pixel data, can call <strong>GetObject</strong> to fill in a <strong>DIBSECTION</strong> structure. The bitmap is always a 32-bit  top-down DIB. </p><p>Note that this method takes no parameters and returns an <see cref="System.IntPtr"/> variable, not an <see cref="SharpDX.Result"/>.</p><pre>memoryHdc = g_pBitmapRenderTarget-&gt;GetMemoryDC();	
        /// </pre><p>The <see cref="System.IntPtr"/> returned here is still owned by the bitmap render targer object and should not be released or deleted by the client.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget::GetMemoryDC']/*"/>	
        /// <msdn-id>dd368171</msdn-id>	
        /// <unmanaged>GetMemoryDC</unmanaged>	
        /// <unmanaged-short>GetMemoryDC</unmanaged-short>	
        /// <unmanaged>HDC IDWriteBitmapRenderTarget::GetMemoryDC()</unmanaged>
        public System.IntPtr MemoryDC
        {
            get { return GetMemoryDC(); }
        }

        /// <summary>	
        /// <p>Gets or sets the number of bitmap pixels per DIP.  </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>A DIP (device-independent pixel) is 1/96 inch. Therefore, this value is the number if pixels per inch divided by 96.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget::GetPixelsPerDip']/*"/>	
        /// <msdn-id>dd368173</msdn-id>	
        /// <unmanaged>GetPixelsPerDip / SetPixelsPerDip</unmanaged>	
        /// <unmanaged-short>GetPixelsPerDip</unmanaged-short>	
        /// <unmanaged>float IDWriteBitmapRenderTarget::GetPixelsPerDip()</unmanaged>
        public float PixelsPerDip
        {
            get { return GetPixelsPerDip(); }
            set { SetPixelsPerDip(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the transform that maps abstract coordinates to DIPs. By default this is the identity  transform. Note that this is unrelated to the world transform of the underlying device context. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget::GetCurrentTransform']/*"/>	
        /// <msdn-id>dd368169</msdn-id>	
        /// <unmanaged>GetCurrentTransform / SetCurrentTransform</unmanaged>	
        /// <unmanaged-short>GetCurrentTransform</unmanaged-short>	
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget::GetCurrentTransform([Out] DWRITE_MATRIX* transform)</unmanaged>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 CurrentTransform
        {
            get { SharpDX.Mathematics.Interop.RawMatrix3x2 __output__; GetCurrentTransform(out __output__); return __output__; }
            set { SetCurrentTransform(value); }
        }

        /// <summary>	
        /// <p> Gets the dimensions of the target bitmap. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget::GetSize']/*"/>	
        /// <msdn-id>dd368176</msdn-id>	
        /// <unmanaged>GetSize</unmanaged>	
        /// <unmanaged-short>GetSize</unmanaged-short>	
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget::GetSize([Out] SIZE* size)</unmanaged>
        public SharpDX.Size2 Size
        {
            get { SharpDX.Size2 __output__; GetSize(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Draws a run of glyphs to a bitmap target at the specified position.</p>	
        /// </summary>	
        /// <param name="baselineOriginX"><dd>  <p> The horizontal position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</p> </dd></param>	
        /// <param name="baselineOriginY"><dd>  <p> The vertical position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</p> </dd></param>	
        /// <param name="measuringMode"><dd>  <p> The measuring method for glyphs in the run, used with the other properties to determine the rendering mode.</p> </dd></param>	
        /// <param name="glyphRun"><dd>  <p> The structure containing the properties of the glyph run.</p> </dd></param>	
        /// <param name="renderingParams"><dd>  <p> The object that controls rendering behavior.</p> </dd></param>	
        /// <param name="textColor"><dd>  <p> The foreground color of the text.</p> </dd></param>	
        /// <param name="blackBoxRect"><dd>  <p> The optional rectangle that receives the bounding box (in pixels not DIPs) of all the pixels affected by  drawing the glyph run. The black box rectangle may extend beyond the dimensions of the bitmap.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>You can use the <strong><see cref="SharpDX.DirectWrite.BitmapRenderTarget.DrawGlyphRun"/></strong> to render to a bitmap from a custom text renderer that you implement.  The custom text renderer should call this method from within the <strong><see cref="SharpDX.DirectWrite.TextRenderer.DrawGlyphRun"/></strong> callback method as shown in the following code.</p><pre>STDMETHODIMP GdiTextRenderer::DrawGlyphRun( __maybenull void* clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, <see cref="SharpDX.Direct2D1.MeasuringMode"/> measuringMode, __in <see cref="SharpDX.DirectWrite.GlyphRun"/> const* glyphRun, __in <see cref="SharpDX.DirectWrite.GlyphRunDescription"/> const* glyphRunDescription, <see cref="SharpDX.ComObject"/>* clientDrawingEffect )	
        /// { <see cref="SharpDX.Result"/> hr = <see cref="SharpDX.Result.Ok"/>; // Pass on the drawing call to the render target to do the real work. <see cref="SharpDX.Mathematics.Interop.RawRectangle"/> dirtyRect = {0}; hr = pRenderTarget_-&gt;DrawGlyphRun( baselineOriginX, baselineOriginY, measuringMode, glyphRun, pRenderingParams_, RGB(0,200,255), &amp;dirtyRect ); return hr;	
        /// }	
        /// </pre><p>The <em>baselineOriginX</em>, <em>baslineOriginY</em>, <em>measuringMethod</em>, and <em>glyphRun</em> parameters are provided (as arguments) when the callback method is invoked.  The <em>renderingParams</em>, <em>textColor</em> and <em>blackBoxRect</em> are not.</p><p>Default rendering params can be retrieved by using the <strong><see cref="SharpDX.DirectWrite.Factory.CreateMonitorRenderingParams"/></strong> method.</p><p></p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget::DrawGlyphRun']/*"/>	
        /// <msdn-id>dd368167</msdn-id>	
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget::DrawGlyphRun([In] float baselineOriginX,[In] float baselineOriginY,[In] DWRITE_MEASURING_MODE measuringMode,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] IDWriteRenderingParams* renderingParams,[In] int textColor,[Out, Optional] RECT* blackBoxRect)</unmanaged>	
        /// <unmanaged-short>IDWriteBitmapRenderTarget::DrawGlyphRun</unmanaged-short>	
        private void DrawGlyphRun(float baselineOriginX, float baselineOriginY, SharpDX.Direct2D1.MeasuringMode measuringMode, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.DirectWrite.RenderingParams renderingParams, int textColor, out SharpDX.Mathematics.Interop.RawRectangle blackBoxRect)
        {
            unsafe
            {
                var glyphRun_ = new SharpDX.DirectWrite.GlyphRun.__Native();
                glyphRun.__MarshalTo(ref glyphRun_);
                blackBoxRect = new SharpDX.Mathematics.Interop.RawRectangle();
                SharpDX.Result __result__;
                fixed (void* blackBoxRect_ = &blackBoxRect)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, baselineOriginX, baselineOriginY, unchecked((int)measuringMode), &glyphRun_, (void*)((renderingParams == null) ? IntPtr.Zero : renderingParams.NativePointer), textColor, blackBoxRect_, ((void**)(*(void**)_nativePointer))[3]);
                glyphRun.__MarshalFree(ref glyphRun_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets a handle to the memory device context. </p>	
        /// </summary>	
        /// <returns><p>Returns a device context handle to the memory device context.</p></returns>	
        /// <remarks>	
        /// <p> An application can use the device context to draw using GDI functions. An application can obtain the bitmap handle (<see cref="System.IntPtr"/>) by calling <strong>GetCurrentObject</strong>. An application that wants information about the underlying bitmap, including a reference to the pixel data, can call <strong>GetObject</strong> to fill in a <strong>DIBSECTION</strong> structure. The bitmap is always a 32-bit  top-down DIB. </p><p>Note that this method takes no parameters and returns an <see cref="System.IntPtr"/> variable, not an <see cref="SharpDX.Result"/>.</p><pre>memoryHdc = g_pBitmapRenderTarget-&gt;GetMemoryDC();	
        /// </pre><p>The <see cref="System.IntPtr"/> returned here is still owned by the bitmap render targer object and should not be released or deleted by the client.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget::GetMemoryDC']/*"/>	
        /// <msdn-id>dd368171</msdn-id>	
        /// <unmanaged>HDC IDWriteBitmapRenderTarget::GetMemoryDC()</unmanaged>	
        /// <unmanaged-short>IDWriteBitmapRenderTarget::GetMemoryDC</unmanaged-short>	
        internal System.IntPtr GetMemoryDC()
        {
            unsafe
            {
                System.IntPtr __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSystemIntPtr(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the number of bitmap pixels per DIP.  </p>	
        /// </summary>	
        /// <returns><p>The number of bitmap pixels per DIP.</p></returns>	
        /// <remarks>	
        /// <p>A DIP (device-independent pixel) is 1/96 inch. Therefore, this value is the number if pixels per inch divided by 96.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget::GetPixelsPerDip']/*"/>	
        /// <msdn-id>dd368173</msdn-id>	
        /// <unmanaged>float IDWriteBitmapRenderTarget::GetPixelsPerDip()</unmanaged>	
        /// <unmanaged-short>IDWriteBitmapRenderTarget::GetPixelsPerDip</unmanaged-short>	
        internal float GetPixelsPerDip()
        {
            unsafe
            {
                float __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callifloat(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Sets the number of bitmap pixels per DIP (device-independent pixel). A DIP is 1/96 inch, so this value is the number if pixels per inch divided by 96. </p>	
        /// </summary>	
        /// <param name="pixelsPerDip"><dd>  <p>A value that specifies the number of pixels per DIP.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget::SetPixelsPerDip']/*"/>	
        /// <msdn-id>dd368182</msdn-id>	
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget::SetPixelsPerDip([In] float pixelsPerDip)</unmanaged>	
        /// <unmanaged-short>IDWriteBitmapRenderTarget::SetPixelsPerDip</unmanaged-short>	
        internal void SetPixelsPerDip(float pixelsPerDip)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, pixelsPerDip, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the transform that maps abstract coordinates to DIPs. By default this is the identity  transform. Note that this is unrelated to the world transform of the underlying device context. </p>	
        /// </summary>	
        /// <param name="transform"><dd>  <p>When this method returns, contains a transform matrix.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget::GetCurrentTransform']/*"/>	
        /// <msdn-id>dd368169</msdn-id>	
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget::GetCurrentTransform([Out] DWRITE_MATRIX* transform)</unmanaged>	
        /// <unmanaged-short>IDWriteBitmapRenderTarget::GetCurrentTransform</unmanaged-short>	
        internal void GetCurrentTransform(out SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            unsafe
            {
                transform = new SharpDX.Mathematics.Interop.RawMatrix3x2();
                SharpDX.Result __result__;
                fixed (void* transform_ = &transform)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, transform_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the transform that maps abstract coordinate to DIPs (device-independent pixel). This does not affect the world transform of the underlying device context. </p>	
        /// </summary>	
        /// <param name="transform"><dd>  <p> Specifies the new transform. This parameter can be <strong><c>null</c></strong>, in which case the identity transform is implied.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget::SetCurrentTransform']/*"/>	
        /// <msdn-id>dd368179</msdn-id>	
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget::SetCurrentTransform([In, Optional] const DWRITE_MATRIX* transform)</unmanaged>	
        /// <unmanaged-short>IDWriteBitmapRenderTarget::SetCurrentTransform</unmanaged-short>	
        internal void SetCurrentTransform(SharpDX.Mathematics.Interop.RawMatrix3x2? transform)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
                if (transform.HasValue)
                    transform_ = transform.Value;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (transform.HasValue) ? &transform_ : (void*)IntPtr.Zero, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the dimensions of the target bitmap. </p>	
        /// </summary>	
        /// <param name="size"><dd>  <p>Returns  the width and height of the bitmap in pixels.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget::GetSize']/*"/>	
        /// <msdn-id>dd368176</msdn-id>	
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget::GetSize([Out] SIZE* size)</unmanaged>	
        /// <unmanaged-short>IDWriteBitmapRenderTarget::GetSize</unmanaged-short>	
        internal void GetSize(out SharpDX.Size2 size)
        {
            unsafe
            {
                size = new SharpDX.Size2();
                SharpDX.Result __result__;
                fixed (void* size_ = &size)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, size_, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Resizes the bitmap. </p>	
        /// </summary>	
        /// <param name="width"><dd>  <p>The new bitmap width, in pixels.</p> </dd></param>	
        /// <param name="height"><dd>  <p>The new bitmap height, in pixels.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget::Resize']/*"/>	
        /// <msdn-id>dd368177</msdn-id>	
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget::Resize([In] unsigned int width,[In] unsigned int height)</unmanaged>	
        /// <unmanaged-short>IDWriteBitmapRenderTarget::Resize</unmanaged-short>	
        public void Resize(int width, int height)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, width, height, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Encapsulates a 32-bit device independent bitmap and device context, which you can use for rendering glyphs.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget1']/*"/>	
    /// <msdn-id>hh780398</msdn-id>	
    /// <unmanaged>IDWriteBitmapRenderTarget1</unmanaged>	
    /// <unmanaged-short>IDWriteBitmapRenderTarget1</unmanaged-short>	
    [Guid("791e8298-3ef3-4230-9880-c9bdecc42064")]
    public partial class BitmapRenderTarget1 : SharpDX.DirectWrite.BitmapRenderTarget
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.BitmapRenderTarget1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapRenderTarget1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.BitmapRenderTarget1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.BitmapRenderTarget1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.BitmapRenderTarget1(nativePointer);
        }


        /// <summary>	
        /// <p>Gets or sets the current text antialiasing mode of the bitmap render target.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget1::GetTextAntialiasMode']/*"/>	
        /// <msdn-id>Hh780399</msdn-id>	
        /// <unmanaged>GetTextAntialiasMode / SetTextAntialiasMode</unmanaged>	
        /// <unmanaged-short>GetTextAntialiasMode</unmanaged-short>	
        /// <unmanaged>DWRITE_TEXT_ANTIALIAS_MODE IDWriteBitmapRenderTarget1::GetTextAntialiasMode()</unmanaged>
        public SharpDX.DirectWrite.TextAntialiasMode TextAntialiasMode
        {
            get { return GetTextAntialiasMode(); }
            set { SetTextAntialiasMode(value); }
        }

        /// <summary>	
        /// <p>Gets the current text antialiasing mode of the bitmap render target.</p>	
        /// </summary>	
        /// <returns><p>Returns a <strong><see cref="SharpDX.DirectWrite.TextAntialiasMode"/></strong>-typed value that specifies the antialiasing mode.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget1::GetTextAntialiasMode']/*"/>	
        /// <msdn-id>Hh780399</msdn-id>	
        /// <unmanaged>DWRITE_TEXT_ANTIALIAS_MODE IDWriteBitmapRenderTarget1::GetTextAntialiasMode()</unmanaged>	
        /// <unmanaged-short>IDWriteBitmapRenderTarget1::GetTextAntialiasMode</unmanaged-short>	
        internal SharpDX.DirectWrite.TextAntialiasMode GetTextAntialiasMode()
        {
            unsafe
            {
                SharpDX.DirectWrite.TextAntialiasMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteTextAntialiasMode(_nativePointer, ((void**)(*(void**)_nativePointer))[11]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Sets the current text antialiasing mode of the bitmap render target.</p>	
        /// </summary>	
        /// <param name="antialiasMode"><dd>  <p>A <strong><see cref="SharpDX.DirectWrite.TextAntialiasMode"/></strong>-typed value that specifies the antialiasing mode.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, or E_INVALIDARG if the argument is not valid.</p></returns>	
        /// <remarks>	
        /// <p>The antialiasing mode of a newly-created bitmap render target defaults to  <strong><see cref="SharpDX.DirectWrite.TextAntialiasMode.Cleartype"/></strong>. An app can change the antialiasing mode by calling <strong>SetTextAntialiasMode</strong>. For example, an app might specify <strong><see cref="SharpDX.DirectWrite.TextAntialiasMode.Grayscale"/></strong> for grayscale antialiasing when it renders text onto a transparent bitmap.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteBitmapRenderTarget1::SetTextAntialiasMode']/*"/>	
        /// <msdn-id>Hh780400</msdn-id>	
        /// <unmanaged>HRESULT IDWriteBitmapRenderTarget1::SetTextAntialiasMode([In] DWRITE_TEXT_ANTIALIAS_MODE antialiasMode)</unmanaged>	
        /// <unmanaged-short>IDWriteBitmapRenderTarget1::SetTextAntialiasMode</unmanaged-short>	
        internal void SetTextAntialiasMode(SharpDX.DirectWrite.TextAntialiasMode antialiasMode)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)antialiasMode), ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Used to create all subsequent DirectWrite objects. This interface is the root factory interface for all DirectWrite objects.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> Create an <strong><see cref="SharpDX.DirectWrite.Factory"/></strong> object by using the <strong><see cref="SharpDX.DirectWrite.DWrite.CreateFactory"/></strong> function.  </p><pre> if (SUCCEEDED(hr))	
    /// { hr = <see cref="SharpDX.DirectWrite.DWrite.CreateFactory"/>( <see cref="SharpDX.DirectWrite.FactoryType.Shared"/>, __uuidof(<see cref="SharpDX.DirectWrite.Factory"/>), reinterpret_cast&lt;<see cref="SharpDX.ComObject"/>**&gt;(&amp;pDWriteFactory_) );	
    /// } </pre><p>An <strong><see cref="SharpDX.DirectWrite.Factory"/></strong> object holds state information, such as font loader registration and cached font data.  This state can be shared or isolated.  Shared is recommended for most applications because it saves memory.  However, isolated can be useful in situations where you want to have a separate state for some objects.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory']/*"/>	
    /// <msdn-id>dd368183</msdn-id>	
    /// <unmanaged>IDWriteFactory</unmanaged>	
    /// <unmanaged-short>IDWriteFactory</unmanaged-short>	
    [Guid("b859ee5a-d838-4b5b-a2e8-1adc7d93db48")]
    public partial class Factory : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.Factory"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Factory(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.Factory"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.Factory(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.Factory(nativePointer);
        }


        /// <summary>	
        /// <p> Creates an object that is used for interoperability with GDI. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::GetGdiInterop']/*"/>	
        /// <msdn-id>dd368207</msdn-id>	
        /// <unmanaged>GetGdiInterop</unmanaged>	
        /// <unmanaged-short>GetGdiInterop</unmanaged-short>	
        /// <unmanaged>HRESULT IDWriteFactory::GetGdiInterop([Out] IDWriteGdiInterop** gdiInterop)</unmanaged>
        public SharpDX.DirectWrite.GdiInterop GdiInterop
        {
            get { SharpDX.DirectWrite.GdiInterop __output__; GetGdiInterop(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Gets an object which represents the set of installed fonts. </p>	
        /// </summary>	
        /// <param name="checkForUpdates"><dd>  <p>If this parameter is nonzero, the function performs an immediate check for changes to the set of installed fonts. If this parameter is <strong><see cref="SharpDX.Result.False"/></strong>, the function will still detect changes if the font cache service is running, but there may be some latency. For example, an application might specify <strong>TRUE</strong> if it has itself just installed a font and wants to  be sure the font collection contains that font.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains the address of a reference to the system font collection object, or <strong><c>null</c></strong> in case of failure.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::GetSystemFontCollection']/*"/>	
        /// <msdn-id>dd368208</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::GetSystemFontCollection([Out] IDWriteFontCollection** fontCollection,[In] BOOL checkForUpdates)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::GetSystemFontCollection</unmanaged-short>	
        public SharpDX.DirectWrite.FontCollection GetSystemFontCollection(SharpDX.Mathematics.Interop.RawBool checkForUpdates)
        {
            unsafe
            {
                SharpDX.DirectWrite.FontCollection fontCollection;
                IntPtr fontCollection_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint162(_nativePointer, &fontCollection_, checkForUpdates, ((void**)(*(void**)_nativePointer))[3]);
                fontCollection = (fontCollection_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.FontCollection(fontCollection_);
                __result__.CheckError();
                return fontCollection;
            }
        }

        /// <summary>	
        /// <p> Creates a font collection using a custom font collection loader. </p>	
        /// </summary>	
        /// <param name="collectionLoader"><dd>  <p>An application-defined font collection loader, which must have been previously registered using <strong>RegisterFontCollectionLoader</strong>.</p> </dd></param>	
        /// <param name="collectionKey"><dd>  <p>The key used by the loader to identify a collection of font files.  The buffer allocated for this key should at least be the size of <em>collectionKeySize</em>.</p> </dd></param>	
        /// <param name="collectionKeySize"><dd>  <p>The size, in bytes, of the collection key.</p> </dd></param>	
        /// <param name="fontCollection"><dd>  <p>Contains  an address of a reference to the system font collection object if the method succeeds, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateCustomFontCollection']/*"/>	
        /// <msdn-id>dd368186</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateCustomFontCollection([In] IDWriteFontCollectionLoader* collectionLoader,[In, Buffer] const void* collectionKey,[In] unsigned int collectionKeySize,[Out, Fast] IDWriteFontCollection** fontCollection)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateCustomFontCollection</unmanaged-short>	
        internal void CreateCustomFontCollection_(System.IntPtr collectionLoader, System.IntPtr collectionKey, int collectionKeySize, SharpDX.DirectWrite.FontCollection fontCollection)
        {
            unsafe
            {
                IntPtr fontCollection_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)collectionLoader, (void*)collectionKey, collectionKeySize, &fontCollection_, ((void**)(*(void**)_nativePointer))[4]);
                ((SharpDX.DirectWrite.FontCollection)fontCollection).NativePointer = fontCollection_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Registers a custom font collection loader with the factory object. </p>	
        /// </summary>	
        /// <param name="fontCollectionLoader"><dd>  <p>Pointer to a <strong><see cref="SharpDX.DirectWrite.FontCollectionLoader"/></strong> object to be registered.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function registers a font collection loader with DirectWrite. The font collection loader interface, which should be implemented by a singleton object, handles enumerating font files in a font collection given a particular type of key. A given instance can only be registered once. Succeeding attempts will return an error, indicating that it has already been registered. Note that font file loader implementations must not register themselves with DirectWrite inside their constructors, and must not unregister themselves inside their destructors, because registration and unregistraton operations increment and decrement the object reference count respectively. Instead, registration and unregistration with DirectWrite of font file loaders should be performed outside of the font file loader implementation.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::RegisterFontCollectionLoader']/*"/>	
        /// <msdn-id>dd368209</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::RegisterFontCollectionLoader([In] IDWriteFontCollectionLoader* fontCollectionLoader)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::RegisterFontCollectionLoader</unmanaged-short>	
        internal void RegisterFontCollectionLoader_(System.IntPtr fontCollectionLoader)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)fontCollectionLoader, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Unregisters a custom font collection loader that was previously registered using <strong>RegisterFontCollectionLoader</strong>. </p>	
        /// </summary>	
        /// <param name="fontCollectionLoader">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::UnregisterFontCollectionLoader']/*"/>	
        /// <msdn-id>dd368211</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::UnregisterFontCollectionLoader([In] IDWriteFontCollectionLoader* fontCollectionLoader)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::UnregisterFontCollectionLoader</unmanaged-short>	
        internal void UnregisterFontCollectionLoader_(System.IntPtr fontCollectionLoader)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)fontCollectionLoader, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates a font file reference object from a local font file. </p>	
        /// </summary>	
        /// <param name="filePath"><dd>  <p>An array of characters that contains the absolute file path for the font file. Subsequent operations on the constructed object may fail if the user provided <em>filePath</em> doesn't correspond to a valid file on the disk.</p> </dd></param>	
        /// <param name="lastWriteTime"><dd>  <p>The last modified time of the input file path. If the parameter is omitted, the function will access the font file to obtain its last write time. You should specify this value to avoid extra disk access. Subsequent operations on the constructed object may fail if the user provided <em>lastWriteTime</em> doesn't match the file on the disk.</p> </dd></param>	
        /// <param name="fontFile"><dd>  <p>When this method returns, contains an address of a reference to the newly created font file reference object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateFontFileReference']/*"/>	
        /// <msdn-id>dd368197</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateFontFileReference([In] const wchar_t* filePath,[In, Optional] const FILETIME* lastWriteTime,[Out, Fast] IDWriteFontFile** fontFile)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateFontFileReference</unmanaged-short>	
        internal void CreateFontFileReference(string filePath, long? lastWriteTime, SharpDX.DirectWrite.FontFile fontFile)
        {
            unsafe
            {
                IntPtr filePath_ = Utilities.StringToHGlobalUni(filePath);
                long lastWriteTime_;
                if (lastWriteTime.HasValue)
                    lastWriteTime_ = lastWriteTime.Value;
                IntPtr fontFile_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)filePath_, (lastWriteTime.HasValue) ? &lastWriteTime_ : (void*)IntPtr.Zero, &fontFile_, ((void**)(*(void**)_nativePointer))[7]);
                Marshal.FreeHGlobal(filePath_);
                ((SharpDX.DirectWrite.FontFile)fontFile).NativePointer = fontFile_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates a reference to an application-specific font file resource. </p>	
        /// </summary>	
        /// <param name="fontFileReferenceKey"><dd>  <p>A font file reference key that uniquely identifies the font file resource during the lifetime of <em>fontFileLoader</em>.</p> </dd></param>	
        /// <param name="fontFileReferenceKeySize"><dd>  <p>The size of the font file reference key in bytes.</p> </dd></param>	
        /// <param name="fontFileLoader"><dd>  <p>The font file loader that will be used by the font system to load data from the file identified by <em>fontFileReferenceKey</em>.</p> </dd></param>	
        /// <param name="fontFile"><dd>  <p>Contains an address of a reference to the newly created font file object when this method succeeds, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This function is provided for cases when an application or a document needs to use a private font without having to install it on the system. <em>fontFileReferenceKey</em> has to be unique only in the scope of the <em>fontFileLoader</em> used in this call. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateCustomFontFileReference']/*"/>	
        /// <msdn-id>dd368188</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateCustomFontFileReference([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[In] IDWriteFontFileLoader* fontFileLoader,[Out, Fast] IDWriteFontFile** fontFile)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateCustomFontFileReference</unmanaged-short>	
        internal void CreateCustomFontFileReference_(System.IntPtr fontFileReferenceKey, int fontFileReferenceKeySize, System.IntPtr fontFileLoader, SharpDX.DirectWrite.FontFile fontFile)
        {
            unsafe
            {
                IntPtr fontFile_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)fontFileReferenceKey, fontFileReferenceKeySize, (void*)fontFileLoader, &fontFile_, ((void**)(*(void**)_nativePointer))[8]);
                ((SharpDX.DirectWrite.FontFile)fontFile).NativePointer = fontFile_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates an object that represents a font face. </p>	
        /// </summary>	
        /// <param name="fontFaceType"><dd>  <p>A value that indicates the type of file format of the font face.</p> </dd></param>	
        /// <param name="numberOfFiles"><dd>  <p>The number of font files, in element count, required to represent the font face.</p> </dd></param>	
        /// <param name="fontFiles"><dd>  <p>A font file object representing the font face.  Because <strong><see cref="SharpDX.DirectWrite.FontFace"/></strong> maintains its own references to the input font file objects, you may release them after this call.</p> </dd></param>	
        /// <param name="faceIndex"><dd>  <p>The zero-based index of a font face, in cases when the font files contain a collection of font faces. If the font files contain a single face, this value should be zero.</p> </dd></param>	
        /// <param name="fontFaceSimulationFlags"><dd>  <p>A value that indicates which, if any, font face simulation flags for algorithmic means of making text bold or italic are applied to the current font face.</p> </dd></param>	
        /// <param name="fontFace"><dd>  <p>When this method returns, contains an address of a reference to the newly created font face object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateFontFace']/*"/>	
        /// <msdn-id>dd368196</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateFontFace([In] DWRITE_FONT_FACE_TYPE fontFaceType,[In] unsigned int numberOfFiles,[In, Buffer] const IDWriteFontFile** fontFiles,[In] unsigned int faceIndex,[In] DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,[Out, Fast] IDWriteFontFace** fontFace)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateFontFace</unmanaged-short>	
        internal void CreateFontFace(SharpDX.DirectWrite.FontFaceType fontFaceType, int numberOfFiles, SharpDX.DirectWrite.FontFile[] fontFiles, int faceIndex, SharpDX.DirectWrite.FontSimulations fontFaceSimulationFlags, SharpDX.DirectWrite.FontFace fontFace)
        {
            unsafe
            {
                IntPtr* fontFiles_ = (IntPtr*)0;
                if (fontFiles != null)
                {
                    IntPtr* fontFiles__ = stackalloc IntPtr[fontFiles.Length];
                    fontFiles_ = fontFiles__;
                    for (int i = 0; i < fontFiles.Length; i++)
                        fontFiles_[i] = (fontFiles[i] == null) ? IntPtr.Zero : fontFiles[i].NativePointer;
                }
                IntPtr fontFace_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)fontFaceType), numberOfFiles, fontFiles_, faceIndex, unchecked((int)fontFaceSimulationFlags), &fontFace_, ((void**)(*(void**)_nativePointer))[9]);
                ((SharpDX.DirectWrite.FontFace)fontFace).NativePointer = fontFace_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates an object that represents a font face. </p>	
        /// </summary>	
        /// <param name="fontFaceType"><dd>  <p>A value that indicates the type of file format of the font face.</p> </dd></param>	
        /// <param name="numberOfFiles"><dd>  <p>The number of font files, in element count, required to represent the font face.</p> </dd></param>	
        /// <param name="fontFiles"><dd>  <p>A font file object representing the font face.  Because <strong><see cref="SharpDX.DirectWrite.FontFace"/></strong> maintains its own references to the input font file objects, you may release them after this call.</p> </dd></param>	
        /// <param name="faceIndex"><dd>  <p>The zero-based index of a font face, in cases when the font files contain a collection of font faces. If the font files contain a single face, this value should be zero.</p> </dd></param>	
        /// <param name="fontFaceSimulationFlags"><dd>  <p>A value that indicates which, if any, font face simulation flags for algorithmic means of making text bold or italic are applied to the current font face.</p> </dd></param>	
        /// <param name="fontFace"><dd>  <p>When this method returns, contains an address of a reference to the newly created font face object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateFontFace']/*"/>	
        /// <msdn-id>dd368196</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateFontFace([In] DWRITE_FONT_FACE_TYPE fontFaceType,[In] unsigned int numberOfFiles,[In, Buffer] const IDWriteFontFile** fontFiles,[In] unsigned int faceIndex,[In] DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,[Out, Fast] IDWriteFontFace** fontFace)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateFontFace</unmanaged-short>	
        internal void CreateFontFace(SharpDX.DirectWrite.FontFaceType fontFaceType, int numberOfFiles, SharpDX.ComArray<SharpDX.DirectWrite.FontFile> fontFiles, int faceIndex, SharpDX.DirectWrite.FontSimulations fontFaceSimulationFlags, SharpDX.DirectWrite.FontFace fontFace)
        {
            unsafe
            {
                IntPtr fontFace_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)fontFaceType), numberOfFiles, (void*)((fontFiles == null) ? IntPtr.Zero : fontFiles.NativePointer), faceIndex, unchecked((int)fontFaceSimulationFlags), &fontFace_, ((void**)(*(void**)_nativePointer))[9]);
                ((SharpDX.DirectWrite.FontFace)fontFace).NativePointer = fontFace_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates an object that represents a font face. </p>	
        /// </summary>	
        /// <param name="fontFaceType"><dd>  <p>A value that indicates the type of file format of the font face.</p> </dd></param>	
        /// <param name="numberOfFiles"><dd>  <p>The number of font files, in element count, required to represent the font face.</p> </dd></param>	
        /// <param name="fontFiles"><dd>  <p>A font file object representing the font face.  Because <strong><see cref="SharpDX.DirectWrite.FontFace"/></strong> maintains its own references to the input font file objects, you may release them after this call.</p> </dd></param>	
        /// <param name="faceIndex"><dd>  <p>The zero-based index of a font face, in cases when the font files contain a collection of font faces. If the font files contain a single face, this value should be zero.</p> </dd></param>	
        /// <param name="fontFaceSimulationFlags"><dd>  <p>A value that indicates which, if any, font face simulation flags for algorithmic means of making text bold or italic are applied to the current font face.</p> </dd></param>	
        /// <param name="fontFace"><dd>  <p>When this method returns, contains an address of a reference to the newly created font face object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateFontFace']/*"/>	
        /// <msdn-id>dd368196</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateFontFace([In] DWRITE_FONT_FACE_TYPE fontFaceType,[In] unsigned int numberOfFiles,[In, Buffer] const IDWriteFontFile** fontFiles,[In] unsigned int faceIndex,[In] DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,[Out, Fast] IDWriteFontFace** fontFace)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateFontFace</unmanaged-short>	
        private void CreateFontFace(SharpDX.DirectWrite.FontFaceType fontFaceType, int numberOfFiles, System.IntPtr fontFiles, int faceIndex, SharpDX.DirectWrite.FontSimulations fontFaceSimulationFlags, System.IntPtr fontFace)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)fontFaceType), numberOfFiles, (void*)fontFiles, faceIndex, unchecked((int)fontFaceSimulationFlags), (void*)fontFace, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates a rendering parameters object with default settings for the primary monitor. Different monitors may have different rendering parameters, for more information see the How to Add Support for Multiple Monitors topic.</p>	
        /// </summary>	
        /// <param name="renderingParams">No documentation.</param>	
        /// <returns><p>Standard <see cref="SharpDX.Result"/> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateRenderingParams']/*"/>	
        /// <msdn-id>dd368201</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateRenderingParams([Out, Fast] IDWriteRenderingParams** renderingParams)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateRenderingParams</unmanaged-short>	
        internal void CreateRenderingParams(SharpDX.DirectWrite.RenderingParams renderingParams)
        {
            unsafe
            {
                IntPtr renderingParams_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &renderingParams_, ((void**)(*(void**)_nativePointer))[10]);
                ((SharpDX.DirectWrite.RenderingParams)renderingParams).NativePointer = renderingParams_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates a rendering parameters object with default settings for the specified monitor. In most cases, this is the preferred way to create a rendering parameters object.</p>	
        /// </summary>	
        /// <param name="monitor"><dd>  <p>A handle for the specified monitor.</p> </dd></param>	
        /// <param name="renderingParams"><dd>  <p>When this method returns, contains an address of a reference to the rendering parameters object created by this method.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateMonitorRenderingParams']/*"/>	
        /// <msdn-id>dd368199</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateMonitorRenderingParams([In] HMONITOR monitor,[Out, Fast] IDWriteRenderingParams** renderingParams)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateMonitorRenderingParams</unmanaged-short>	
        internal void CreateMonitorRenderingParams(System.IntPtr monitor, SharpDX.DirectWrite.RenderingParams renderingParams)
        {
            unsafe
            {
                IntPtr renderingParams_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)monitor, &renderingParams_, ((void**)(*(void**)_nativePointer))[11]);
                ((SharpDX.DirectWrite.RenderingParams)renderingParams).NativePointer = renderingParams_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates a rendering parameters object with the specified properties. </p>	
        /// </summary>	
        /// <param name="gamma"><dd>  <p>The gamma level to be set for the new rendering parameters object.</p> </dd></param>	
        /// <param name="enhancedContrast"><dd>  <p>The enhanced contrast level to be set for the new rendering parameters object.</p> </dd></param>	
        /// <param name="clearTypeLevel"><dd>  <p>The ClearType level to be set for the new rendering parameters object.</p> </dd></param>	
        /// <param name="pixelGeometry"><dd>  <p>Represents the internal structure of a device pixel (that is, the physical arrangement of red, green, and blue color components) that is assumed for purposes of rendering text.</p> </dd></param>	
        /// <param name="renderingMode"><dd>  <p>A value that represents the method (for example, ClearType natural quality) for rendering glyphs.</p> </dd></param>	
        /// <param name="renderingParams"><dd>  <p>When this method returns, contains an address of a reference to the newly created rendering parameters object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateCustomRenderingParams']/*"/>	
        /// <msdn-id>dd368190</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateCustomRenderingParams([In] float gamma,[In] float enhancedContrast,[In] float clearTypeLevel,[In] DWRITE_PIXEL_GEOMETRY pixelGeometry,[In] DWRITE_RENDERING_MODE renderingMode,[Out, Fast] IDWriteRenderingParams** renderingParams)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateCustomRenderingParams</unmanaged-short>	
        internal void CreateCustomRenderingParams(float gamma, float enhancedContrast, float clearTypeLevel, SharpDX.DirectWrite.PixelGeometry pixelGeometry, SharpDX.DirectWrite.RenderingMode renderingMode, SharpDX.DirectWrite.RenderingParams renderingParams)
        {
            unsafe
            {
                IntPtr renderingParams_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, gamma, enhancedContrast, clearTypeLevel, unchecked((int)pixelGeometry), unchecked((int)renderingMode), &renderingParams_, ((void**)(*(void**)_nativePointer))[12]);
                ((SharpDX.DirectWrite.RenderingParams)renderingParams).NativePointer = renderingParams_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Registers a font file loader with DirectWrite. </p>	
        /// </summary>	
        /// <param name="fontFileLoader"><dd>  <p>Pointer to a <strong><see cref="SharpDX.DirectWrite.FontFileLoader"/></strong> object for a particular file resource type.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This function registers a font file loader with DirectWrite. The font file loader interface, which should be implemented   by a singleton object, handles loading font file resources of a particular type from a key. A given instance can only be registered once. Succeeding attempts will return an error, indicating that it has already been registered. Note that font file loader implementations must not register themselves with DirectWrite inside their constructors, and must not unregister themselves inside their destructors, because registration and unregistraton operations increment and decrement the object reference count respectively. Instead, registration and unregistration with DirectWrite of font file loaders should be performed outside of the font file loader implementation. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::RegisterFontFileLoader']/*"/>	
        /// <msdn-id>dd368210</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::RegisterFontFileLoader([In] IDWriteFontFileLoader* fontFileLoader)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::RegisterFontFileLoader</unmanaged-short>	
        internal void RegisterFontFileLoader_(System.IntPtr fontFileLoader)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)fontFileLoader, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Unregisters a font file loader that was previously registered with the DirectWrite font system using <strong>RegisterFontFileLoader</strong>. </p>	
        /// </summary>	
        /// <param name="fontFileLoader">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This function unregisters font file loader callbacks with the DirectWrite font system. You should implement the font file loader interface by a singleton object. Note that font file loader implementations must not register themselves with DirectWrite inside their constructors and must not unregister themselves in their destructors, because registration and unregistraton operations increment and decrement the object reference count respectively. Instead, registration and unregistration of font file loaders with DirectWrite should be performed outside of the font file loader implementation. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::UnregisterFontFileLoader']/*"/>	
        /// <msdn-id>dd368212</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::UnregisterFontFileLoader([In] IDWriteFontFileLoader* fontFileLoader)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::UnregisterFontFileLoader</unmanaged-short>	
        internal void UnregisterFontFileLoader_(System.IntPtr fontFileLoader)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)fontFileLoader, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates a text format object used for text layout. </p>	
        /// </summary>	
        /// <param name="fontFamilyName"><dd>  <p>An array of characters that contains the name of the font family</p> </dd></param>	
        /// <param name="fontCollection"><dd>  <p>A reference to a font collection object. When this is <strong><c>null</c></strong>, indicates the system font collection.</p> </dd></param>	
        /// <param name="fontWeight"><dd>  <p>A value that indicates the font weight for the text object created by this method.</p> </dd></param>	
        /// <param name="fontStyle"><dd>  <p>A value that indicates the font style for the text object created by this method.</p> </dd></param>	
        /// <param name="fontStretch"><dd>  <p>A value that indicates the font stretch for the text object created by this method.</p> </dd></param>	
        /// <param name="fontSize"><dd>  <p>The logical size of the font in DIP ("device-independent pixel") units. A DIP equals 1/96 inch.</p> </dd></param>	
        /// <param name="localeName"><dd>  <p>An array of characters that contains the locale name.</p> </dd></param>	
        /// <param name="textFormat"><dd>  <p>When this method returns, contains an address of a reference to a  newly created text format object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateTextFormat']/*"/>	
        /// <msdn-id>dd368203</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateTextFormat([In] const wchar_t* fontFamilyName,[In, Optional] IDWriteFontCollection* fontCollection,[In] DWRITE_FONT_WEIGHT fontWeight,[In] DWRITE_FONT_STYLE fontStyle,[In] DWRITE_FONT_STRETCH fontStretch,[In] float fontSize,[In] const wchar_t* localeName,[Out, Fast] IDWriteTextFormat** textFormat)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateTextFormat</unmanaged-short>	
        internal void CreateTextFormat(string fontFamilyName, SharpDX.DirectWrite.FontCollection fontCollection, SharpDX.DirectWrite.FontWeight fontWeight, SharpDX.DirectWrite.FontStyle fontStyle, SharpDX.DirectWrite.FontStretch fontStretch, float fontSize, string localeName, SharpDX.DirectWrite.TextFormat textFormat)
        {
            unsafe
            {
                IntPtr fontFamilyName_ = Utilities.StringToHGlobalUni(fontFamilyName);
                IntPtr localeName_ = Utilities.StringToHGlobalUni(localeName);
                IntPtr textFormat_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)fontFamilyName_, (void*)((fontCollection == null) ? IntPtr.Zero : fontCollection.NativePointer), unchecked((int)fontWeight), unchecked((int)fontStyle), unchecked((int)fontStretch), fontSize, (void*)localeName_, &textFormat_, ((void**)(*(void**)_nativePointer))[15]);
                Marshal.FreeHGlobal(fontFamilyName_);
                Marshal.FreeHGlobal(localeName_);
                ((SharpDX.DirectWrite.TextFormat)textFormat).NativePointer = textFormat_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates a typography object for use in a text layout. </p>	
        /// </summary>	
        /// <param name="typography"><dd>  <p>When this method returns, contains the address of  a reference to a newly created typography object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateTypography']/*"/>	
        /// <msdn-id>dd368206</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateTypography([Out, Fast] IDWriteTypography** typography)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateTypography</unmanaged-short>	
        internal void CreateTypography(SharpDX.DirectWrite.Typography typography)
        {
            unsafe
            {
                IntPtr typography_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &typography_, ((void**)(*(void**)_nativePointer))[16]);
                ((SharpDX.DirectWrite.Typography)typography).NativePointer = typography_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates an object that is used for interoperability with GDI. </p>	
        /// </summary>	
        /// <param name="gdiInterop"><dd>  <p>When this method returns, contains an address of a reference to a GDI interop object if successful, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::GetGdiInterop']/*"/>	
        /// <msdn-id>dd368207</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::GetGdiInterop([Out] IDWriteGdiInterop** gdiInterop)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::GetGdiInterop</unmanaged-short>	
        internal void GetGdiInterop(out SharpDX.DirectWrite.GdiInterop gdiInterop)
        {
            unsafe
            {
                IntPtr gdiInterop_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &gdiInterop_, ((void**)(*(void**)_nativePointer))[17]);
                gdiInterop = (gdiInterop_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.GdiInterop(gdiInterop_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Takes a string, text format, and associated constraints, and produces an object that represents the fully analyzed and formatted result. </p>	
        /// </summary>	
        /// <param name="text"><dd>  <p>An array of characters that contains the string to create a new <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> object from. This array must be of length <em>stringLength</em> and can contain embedded <strong><c>null</c></strong> characters.</p> </dd></param>	
        /// <param name="stringLength"><dd>  <p>The number of characters in  the string.</p> </dd></param>	
        /// <param name="textFormat"><dd>  <p>A reference to an object that indicates the format to apply to the string.</p> </dd></param>	
        /// <param name="maxWidth"><dd>  <p>The width of the layout box.</p> </dd></param>	
        /// <param name="maxHeight"><dd>  <p>The height of the layout box.</p> </dd></param>	
        /// <param name="textLayout"><dd>  <p>When this method returns, contains an address of a reference to the resultant text layout object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateTextLayout']/*"/>	
        /// <msdn-id>dd368205</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateTextLayout([In, Buffer] const wchar_t* string,[In] unsigned int stringLength,[In] IDWriteTextFormat* textFormat,[In] float maxWidth,[In] float maxHeight,[Out, Fast] IDWriteTextLayout** textLayout)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateTextLayout</unmanaged-short>	
        internal void CreateTextLayout(string text, int stringLength, SharpDX.DirectWrite.TextFormat textFormat, float maxWidth, float maxHeight, SharpDX.DirectWrite.TextLayout textLayout)
        {
            unsafe
            {
                IntPtr text_ = Utilities.StringToHGlobalUni(text);
                IntPtr textLayout_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)text_, stringLength, (void*)((textFormat == null) ? IntPtr.Zero : textFormat.NativePointer), maxWidth, maxHeight, &textLayout_, ((void**)(*(void**)_nativePointer))[18]);
                Marshal.FreeHGlobal(text_);
                ((SharpDX.DirectWrite.TextLayout)textLayout).NativePointer = textLayout_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Takes a string, format, and associated constraints, and produces an object representing the result, formatted for a particular display resolution and measuring mode.  </p>	
        /// </summary>	
        /// <param name="text"><dd>  <p>An array of characters that contains the string to create a new <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> object from. This array must be of length <em>stringLength</em> and can contain embedded <strong><c>null</c></strong> characters.</p> </dd></param>	
        /// <param name="stringLength"><dd>  <p>The length of the string, in character count.</p> </dd></param>	
        /// <param name="textFormat"><dd>  <p>The text formatting object to apply to the string.</p> </dd></param>	
        /// <param name="layoutWidth"><dd>  <p>The width of the layout box.</p> </dd></param>	
        /// <param name="layoutHeight"><dd>  <p>The height of the layout box.</p> </dd></param>	
        /// <param name="pixelsPerDip"><dd>  <p>The number of physical pixels per DIP (device independent pixel). For example, if rendering onto a 96 DPI device <em>pixelsPerDip</em> is 1. If rendering onto a 120 DPI device <em>pixelsPerDip</em> is 1.25 (120/96).</p> </dd></param>	
        /// <param name="transform"><dd>  <p>An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specifies the font size and pixels per DIP.</p> </dd></param>	
        /// <param name="useGdiNatural"><dd>  <p> Instructs the text layout to use the same metrics as GDI bi-level text when set to <strong><see cref="SharpDX.Result.False"/></strong>. When set to <strong>TRUE</strong>, instructs the text layout to use the same metrics as text measured by GDI using a font created with <strong>CLEARTYPE_NATURAL_QUALITY</strong>. </p> </dd></param>	
        /// <param name="textLayout"><dd>  <p>When this method returns, contains an address to the reference of the resultant text layout object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The resulting text layout should only be used for the intended resolution, and for cases where text scalability is desired <strong>CreateTextLayout</strong> should be used instead.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateGdiCompatibleTextLayout']/*"/>	
        /// <msdn-id>dd368192</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateGdiCompatibleTextLayout([In, Buffer] const wchar_t* string,[In] unsigned int stringLength,[In] IDWriteTextFormat* textFormat,[In] float layoutWidth,[In] float layoutHeight,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL useGdiNatural,[Out, Fast] IDWriteTextLayout** textLayout)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateGdiCompatibleTextLayout</unmanaged-short>	
        internal void CreateGdiCompatibleTextLayout(string text, int stringLength, SharpDX.DirectWrite.TextFormat textFormat, float layoutWidth, float layoutHeight, float pixelsPerDip, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.Mathematics.Interop.RawBool useGdiNatural, SharpDX.DirectWrite.TextLayout textLayout)
        {
            unsafe
            {
                IntPtr text_ = Utilities.StringToHGlobalUni(text);
                SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
                if (transform.HasValue)
                    transform_ = transform.Value;
                IntPtr textLayout_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint167(_nativePointer, (void*)text_, stringLength, (void*)((textFormat == null) ? IntPtr.Zero : textFormat.NativePointer), layoutWidth, layoutHeight, pixelsPerDip, (transform.HasValue) ? &transform_ : (void*)IntPtr.Zero, useGdiNatural, &textLayout_, ((void**)(*(void**)_nativePointer))[19]);
                Marshal.FreeHGlobal(text_);
                ((SharpDX.DirectWrite.TextLayout)textLayout).NativePointer = textLayout_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates an inline object for trimming, using an ellipsis as the omission sign. </p>	
        /// </summary>	
        /// <param name="textFormat"><dd>  <p>A text format object, created with <strong>CreateTextFormat</strong>, used for text layout.</p> </dd></param>	
        /// <param name="trimmingSign"><dd>  <p>When this method returns, contains an address of a reference to the omission (that is, ellipsis trimming) sign created by this method.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The ellipsis will be created using the current settings of the format, including base font, style, and any effects. Alternate omission signs can be created by the application by implementing <strong><see cref="SharpDX.DirectWrite.InlineObject"/></strong>. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateEllipsisTrimmingSign']/*"/>	
        /// <msdn-id>dd368194</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateEllipsisTrimmingSign([In] IDWriteTextFormat* textFormat,[Out, Fast] IDWriteInlineObject** trimmingSign)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateEllipsisTrimmingSign</unmanaged-short>	
        internal void CreateEllipsisTrimmingSign(SharpDX.DirectWrite.TextFormat textFormat, SharpDX.DirectWrite.InlineObject trimmingSign)
        {
            unsafe
            {
                IntPtr trimmingSign_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((textFormat == null) ? IntPtr.Zero : textFormat.NativePointer), &trimmingSign_, ((void**)(*(void**)_nativePointer))[20]);
                ((SharpDX.DirectWrite.InlineObjectNative)trimmingSign).NativePointer = trimmingSign_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Returns an interface for performing text analysis. </p>	
        /// </summary>	
        /// <param name="textAnalyzer"><dd>  <p>When this method returns, contains an address of  a reference to the newly created text analyzer object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateTextAnalyzer']/*"/>	
        /// <msdn-id>dd368202</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateTextAnalyzer([Out, Fast] IDWriteTextAnalyzer** textAnalyzer)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateTextAnalyzer</unmanaged-short>	
        internal void CreateTextAnalyzer(SharpDX.DirectWrite.TextAnalyzer textAnalyzer)
        {
            unsafe
            {
                IntPtr textAnalyzer_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &textAnalyzer_, ((void**)(*(void**)_nativePointer))[21]);
                ((SharpDX.DirectWrite.TextAnalyzer)textAnalyzer).NativePointer = textAnalyzer_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates a number substitution object using a locale name, substitution method, and an indicator  whether to ignore user overrides (use NLS defaults for the given culture instead). </p>	
        /// </summary>	
        /// <param name="substitutionMethod"><dd>  <p>A value that specifies how to apply number substitution on digits and related punctuation.</p> </dd></param>	
        /// <param name="localeName"><dd>  <p>The name of the locale to be used in the <em>numberSubstitution</em> object.</p> </dd></param>	
        /// <param name="ignoreUserOverride"><dd>  <p>A Boolean flag that indicates whether to ignore user overrides.</p> </dd></param>	
        /// <param name="numberSubstitution"><dd>  <p>When this method returns, contains an address to  a reference to the number substitution object created by this method.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateNumberSubstitution']/*"/>	
        /// <msdn-id>dd368200</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateNumberSubstitution([In] DWRITE_NUMBER_SUBSTITUTION_METHOD substitutionMethod,[In] const wchar_t* localeName,[In] BOOL ignoreUserOverride,[Out, Fast] IDWriteNumberSubstitution** numberSubstitution)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateNumberSubstitution</unmanaged-short>	
        internal void CreateNumberSubstitution(SharpDX.DirectWrite.NumberSubstitutionMethod substitutionMethod, string localeName, SharpDX.Mathematics.Interop.RawBool ignoreUserOverride, SharpDX.DirectWrite.NumberSubstitution numberSubstitution)
        {
            unsafe
            {
                IntPtr localeName_ = Utilities.StringToHGlobalUni(localeName);
                IntPtr numberSubstitution_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint168(_nativePointer, unchecked((int)substitutionMethod), (void*)localeName_, ignoreUserOverride, &numberSubstitution_, ((void**)(*(void**)_nativePointer))[22]);
                Marshal.FreeHGlobal(localeName_);
                ((SharpDX.DirectWrite.NumberSubstitution)numberSubstitution).NativePointer = numberSubstitution_;
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates a glyph run analysis object, which encapsulates information used to render a glyph run. </p>	
        /// </summary>	
        /// <param name="glyphRun"><dd>  <p>A structure that contains the properties of the glyph run (font face, advances, and so on).</p> </dd></param>	
        /// <param name="pixelsPerDip"><dd>  <p>Number of physical pixels per DIP (device independent pixel). For example, if rendering onto a 96 DPI bitmap then <em>pixelsPerDip</em> is 1. If rendering onto a 120 DPI bitmap then <em>pixelsPerDip</em> is 1.25.</p> </dd></param>	
        /// <param name="transform"><dd>  <p>Optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified the <em>emSize</em> and <em>pixelsPerDip</em>.</p> </dd></param>	
        /// <param name="renderingMode"><dd>  <p>A value that specifies the rendering mode, which must be one of the raster rendering modes (that is, not default and not outline).</p> </dd></param>	
        /// <param name="measuringMode"><dd>  <p>Specifies the measuring mode to use with glyphs.</p> </dd></param>	
        /// <param name="baselineOriginX"><dd>  <p>The horizontal position (X-coordinate) of the baseline origin, in DIPs.</p> </dd></param>	
        /// <param name="baselineOriginY"><dd>  <p>Vertical position (Y-coordinate) of the baseline origin, in DIPs.</p> </dd></param>	
        /// <param name="glyphRunAnalysis"><dd>  <p>When this method returns, contains an address of a reference to the newly created glyph run analysis object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The glyph run analysis object contains the results of analyzing the glyph run, including the positions of all the glyphs and references to all of the rasterized glyphs in the font cache. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory::CreateGlyphRunAnalysis']/*"/>	
        /// <msdn-id>dd368198</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory::CreateGlyphRunAnalysis([In] const DWRITE_GLYPH_RUN* glyphRun,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] DWRITE_RENDERING_MODE renderingMode,[In] DWRITE_MEASURING_MODE measuringMode,[In] float baselineOriginX,[In] float baselineOriginY,[Out, Fast] IDWriteGlyphRunAnalysis** glyphRunAnalysis)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory::CreateGlyphRunAnalysis</unmanaged-short>	
        internal void CreateGlyphRunAnalysis(SharpDX.DirectWrite.GlyphRun glyphRun, float pixelsPerDip, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.DirectWrite.RenderingMode renderingMode, SharpDX.Direct2D1.MeasuringMode measuringMode, float baselineOriginX, float baselineOriginY, SharpDX.DirectWrite.GlyphRunAnalysis glyphRunAnalysis)
        {
            unsafe
            {
                var glyphRun_ = new SharpDX.DirectWrite.GlyphRun.__Native();
                glyphRun.__MarshalTo(ref glyphRun_);
                SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
                if (transform.HasValue)
                    transform_ = transform.Value;
                IntPtr glyphRunAnalysis_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &glyphRun_, pixelsPerDip, (transform.HasValue) ? &transform_ : (void*)IntPtr.Zero, unchecked((int)renderingMode), unchecked((int)measuringMode), baselineOriginX, baselineOriginY, &glyphRunAnalysis_, ((void**)(*(void**)_nativePointer))[23]);
                glyphRun.__MarshalFree(ref glyphRun_);
                ((SharpDX.DirectWrite.GlyphRunAnalysis)glyphRunAnalysis).NativePointer = glyphRunAnalysis_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Creates a rendering parameters object with the specified properties.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory1']/*"/>	
    /// <msdn-id>Hh780402</msdn-id>	
    /// <unmanaged>IDWriteFactory1</unmanaged>	
    /// <unmanaged-short>IDWriteFactory1</unmanaged-short>	
    [Guid("30572f99-dac6-41db-a16e-0486307e606a")]
    public partial class Factory1 : SharpDX.DirectWrite.Factory
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.Factory1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Factory1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.Factory1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.Factory1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.Factory1(nativePointer);
        }


        /// <summary>	
        /// <p>Gets a font collection representing the set of EUDC (end-user defined characters) fonts.</p>	
        /// </summary>	
        /// <param name="fontCollection"><dd>  <p>The font collection to fill.</p> </dd></param>	
        /// <param name="checkForUpdates"><dd>  <p>Whether to check for updates.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Note that if no EUDC is set on the system, the returned collection will be empty, meaning it will return success but GetFontFamilyCount will be zero.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory1::GetEudcFontCollection']/*"/>	
        /// <msdn-id>hh780403</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory1::GetEudcFontCollection([Out] IDWriteFontCollection** fontCollection,[In] BOOL checkForUpdates)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory1::GetEudcFontCollection</unmanaged-short>	
        public void GetEudcFontCollection(out SharpDX.DirectWrite.FontCollection fontCollection, SharpDX.Mathematics.Interop.RawBool checkForUpdates)
        {
            unsafe
            {
                IntPtr fontCollection_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint162(_nativePointer, &fontCollection_, checkForUpdates, ((void**)(*(void**)_nativePointer))[24]);
                fontCollection = (fontCollection_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.FontCollection(fontCollection_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Creates a rendering parameters object with the specified properties.</p>	
        /// </summary>	
        /// <param name="gamma"><dd>  <p>The gamma level to be set for the new rendering parameters object.</p> </dd></param>	
        /// <param name="enhancedContrast"><dd>  <p>The enhanced contrast level to be set for the new rendering parameters object.</p> </dd></param>	
        /// <param name="enhancedContrastGrayscale"><dd>  <p>The amount of contrast enhancement to use for grayscale antialiasing, zero or greater.</p> </dd></param>	
        /// <param name="clearTypeLevel"><dd>  <p>The ClearType level to be set for the new rendering parameters object.</p> </dd></param>	
        /// <param name="pixelGeometry"><dd>  <p>Represents the internal structure of a device pixel (that is, the physical arrangement of red, green, and blue color components) that is assumed for purposes of rendering text.</p> </dd></param>	
        /// <param name="renderingMode"><dd>  <p>A value that represents the method (for example, ClearType natural quality) for rendering glyphs.</p> </dd></param>	
        /// <param name="renderingParams"><dd>  <p>When this method returns, contains an address of a reference to the newly created rendering parameters object.</p> </dd></param>	
        /// <returns><p>Standard <see cref="SharpDX.Result"/> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFactory1::CreateCustomRenderingParams']/*"/>	
        /// <msdn-id>Hh780402</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFactory1::CreateCustomRenderingParams([In] float gamma,[In] float enhancedContrast,[In] float enhancedContrastGrayscale,[In] float clearTypeLevel,[In] DWRITE_PIXEL_GEOMETRY pixelGeometry,[In] DWRITE_RENDERING_MODE renderingMode,[Out] IDWriteRenderingParams1** renderingParams)</unmanaged>	
        /// <unmanaged-short>IDWriteFactory1::CreateCustomRenderingParams</unmanaged-short>	
        public void CreateCustomRenderingParams(float gamma, float enhancedContrast, float enhancedContrastGrayscale, float clearTypeLevel, SharpDX.DirectWrite.PixelGeometry pixelGeometry, SharpDX.DirectWrite.RenderingMode renderingMode, out SharpDX.DirectWrite.RenderingParams1 renderingParams)
        {
            unsafe
            {
                IntPtr renderingParams_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, gamma, enhancedContrast, enhancedContrastGrayscale, clearTypeLevel, unchecked((int)pixelGeometry), unchecked((int)renderingMode), &renderingParams_, ((void**)(*(void**)_nativePointer))[25]);
                renderingParams = (renderingParams_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.RenderingParams1(renderingParams_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Represents a physical font in a font collection. This interface is used to create font faces from  physical fonts, or  to retrieve information such as  font face metrics or face names from existing font faces.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont']/*"/>	
    /// <msdn-id>dd368213</msdn-id>	
    /// <unmanaged>IDWriteFont</unmanaged>	
    /// <unmanaged-short>IDWriteFont</unmanaged-short>	
    [Guid("acd16696-8c14-4f5d-877e-fe3fc1d32737")]
    public partial class Font : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.Font"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Font(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.Font"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.Font(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.Font(nativePointer);
        }


        /// <summary>	
        /// <p> Gets the font family to which the specified font belongs. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::GetFontFamily']/*"/>	
        /// <msdn-id>dd371143</msdn-id>	
        /// <unmanaged>GetFontFamily</unmanaged>	
        /// <unmanaged-short>GetFontFamily</unmanaged-short>	
        /// <unmanaged>HRESULT IDWriteFont::GetFontFamily([Out] IDWriteFontFamily** fontFamily)</unmanaged>
        public SharpDX.DirectWrite.FontFamily FontFamily
        {
            get { SharpDX.DirectWrite.FontFamily __output__; GetFontFamily(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Gets the weight, or stroke thickness, of the specified font. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::GetWeight']/*"/>	
        /// <msdn-id>dd371162</msdn-id>	
        /// <unmanaged>GetWeight</unmanaged>	
        /// <unmanaged-short>GetWeight</unmanaged-short>	
        /// <unmanaged>DWRITE_FONT_WEIGHT IDWriteFont::GetWeight()</unmanaged>
        public SharpDX.DirectWrite.FontWeight Weight
        {
            get { return GetWeight(); }
        }

        /// <summary>	
        /// <p> Gets the stretch, or width, of the specified font. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::GetStretch']/*"/>	
        /// <msdn-id>dd371156</msdn-id>	
        /// <unmanaged>GetStretch</unmanaged>	
        /// <unmanaged-short>GetStretch</unmanaged-short>	
        /// <unmanaged>DWRITE_FONT_STRETCH IDWriteFont::GetStretch()</unmanaged>
        public SharpDX.DirectWrite.FontStretch Stretch
        {
            get { return GetStretch(); }
        }

        /// <summary>	
        /// <p> Gets the style, or slope, of the specified font. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::GetStyle']/*"/>	
        /// <msdn-id>dd371159</msdn-id>	
        /// <unmanaged>GetStyle</unmanaged>	
        /// <unmanaged-short>GetStyle</unmanaged-short>	
        /// <unmanaged>DWRITE_FONT_STYLE IDWriteFont::GetStyle()</unmanaged>
        public SharpDX.DirectWrite.FontStyle Style
        {
            get { return GetStyle(); }
        }

        /// <summary>	
        /// <p> Determines whether the font is a symbol font. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::IsSymbolFont']/*"/>	
        /// <msdn-id>dd371168</msdn-id>	
        /// <unmanaged>IsSymbolFont</unmanaged>	
        /// <unmanaged-short>IsSymbolFont</unmanaged-short>	
        /// <unmanaged>BOOL IDWriteFont::IsSymbolFont()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsSymbolFont
        {
            get { return IsSymbolFont_(); }
        }

        /// <summary>	
        /// <p> Gets a localized strings collection containing the face names for the font (such as Regular or Bold), indexed by locale name. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::GetFaceNames']/*"/>	
        /// <msdn-id>dd371140</msdn-id>	
        /// <unmanaged>GetFaceNames</unmanaged>	
        /// <unmanaged-short>GetFaceNames</unmanaged-short>	
        /// <unmanaged>HRESULT IDWriteFont::GetFaceNames([Out] IDWriteLocalizedStrings** names)</unmanaged>
        public SharpDX.DirectWrite.LocalizedStrings FaceNames
        {
            get { SharpDX.DirectWrite.LocalizedStrings __output__; GetFaceNames(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Gets a value that indicates what simulations are applied to the specified font. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::GetSimulations']/*"/>	
        /// <msdn-id>dd371153</msdn-id>	
        /// <unmanaged>GetSimulations</unmanaged>	
        /// <unmanaged-short>GetSimulations</unmanaged-short>	
        /// <unmanaged>DWRITE_FONT_SIMULATIONS IDWriteFont::GetSimulations()</unmanaged>
        public SharpDX.DirectWrite.FontSimulations Simulations
        {
            get { return GetSimulations(); }
        }

        /// <summary>	
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::GetMetrics']/*"/>	
        /// <msdn-id>dd371149</msdn-id>	
        /// <unmanaged>GetMetrics</unmanaged>	
        /// <unmanaged-short>GetMetrics</unmanaged-short>	
        /// <unmanaged>void IDWriteFont::GetMetrics([Out] DWRITE_FONT_METRICS* fontMetrics)</unmanaged>
        public SharpDX.DirectWrite.FontMetrics Metrics
        {
            get { SharpDX.DirectWrite.FontMetrics __output__; GetMetrics(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Gets the font family to which the specified font belongs. </p>	
        /// </summary>	
        /// <param name="fontFamily"><dd>  <p>When this method returns, contains an address of a reference to the font family object to which the specified font belongs.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::GetFontFamily']/*"/>	
        /// <msdn-id>dd371143</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFont::GetFontFamily([Out] IDWriteFontFamily** fontFamily)</unmanaged>	
        /// <unmanaged-short>IDWriteFont::GetFontFamily</unmanaged-short>	
        internal void GetFontFamily(out SharpDX.DirectWrite.FontFamily fontFamily)
        {
            unsafe
            {
                IntPtr fontFamily_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &fontFamily_, ((void**)(*(void**)_nativePointer))[3]);
                fontFamily = (fontFamily_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.FontFamily(fontFamily_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the weight, or stroke thickness, of the specified font. </p>	
        /// </summary>	
        /// <returns><p>A value that indicates the weight for the specified font.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::GetWeight']/*"/>	
        /// <msdn-id>dd371162</msdn-id>	
        /// <unmanaged>DWRITE_FONT_WEIGHT IDWriteFont::GetWeight()</unmanaged>	
        /// <unmanaged-short>IDWriteFont::GetWeight</unmanaged-short>	
        internal SharpDX.DirectWrite.FontWeight GetWeight()
        {
            unsafe
            {
                SharpDX.DirectWrite.FontWeight __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteFontWeight(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the stretch, or width, of the specified font. </p>	
        /// </summary>	
        /// <returns><p>A value that indicates the type of stretch, or width, applied to the specified font.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::GetStretch']/*"/>	
        /// <msdn-id>dd371156</msdn-id>	
        /// <unmanaged>DWRITE_FONT_STRETCH IDWriteFont::GetStretch()</unmanaged>	
        /// <unmanaged-short>IDWriteFont::GetStretch</unmanaged-short>	
        internal SharpDX.DirectWrite.FontStretch GetStretch()
        {
            unsafe
            {
                SharpDX.DirectWrite.FontStretch __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteFontStretch(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the style, or slope, of the specified font. </p>	
        /// </summary>	
        /// <returns><p>A value that indicates the type of style, or slope, of the specified font.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::GetStyle']/*"/>	
        /// <msdn-id>dd371159</msdn-id>	
        /// <unmanaged>DWRITE_FONT_STYLE IDWriteFont::GetStyle()</unmanaged>	
        /// <unmanaged-short>IDWriteFont::GetStyle</unmanaged-short>	
        internal SharpDX.DirectWrite.FontStyle GetStyle()
        {
            unsafe
            {
                SharpDX.DirectWrite.FontStyle __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteFontStyle(_nativePointer, ((void**)(*(void**)_nativePointer))[6]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Determines whether the font is a symbol font. </p>	
        /// </summary>	
        /// <returns><p><strong>TRUE</strong> if the font is a symbol font; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::IsSymbolFont']/*"/>	
        /// <msdn-id>dd371168</msdn-id>	
        /// <unmanaged>BOOL IDWriteFont::IsSymbolFont()</unmanaged>	
        /// <unmanaged-short>IDWriteFont::IsSymbolFont</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsSymbolFont_()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[7]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets a localized strings collection containing the face names for the font (such as Regular or Bold), indexed by locale name. </p>	
        /// </summary>	
        /// <param name="names"><dd>  <p>When this method returns, contains an address to a  reference to the newly created localized strings object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::GetFaceNames']/*"/>	
        /// <msdn-id>dd371140</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFont::GetFaceNames([Out] IDWriteLocalizedStrings** names)</unmanaged>	
        /// <unmanaged-short>IDWriteFont::GetFaceNames</unmanaged-short>	
        internal void GetFaceNames(out SharpDX.DirectWrite.LocalizedStrings names)
        {
            unsafe
            {
                IntPtr names_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &names_, ((void**)(*(void**)_nativePointer))[8]);
                names = (names_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.LocalizedStrings(names_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets a localized strings collection containing the specified informational strings, indexed by locale name. </p>	
        /// </summary>	
        /// <param name="informationalStringID"><dd>  <p>A value that identifies the  informational string to get. For example, <strong><see cref="SharpDX.DirectWrite.InformationalStringId.Description"/></strong> specifies a string that contains a description of the font. </p> </dd></param>	
        /// <param name="informationalStrings"><dd>  <p>When this method returns, contains an address of a reference to the newly created localized strings object.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, <strong>TRUE</strong> if the font contains the specified string ID; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></returns>	
        /// <remarks>	
        /// <p> If the font does not contain the string specified by <em>informationalStringID</em>, the return value is <strong><see cref="SharpDX.Result.Ok"/></strong> but  <em>informationalStrings</em> receives a <strong><c>null</c></strong> reference and <em>exists</em> receives the value <strong><see cref="SharpDX.Result.False"/></strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::GetInformationalStrings']/*"/>	
        /// <msdn-id>dd371147</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFont::GetInformationalStrings([In] DWRITE_INFORMATIONAL_STRING_ID informationalStringID,[Out, Optional] IDWriteLocalizedStrings** informationalStrings,[Out] BOOL* exists)</unmanaged>	
        /// <unmanaged-short>IDWriteFont::GetInformationalStrings</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool GetInformationalStrings(SharpDX.DirectWrite.InformationalStringId informationalStringID, out SharpDX.DirectWrite.LocalizedStrings informationalStrings)
        {
            unsafe
            {
                IntPtr informationalStrings_ = IntPtr.Zero;
                SharpDX.Mathematics.Interop.RawBool exists;
                exists = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)informationalStringID), &informationalStrings_, &exists, ((void**)(*(void**)_nativePointer))[9]);
                informationalStrings = (informationalStrings_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.LocalizedStrings(informationalStrings_);
                __result__.CheckError();
                return exists;
            }
        }

        /// <summary>	
        /// <p> Gets a value that indicates what simulations are applied to the specified font. </p>	
        /// </summary>	
        /// <returns><p> A value that indicates one or more of the  types of simulations (none, bold, or oblique)  applied to the specified font.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::GetSimulations']/*"/>	
        /// <msdn-id>dd371153</msdn-id>	
        /// <unmanaged>DWRITE_FONT_SIMULATIONS IDWriteFont::GetSimulations()</unmanaged>	
        /// <unmanaged-short>IDWriteFont::GetSimulations</unmanaged-short>	
        internal SharpDX.DirectWrite.FontSimulations GetSimulations()
        {
            unsafe
            {
                SharpDX.DirectWrite.FontSimulations __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteFontSimulations(_nativePointer, ((void**)(*(void**)_nativePointer))[10]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>	
        /// </summary>	
        /// <param name="fontMetrics"><dd>  <p>When this method returns, contains a structure that has font metrics for the current font face. The metrics returned by this function are in font design units.</p> </dd></param>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::GetMetrics']/*"/>	
        /// <msdn-id>dd371149</msdn-id>	
        /// <unmanaged>void IDWriteFont::GetMetrics([Out] DWRITE_FONT_METRICS* fontMetrics)</unmanaged>	
        /// <unmanaged-short>IDWriteFont::GetMetrics</unmanaged-short>	
        internal void GetMetrics(out SharpDX.DirectWrite.FontMetrics fontMetrics)
        {
            unsafe
            {
                fontMetrics = new SharpDX.DirectWrite.FontMetrics();
                fixed (void* fontMetrics_ = &fontMetrics)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, fontMetrics_, ((void**)(*(void**)_nativePointer))[11]);
            }
        }

        /// <summary>	
        /// <p> Determines whether the font supports a specified character. </p>	
        /// </summary>	
        /// <param name="unicodeValue"><dd>  <p>A Unicode (UCS-4) character value for the method to inspect.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, <strong>TRUE</strong> if the font supports the specified character; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::HasCharacter']/*"/>	
        /// <msdn-id>dd371165</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFont::HasCharacter([In] unsigned int unicodeValue,[Out] BOOL* exists)</unmanaged>	
        /// <unmanaged-short>IDWriteFont::HasCharacter</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool HasCharacter(int unicodeValue)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool exists;
                exists = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unicodeValue, &exists, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
                return exists;
            }
        }

        /// <summary>	
        /// <p> Creates a font face object for the font. </p>	
        /// </summary>	
        /// <param name="fontFace"><dd>  <p>When this method returns, contains an address of a reference to the newly created font face object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont::CreateFontFace']/*"/>	
        /// <msdn-id>dd371137</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFont::CreateFontFace([Out, Fast] IDWriteFontFace** fontFace)</unmanaged>	
        /// <unmanaged-short>IDWriteFont::CreateFontFace</unmanaged-short>	
        internal void CreateFontFace(SharpDX.DirectWrite.FontFace fontFace)
        {
            unsafe
            {
                IntPtr fontFace_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &fontFace_, ((void**)(*(void**)_nativePointer))[13]);
                ((SharpDX.DirectWrite.FontFace)fontFace).NativePointer = fontFace_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a physical font in a font collection.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont1']/*"/>	
    /// <msdn-id>hh780404</msdn-id>	
    /// <unmanaged>IDWriteFont1</unmanaged>	
    /// <unmanaged-short>IDWriteFont1</unmanaged-short>	
    [Guid("acd16696-8c14-4f5d-877e-fe3fc1d32738")]
    public partial class Font1 : SharpDX.DirectWrite.Font
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.Font1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Font1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.Font1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.Font1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.Font1(nativePointer);
        }


        /// <summary>	
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont1::GetMetrics']/*"/>	
        /// <msdn-id>Hh780405</msdn-id>	
        /// <unmanaged>GetMetrics</unmanaged>	
        /// <unmanaged-short>GetMetrics</unmanaged-short>	
        /// <unmanaged>void IDWriteFont1::GetMetrics([Out] DWRITE_FONT_METRICS1* fontMetrics)</unmanaged>
        public new SharpDX.DirectWrite.FontMetrics1 Metrics
        {
            get { SharpDX.DirectWrite.FontMetrics1 __output__; GetMetrics(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets the PANOSE values from the font and is used for font selection and matching.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If the font has no PANOSE values, they are set to 'any' (0) and DirectWrite doesn't simulate those values.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont1::GetPanose']/*"/>	
        /// <msdn-id>Hh780406</msdn-id>	
        /// <unmanaged>GetPanose</unmanaged>	
        /// <unmanaged-short>GetPanose</unmanaged-short>	
        /// <unmanaged>void IDWriteFont1::GetPanose([Out] DWRITE_PANOSE* panose)</unmanaged>
        public SharpDX.DirectWrite.Panose Panose
        {
            get { SharpDX.DirectWrite.Panose __output__; GetPanose(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Determines if the font is monospaced, that is, the characters are the same fixed-pitch width (non-proportional).</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont1::IsMonospacedFont']/*"/>	
        /// <msdn-id>Hh780408</msdn-id>	
        /// <unmanaged>IsMonospacedFont</unmanaged>	
        /// <unmanaged-short>IsMonospacedFont</unmanaged-short>	
        /// <unmanaged>BOOL IDWriteFont1::IsMonospacedFont()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsMonospacedFont
        {
            get { return IsMonospacedFont_(); }
        }

        /// <summary>	
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>	
        /// </summary>	
        /// <param name="fontMetrics"><dd>  <p> A filled  <strong><see cref="SharpDX.DirectWrite.FontMetrics1"/></strong> structure that has font metrics for the current font face. The metrics returned by this method are in font design units.</p> </dd></param>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont1::GetMetrics']/*"/>	
        /// <msdn-id>Hh780405</msdn-id>	
        /// <unmanaged>void IDWriteFont1::GetMetrics([Out] DWRITE_FONT_METRICS1* fontMetrics)</unmanaged>	
        /// <unmanaged-short>IDWriteFont1::GetMetrics</unmanaged-short>	
        internal void GetMetrics(out SharpDX.DirectWrite.FontMetrics1 fontMetrics)
        {
            unsafe
            {
                fontMetrics = new SharpDX.DirectWrite.FontMetrics1();
                fixed (void* fontMetrics_ = &fontMetrics)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, fontMetrics_, ((void**)(*(void**)_nativePointer))[14]);
            }
        }

        /// <summary>	
        /// <p>Gets the PANOSE values from the font and is used for font selection and matching.</p>	
        /// </summary>	
        /// <param name="anoseRef"><dd>  <p>A reference to the <strong><see cref="SharpDX.DirectWrite.Panose"/></strong> structure to fill in.</p> </dd></param>	
        /// <remarks>	
        /// <p>If the font has no PANOSE values, they are set to 'any' (0) and DirectWrite doesn't simulate those values.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont1::GetPanose']/*"/>	
        /// <msdn-id>Hh780406</msdn-id>	
        /// <unmanaged>void IDWriteFont1::GetPanose([Out] DWRITE_PANOSE* panose)</unmanaged>	
        /// <unmanaged-short>IDWriteFont1::GetPanose</unmanaged-short>	
        internal void GetPanose(out SharpDX.DirectWrite.Panose anoseRef)
        {
            unsafe
            {
                var anoseRef_ = new SharpDX.DirectWrite.Panose.__Native();
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, &anoseRef_, ((void**)(*(void**)_nativePointer))[15]);
                anoseRef = new SharpDX.DirectWrite.Panose();
                anoseRef.__MarshalFrom(ref anoseRef_);
            }
        }

        /// <summary>	
        /// <p>Retrieves the list of character ranges supported by a font.</p>	
        /// </summary>	
        /// <param name="maxRangeCount"><dd>  <p>The maximum number of character ranges passed in from the client.</p> </dd></param>	
        /// <param name="unicodeRanges"><dd>  <p>An array of <strong><see cref="SharpDX.DirectWrite.UnicodeRange"/></strong> structures that are filled with the character ranges.</p> </dd></param>	
        /// <param name="actualRangeCount"><dd>  <p>A reference to the actual number of character ranges, regardless of the maximum count.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref="SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The method executed successfully.</p> </td></tr> <tr><td> <dl> <dt>E_NOT_SUFFICIENT_BUFFER</dt> </dl> </td><td> <p>The buffer is too small.  The <em>actualRangeCount</em> was more than the <em>maxRangeCount</em>.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>The list of character ranges supported by a font, is useful for scenarios like character picking, glyph display, and efficient font selection lookup. GetUnicodeRanges is similar to GDI's GetFontUnicodeRanges, except that it returns the full Unicode range, not just 16-bit UCS-2.</p><p>These ranges are from the cmap, not the OS/2::ulCodePageRange1.</p><p>If this method is unavailable, you can use the <strong><see cref="SharpDX.DirectWrite.FontFace.GetGlyphIndices"/></strong> method to check for missing glyphs.  The method returns the 0 index for glyphs that aren't present in the font.</p><p> The <strong><see cref="SharpDX.DirectWrite.Font.HasCharacter"/></strong> method is often simpler in cases where you need to check a single character or a series of single characters in succession, such as in font fallback.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont1::GetUnicodeRanges']/*"/>	
        /// <msdn-id>Hh780407</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFont1::GetUnicodeRanges([In] unsigned int maxRangeCount,[Out, Buffer, Optional] DWRITE_UNICODE_RANGE* unicodeRanges,[Out] unsigned int* actualRangeCount)</unmanaged>	
        /// <unmanaged-short>IDWriteFont1::GetUnicodeRanges</unmanaged-short>	
        public void GetUnicodeRanges(int maxRangeCount, SharpDX.DirectWrite.UnicodeRange[] unicodeRanges, out int actualRangeCount)
        {
            unsafe
            {
                SharpDX.DirectWrite.UnicodeRange[] unicodeRanges__ = unicodeRanges;
                SharpDX.Result __result__;
                fixed (void* unicodeRanges_ = unicodeRanges__)
                    fixed (void* actualRangeCount_ = &actualRangeCount)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, maxRangeCount, unicodeRanges_, actualRangeCount_, ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Determines if the font is monospaced, that is, the characters are the same fixed-pitch width (non-proportional).</p>	
        /// </summary>	
        /// <returns><p>Returns true if the font is monospaced, else it returns false.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFont1::IsMonospacedFont']/*"/>	
        /// <msdn-id>Hh780408</msdn-id>	
        /// <unmanaged>BOOL IDWriteFont1::IsMonospacedFont()</unmanaged>	
        /// <unmanaged-short>IDWriteFont1::IsMonospacedFont</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsMonospacedFont_()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[17]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p> An object that encapsulates a set of fonts, such as the set of fonts installed on the system, or the set of fonts in a particular directory. The font collection API can be used to discover what font families and fonts are available, and to obtain some metadata about the fonts.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.DirectWrite.Factory.GetSystemFontCollection"/></strong> method will give you an <strong><see cref="SharpDX.DirectWrite.FontCollection"/></strong> object, which encapsulates the set of fonts installed on the system, as shown in the following code example.</p><pre><see cref="SharpDX.DirectWrite.FontCollection"/>* pFontCollection = <c>null</c>; // Get the system font collection.	
    /// if (SUCCEEDED(hr))	
    /// { hr = pDWriteFactory-&gt;GetSystemFontCollection(&amp;pFontCollection);	
    /// }	
    /// </pre><p> <strong><see cref="SharpDX.DirectWrite.TextFormat"/></strong> and <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> both have a <strong>GetFontCollection</strong> method that returns the font collection being used by the object.  These interfaces use the system font collection by default, but can use a custom font collection instead.</p><p>To determine what fonts are available on the system,  get a reference to the system font collection.  You can then use the <strong><see cref="SharpDX.DirectWrite.FontCollection.GetFontFamilyCount"/></strong> method to determine the number of fonts and loop through the list. The following example enumerates the fonts in the system font collection, and prints the font family names to the console.</p><pre> #include &lt;dwrite.h&gt;	
    /// #include &lt;string.h&gt;	
    /// #include &lt;stdio.h&gt;	
    /// #include &lt;new&gt; // SafeRelease inline function.	
    /// template &lt;class T&gt; inline void SafeRelease(T **ppT)	
    /// { if (*ppT) { (*ppT)-&gt;Release(); *ppT = <c>null</c>; }	
    /// } void wmain()	
    /// { <see cref="SharpDX.DirectWrite.Factory"/>* pDWriteFactory = <c>null</c>; <see cref="SharpDX.Result"/> hr = <see cref="SharpDX.DirectWrite.DWrite.CreateFactory"/>( <see cref="SharpDX.DirectWrite.FactoryType.Shared"/>, __uuidof(<see cref="SharpDX.DirectWrite.Factory"/>), reinterpret_cast&lt;<see cref="SharpDX.ComObject"/>**&gt;(&amp;pDWriteFactory) ); <see cref="SharpDX.DirectWrite.FontCollection"/>* pFontCollection = <c>null</c>; // Get the system font collection. if (SUCCEEDED(hr)) { hr = pDWriteFactory-&gt;GetSystemFontCollection(&amp;pFontCollection); } UINT32 familyCount = 0; // Get the number of font families in the collection. if (SUCCEEDED(hr)) { familyCount = pFontCollection-&gt;GetFontFamilyCount(); } for (UINT32 i = 0; i &lt; familyCount; ++i) { <see cref="SharpDX.DirectWrite.FontFamily"/>* pFontFamily = <c>null</c>; // Get the font family. if (SUCCEEDED(hr)) { hr = pFontCollection-&gt;GetFontFamily(i, &amp;pFontFamily); } <see cref="SharpDX.DirectWrite.LocalizedStrings"/>* pFamilyNames = <c>null</c>; // Get a list of localized strings for the family name. if (SUCCEEDED(hr)) { hr = pFontFamily-&gt;GetFamilyNames(&amp;pFamilyNames); } UINT32 index = 0; <see cref="SharpDX.Mathematics.Interop.RawBool"/> exists = false; wchar_t localeName[LOCALE_NAME_MAX_LENGTH]; if (SUCCEEDED(hr)) { // Get the default locale for this user. int defaultLocaleSuccess = GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH); // If the default locale is returned, find that locale name, otherwise use "en-us". if (defaultLocaleSuccess) { hr = pFamilyNames-&gt;FindLocaleName(localeName, &amp;index, &amp;exists); } if (SUCCEEDED(hr) &amp;&amp; !exists) // if the above find did not find a match, retry with US English { hr = pFamilyNames-&gt;FindLocaleName(L"en-us", &amp;index, &amp;exists); } } // If the specified locale doesn't exist, select the first on the list. if (!exists) index = 0; UINT32 length = 0; // Get the string length. if (SUCCEEDED(hr)) { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length); } // Allocate a string big enough to hold the name. wchar_t* name = new (std::nothrow) wchar_t[length+1]; if (name == <c>null</c>) { hr = E_OUTOFMEMORY; } // Get the family name. if (SUCCEEDED(hr)) { hr = pFamilyNames-&gt;GetString(index, name, length+1); } if (SUCCEEDED(hr)) { // Print out the family name. wprintf(L"%s\n", name); } SafeRelease(&amp;pFontFamily); SafeRelease(&amp;pFamilyNames); delete [] name; } SafeRelease(&amp;pFontCollection); SafeRelease(&amp;pDWriteFactory);	
    /// } </pre>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontCollection']/*"/>	
    /// <msdn-id>dd368214</msdn-id>	
    /// <unmanaged>IDWriteFontCollection</unmanaged>	
    /// <unmanaged-short>IDWriteFontCollection</unmanaged-short>	
    [Guid("a84cee02-3eea-4eee-a827-87c1a02a0fcc")]
    public partial class FontCollection : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.FontCollection"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FontCollection(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.FontCollection"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.FontCollection(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.FontCollection(nativePointer);
        }


        /// <summary>	
        /// <p> Gets the number of font families in the collection. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontCollection::GetFontFamilyCount']/*"/>	
        /// <msdn-id>dd370974</msdn-id>	
        /// <unmanaged>GetFontFamilyCount</unmanaged>	
        /// <unmanaged-short>GetFontFamilyCount</unmanaged-short>	
        /// <unmanaged>unsigned int IDWriteFontCollection::GetFontFamilyCount()</unmanaged>
        public int FontFamilyCount
        {
            get { return GetFontFamilyCount(); }
        }

        /// <summary>	
        /// <p> Gets the number of font families in the collection. </p>	
        /// </summary>	
        /// <returns><p>The number of font families in the collection.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontCollection::GetFontFamilyCount']/*"/>	
        /// <msdn-id>dd370974</msdn-id>	
        /// <unmanaged>unsigned int IDWriteFontCollection::GetFontFamilyCount()</unmanaged>	
        /// <unmanaged-short>IDWriteFontCollection::GetFontFamilyCount</unmanaged-short>	
        internal int GetFontFamilyCount()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Creates a font family object given a zero-based font family index. </p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Zero-based index of the font family.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains the address of   a reference to the newly created font family object.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontCollection::GetFontFamily']/*"/>	
        /// <msdn-id>dd370970</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontCollection::GetFontFamily([In] unsigned int index,[Out] IDWriteFontFamily** fontFamily)</unmanaged>	
        /// <unmanaged-short>IDWriteFontCollection::GetFontFamily</unmanaged-short>	
        public SharpDX.DirectWrite.FontFamily GetFontFamily(int index)
        {
            unsafe
            {
                SharpDX.DirectWrite.FontFamily fontFamily;
                IntPtr fontFamily_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, index, &fontFamily_, ((void**)(*(void**)_nativePointer))[4]);
                fontFamily = (fontFamily_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.FontFamily(fontFamily_);
                __result__.CheckError();
                return fontFamily;
            }
        }

        /// <summary>	
        /// <p> Finds the font family with the specified family name. </p>	
        /// </summary>	
        /// <param name="familyName"><dd>  <p>An array of characters, which is null-terminated, containing the name of the font family. The name is not case-sensitive but must otherwise exactly match a family name in the collection.</p> </dd></param>	
        /// <param name="index"><dd>  <p>When this method returns, contains the zero-based index of the matching font family if the family name was found; otherwise, <strong>UINT_MAX</strong>.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, <strong>TRUE</strong> if the family name exists; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontCollection::FindFamilyName']/*"/>	
        /// <msdn-id>dd368217</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontCollection::FindFamilyName([In] const wchar_t* familyName,[Out] unsigned int* index,[Out] BOOL* exists)</unmanaged>	
        /// <unmanaged-short>IDWriteFontCollection::FindFamilyName</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool FindFamilyName(string familyName, out int index)
        {
            unsafe
            {
                IntPtr familyName_ = Utilities.StringToHGlobalUni(familyName);
                SharpDX.Mathematics.Interop.RawBool exists;
                exists = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* index_ = &index)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)familyName_, index_, &exists, ((void**)(*(void**)_nativePointer))[5]);
                Marshal.FreeHGlobal(familyName_);
                __result__.CheckError();
                return exists;
            }
        }

        /// <summary>	
        /// <p> Gets the font object that corresponds to the same physical font as the specified font face object. The specified physical font must belong  to the font collection. </p>	
        /// </summary>	
        /// <param name="fontFace"><dd>  <p>A font face object that specifies the physical font.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains the address of a reference to the newly created font object if successful; otherwise, <strong><c>null</c></strong>.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontCollection::GetFontFromFontFace']/*"/>	
        /// <msdn-id>dd370978</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontCollection::GetFontFromFontFace([In] IDWriteFontFace* fontFace,[Out] IDWriteFont** font)</unmanaged>	
        /// <unmanaged-short>IDWriteFontCollection::GetFontFromFontFace</unmanaged-short>	
        public SharpDX.DirectWrite.Font GetFontFromFontFace(SharpDX.DirectWrite.FontFace fontFace)
        {
            unsafe
            {
                SharpDX.DirectWrite.Font font;
                IntPtr font_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((fontFace == null) ? IntPtr.Zero : fontFace.NativePointer), &font_, ((void**)(*(void**)_nativePointer))[6]);
                font = (font_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.Font(font_);
                __result__.CheckError();
                return font;
            }
        }
    }
    /// <summary>	
    /// <p> Used to construct a collection of fonts given a particular type of key. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The font collection loader interface is recommended to be implemented by a singleton object. Note that font collection loader implementations must not register themselves with DirectWrite factory inside their constructors and must not unregister themselves in their destructors, because registration and unregistraton operations increment and decrement the object reference count respectively. Instead, registration and unregistration of font file loaders with DirectWrite factory should be performed outside of the font file loader implementation as a separate step.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontCollectionLoader']/*"/>	
    /// <msdn-id>dd368215</msdn-id>	
    /// <unmanaged>IDWriteFontCollectionLoader</unmanaged>	
    /// <unmanaged-short>IDWriteFontCollectionLoader</unmanaged-short>	
    [Guid("cca920e4-52f0-492b-bfa8-29c72ee0a468")]
    public partial interface FontCollectionLoader : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p> Creates a font file enumerator object that encapsulates a collection of font files. The font system calls back to this interface to create a font collection. </p>	
        /// </summary>	
        /// <param name="factory"><dd>  <p>Pointer to the <strong><see cref="SharpDX.DirectWrite.Factory"/></strong> object that was used to create the current font collection.</p> </dd></param>	
        /// <param name="collectionKey"><dd>  <p>A font collection key that uniquely identifies the collection of font files within the scope of the font collection loader being used. The buffer allocated for this key must be at least  the size, in bytes, specified by <em>collectionKeySize</em>.</p> </dd></param>	
        /// <param name="collectionKeySize"><dd>  <p>The size of the font collection key, in bytes.</p> </dd></param>	
        /// <param name="fontFileEnumerator"><dd>  <p>When this method returns, contains the address of  a reference to the newly created font file enumerator.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontCollectionLoader::CreateEnumeratorFromKey']/*"/>	
        /// <msdn-id>dd368216</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontCollectionLoader::CreateEnumeratorFromKey([In] IDWriteFactory* factory,[In, Buffer] const void* collectionKey,[In] unsigned int collectionKeySize,[Out] IDWriteFontFileEnumerator** fontFileEnumerator)</unmanaged>	
        /// <unmanaged-short>IDWriteFontCollectionLoader::CreateEnumeratorFromKey</unmanaged-short>	
        /* public void CreateEnumeratorFromKey(SharpDX.DirectWrite.Factory factory, System.IntPtr collectionKey, int collectionKeySize, out SharpDX.DirectWrite.FontFileEnumerator fontFileEnumerator) */
    }
    /// <summary>	
    /// <p>Represents an absolute reference to a font face which contains font face type, appropriate file references,  face identification data and various font data such as metrics, names and glyph outlines. </p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace']/*"/>	
    /// <msdn-id>dd370983</msdn-id>	
    /// <unmanaged>IDWriteFontFace</unmanaged>	
    /// <unmanaged-short>IDWriteFontFace</unmanaged-short>	
    [Guid("5f49804d-7024-4d43-bfa9-d25984f53849")]
    public partial class FontFace : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.FontFace"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FontFace(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.FontFace"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.FontFace(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.FontFace(nativePointer);
        }


        /// <summary>	
        /// <p> Obtains the file format type of a font face. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetType']/*"/>	
        /// <msdn-id>dd371031</msdn-id>	
        /// <unmanaged>GetType</unmanaged>	
        /// <unmanaged-short>GetType</unmanaged-short>	
        /// <unmanaged>DWRITE_FONT_FACE_TYPE IDWriteFontFace::GetType()</unmanaged>
        public SharpDX.DirectWrite.FontFaceType FaceType
        {
            get { return GetFaceType(); }
        }

        /// <summary>	
        /// <p> Obtains the index of a font face in the context of its font files. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetIndex']/*"/>	
        /// <msdn-id>dd371007</msdn-id>	
        /// <unmanaged>GetIndex</unmanaged>	
        /// <unmanaged-short>GetIndex</unmanaged-short>	
        /// <unmanaged>unsigned int IDWriteFontFace::GetIndex()</unmanaged>
        public int Index
        {
            get { return GetIndex(); }
        }

        /// <summary>	
        /// <p> Obtains the algorithmic style simulation flags of a font face. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetSimulations']/*"/>	
        /// <msdn-id>dd371018</msdn-id>	
        /// <unmanaged>GetSimulations</unmanaged>	
        /// <unmanaged-short>GetSimulations</unmanaged-short>	
        /// <unmanaged>DWRITE_FONT_SIMULATIONS IDWriteFontFace::GetSimulations()</unmanaged>
        public SharpDX.DirectWrite.FontSimulations Simulations
        {
            get { return GetSimulations(); }
        }

        /// <summary>	
        /// <p> Determines whether the font is a symbol font. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::IsSymbolFont']/*"/>	
        /// <msdn-id>dd371034</msdn-id>	
        /// <unmanaged>IsSymbolFont</unmanaged>	
        /// <unmanaged-short>IsSymbolFont</unmanaged-short>	
        /// <unmanaged>BOOL IDWriteFontFace::IsSymbolFont()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsSymbolFont
        {
            get { return IsSymbolFont_(); }
        }

        /// <summary>	
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetMetrics']/*"/>	
        /// <msdn-id>dd371011</msdn-id>	
        /// <unmanaged>GetMetrics</unmanaged>	
        /// <unmanaged-short>GetMetrics</unmanaged-short>	
        /// <unmanaged>void IDWriteFontFace::GetMetrics([Out] DWRITE_FONT_METRICS* fontFaceMetrics)</unmanaged>
        public SharpDX.DirectWrite.FontMetrics Metrics
        {
            get { SharpDX.DirectWrite.FontMetrics __output__; GetMetrics(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Obtains the number of glyphs in the font face. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetGlyphCount']/*"/>	
        /// <msdn-id>dd370993</msdn-id>	
        /// <unmanaged>GetGlyphCount</unmanaged>	
        /// <unmanaged-short>GetGlyphCount</unmanaged-short>	
        /// <unmanaged>unsigned short IDWriteFontFace::GetGlyphCount()</unmanaged>
        public short GlyphCount
        {
            get { return GetGlyphCount(); }
        }

        /// <summary>	
        /// <p> Obtains the file format type of a font face. </p>	
        /// </summary>	
        /// <returns><p>A value that indicates the type of format for the font face (such as Type 1, TrueType, vector, or bitmap).</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetType']/*"/>	
        /// <msdn-id>dd371031</msdn-id>	
        /// <unmanaged>DWRITE_FONT_FACE_TYPE IDWriteFontFace::GetType()</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace::GetType</unmanaged-short>	
        internal SharpDX.DirectWrite.FontFaceType GetFaceType()
        {
            unsafe
            {
                SharpDX.DirectWrite.FontFaceType __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteFontFaceType(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Obtains the font files representing a font face. </p>	
        /// </summary>	
        /// <param name="numberOfFiles"><dd>  <p>If <em>fontFiles</em> is <strong><c>null</c></strong>, receives the number of files representing the font face.  Otherwise, the number of font files being requested should be passed.  See the Remarks section below for more information.</p> </dd></param>	
        /// <param name="fontFiles"><dd>  <p>When this method returns, contains a reference to a user-provided array that stores references to font files representing the font face. This parameter can be <strong><c>null</c></strong> if the user wants only the number of files representing the font face. This API increments reference count of the font file references returned according to COM conventions, and the client should release them when finished.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.DirectWrite.FontFace.GetFiles"/></strong> method should be called twice.  The first time you call <strong>GetFiles</strong><em>fontFiles</em> should be <strong><c>null</c></strong>. When the method returns, <em>numberOfFiles</em> receives the number of font files that represent the font face.</p><p>Then, call the method a second time, passing the <em>numberOfFiles</em> value that was output the first call, and a non-null buffer of the correct size to store the <strong><see cref="SharpDX.DirectWrite.FontFile"/></strong> references.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetFiles']/*"/>	
        /// <msdn-id>dd370989</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFace::GetFiles([InOut] unsigned int* numberOfFiles,[Out, Buffer, Optional] IDWriteFontFile** fontFiles)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace::GetFiles</unmanaged-short>	
        internal void GetFiles(ref int numberOfFiles, SharpDX.DirectWrite.FontFile[] fontFiles)
        {
            unsafe
            {
                IntPtr* fontFiles_ = stackalloc IntPtr[fontFiles == null ? 0 : fontFiles.Length];
                SharpDX.Result __result__;
                fixed (void* numberOfFiles_ = &numberOfFiles)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, numberOfFiles_, fontFiles == null ? (void*)0 : fontFiles_, ((void**)(*(void**)_nativePointer))[4]);
                if (fontFiles != null)
                    for (int i = 0; i < fontFiles.Length; i++)
                        fontFiles[i] = (fontFiles_[i] == IntPtr.Zero) ? null : new SharpDX.DirectWrite.FontFile(fontFiles_[i]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Obtains the index of a font face in the context of its font files. </p>	
        /// </summary>	
        /// <returns><p>The zero-based index of a font face in cases when the font files contain a collection of font faces. If the font files contain a single face, this value is zero.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetIndex']/*"/>	
        /// <msdn-id>dd371007</msdn-id>	
        /// <unmanaged>unsigned int IDWriteFontFace::GetIndex()</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace::GetIndex</unmanaged-short>	
        internal int GetIndex()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Obtains the algorithmic style simulation flags of a font face. </p>	
        /// </summary>	
        /// <returns><p>Font face simulation flags for algorithmic means of making text bold or italic.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetSimulations']/*"/>	
        /// <msdn-id>dd371018</msdn-id>	
        /// <unmanaged>DWRITE_FONT_SIMULATIONS IDWriteFontFace::GetSimulations()</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace::GetSimulations</unmanaged-short>	
        internal SharpDX.DirectWrite.FontSimulations GetSimulations()
        {
            unsafe
            {
                SharpDX.DirectWrite.FontSimulations __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteFontSimulations(_nativePointer, ((void**)(*(void**)_nativePointer))[6]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Determines whether the font is a symbol font. </p>	
        /// </summary>	
        /// <returns><p>Returns <strong>TRUE</strong> if the font is a symbol font, otherwise <strong><see cref="SharpDX.Result.False"/></strong>.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::IsSymbolFont']/*"/>	
        /// <msdn-id>dd371034</msdn-id>	
        /// <unmanaged>BOOL IDWriteFontFace::IsSymbolFont()</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace::IsSymbolFont</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsSymbolFont_()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[7]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>	
        /// </summary>	
        /// <param name="fontFaceMetrics"><dd>  <p>When this method returns, a?<strong><see cref="SharpDX.DirectWrite.FontMetrics"/></strong> structure that holds metrics (such as ascent, descent, or cap height) for the current font face element. The metrics returned by this function are in font design units.</p> </dd></param>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetMetrics']/*"/>	
        /// <msdn-id>dd371011</msdn-id>	
        /// <unmanaged>void IDWriteFontFace::GetMetrics([Out] DWRITE_FONT_METRICS* fontFaceMetrics)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace::GetMetrics</unmanaged-short>	
        internal void GetMetrics(out SharpDX.DirectWrite.FontMetrics fontFaceMetrics)
        {
            unsafe
            {
                fontFaceMetrics = new SharpDX.DirectWrite.FontMetrics();
                fixed (void* fontFaceMetrics_ = &fontFaceMetrics)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, fontFaceMetrics_, ((void**)(*(void**)_nativePointer))[8]);
            }
        }

        /// <summary>	
        /// <p> Obtains the number of glyphs in the font face. </p>	
        /// </summary>	
        /// <returns><p>The number of glyphs in the font face.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetGlyphCount']/*"/>	
        /// <msdn-id>dd370993</msdn-id>	
        /// <unmanaged>unsigned short IDWriteFontFace::GetGlyphCount()</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace::GetGlyphCount</unmanaged-short>	
        internal short GetGlyphCount()
        {
            unsafe
            {
                short __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callishort(_nativePointer, ((void**)(*(void**)_nativePointer))[9]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Obtains ideal (resolution-independent) glyph metrics in font design units.  </p>	
        /// </summary>	
        /// <param name="glyphIndices"><dd>  <p> An array of glyph indices for which to compute  metrics. The array must contain at least as many elements as specified by <em>glyphCount</em>.</p> </dd></param>	
        /// <param name="glyphCount"><dd>  <p>The number of elements in the <em>glyphIndices</em> array.</p> </dd></param>	
        /// <param name="glyphMetrics"><dd>  <p>When this method returns, contains an array of <see cref="SharpDX.DirectWrite.GlyphMetrics"/> structures.  <em>glyphMetrics</em> must be initialized with an empty buffer that contains at least as many elements as <em>glyphCount</em>. The metrics returned by this function are in font design units.</p> </dd></param>	
        /// <param name="isSideways"><dd>  <p>Indicates whether the font is being used in a sideways run. This can affect the glyph metrics if the font has oblique simulation because sideways oblique simulation differs from non-sideways oblique simulation</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Design glyph metrics are used for glyph positioning.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetDesignGlyphMetrics']/*"/>	
        /// <msdn-id>dd370986</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFace::GetDesignGlyphMetrics([In, Buffer] const unsigned short* glyphIndices,[In] unsigned int glyphCount,[Out, Buffer] DWRITE_GLYPH_METRICS* glyphMetrics,[In] BOOL isSideways)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace::GetDesignGlyphMetrics</unmanaged-short>	
        internal void GetDesignGlyphMetrics(short[] glyphIndices, int glyphCount, SharpDX.DirectWrite.GlyphMetrics[] glyphMetrics, SharpDX.Mathematics.Interop.RawBool isSideways)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* glyphIndices_ = glyphIndices)
                    fixed (void* glyphMetrics_ = glyphMetrics)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint148(_nativePointer, glyphIndices_, glyphCount, glyphMetrics_, isSideways, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Returns the nominal mapping of UCS4 Unicode code points to glyph indices as defined by the font 'CMAP' table. </p>	
        /// </summary>	
        /// <param name="codePoints"><dd>  <p>An array of USC4 code points from which to obtain nominal glyph indices. The array must be allocated and be able to contain the number of elements specified by <em>codePointCount</em>.</p> </dd></param>	
        /// <param name="codePointCount"><dd>  <p>The number of elements in the <em>codePoints</em> array.</p> </dd></param>	
        /// <param name="glyphIndices"><dd>  <p>When this method returns, contains a reference to an array of nominal glyph indices filled by this function.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Note that this mapping is primarily provided for line layout engines built on top of the physical font API. Because of OpenType glyph substitution and line layout character substitution, the nominal conversion does not always correspond to how a Unicode string will map to glyph indices when rendering using a particular font face. Also, note that Unicode variant selectors provide for alternate mappings for character to glyph. This call will always return the default variant.</p><p> When characters are not present in the font this method returns the index 0, which is the undefined glyph or ".notdef" glyph.  If a character isn't in a font, <see cref="SharpDX.DirectWrite.Font.HasCharacter"/> returns false and GetUnicodeRanges doesn't return it in the range.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetGlyphIndicesW']/*"/>	
        /// <msdn-id>dd370998</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFace::GetGlyphIndicesW([In, Buffer] const unsigned int* codePoints,[In] unsigned int codePointCount,[Out, Buffer] unsigned short* glyphIndices)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace::GetGlyphIndicesW</unmanaged-short>	
        internal void GetGlyphIndices(int[] codePoints, int codePointCount, short[] glyphIndices)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* codePoints_ = codePoints)
                    fixed (void* glyphIndices_ = glyphIndices)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, codePoints_, codePointCount, glyphIndices_, ((void**)(*(void**)_nativePointer))[11]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Finds the specified OpenType font table if it exists and returns a reference to it. The function accesses the underlying font data through the <strong><see cref="SharpDX.DirectWrite.FontFileStream"/></strong> interface implemented by the font file loader. </p>	
        /// </summary>	
        /// <param name="openTypeTableTag">No documentation.</param>	
        /// <param name="tableData">No documentation.</param>	
        /// <param name="tableSize">No documentation.</param>	
        /// <param name="tableContext">No documentation.</param>	
        /// <param name="exists">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The context for the same tag may be different for each call, so each one must be held and released separately. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::TryGetFontTable']/*"/>	
        /// <msdn-id>dd371039</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFace::TryGetFontTable([In] unsigned int openTypeTableTag,[Out, Buffer] const void** tableData,[Out] unsigned int* tableSize,[Out] void** tableContext,[Out] BOOL* exists)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace::TryGetFontTable</unmanaged-short>	
        internal void TryGetFontTable(int openTypeTableTag, System.IntPtr tableData, out int tableSize, out System.IntPtr tableContext, out SharpDX.Mathematics.Interop.RawBool exists)
        {
            unsafe
            {
                exists = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* tableSize_ = &tableSize)
                    fixed (void* tableContext_ = &tableContext)
                        fixed (void* exists_ = &exists)
                            __result__ =
                            SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, openTypeTableTag, (void*)tableData, tableSize_, tableContext_, exists_, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Releases the table obtained earlier from <strong>TryGetFontTable</strong>. </p>	
        /// </summary>	
        /// <param name="tableContext">No documentation.</param>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::ReleaseFontTable']/*"/>	
        /// <msdn-id>dd371036</msdn-id>	
        /// <unmanaged>void IDWriteFontFace::ReleaseFontTable([In] void* tableContext)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace::ReleaseFontTable</unmanaged-short>	
        public void ReleaseFontTable(System.IntPtr tableContext)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)tableContext, ((void**)(*(void**)_nativePointer))[13]);
            }
        }

        /// <summary>	
        /// <p> Computes the outline of a run of glyphs by calling back to the outline sink interface. </p>	
        /// </summary>	
        /// <param name="emSize"><dd>  <p>The logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</p> </dd></param>	
        /// <param name="glyphIndices"><dd>  <p>An array of glyph indices. The glyphs are in logical order and the advance direction depends on the <em>isRightToLeft</em> parameter. The array must be allocated and be able to contain the number of elements specified by <em>glyphCount</em>.</p> </dd></param>	
        /// <param name="glyphAdvances"><dd>  <p>An optional array of glyph advances in DIPs. The advance of a glyph is the amount to advance the position (in the direction of the baseline) after drawing the glyph. <em>glyphAdvances</em> contains the number of elements specified by <em>glyphCount</em>.</p> </dd></param>	
        /// <param name="glyphOffsets"><dd>  <p>An optional array of glyph offsets, each of which specifies the offset along the baseline and offset perpendicular to the baseline of a glyph relative to the current pen position.   <em>glyphOffsets</em> contains the number of elements specified by <em>glyphCount</em>.</p> </dd></param>	
        /// <param name="glyphCount"><dd>  <p>The number of glyphs in the run.</p> </dd></param>	
        /// <param name="isSideways"><dd>  <p>If <strong>TRUE</strong>, the ascender of the glyph runs alongside the baseline. If <strong><see cref="SharpDX.Result.False"/></strong>, the glyph ascender runs perpendicular to the baseline. For example, an English alphabet on a vertical baseline would have <em>isSideways</em> set to <strong><see cref="SharpDX.Result.False"/></strong>.</p> <p>A client can render a vertical run by setting <em>isSideways</em> to <strong>TRUE</strong> and rotating the resulting geometry 90 degrees to the right using a transform. The <em>isSideways</em> and <em>isRightToLeft</em> parameters cannot both be true.</p> </dd></param>	
        /// <param name="isRightToLeft"><dd>  <p>The visual order of the glyphs. If this parameter is <strong><see cref="SharpDX.Result.False"/></strong>, then glyph advances are from left to right. If <strong>TRUE</strong>, the advance direction is right to left. By default, the advance direction is left to right.</p> </dd></param>	
        /// <param name="geometrySink"><dd>  <p>A reference to the interface that is called back to perform outline drawing operations.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetGlyphRunOutline']/*"/>	
        /// <msdn-id>dd371003</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFace::GetGlyphRunOutline([In] float emSize,[In, Buffer] const unsigned short* glyphIndices,[In, Buffer, Optional] const float* glyphAdvances,[In, Buffer, Optional] const DWRITE_GLYPH_OFFSET* glyphOffsets,[In] unsigned int glyphCount,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace::GetGlyphRunOutline</unmanaged-short>	
        internal void GetGlyphRunOutline_(float emSize, short[] glyphIndices, float[] glyphAdvances, SharpDX.DirectWrite.GlyphOffset[] glyphOffsets, int glyphCount, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.Mathematics.Interop.RawBool isRightToLeft, System.IntPtr geometrySink)
        {
            unsafe
            {
                float[] glyphAdvances__ = glyphAdvances;
                SharpDX.DirectWrite.GlyphOffset[] glyphOffsets__ = glyphOffsets;
                SharpDX.Result __result__;
                fixed (void* glyphIndices_ = glyphIndices)
                    fixed (void* glyphAdvances_ = glyphAdvances__)
                        fixed (void* glyphOffsets_ = glyphOffsets__)
                            __result__ =
                            SharpDX.Direct2D1.LocalInterop.Calliint150(_nativePointer, emSize, glyphIndices_, glyphAdvances_, glyphOffsets_, glyphCount, isSideways, isRightToLeft, (void*)geometrySink, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Determines the recommended rendering mode for the font, using the specified size and rendering parameters. </p>	
        /// </summary>	
        /// <param name="emSize"><dd>  <p>The logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</p> </dd></param>	
        /// <param name="pixelsPerDip"><dd>  <p>The number of physical pixels per DIP. For example, if the DPI of the rendering surface is 96, this  value is 1.0f. If the DPI is 120, this value is 120.0f/96.</p> </dd></param>	
        /// <param name="measuringMode"><dd>  <p>The measuring method that will be used for glyphs in the font. Renderer implementations may choose different rendering modes for different measuring methods, for example: </p> <ul> <li><see cref="SharpDX.DirectWrite.RenderingMode.CleartypeNatural"/> for <strong><see cref="SharpDX.Direct2D1.MeasuringMode.Natural"/></strong> </li> <li> <see cref="SharpDX.DirectWrite.RenderingMode.CleartypeGdiClassic"/> for <strong><see cref="SharpDX.Direct2D1.MeasuringMode.GdiClassic"/></strong> </li> <li> <see cref="SharpDX.DirectWrite.RenderingMode.CleartypeGdiNatural"/> for <strong><see cref="SharpDX.Direct2D1.MeasuringMode.GdiNatural"/></strong> </li> </ul> </dd></param>	
        /// <param name="renderingParams"><dd>  <p>A reference to an object that contains rendering settings such as gamma level, enhanced contrast, and ClearType level. This parameter is necessary in case the rendering parameters  object overrides the rendering mode.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains a value that indicates the recommended rendering mode to use.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetRecommendedRenderingMode']/*"/>	
        /// <msdn-id>dd371015</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFace::GetRecommendedRenderingMode([In] float emSize,[In] float pixelsPerDip,[In] DWRITE_MEASURING_MODE measuringMode,[In] IDWriteRenderingParams* renderingParams,[Out] DWRITE_RENDERING_MODE* renderingMode)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace::GetRecommendedRenderingMode</unmanaged-short>	
        public SharpDX.DirectWrite.RenderingMode GetRecommendedRenderingMode(float emSize, float pixelsPerDip, SharpDX.Direct2D1.MeasuringMode measuringMode, SharpDX.DirectWrite.RenderingParams renderingParams)
        {
            unsafe
            {
                SharpDX.DirectWrite.RenderingMode renderingMode;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, emSize, pixelsPerDip, unchecked((int)measuringMode), (void*)((renderingParams == null) ? IntPtr.Zero : renderingParams.NativePointer), &renderingMode, ((void**)(*(void**)_nativePointer))[15]);
                __result__.CheckError();
                return renderingMode;
            }
        }

        /// <summary>	
        /// <p>Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a fontface and are used by applications for layout calculations.</p>	
        /// </summary>	
        /// <param name="emSize"><dd>  <p>The logical size of the font in DIP units.</p> </dd></param>	
        /// <param name="pixelsPerDip"><dd>  <p>The number of physical pixels per DIP.</p> </dd></param>	
        /// <param name="transform"><dd>  <p>An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and <em>pixelsPerDip</em>.</p> </dd></param>	
        /// <returns><dd>  <p>A reference to a <strong>DWRITE_FONT_METRIC</strong>S structure to fill in. The metrics returned by this function are in font design units.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetGdiCompatibleMetrics']/*"/>	
        /// <msdn-id>dd941789</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFace::GetGdiCompatibleMetrics([In] float emSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[Out] DWRITE_FONT_METRICS* fontFaceMetrics)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace::GetGdiCompatibleMetrics</unmanaged-short>	
        public SharpDX.DirectWrite.FontMetrics GetGdiCompatibleMetrics(float emSize, float pixelsPerDip, SharpDX.Mathematics.Interop.RawMatrix3x2? transform)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
                if (transform.HasValue)
                    transform_ = transform.Value;
                SharpDX.DirectWrite.FontMetrics fontFaceMetrics;
                fontFaceMetrics = new SharpDX.DirectWrite.FontMetrics();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, emSize, pixelsPerDip, (transform.HasValue) ? &transform_ : (void*)IntPtr.Zero, &fontFaceMetrics, ((void**)(*(void**)_nativePointer))[16]);
                __result__.CheckError();
                return fontFaceMetrics;
            }
        }

        /// <summary>	
        /// <p>Obtains glyph metrics in font design units with the return values compatible with what GDI would produce.</p>	
        /// </summary>	
        /// <param name="emSize"><dd>  <p>The ogical size of the font in DIP units.</p> </dd></param>	
        /// <param name="pixelsPerDip"><dd>  <p>The number of physical pixels per DIP.</p> </dd></param>	
        /// <param name="transform"><dd>  <p>An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and <em>pixelsPerDip</em>.</p> </dd></param>	
        /// <param name="useGdiNatural"><dd>  <p>When set to <strong><see cref="SharpDX.Result.False"/></strong>, the metrics are the same as the metrics of GDI aliased text.  When set to <strong>TRUE</strong>, the metrics are the same as the metrics of text measured by GDI using a font created with <strong>CLEARTYPE_NATURAL_QUALITY</strong>.</p> </dd></param>	
        /// <param name="glyphIndices"><dd>  <p>An array of glyph indices for which to compute the metrics.</p> </dd></param>	
        /// <param name="glyphCount"><dd>  <p>The number of elements in the <em>glyphIndices</em> array.</p> </dd></param>	
        /// <param name="glyphMetrics"><dd>  <p>An array of <strong><see cref="SharpDX.DirectWrite.GlyphMetrics"/></strong> structures filled by this function. The metrics are in font design units.</p> </dd></param>	
        /// <param name="isSideways"><dd>  <p>A <see cref="SharpDX.Mathematics.Interop.RawBool"/> value that indicates whether the font is being used in a sideways run.  This can affect the glyph metrics if the font has oblique simulation because sideways oblique simulation differs from non-sideways oblique simulation.</p> </dd></param>	
        /// <returns><p>Standard <strong><see cref="SharpDX.Result"/></strong> error code. If any of the input glyph indices are outside of the valid glyph index range for the current font face, <strong>E_INVALIDARG</strong> will be returned.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace::GetGdiCompatibleGlyphMetrics']/*"/>	
        /// <msdn-id>dd941788</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFace::GetGdiCompatibleGlyphMetrics([In] float emSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL useGdiNatural,[In, Buffer] const unsigned short* glyphIndices,[In] unsigned int glyphCount,[Out, Buffer] DWRITE_GLYPH_METRICS* glyphMetrics,[In] BOOL isSideways)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace::GetGdiCompatibleGlyphMetrics</unmanaged-short>	
        internal void GetGdiCompatibleGlyphMetrics(float emSize, float pixelsPerDip, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.Mathematics.Interop.RawBool useGdiNatural, short[] glyphIndices, int glyphCount, SharpDX.DirectWrite.GlyphMetrics[] glyphMetrics, SharpDX.Mathematics.Interop.RawBool isSideways)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
                if (transform.HasValue)
                    transform_ = transform.Value;
                SharpDX.Result __result__;
                fixed (void* glyphIndices_ = glyphIndices)
                    fixed (void* glyphMetrics_ = glyphMetrics)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint153(_nativePointer, emSize, pixelsPerDip, (transform.HasValue) ? &transform_ : (void*)IntPtr.Zero, useGdiNatural, glyphIndices_, glyphCount, glyphMetrics_, isSideways, ((void**)(*(void**)_nativePointer))[17]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents an absolute reference to a font face.  </p><p>This interface contains the font face type, appropriate file references, and face identification data.  </p><p>You obtain various font data like metrics, names, and glyph outlines from the <strong><see cref="SharpDX.DirectWrite.FontFace1"/></strong> interface.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1']/*"/>	
    /// <msdn-id>Hh780409</msdn-id>	
    /// <unmanaged>IDWriteFontFace1</unmanaged>	
    /// <unmanaged-short>IDWriteFontFace1</unmanaged-short>	
    [Guid("a71efdb4-9fdb-4838-ad90-cfc3be8c3daf")]
    public partial class FontFace1 : SharpDX.DirectWrite.FontFace
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.FontFace1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FontFace1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.FontFace1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.FontFace1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.FontFace1(nativePointer);
        }


        /// <summary>	
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1::GetMetrics']/*"/>	
        /// <msdn-id>Hh780415</msdn-id>	
        /// <unmanaged>GetMetrics</unmanaged>	
        /// <unmanaged-short>GetMetrics</unmanaged-short>	
        /// <unmanaged>void IDWriteFontFace1::GetMetrics([Out] DWRITE_FONT_METRICS1* fontMetrics)</unmanaged>
        public new SharpDX.DirectWrite.FontMetrics1 Metrics
        {
            get { SharpDX.DirectWrite.FontMetrics1 __output__; GetMetrics(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Gets caret metrics for the font in design units.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Caret metrics are used by text editors for drawing the correct caret placement and slant.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1::GetCaretMetrics']/*"/>	
        /// <msdn-id>Hh780410</msdn-id>	
        /// <unmanaged>GetCaretMetrics</unmanaged>	
        /// <unmanaged-short>GetCaretMetrics</unmanaged-short>	
        /// <unmanaged>void IDWriteFontFace1::GetCaretMetrics([Out] DWRITE_CARET_METRICS* caretMetrics)</unmanaged>
        public SharpDX.DirectWrite.CaretMetrics CaretMetrics
        {
            get { SharpDX.DirectWrite.CaretMetrics __output__; GetCaretMetrics(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Determines whether the font of a text range is monospaced, that is, the font characters are the same fixed-pitch width.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1::IsMonospacedFont']/*"/>	
        /// <msdn-id>Hh780421</msdn-id>	
        /// <unmanaged>IsMonospacedFont</unmanaged>	
        /// <unmanaged-short>IsMonospacedFont</unmanaged-short>	
        /// <unmanaged>BOOL IDWriteFontFace1::IsMonospacedFont()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsMonospacedFont
        {
            get { return IsMonospacedFont_(); }
        }

        /// <summary>	
        /// <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>	
        /// </summary>	
        /// <param name="fontMetrics"><dd>  <p>A filled <strong><see cref="SharpDX.DirectWrite.FontMetrics1"/></strong> structure that holds metrics for the current font face element. The metrics returned by this method are in font design units.</p> </dd></param>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1::GetMetrics']/*"/>	
        /// <msdn-id>Hh780415</msdn-id>	
        /// <unmanaged>void IDWriteFontFace1::GetMetrics([Out] DWRITE_FONT_METRICS1* fontMetrics)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace1::GetMetrics</unmanaged-short>	
        internal void GetMetrics(out SharpDX.DirectWrite.FontMetrics1 fontMetrics)
        {
            unsafe
            {
                fontMetrics = new SharpDX.DirectWrite.FontMetrics1();
                fixed (void* fontMetrics_ = &fontMetrics)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, fontMetrics_, ((void**)(*(void**)_nativePointer))[18]);
            }
        }

        /// <summary>	
        /// <p>Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a fontface and are used by applications for layout calculations.</p>	
        /// </summary>	
        /// <param name="emSize"><dd>  <p>The logical size of the font in DIP units.</p> </dd></param>	
        /// <param name="pixelsPerDip"><dd>  <p>The number of physical pixels per DIP.</p> </dd></param>	
        /// <param name="transform"><dd>  <p>An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and <em>pixelsPerDip</em>.</p> </dd></param>	
        /// <param name="fontMetrics"><dd>  <p>A reference to a <strong><see cref="SharpDX.DirectWrite.FontMetrics1"/></strong> structure to fill in. The metrics returned by this function are in font design units.</p> </dd></param>	
        /// <returns><p>Standard <see cref="SharpDX.Result"/> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1::GetGdiCompatibleMetrics']/*"/>	
        /// <msdn-id>Hh780413</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFace1::GetGdiCompatibleMetrics([In] float emSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[Out] DWRITE_FONT_METRICS1* fontMetrics)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace1::GetGdiCompatibleMetrics</unmanaged-short>	
        public void GetGdiCompatibleMetrics(float emSize, float pixelsPerDip, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, out SharpDX.DirectWrite.FontMetrics1 fontMetrics)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
                if (transform.HasValue)
                    transform_ = transform.Value;
                fontMetrics = new SharpDX.DirectWrite.FontMetrics1();
                SharpDX.Result __result__;
                fixed (void* fontMetrics_ = &fontMetrics)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, emSize, pixelsPerDip, (transform.HasValue) ? &transform_ : (void*)IntPtr.Zero, fontMetrics_, ((void**)(*(void**)_nativePointer))[19]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets caret metrics for the font in design units.</p>	
        /// </summary>	
        /// <param name="caretMetrics"><dd>  <p>A reference to the <strong><see cref="SharpDX.DirectWrite.CaretMetrics"/></strong> structure that is filled.</p> </dd></param>	
        /// <remarks>	
        /// <p>Caret metrics are used by text editors for drawing the correct caret placement and slant.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1::GetCaretMetrics']/*"/>	
        /// <msdn-id>Hh780410</msdn-id>	
        /// <unmanaged>void IDWriteFontFace1::GetCaretMetrics([Out] DWRITE_CARET_METRICS* caretMetrics)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace1::GetCaretMetrics</unmanaged-short>	
        internal void GetCaretMetrics(out SharpDX.DirectWrite.CaretMetrics caretMetrics)
        {
            unsafe
            {
                caretMetrics = new SharpDX.DirectWrite.CaretMetrics();
                fixed (void* caretMetrics_ = &caretMetrics)
                    SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, caretMetrics_, ((void**)(*(void**)_nativePointer))[20]);
            }
        }

        /// <summary>	
        /// <p>Retrieves a list of character ranges supported by a font.</p>	
        /// </summary>	
        /// <param name="maxRangeCount"><dd>  <p>Maximum number of character ranges passed in from the client.</p> </dd></param>	
        /// <param name="unicodeRanges"><dd>  <p>An array of <strong><see cref="SharpDX.DirectWrite.UnicodeRange"/></strong> structures that are filled with the character ranges.</p> </dd></param>	
        /// <param name="actualRangeCount"><dd>  <p>A reference to the actual number of character ranges, regardless of the maximum count.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref="SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The method executed successfully.</p> </td></tr> <tr><td> <dl> <dt>E_NOT_SUFFICIENT_BUFFER</dt> </dl> </td><td> <p>The buffer is too small.  The <em>actualRangeCount</em> was more than the <em>maxRangeCount</em>.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>A  list of character ranges supported by the font is useful for scenarios like character picking, glyph display, and efficient font selection lookup. This is similar to GDI's <strong>GetFontUnicodeRanges</strong>, except that it returns the full Unicode range, not just 16-bit UCS-2.</p><p>These ranges are from the cmap, not the OS/2::ulCodePageRange1.</p><p>If this method is unavailable, you can use the <strong><see cref="SharpDX.DirectWrite.FontFace.GetGlyphIndices"/></strong> method to check for missing glyphs.  The method returns the 0 index for glyphs that aren't present in the font.</p><p> The <strong><see cref="SharpDX.DirectWrite.Font.HasCharacter"/></strong> method is often simpler in cases where you need to check a single character or a series of single characters in succession, such as in font fallback.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1::GetUnicodeRanges']/*"/>	
        /// <msdn-id>Hh780417</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFace1::GetUnicodeRanges([In] unsigned int maxRangeCount,[Out, Buffer, Optional] DWRITE_UNICODE_RANGE* unicodeRanges,[Out] unsigned int* actualRangeCount)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace1::GetUnicodeRanges</unmanaged-short>	
        public void GetUnicodeRanges(int maxRangeCount, SharpDX.DirectWrite.UnicodeRange[] unicodeRanges, out int actualRangeCount)
        {
            unsafe
            {
                SharpDX.DirectWrite.UnicodeRange[] unicodeRanges__ = unicodeRanges;
                SharpDX.Result __result__;
                fixed (void* unicodeRanges_ = unicodeRanges__)
                    fixed (void* actualRangeCount_ = &actualRangeCount)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, maxRangeCount, unicodeRanges_, actualRangeCount_, ((void**)(*(void**)_nativePointer))[21]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Determines whether the font of a text range is monospaced, that is, the font characters are the same fixed-pitch width.</p>	
        /// </summary>	
        /// <returns><p>Returns TRUE if the font is monospaced, otherwise it returns <see cref="SharpDX.Result.False"/>.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1::IsMonospacedFont']/*"/>	
        /// <msdn-id>Hh780421</msdn-id>	
        /// <unmanaged>BOOL IDWriteFontFace1::IsMonospacedFont()</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace1::IsMonospacedFont</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsMonospacedFont_()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[22]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Retrieves the advances in design units for a sequences of glyphs.</p>	
        /// </summary>	
        /// <param name="glyphCount"><dd>  <p>The number of glyphs to retrieve advances for.</p> </dd></param>	
        /// <param name="glyphIndices"><dd>  <p>An array of glyph id's to retrieve advances for.</p> </dd></param>	
        /// <param name="glyphAdvances"><dd>  <p>The returned advances in font design units for each glyph.</p> </dd></param>	
        /// <param name="isSideways"><dd>  <p>Retrieve the glyph's vertical advance height rather than horizontal advance widths.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This is equivalent to calling GetGlyphMetrics and using only the advance width and height.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1::GetDesignGlyphAdvances']/*"/>	
        /// <msdn-id>Hh780411</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFace1::GetDesignGlyphAdvances([In] unsigned int glyphCount,[In, Buffer] const unsigned short* glyphIndices,[Out, Buffer] int* glyphAdvances,[In] BOOL isSideways)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace1::GetDesignGlyphAdvances</unmanaged-short>	
        public void GetDesignGlyphAdvances(int glyphCount, short[] glyphIndices, int[] glyphAdvances, SharpDX.Mathematics.Interop.RawBool isSideways)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* glyphIndices_ = glyphIndices)
                    fixed (void* glyphAdvances_ = glyphAdvances)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint175(_nativePointer, glyphCount, glyphIndices_, glyphAdvances_, isSideways, ((void**)(*(void**)_nativePointer))[23]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Returns the pixel-aligned advances for a sequences of glyphs.</p>	
        /// </summary>	
        /// <param name="emSize"><dd>  <p>Logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</p> </dd></param>	
        /// <param name="pixelsPerDip"><dd>  <p>Number of physical pixels per DIP. For example, if the DPI of the rendering surface is 96 this value is 1.0f. If the DPI is 120, this value is 120.0f/96.</p> </dd></param>	
        /// <param name="transform"><dd>  <p>Optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and pixelsPerDip.</p> </dd></param>	
        /// <param name="useGdiNatural"><dd>  <p>When <see cref="SharpDX.Result.False"/>, the metrics are the same as GDI aliased text (<see cref="SharpDX.Direct2D1.MeasuringMode.GdiClassic"/>). When TRUE, the metrics are the same as those measured by GDI using a font using CLEARTYPE_NATURAL_QUALITY (<see cref="SharpDX.Direct2D1.MeasuringMode.GdiNatural"/>).</p> </dd></param>	
        /// <param name="isSideways"><dd>  <p>Retrieve the glyph's vertical advances rather than horizontal advances.</p> </dd></param>	
        /// <param name="glyphCount"><dd>  <p>Total glyphs to retrieve adjustments for.</p> </dd></param>	
        /// <param name="glyphIndices"><dd>  <p>An array of glyph id's to retrieve advances.</p> </dd></param>	
        /// <param name="glyphAdvances"><dd>  <p>The returned advances in font design units for each glyph.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This is equivalent to calling <strong>GetGdiCompatibleGlyphMetrics</strong> and using only the advance width and height. </p><p>Like <strong>GetGdiCompatibleGlyphMetrics</strong>, these are in design units, meaning they must be scaled down by DWRITE_FONT_METRICS::designUnitsPerEm.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1::GetGdiCompatibleGlyphAdvances']/*"/>	
        /// <msdn-id>Hh780412</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFace1::GetGdiCompatibleGlyphAdvances([In] float emSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL useGdiNatural,[In] BOOL isSideways,[In] unsigned int glyphCount,[In, Buffer] const unsigned short* glyphIndices,[Out, Buffer] int* glyphAdvances)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace1::GetGdiCompatibleGlyphAdvances</unmanaged-short>	
        public void GetGdiCompatibleGlyphAdvances(float emSize, float pixelsPerDip, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.Mathematics.Interop.RawBool useGdiNatural, SharpDX.Mathematics.Interop.RawBool isSideways, int glyphCount, short[] glyphIndices, int[] glyphAdvances)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
                if (transform.HasValue)
                    transform_ = transform.Value;
                SharpDX.Result __result__;
                fixed (void* glyphIndices_ = glyphIndices)
                    fixed (void* glyphAdvances_ = glyphAdvances)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint176(_nativePointer, emSize, pixelsPerDip, (transform.HasValue) ? &transform_ : (void*)IntPtr.Zero, useGdiNatural, isSideways, glyphCount, glyphIndices_, glyphAdvances_, ((void**)(*(void**)_nativePointer))[24]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Retrieves the kerning pair adjustments from the font's kern table.</p>	
        /// </summary>	
        /// <param name="glyphCount"><dd>  <p>Number of glyphs to retrieve adjustments for.</p> </dd></param>	
        /// <param name="glyphIndices"><dd>  <p>An array of glyph id's to retrieve adjustments for.</p> </dd></param>	
        /// <param name="glyphAdvanceAdjustments"><dd>  <p>The advances, returned in font design units, for each glyph. The last glyph adjustment is zero.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><strong>GetKerningPairAdjustments</strong> isn't a direct replacement for GDI's character based <strong>GetKerningPairs</strong>, but it serves the same role, without the client needing to cache them locally. <strong>GetKerningPairAdjustments</strong> also uses glyph id's directly rather than UCS-2 characters (how the kern table actually stores them), which avoids glyph collapse and ambiguity, such as the dash and hyphen, or space and non-breaking space. </p><p>Newer fonts may have only GPOS kerning instead of the legacy pair-table kerning. Such fonts, like Gabriola, will only return 0's for adjustments. <strong>GetKerningPairAdjustments</strong> doesn't virtualize and flatten these GPOS entries into kerning pairs.</p><p>You can realize a performance benefit by calling <strong><see cref="SharpDX.DirectWrite.FontFace1.HasKerningPairs"/></strong> to determine whether you need to call  <strong>GetKerningPairAdjustments</strong>. If you previously called <strong><see cref="SharpDX.DirectWrite.FontFace1.HasKerningPairs"/></strong> and it returned <see cref="SharpDX.Result.False"/>, you can avoid calling <strong>GetKerningPairAdjustments</strong> because the font has no kerning pair-table entries. That is, in this situation, a call to <strong>GetKerningPairAdjustments</strong> would be a no-op.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1::GetKerningPairAdjustments']/*"/>	
        /// <msdn-id>Hh780414</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFace1::GetKerningPairAdjustments([In] unsigned int glyphCount,[In, Buffer] const unsigned short* glyphIndices,[Out, Buffer] int* glyphAdvanceAdjustments)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace1::GetKerningPairAdjustments</unmanaged-short>	
        public void GetKerningPairAdjustments(int glyphCount, short[] glyphIndices, int[] glyphAdvanceAdjustments)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* glyphIndices_ = glyphIndices)
                    fixed (void* glyphAdvanceAdjustments_ = glyphAdvanceAdjustments)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, glyphCount, glyphIndices_, glyphAdvanceAdjustments_, ((void**)(*(void**)_nativePointer))[25]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Determines whether the font supports pair-kerning.</p>	
        /// </summary>	
        /// <returns><p>Returns TRUE if the font supports kerning pairs, otherwise <see cref="SharpDX.Result.False"/>.</p></returns>	
        /// <remarks>	
        /// <p>If the font doesn't support pair table kerning, you don't need to call <strong><see cref="SharpDX.DirectWrite.FontFace1.GetKerningPairAdjustments"/></strong> because it would retrieve all zeroes.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1::HasKerningPairs']/*"/>	
        /// <msdn-id>Hh780419</msdn-id>	
        /// <unmanaged>BOOL IDWriteFontFace1::HasKerningPairs()</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace1::HasKerningPairs</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool HasKerningPairs()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[26]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Determines the recommended rendering mode for the font, using the specified size and rendering parameters. </p>	
        /// </summary>	
        /// <param name="fontEmSize"><dd>  <p>The logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</p> </dd></param>	
        /// <param name="dpiX"><dd>  <p>The number of physical pixels per DIP in a horizontal position. For example, if the DPI of the rendering surface is 96, this  value is 1.0f. If the DPI is 120, this value is 120.0f/96.</p> </dd></param>	
        /// <param name="dpiY"><dd>  <p>The number of physical pixels per DIP in a vertical position. For example, if the DPI of the rendering surface is 96, this  value is 1.0f. If the DPI is 120, this value is 120.0f/96.</p> </dd></param>	
        /// <param name="transform"><dd>  <p>Specifies the world transform.</p> </dd></param>	
        /// <param name="isSideways"><dd>  <p>Whether the glyphs in the run are sideways or not.</p> </dd></param>	
        /// <param name="outlineThreshold"><dd>  <p>A <strong><see cref="SharpDX.DirectWrite.OutlineThreshold"/></strong>-typed value that specifies the quality of the graphics system's outline rendering, affects the size threshold above which outline rendering is used.</p> </dd></param>	
        /// <param name="measuringMode"><dd>  <p>The measuring method that will be used for glyphs in the font. Renderer implementations may choose different rendering modes for different measuring methods, for example: </p> <ul> <li><see cref="SharpDX.DirectWrite.RenderingMode.CleartypeNatural"/> for <strong><see cref="SharpDX.Direct2D1.MeasuringMode.Natural"/></strong> </li> <li> <see cref="SharpDX.DirectWrite.RenderingMode.CleartypeGdiClassic"/> for <strong><see cref="SharpDX.Direct2D1.MeasuringMode.GdiClassic"/></strong> </li> <li> <see cref="SharpDX.DirectWrite.RenderingMode.CleartypeGdiNatural"/> for <strong><see cref="SharpDX.Direct2D1.MeasuringMode.GdiNatural"/></strong> </li> </ul> </dd></param>	
        /// <param name="renderingMode"><dd>  <p>When this method returns, contains a value that indicates the recommended rendering mode to use.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method should be used to determine the actual rendering mode in cases where the rendering  mode of the rendering params object is <see cref="SharpDX.DirectWrite.RenderingMode.Default"/>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1::GetRecommendedRenderingMode']/*"/>	
        /// <msdn-id>Hh780416</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFace1::GetRecommendedRenderingMode([In] float fontEmSize,[In] float dpiX,[In] float dpiY,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL isSideways,[In] DWRITE_OUTLINE_THRESHOLD outlineThreshold,[In] DWRITE_MEASURING_MODE measuringMode,[Out] DWRITE_RENDERING_MODE* renderingMode)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace1::GetRecommendedRenderingMode</unmanaged-short>	
        public void GetRecommendedRenderingMode(float fontEmSize, float dpiX, float dpiY, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.DirectWrite.OutlineThreshold outlineThreshold, SharpDX.Direct2D1.MeasuringMode measuringMode, out SharpDX.DirectWrite.RenderingMode renderingMode)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
                if (transform.HasValue)
                    transform_ = transform.Value;
                SharpDX.Result __result__;
                fixed (void* renderingMode_ = &renderingMode)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint177(_nativePointer, fontEmSize, dpiX, dpiY, (transform.HasValue) ? &transform_ : (void*)IntPtr.Zero, isSideways, unchecked((int)outlineThreshold), unchecked((int)measuringMode), renderingMode_, ((void**)(*(void**)_nativePointer))[27]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Retrieves the vertical forms of the nominal glyphs retrieved from GetGlyphIndices.</p>	
        /// </summary>	
        /// <param name="glyphCount"><dd>  <p>The number of glyphs to retrieve.</p> </dd></param>	
        /// <param name="nominalGlyphIndices"><dd>  <p>Original glyph indices from cmap.</p> </dd></param>	
        /// <param name="verticalGlyphIndices"><dd>  <p>The vertical form of glyph indices.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The retrieval uses the font's 'vert' table. This is used in CJK vertical layout so the correct characters are shown.</p><p>Call <strong>GetGlyphIndices</strong> to get the nominal glyph indices, followed by calling this to remap the to the substituted forms, when the run is sideways, and the font has vertical glyph variants. See <strong>HasVerticalGlyphVariants</strong> for more info.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1::GetVerticalGlyphVariants']/*"/>	
        /// <msdn-id>hh780418</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFace1::GetVerticalGlyphVariants([In] unsigned int glyphCount,[In, Buffer] const unsigned short* nominalGlyphIndices,[Out, Buffer] unsigned short* verticalGlyphIndices)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace1::GetVerticalGlyphVariants</unmanaged-short>	
        public void GetVerticalGlyphVariants(int glyphCount, short[] nominalGlyphIndices, short[] verticalGlyphIndices)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* nominalGlyphIndices_ = nominalGlyphIndices)
                    fixed (void* verticalGlyphIndices_ = verticalGlyphIndices)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, glyphCount, nominalGlyphIndices_, verticalGlyphIndices_, ((void**)(*(void**)_nativePointer))[28]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Determines whether the font has any vertical glyph variants.</p>	
        /// </summary>	
        /// <returns><p>Returns TRUE if the font contains vertical glyph variants, otherwise <see cref="SharpDX.Result.False"/>.</p></returns>	
        /// <remarks>	
        /// <p>For OpenType fonts, <strong>HasVerticalGlyphVariants</strong> returns TRUE if the font contains a "vert" feature. </p><p> <strong><see cref="SharpDX.DirectWrite.FontFace1.GetVerticalGlyphVariants"/></strong> retrieves the vertical forms of the nominal glyphs that are retrieved from <strong><see cref="SharpDX.DirectWrite.FontFace.GetGlyphIndices"/></strong>. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFace1::HasVerticalGlyphVariants']/*"/>	
        /// <msdn-id>hh780420</msdn-id>	
        /// <unmanaged>BOOL IDWriteFontFace1::HasVerticalGlyphVariants()</unmanaged>	
        /// <unmanaged-short>IDWriteFontFace1::HasVerticalGlyphVariants</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool HasVerticalGlyphVariants()
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, ((void**)(*(void**)_nativePointer))[29]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p> Creates a localized strings object that contains the family names for the font family, indexed by locale name. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p> The following code example shows how to get the font family name from a <strong><see cref="SharpDX.DirectWrite.FontFamily"/></strong> object.</p><pre><see cref="SharpDX.DirectWrite.LocalizedStrings"/>* pFamilyNames = <c>null</c>; // Get a list of localized strings for the family name.	
    /// if (SUCCEEDED(hr))	
    /// { hr = pFontFamily-&gt;GetFamilyNames(&amp;pFamilyNames);	
    /// } UINT32 index = 0;	
    /// <see cref="SharpDX.Mathematics.Interop.RawBool"/> exists = false; wchar_t localeName[LOCALE_NAME_MAX_LENGTH]; if (SUCCEEDED(hr))	
    /// { // Get the default locale for this user. int defaultLocaleSuccess = GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH); // If the default locale is returned, find that locale name, otherwise use "en-us". if (defaultLocaleSuccess) { hr = pFamilyNames-&gt;FindLocaleName(localeName, &amp;index, &amp;exists); } if (SUCCEEDED(hr) &amp;&amp; !exists) // if the above find did not find a match, retry with US English { hr = pFamilyNames-&gt;FindLocaleName(L"en-us", &amp;index, &amp;exists); }	
    /// } // If the specified locale doesn't exist, select the first on the list.	
    /// if (!exists) index = 0; UINT32 length = 0; // Get the string length.	
    /// if (SUCCEEDED(hr))	
    /// { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);	
    /// } // Allocate a string big enough to hold the name.	
    /// wchar_t* name = new (std::nothrow) wchar_t[length+1];	
    /// if (name == <c>null</c>)	
    /// { hr = E_OUTOFMEMORY;	
    /// } // Get the family name.	
    /// if (SUCCEEDED(hr))	
    /// { hr = pFamilyNames-&gt;GetString(index, name, length+1);	
    /// }	
    /// </pre>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFamily']/*"/>	
    /// <msdn-id>dd371047</msdn-id>	
    /// <unmanaged>IDWriteFontFamily</unmanaged>	
    /// <unmanaged-short>IDWriteFontFamily</unmanaged-short>	
    [Guid("da20d8ef-812a-4c43-9802-62ec4abd7add")]
    public partial class FontFamily : SharpDX.DirectWrite.FontList
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.FontFamily"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FontFamily(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.FontFamily"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.FontFamily(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.FontFamily(nativePointer);
        }


        /// <summary>	
        /// <p> Creates a localized strings object that contains the family names for the font family, indexed by locale name. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p> The following code example shows how to get the font family name from a <strong><see cref="SharpDX.DirectWrite.FontFamily"/></strong> object.</p><pre><see cref="SharpDX.DirectWrite.LocalizedStrings"/>* pFamilyNames = <c>null</c>; // Get a list of localized strings for the family name.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFontFamily-&gt;GetFamilyNames(&amp;pFamilyNames);	
        /// } UINT32 index = 0;	
        /// <see cref="SharpDX.Mathematics.Interop.RawBool"/> exists = false; wchar_t localeName[LOCALE_NAME_MAX_LENGTH]; if (SUCCEEDED(hr))	
        /// { // Get the default locale for this user. int defaultLocaleSuccess = GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH); // If the default locale is returned, find that locale name, otherwise use "en-us". if (defaultLocaleSuccess) { hr = pFamilyNames-&gt;FindLocaleName(localeName, &amp;index, &amp;exists); } if (SUCCEEDED(hr) &amp;&amp; !exists) // if the above find did not find a match, retry with US English { hr = pFamilyNames-&gt;FindLocaleName(L"en-us", &amp;index, &amp;exists); }	
        /// } // If the specified locale doesn't exist, select the first on the list.	
        /// if (!exists) index = 0; UINT32 length = 0; // Get the string length.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);	
        /// } // Allocate a string big enough to hold the name.	
        /// wchar_t* name = new (std::nothrow) wchar_t[length+1];	
        /// if (name == <c>null</c>)	
        /// { hr = E_OUTOFMEMORY;	
        /// } // Get the family name.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetString(index, name, length+1);	
        /// }	
        /// </pre>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFamily::GetFamilyNames']/*"/>	
        /// <msdn-id>dd371047</msdn-id>	
        /// <unmanaged>GetFamilyNames</unmanaged>	
        /// <unmanaged-short>GetFamilyNames</unmanaged-short>	
        /// <unmanaged>HRESULT IDWriteFontFamily::GetFamilyNames([Out] IDWriteLocalizedStrings** names)</unmanaged>
        public SharpDX.DirectWrite.LocalizedStrings FamilyNames
        {
            get { SharpDX.DirectWrite.LocalizedStrings __output__; GetFamilyNames(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Creates a localized strings object that contains the family names for the font family, indexed by locale name. </p>	
        /// </summary>	
        /// <param name="names"><dd>  <p>The address of a reference to the newly created <strong><see cref="SharpDX.DirectWrite.LocalizedStrings"/></strong> object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The following code example shows how to get the font family name from a <strong><see cref="SharpDX.DirectWrite.FontFamily"/></strong> object.</p><pre><see cref="SharpDX.DirectWrite.LocalizedStrings"/>* pFamilyNames = <c>null</c>; // Get a list of localized strings for the family name.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFontFamily-&gt;GetFamilyNames(&amp;pFamilyNames);	
        /// } UINT32 index = 0;	
        /// <see cref="SharpDX.Mathematics.Interop.RawBool"/> exists = false; wchar_t localeName[LOCALE_NAME_MAX_LENGTH]; if (SUCCEEDED(hr))	
        /// { // Get the default locale for this user. int defaultLocaleSuccess = GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH); // If the default locale is returned, find that locale name, otherwise use "en-us". if (defaultLocaleSuccess) { hr = pFamilyNames-&gt;FindLocaleName(localeName, &amp;index, &amp;exists); } if (SUCCEEDED(hr) &amp;&amp; !exists) // if the above find did not find a match, retry with US English { hr = pFamilyNames-&gt;FindLocaleName(L"en-us", &amp;index, &amp;exists); }	
        /// } // If the specified locale doesn't exist, select the first on the list.	
        /// if (!exists) index = 0; UINT32 length = 0; // Get the string length.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);	
        /// } // Allocate a string big enough to hold the name.	
        /// wchar_t* name = new (std::nothrow) wchar_t[length+1];	
        /// if (name == <c>null</c>)	
        /// { hr = E_OUTOFMEMORY;	
        /// } // Get the family name.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetString(index, name, length+1);	
        /// }	
        /// </pre>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFamily::GetFamilyNames']/*"/>	
        /// <msdn-id>dd371047</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFamily::GetFamilyNames([Out] IDWriteLocalizedStrings** names)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFamily::GetFamilyNames</unmanaged-short>	
        internal void GetFamilyNames(out SharpDX.DirectWrite.LocalizedStrings names)
        {
            unsafe
            {
                IntPtr names_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &names_, ((void**)(*(void**)_nativePointer))[6]);
                names = (names_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.LocalizedStrings(names_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the font that best matches the specified properties. </p>	
        /// </summary>	
        /// <param name="weight"><dd>  <p>A value that is used to match a requested font weight.</p> </dd></param>	
        /// <param name="stretch"><dd>  <p>A value that is used to match a requested font stretch.</p> </dd></param>	
        /// <param name="style"><dd>  <p>A value that is used to match a requested font style.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains the address of a reference to the newly created <strong><see cref="SharpDX.DirectWrite.Font"/></strong> object.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFamily::GetFirstMatchingFont']/*"/>	
        /// <msdn-id>dd371051</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFamily::GetFirstMatchingFont([In] DWRITE_FONT_WEIGHT weight,[In] DWRITE_FONT_STRETCH stretch,[In] DWRITE_FONT_STYLE style,[Out] IDWriteFont** matchingFont)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFamily::GetFirstMatchingFont</unmanaged-short>	
        public SharpDX.DirectWrite.Font GetFirstMatchingFont(SharpDX.DirectWrite.FontWeight weight, SharpDX.DirectWrite.FontStretch stretch, SharpDX.DirectWrite.FontStyle style)
        {
            unsafe
            {
                SharpDX.DirectWrite.Font matchingFont;
                IntPtr matchingFont_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)weight), unchecked((int)stretch), unchecked((int)style), &matchingFont_, ((void**)(*(void**)_nativePointer))[7]);
                matchingFont = (matchingFont_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.Font(matchingFont_);
                __result__.CheckError();
                return matchingFont;
            }
        }

        /// <summary>	
        /// <p> Gets a list of fonts in the font family ranked in order of how well they match the specified properties. </p>	
        /// </summary>	
        /// <param name="weight"><dd>  <p>A value that is used to match a requested font weight.</p> </dd></param>	
        /// <param name="stretch"><dd>  <p>A value that is used to match a requested font stretch.</p> </dd></param>	
        /// <param name="style"><dd>  <p>A value that is used to match a requested font style.</p> </dd></param>	
        /// <returns><dd>  <p>An address of a reference to the newly created <strong><see cref="SharpDX.DirectWrite.FontList"/></strong> object.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFamily::GetMatchingFonts']/*"/>	
        /// <msdn-id>dd371056</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFamily::GetMatchingFonts([In] DWRITE_FONT_WEIGHT weight,[In] DWRITE_FONT_STRETCH stretch,[In] DWRITE_FONT_STYLE style,[Out] IDWriteFontList** matchingFonts)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFamily::GetMatchingFonts</unmanaged-short>	
        public SharpDX.DirectWrite.FontList GetMatchingFonts(SharpDX.DirectWrite.FontWeight weight, SharpDX.DirectWrite.FontStretch stretch, SharpDX.DirectWrite.FontStyle style)
        {
            unsafe
            {
                SharpDX.DirectWrite.FontList matchingFonts;
                IntPtr matchingFonts_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)weight), unchecked((int)stretch), unchecked((int)style), &matchingFonts_, ((void**)(*(void**)_nativePointer))[8]);
                matchingFonts = (matchingFonts_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.FontList(matchingFonts_);
                __result__.CheckError();
                return matchingFonts;
            }
        }
    }
    /// <summary>	
    /// <p> Represents a font file. Applications  such as font managers or font viewers can call <strong><see cref="SharpDX.DirectWrite.FontFile.Analyze"/></strong> to find out if a particular file is a font file, and whether it is a font type that is supported by the font system.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFile']/*"/>	
    /// <msdn-id>dd371060</msdn-id>	
    /// <unmanaged>IDWriteFontFile</unmanaged>	
    /// <unmanaged-short>IDWriteFontFile</unmanaged-short>	
    [Guid("739d886a-cef5-47dc-8769-1a8b41bebbb0")]
    public partial class FontFile : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.FontFile"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FontFile(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.FontFile"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.FontFile(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.FontFile(nativePointer);
        }


        /// <summary>	
        /// <p> Obtains the reference to the reference key of a font file. The returned reference is valid until the font file object is released.  </p>	
        /// </summary>	
        /// <param name="fontFileReferenceKey"><dd>  <p>When this method returns, contains an address of  a reference to the font file reference key. Note that the reference value is only valid until the font file object it is obtained from is released. This parameter is passed uninitialized.</p> </dd></param>	
        /// <param name="fontFileReferenceKeySize"><dd>  <p>When this method returns, contains the size of the font file reference key in bytes. This parameter is passed uninitialized.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFile::GetReferenceKey']/*"/>	
        /// <msdn-id>dd371108</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFile::GetReferenceKey([Out, Buffer] const void** fontFileReferenceKey,[Out] unsigned int* fontFileReferenceKeySize)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFile::GetReferenceKey</unmanaged-short>	
        internal void GetReferenceKey(System.IntPtr fontFileReferenceKey, out int fontFileReferenceKeySize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* fontFileReferenceKeySize_ = &fontFileReferenceKeySize)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)fontFileReferenceKey, fontFileReferenceKeySize_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Obtains the file loader associated with a font file object. </p>	
        /// </summary>	
        /// <param name="fontFileLoader"><dd>  <p>When this method returns, contains the address of  a reference to the font file loader associated with the font file object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFile::GetLoader']/*"/>	
        /// <msdn-id>dd371104</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFile::GetLoader([Out] IDWriteFontFileLoader** fontFileLoader)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFile::GetLoader</unmanaged-short>	
        internal void GetLoader(out SharpDX.DirectWrite.FontFileLoader fontFileLoader)
        {
            unsafe
            {
                IntPtr fontFileLoader_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &fontFileLoader_, ((void**)(*(void**)_nativePointer))[4]);
                fontFileLoader = (fontFileLoader_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.FontFileLoaderNative(fontFileLoader_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Analyzes a file and returns whether it represents a font, and whether the font type is supported by the font system. </p>	
        /// </summary>	
        /// <param name="isSupportedFontType"><dd>  <p><strong>TRUE</strong> if the font type is supported by the font system; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <param name="fontFileType"><dd>  <p>When this method returns, contains a value that indicates the type of the font file. Note that even if <em> isSupportedFontType</em> is <strong><see cref="SharpDX.Result.False"/></strong>, the <em>fontFileType</em> value may be different from <strong><see cref="SharpDX.DirectWrite.FontFileType.Unknown"/></strong>.</p> </dd></param>	
        /// <param name="fontFaceType"><dd>  <p>When this method returns, contains a value that indicates the type of the font face. If <em>fontFileType</em> is not equal to <strong><see cref="SharpDX.DirectWrite.FontFileType.Unknown"/></strong>, then that can be constructed from the font file. </p> </dd></param>	
        /// <param name="numberOfFaces"><dd>  <p>When this method returns, contains the number of font faces contained in the font file.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><strong>Important</strong>??Certain font file types are recognized, but not supported by the font system. For example, the font system will recognize a file as a Type 1 font file but will not be able to construct a font face object from it. In such situations, <strong>Analyze</strong> will set <em>isSupportedFontType</em> output parameter to <strong><see cref="SharpDX.Result.False"/></strong>. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFile::Analyze']/*"/>	
        /// <msdn-id>dd371099</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFile::Analyze([Out] BOOL* isSupportedFontType,[Out] DWRITE_FONT_FILE_TYPE* fontFileType,[Out, Optional] DWRITE_FONT_FACE_TYPE* fontFaceType,[Out] unsigned int* numberOfFaces)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFile::Analyze</unmanaged-short>	
        public void Analyze(out SharpDX.Mathematics.Interop.RawBool isSupportedFontType, out SharpDX.DirectWrite.FontFileType fontFileType, out SharpDX.DirectWrite.FontFaceType fontFaceType, out int numberOfFaces)
        {
            unsafe
            {
                isSupportedFontType = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* isSupportedFontType_ = &isSupportedFontType)
                    fixed (void* fontFileType_ = &fontFileType)
                        fixed (void* fontFaceType_ = &fontFaceType)
                            fixed (void* numberOfFaces_ = &numberOfFaces)
                                __result__ =
                                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, isSupportedFontType_, fontFileType_, fontFaceType_, numberOfFaces_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Encapsulates a collection of font files. The font system uses this interface to enumerate font files when building a font collection.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileEnumerator']/*"/>	
    /// <msdn-id>dd371063</msdn-id>	
    /// <unmanaged>IDWriteFontFileEnumerator</unmanaged>	
    /// <unmanaged-short>IDWriteFontFileEnumerator</unmanaged-short>	
    [Guid("72755049-5ff7-435d-8348-4be97cfa6c7c")]
    public partial interface FontFileEnumerator : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p> Advances to the next font file in the collection. When it is first created, the enumerator is positioned before the first element of the collection and the first call to <strong>MoveNext</strong> advances to the first file. </p>	
        /// </summary>	
        /// <param name="hasCurrentFile"><dd>  <p>When the method returns, contains  the value <strong>TRUE</strong> if the enumerator advances to a file; otherwise, <strong><see cref="SharpDX.Result.False"/></strong> if the enumerator advances past the last file in the collection.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileEnumerator::MoveNext']/*"/>	
        /// <msdn-id>dd371071</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFileEnumerator::MoveNext([Out] BOOL* hasCurrentFile)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFileEnumerator::MoveNext</unmanaged-short>	
        /* public void MoveNext(out SharpDX.Mathematics.Interop.RawBool hasCurrentFile) */

        /// <summary>	
        /// <p> Gets a reference to the current font file. </p>	
        /// </summary>	
        /// <param name="fontFile"><dd>  <p>When this method returns, the address of a reference to the newly created <strong><see cref="SharpDX.DirectWrite.FontFile"/></strong> object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileEnumerator::GetCurrentFontFile']/*"/>	
        /// <msdn-id>dd371067</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFileEnumerator::GetCurrentFontFile([Out] IDWriteFontFile** fontFile)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFileEnumerator::GetCurrentFontFile</unmanaged-short>	
        /* internal void GetCurrentFontFile(out SharpDX.DirectWrite.FontFile fontFile) */
    }
    /// <summary>	
    /// <p> Handles loading font file resources of a particular type from a font file reference key into a font file stream object. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The font file loader interface is recommended to be implemented by a singleton object. Note that font file loader implementations must not register themselves with DirectWrite factory inside their constructors and must not unregister themselves in their destructors, because registration and unregistraton operations increment and decrement the object reference count respectively. Instead, registration and unregistration of font file loaders with DirectWrite factory should be performed outside of the font file loader implementation as a separate step.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileLoader']/*"/>	
    /// <msdn-id>dd371075</msdn-id>	
    /// <unmanaged>IDWriteFontFileLoader</unmanaged>	
    /// <unmanaged-short>IDWriteFontFileLoader</unmanaged-short>	
    [Guid("727cad4e-d6af-4c9e-8a08-d695b11caa49")]
    public partial interface FontFileLoader : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p> Creates a font file stream object that encapsulates an open file resource. </p>	
        /// </summary>	
        /// <param name="fontFileReferenceKey"><dd>  <p>A reference to a font file reference key that uniquely identifies the font file resource within the scope of the font loader being used. The buffer allocated for this key must at least be the size, in bytes, specified by <em> fontFileReferenceKeySize</em>.</p> </dd></param>	
        /// <param name="fontFileReferenceKeySize"><dd>  <p>The size of font file reference key, in bytes.</p> </dd></param>	
        /// <param name="fontFileStream"><dd>  <p>When this method returns, contains the address of a reference to the newly created <strong><see cref="SharpDX.DirectWrite.FontFileStream"/></strong> object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The resource is closed when the last reference to <em>fontFileStream</em> is released. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileLoader::CreateStreamFromKey']/*"/>	
        /// <msdn-id>dd371077</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFileLoader::CreateStreamFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out] IDWriteFontFileStream** fontFileStream)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFileLoader::CreateStreamFromKey</unmanaged-short>	
        /* public void CreateStreamFromKey(System.IntPtr fontFileReferenceKey, int fontFileReferenceKeySize, out SharpDX.DirectWrite.FontFileStream fontFileStream) */
    }
    /// <summary>	
    /// <p> Handles loading font file resources of a particular type from a font file reference key into a font file stream object. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The font file loader interface is recommended to be implemented by a singleton object. Note that font file loader implementations must not register themselves with DirectWrite factory inside their constructors and must not unregister themselves in their destructors, because registration and unregistraton operations increment and decrement the object reference count respectively. Instead, registration and unregistration of font file loaders with DirectWrite factory should be performed outside of the font file loader implementation as a separate step.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileLoader']/*"/>	
    /// <msdn-id>dd371075</msdn-id>	
    /// <unmanaged>IDWriteFontFileLoader</unmanaged>	
    /// <unmanaged-short>IDWriteFontFileLoader</unmanaged-short>	
    [Guid("727cad4e-d6af-4c9e-8a08-d695b11caa49")]
    public partial class FontFileLoaderNative : SharpDX.ComObjectCallback, SharpDX.DirectWrite.FontFileLoader
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.FontFileLoaderNative"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FontFileLoaderNative(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.FontFileLoaderNative"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.FontFileLoaderNative(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.FontFileLoaderNative(nativePointer);
        }


        /// <summary>	
        /// <p> Creates a font file stream object that encapsulates an open file resource. </p>	
        /// </summary>	
        /// <param name="fontFileReferenceKey"><dd>  <p>A reference to a font file reference key that uniquely identifies the font file resource within the scope of the font loader being used. The buffer allocated for this key must at least be the size, in bytes, specified by <em> fontFileReferenceKeySize</em>.</p> </dd></param>	
        /// <param name="fontFileReferenceKeySize"><dd>  <p>The size of font file reference key, in bytes.</p> </dd></param>	
        /// <param name="fontFileStream"><dd>  <p>When this method returns, contains the address of a reference to the newly created <strong><see cref="SharpDX.DirectWrite.FontFileStream"/></strong> object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The resource is closed when the last reference to <em>fontFileStream</em> is released. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileLoader::CreateStreamFromKey']/*"/>	
        /// <msdn-id>dd371077</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFileLoader::CreateStreamFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out] IDWriteFontFileStream** fontFileStream)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFileLoader::CreateStreamFromKey</unmanaged-short>	
        internal void CreateStreamFromKey_(System.IntPtr fontFileReferenceKey, int fontFileReferenceKeySize, out SharpDX.DirectWrite.FontFileStream fontFileStream)
        {
            unsafe
            {
                IntPtr fontFileStream_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)fontFileReferenceKey, fontFileReferenceKeySize, &fontFileStream_, ((void**)(*(void**)_nativePointer))[3]);
                fontFileStream = (fontFileStream_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.FontFileStreamNative(fontFileStream_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Loads font file data from a custom font file loader. </p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileStream']/*"/>	
    /// <msdn-id>dd371081</msdn-id>	
    /// <unmanaged>IDWriteFontFileStream</unmanaged>	
    /// <unmanaged-short>IDWriteFontFileStream</unmanaged-short>	
    [Guid("6d4865fe-0ab8-4d91-8f62-5dd6be34a3e0")]
    public partial interface FontFileStream : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p> Reads a fragment from a font file. </p>	
        /// </summary>	
        /// <param name="fragmentStart"><dd>  <p>When this method returns, contains an address of a  reference to the start of the font file fragment.  This parameter is passed uninitialized.</p> </dd></param>	
        /// <param name="fileOffset"><dd>  <p>The offset of the fragment, in bytes, from the beginning of the font file.</p> </dd></param>	
        /// <param name="fragmentSize"><dd>  <p>The size of the file fragment, in bytes.</p> </dd></param>	
        /// <param name="fragmentContext"><dd>  <p>When this method returns, contains the address of a reference to a reference to the client-defined context to be passed to <strong>ReleaseFileFragment</strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Note that <strong>ReadFileFragment</strong> implementations must check whether the requested font file fragment is within the file bounds. Otherwise, an error should be returned from <strong>ReadFileFragment</strong>. </p><p> DirectWrite may invoke <strong><see cref="SharpDX.DirectWrite.FontFileStream"/></strong> methods on the same object from multiple threads simultaneously. Therefore, <strong>ReadFileFragment</strong> implementations that rely on internal mutable state must serialize access to such state across multiple threads. For example, an implementation that uses separate Seek and Read operations to read a file fragment must place the code block containing Seek and Read calls under a lock or a critical section.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileStream::ReadFileFragment']/*"/>	
        /// <msdn-id>dd371091</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFileStream::ReadFileFragment([Out] const void** fragmentStart,[In] unsigned longlong fileOffset,[In] unsigned longlong fragmentSize,[Out] void** fragmentContext)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFileStream::ReadFileFragment</unmanaged-short>	
        /* public void ReadFileFragment(out System.IntPtr fragmentStart, long fileOffset, long fragmentSize, out System.IntPtr fragmentContext) */

        /// <summary>	
        /// <p> Releases a fragment from a file. </p>	
        /// </summary>	
        /// <param name="fragmentContext"><dd>  <p>A reference to the client-defined context of a font fragment returned from <strong>ReadFileFragment</strong>.</p> </dd></param>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileStream::ReleaseFileFragment']/*"/>	
        /// <msdn-id>dd371095</msdn-id>	
        /// <unmanaged>void IDWriteFontFileStream::ReleaseFileFragment([In] void* fragmentContext)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFileStream::ReleaseFileFragment</unmanaged-short>	
        /* public void ReleaseFileFragment(System.IntPtr fragmentContext) */

        /// <summary>	
        /// <p> Obtains the total size of a file. </p>	
        /// </summary>	
        /// <param name="fileSize"><dd>  <p>When this method returns, contains the total size of the file.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Implementing <strong>GetFileSize</strong>() for asynchronously loaded font files may require downloading the complete file contents. Therefore, this method should be used only for operations that either require a complete font file to be loaded (for example, copying a font file) or that need to make decisions based on the value of the file size (for example, validation against a persisted file size). </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileStream::GetFileSize']/*"/>	
        /// <msdn-id>dd371084</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFileStream::GetFileSize([Out] unsigned longlong* fileSize)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFileStream::GetFileSize</unmanaged-short>	
        /* public void GetFileSize(out long fileSize) */

        /// <summary>	
        /// <p> Obtains the last modified time of the file.  </p>	
        /// </summary>	
        /// <param name="lastWriteTime"><dd>  <p>When this method returns, contains  the last modified time of the file in the format that represents the number of 100-nanosecond intervals since January 1, 1601 (UTC).</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The "last modified time" is used by DirectWrite font selection algorithms to determine whether one font resource is more up to date than another one.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileStream::GetLastWriteTime']/*"/>	
        /// <msdn-id>dd371089</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFileStream::GetLastWriteTime([Out] unsigned longlong* lastWriteTime)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFileStream::GetLastWriteTime</unmanaged-short>	
        /* public void GetLastWriteTime(out long lastWriteTime) */
    }
    /// <summary>	
    /// <p> Loads font file data from a custom font file loader. </p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileStream']/*"/>	
    /// <msdn-id>dd371081</msdn-id>	
    /// <unmanaged>IDWriteFontFileStream</unmanaged>	
    /// <unmanaged-short>IDWriteFontFileStream</unmanaged-short>	
    [Guid("6d4865fe-0ab8-4d91-8f62-5dd6be34a3e0")]
    public partial class FontFileStreamNative : SharpDX.ComObjectCallback, SharpDX.DirectWrite.FontFileStream
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.FontFileStreamNative"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FontFileStreamNative(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.FontFileStreamNative"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.FontFileStreamNative(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.FontFileStreamNative(nativePointer);
        }


        /// <summary>	
        /// <p> Reads a fragment from a font file. </p>	
        /// </summary>	
        /// <param name="fragmentStart"><dd>  <p>When this method returns, contains an address of a  reference to the start of the font file fragment.  This parameter is passed uninitialized.</p> </dd></param>	
        /// <param name="fileOffset"><dd>  <p>The offset of the fragment, in bytes, from the beginning of the font file.</p> </dd></param>	
        /// <param name="fragmentSize"><dd>  <p>The size of the file fragment, in bytes.</p> </dd></param>	
        /// <param name="fragmentContext"><dd>  <p>When this method returns, contains the address of a reference to a reference to the client-defined context to be passed to <strong>ReleaseFileFragment</strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Note that <strong>ReadFileFragment</strong> implementations must check whether the requested font file fragment is within the file bounds. Otherwise, an error should be returned from <strong>ReadFileFragment</strong>. </p><p> DirectWrite may invoke <strong><see cref="SharpDX.DirectWrite.FontFileStream"/></strong> methods on the same object from multiple threads simultaneously. Therefore, <strong>ReadFileFragment</strong> implementations that rely on internal mutable state must serialize access to such state across multiple threads. For example, an implementation that uses separate Seek and Read operations to read a file fragment must place the code block containing Seek and Read calls under a lock or a critical section.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileStream::ReadFileFragment']/*"/>	
        /// <msdn-id>dd371091</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFileStream::ReadFileFragment([Out] const void** fragmentStart,[In] unsigned longlong fileOffset,[In] unsigned longlong fragmentSize,[Out] void** fragmentContext)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFileStream::ReadFileFragment</unmanaged-short>	
        internal void ReadFileFragment_(out System.IntPtr fragmentStart, long fileOffset, long fragmentSize, out System.IntPtr fragmentContext)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* fragmentStart_ = &fragmentStart)
                    fixed (void* fragmentContext_ = &fragmentContext)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, fragmentStart_, fileOffset, fragmentSize, fragmentContext_, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Releases a fragment from a file. </p>	
        /// </summary>	
        /// <param name="fragmentContext"><dd>  <p>A reference to the client-defined context of a font fragment returned from <strong>ReadFileFragment</strong>.</p> </dd></param>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileStream::ReleaseFileFragment']/*"/>	
        /// <msdn-id>dd371095</msdn-id>	
        /// <unmanaged>void IDWriteFontFileStream::ReleaseFileFragment([In] void* fragmentContext)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFileStream::ReleaseFileFragment</unmanaged-short>	
        internal void ReleaseFileFragment_(System.IntPtr fragmentContext)
        {
            unsafe
            {
                SharpDX.Direct2D1.LocalInterop.Callivoid(_nativePointer, (void*)fragmentContext, ((void**)(*(void**)_nativePointer))[4]);
            }
        }

        /// <summary>	
        /// <p> Obtains the total size of a file. </p>	
        /// </summary>	
        /// <param name="fileSize"><dd>  <p>When this method returns, contains the total size of the file.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Implementing <strong>GetFileSize</strong>() for asynchronously loaded font files may require downloading the complete file contents. Therefore, this method should be used only for operations that either require a complete font file to be loaded (for example, copying a font file) or that need to make decisions based on the value of the file size (for example, validation against a persisted file size). </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileStream::GetFileSize']/*"/>	
        /// <msdn-id>dd371084</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFileStream::GetFileSize([Out] unsigned longlong* fileSize)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFileStream::GetFileSize</unmanaged-short>	
        internal void GetFileSize_(out long fileSize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* fileSize_ = &fileSize)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, fileSize_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Obtains the last modified time of the file.  </p>	
        /// </summary>	
        /// <param name="lastWriteTime"><dd>  <p>When this method returns, contains  the last modified time of the file in the format that represents the number of 100-nanosecond intervals since January 1, 1601 (UTC).</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The "last modified time" is used by DirectWrite font selection algorithms to determine whether one font resource is more up to date than another one.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontFileStream::GetLastWriteTime']/*"/>	
        /// <msdn-id>dd371089</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontFileStream::GetLastWriteTime([Out] unsigned longlong* lastWriteTime)</unmanaged>	
        /// <unmanaged-short>IDWriteFontFileStream::GetLastWriteTime</unmanaged-short>	
        internal void GetLastWriteTime_(out long lastWriteTime)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* lastWriteTime_ = &lastWriteTime)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, lastWriteTime_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Represents a list of fonts.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontList']/*"/>	
    /// <msdn-id>dd371120</msdn-id>	
    /// <unmanaged>IDWriteFontList</unmanaged>	
    /// <unmanaged-short>IDWriteFontList</unmanaged-short>	
    [Guid("1a0d8438-1d97-4ec1-aef9-a2fb86ed6acb")]
    public partial class FontList : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.FontList"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FontList(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.FontList"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.FontList(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.FontList(nativePointer);
        }


        /// <summary>	
        /// <p> Gets the font collection that contains the fonts in the font list.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontList::GetFontCollection']/*"/>	
        /// <msdn-id>dd371129</msdn-id>	
        /// <unmanaged>GetFontCollection</unmanaged>	
        /// <unmanaged-short>GetFontCollection</unmanaged-short>	
        /// <unmanaged>HRESULT IDWriteFontList::GetFontCollection([Out] IDWriteFontCollection** fontCollection)</unmanaged>
        public SharpDX.DirectWrite.FontCollection FontCollection
        {
            get { SharpDX.DirectWrite.FontCollection __output__; GetFontCollection(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Gets the number of fonts in the font list. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontList::GetFontCount']/*"/>	
        /// <msdn-id>dd371133</msdn-id>	
        /// <unmanaged>GetFontCount</unmanaged>	
        /// <unmanaged-short>GetFontCount</unmanaged-short>	
        /// <unmanaged>unsigned int IDWriteFontList::GetFontCount()</unmanaged>
        public int FontCount
        {
            get { return GetFontCount(); }
        }

        /// <summary>	
        /// <p> Gets the font collection that contains the fonts in the font list.</p>	
        /// </summary>	
        /// <param name="fontCollection"><dd>  <p>When this method returns, contains the address of a reference to the current <strong><see cref="SharpDX.DirectWrite.FontCollection"/></strong> object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontList::GetFontCollection']/*"/>	
        /// <msdn-id>dd371129</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontList::GetFontCollection([Out] IDWriteFontCollection** fontCollection)</unmanaged>	
        /// <unmanaged-short>IDWriteFontList::GetFontCollection</unmanaged-short>	
        internal void GetFontCollection(out SharpDX.DirectWrite.FontCollection fontCollection)
        {
            unsafe
            {
                IntPtr fontCollection_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &fontCollection_, ((void**)(*(void**)_nativePointer))[3]);
                fontCollection = (fontCollection_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.FontCollection(fontCollection_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the number of fonts in the font list. </p>	
        /// </summary>	
        /// <returns><p>The number of fonts in the font list.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontList::GetFontCount']/*"/>	
        /// <msdn-id>dd371133</msdn-id>	
        /// <unmanaged>unsigned int IDWriteFontList::GetFontCount()</unmanaged>	
        /// <unmanaged-short>IDWriteFontList::GetFontCount</unmanaged-short>	
        internal int GetFontCount()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets a font given its zero-based index. </p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Zero-based index of the font in the font list.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains the address of a reference to the newly created <strong><see cref="SharpDX.DirectWrite.Font"/></strong> object.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteFontList::GetFont']/*"/>	
        /// <msdn-id>dd371125</msdn-id>	
        /// <unmanaged>HRESULT IDWriteFontList::GetFont([In] unsigned int index,[Out] IDWriteFont** font)</unmanaged>	
        /// <unmanaged-short>IDWriteFontList::GetFont</unmanaged-short>	
        public SharpDX.DirectWrite.Font GetFont(int index)
        {
            unsafe
            {
                SharpDX.DirectWrite.Font font;
                IntPtr font_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, index, &font_, ((void**)(*(void**)_nativePointer))[5]);
                font = (font_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.Font(font_);
                __result__.CheckError();
                return font;
            }
        }
    }
    /// <summary>	
    /// <p>Provides interoperability with GDI, such as methods to convert a font face to a <see cref="SharpDX.DirectWrite.GdiInterop.LogFont"/> structure, or to convert a GDI font description into a font face. It is also used to create bitmap render target objects.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteGdiInterop']/*"/>	
    /// <msdn-id>dd371172</msdn-id>	
    /// <unmanaged>IDWriteGdiInterop</unmanaged>	
    /// <unmanaged-short>IDWriteGdiInterop</unmanaged-short>	
    [Guid("1edd9491-9853-4299-898f-6432983b6f3a")]
    public partial class GdiInterop : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.GdiInterop"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public GdiInterop(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.GdiInterop"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.GdiInterop(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.GdiInterop(nativePointer);
        }


        /// <summary>	
        /// <p> Creates a font object that matches the properties specified by the <strong><see cref="SharpDX.DirectWrite.GdiInterop.LogFont"/></strong> structure. </p>	
        /// </summary>	
        /// <param name="logFont"><dd>  <p>A structure containing a GDI-compatible font description.</p> </dd></param>	
        /// <param name="font"><dd>  <p>When this method returns, contains an address of a  reference to a newly created <strong><see cref="SharpDX.DirectWrite.Font"/></strong> object if successful; otherwise, <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteGdiInterop::CreateFontFromLOGFONT']/*"/>	
        /// <msdn-id>dd371187</msdn-id>	
        /// <unmanaged>HRESULT IDWriteGdiInterop::CreateFontFromLOGFONT([In] const void* logFont,[Out] IDWriteFont** font)</unmanaged>	
        /// <unmanaged-short>IDWriteGdiInterop::CreateFontFromLOGFONT</unmanaged-short>	
        internal void CreateFontFromLOGFONT(System.IntPtr logFont, out SharpDX.DirectWrite.Font font)
        {
            unsafe
            {
                IntPtr font_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)logFont, &font_, ((void**)(*(void**)_nativePointer))[3]);
                font = (font_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.Font(font_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Initializes a <strong><see cref="SharpDX.DirectWrite.GdiInterop.LogFont"/></strong> structure based on the GDI-compatible properties of the specified font. </p>	
        /// </summary>	
        /// <param name="font"><dd>  <p>An <strong><see cref="SharpDX.DirectWrite.Font"/></strong> object to be converted into a GDI-compatible <strong><see cref="SharpDX.DirectWrite.GdiInterop.LogFont"/></strong> structure.</p> </dd></param>	
        /// <param name="logFont"><dd>  <p>When this method returns, contains a structure that receives a GDI-compatible font description.</p> </dd></param>	
        /// <param name="isSystemFont"><dd>  <p>When this method returns, contains <strong>TRUE</strong> if the specified font object is part of the system font collection; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The conversion to a  <strong><see cref="SharpDX.DirectWrite.GdiInterop.LogFont"/></strong> by using <strong>ConvertFontToLOGFONT</strong> operates at the logical font level and does not guarantee that it will map to a specific physical font. It is not guaranteed that GDI will select the same physical font for displaying  text formatted by a <strong><see cref="SharpDX.DirectWrite.GdiInterop.LogFont"/></strong> as the <strong><see cref="SharpDX.DirectWrite.Font"/></strong> object that was converted.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteGdiInterop::ConvertFontToLOGFONT']/*"/>	
        /// <msdn-id>dd371177</msdn-id>	
        /// <unmanaged>HRESULT IDWriteGdiInterop::ConvertFontToLOGFONT([In] IDWriteFont* font,[In] void* logFont,[Out] BOOL* isSystemFont)</unmanaged>	
        /// <unmanaged-short>IDWriteGdiInterop::ConvertFontToLOGFONT</unmanaged-short>	
        internal void ConvertFontToLOGFONT(SharpDX.DirectWrite.Font font, System.IntPtr logFont, out SharpDX.Mathematics.Interop.RawBool isSystemFont)
        {
            unsafe
            {
                isSystemFont = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* isSystemFont_ = &isSystemFont)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((font == null) ? IntPtr.Zero : font.NativePointer), (void*)logFont, isSystemFont_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Initializes a <see cref="SharpDX.DirectWrite.GdiInterop.LogFont"/> structure based on the GDI-compatible properties of the specified font. </p>	
        /// </summary>	
        /// <param name="font"><dd>  <p>An <strong><see cref="SharpDX.DirectWrite.FontFace"/></strong> object to be converted into a GDI-compatible <see cref="SharpDX.DirectWrite.GdiInterop.LogFont"/> structure.</p> </dd></param>	
        /// <param name="logFont"><dd>  <p>When this method returns, contains a reference to a structure that receives a GDI-compatible font description.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The conversion to a  <see cref="SharpDX.DirectWrite.GdiInterop.LogFont"/> by using <strong>ConvertFontFaceToLOGFONT</strong> operates at the logical font level and does not guarantee that it will map to a specific physical font. It is not guaranteed that GDI will select the same physical font for displaying  text formatted by a <see cref="SharpDX.DirectWrite.GdiInterop.LogFont"/> as the <strong><see cref="SharpDX.DirectWrite.Font"/></strong> object that was converted.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteGdiInterop::ConvertFontFaceToLOGFONT']/*"/>	
        /// <msdn-id>dd371175</msdn-id>	
        /// <unmanaged>HRESULT IDWriteGdiInterop::ConvertFontFaceToLOGFONT([In] IDWriteFontFace* font,[In] void* logFont)</unmanaged>	
        /// <unmanaged-short>IDWriteGdiInterop::ConvertFontFaceToLOGFONT</unmanaged-short>	
        internal void ConvertFontFaceToLOGFONT(SharpDX.DirectWrite.FontFace font, System.IntPtr logFont)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((font == null) ? IntPtr.Zero : font.NativePointer), (void*)logFont, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Creates an <strong><see cref="SharpDX.DirectWrite.FontFace"/></strong> object that corresponds to the currently selected <strong>HFONT</strong> of the specified <strong><see cref="System.IntPtr"/></strong>. </p>	
        /// </summary>	
        /// <param name="hdc"><dd>  <p>A handle to a device context into which a font has been selected. It is assumed that the client has already performed font mapping and that the font selected into the device context is the actual font to be used  for rendering glyphs.</p> </dd></param>	
        /// <returns><dd>  <p>Contains an address of a reference to  the newly created font face object, or <strong><c>null</c></strong> in case of failure. The font face returned is guaranteed to reference the same physical typeface that would be used for drawing glyphs (but not necessarily characters) using ExtTextOut.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This function is intended for scenarios in which an application wants to use GDI and Uniscribe 1.x for text layout and shaping, but  DirectWrite for final rendering. This function assumes the client is performing text output using glyph indexes.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteGdiInterop::CreateFontFaceFromHdc']/*"/>	
        /// <msdn-id>dd371185</msdn-id>	
        /// <unmanaged>HRESULT IDWriteGdiInterop::CreateFontFaceFromHdc([In] HDC hdc,[Out] IDWriteFontFace** fontFace)</unmanaged>	
        /// <unmanaged-short>IDWriteGdiInterop::CreateFontFaceFromHdc</unmanaged-short>	
        public SharpDX.DirectWrite.FontFace CreateFontFaceFromHdc(System.IntPtr hdc)
        {
            unsafe
            {
                SharpDX.DirectWrite.FontFace fontFace;
                IntPtr fontFace_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)hdc, &fontFace_, ((void**)(*(void**)_nativePointer))[6]);
                fontFace = (fontFace_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.FontFace(fontFace_);
                __result__.CheckError();
                return fontFace;
            }
        }

        /// <summary>	
        /// <p> Creates an object that encapsulates a bitmap and memory DC (device context) which can be used for rendering glyphs. </p>	
        /// </summary>	
        /// <param name="hdc"><dd>  <p>A handle to the optional device context used to create a compatible memory DC (device context).</p> </dd></param>	
        /// <param name="width"><dd>  <p>The width of the bitmap render target.</p> </dd></param>	
        /// <param name="height"><dd>  <p>The height of the bitmap render target.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains an address of a reference to the newly created <strong><see cref="SharpDX.DirectWrite.BitmapRenderTarget"/></strong> object.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteGdiInterop::CreateBitmapRenderTarget']/*"/>	
        /// <msdn-id>dd371182</msdn-id>	
        /// <unmanaged>HRESULT IDWriteGdiInterop::CreateBitmapRenderTarget([In, Optional] HDC hdc,[In] unsigned int width,[In] unsigned int height,[Out] IDWriteBitmapRenderTarget** renderTarget)</unmanaged>	
        /// <unmanaged-short>IDWriteGdiInterop::CreateBitmapRenderTarget</unmanaged-short>	
        public SharpDX.DirectWrite.BitmapRenderTarget CreateBitmapRenderTarget(System.IntPtr hdc, int width, int height)
        {
            unsafe
            {
                SharpDX.DirectWrite.BitmapRenderTarget renderTarget;
                IntPtr renderTarget_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)hdc, width, height, &renderTarget_, ((void**)(*(void**)_nativePointer))[7]);
                renderTarget = (renderTarget_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.BitmapRenderTarget(renderTarget_);
                __result__.CheckError();
                return renderTarget;
            }
        }
    }
    /// <summary>	
    /// <p> Contains low-level information used to render a glyph run.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The alpha texture can be a   bi-level alpha  texture or a ClearType alpha texture.  </p><p>A bi-level alpha texture contains one byte per pixel, therefore the size of the buffer for a bi-level texture will be the area of the texture bounds, in bytes. Each byte in a bi-level alpha texture created by <strong>CreateAlphaTexture</strong> is either set to DWRITE_ALPHA_MAX (that is, 255) or zero.</p><p>A ClearType alpha texture contains three bytes per pixel, therefore the size of the buffer for a ClearType alpha texture is three times the area of the texture bounds, in bytes.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteGlyphRunAnalysis']/*"/>	
    /// <msdn-id>dd371188</msdn-id>	
    /// <unmanaged>IDWriteGlyphRunAnalysis</unmanaged>	
    /// <unmanaged-short>IDWriteGlyphRunAnalysis</unmanaged-short>	
    [Guid("7d97dbf7-e085-42d4-81e3-6a883bded118")]
    public partial class GlyphRunAnalysis : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.GlyphRunAnalysis"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public GlyphRunAnalysis(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.GlyphRunAnalysis"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.GlyphRunAnalysis(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.GlyphRunAnalysis(nativePointer);
        }


        /// <summary>	
        /// <p> Gets the bounding rectangle of the physical pixels affected by the glyph run. </p>	
        /// </summary>	
        /// <param name="textureType"><dd>  <p>Specifies the type of texture requested. If a bi-level texture is requested, the bounding rectangle includes only bi-level glyphs. Otherwise, the bounding rectangle includes only antialiased glyphs.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains the bounding rectangle of the physical pixels affected by the glyph run, or an empty rectangle if there are no glyphs of the specified texture type.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteGlyphRunAnalysis::GetAlphaTextureBounds']/*"/>	
        /// <msdn-id>dd371215</msdn-id>	
        /// <unmanaged>HRESULT IDWriteGlyphRunAnalysis::GetAlphaTextureBounds([In] DWRITE_TEXTURE_TYPE textureType,[Out] RECT* textureBounds)</unmanaged>	
        /// <unmanaged-short>IDWriteGlyphRunAnalysis::GetAlphaTextureBounds</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawRectangle GetAlphaTextureBounds(SharpDX.DirectWrite.TextureType textureType)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawRectangle textureBounds;
                textureBounds = new SharpDX.Mathematics.Interop.RawRectangle();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)textureType), &textureBounds, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
                return textureBounds;
            }
        }

        /// <summary>	
        /// <p> Creates an alpha texture of the specified type for glyphs within a specified bounding rectangle. </p>	
        /// </summary>	
        /// <param name="textureType"><dd>  <p>A value that specifies the type of texture requested. This can be <strong>DWRITE_TEXTURE_BILEVEL_1x1</strong> or <strong><see cref="SharpDX.DirectWrite.TextureType.Cleartype3x1"/></strong>. If a bi-level texture is requested, the texture contains only bi-level glyphs. Otherwise, the texture contains only antialiased glyphs.</p> </dd></param>	
        /// <param name="textureBounds"><dd>  <p>The bounding rectangle of the texture, which can be different than the bounding rectangle returned by <strong>GetAlphaTextureBounds</strong>.</p> </dd></param>	
        /// <param name="alphaValues"><dd>  <p>When this method returns, contains  the array of alpha values from the texture. The buffer allocated for this array must be at least the size of <em>bufferSize</em>.</p> </dd></param>	
        /// <param name="bufferSize"><dd>  <p>The size of the <em>alphaValues</em> array, in bytes. The minimum size depends on the dimensions of the rectangle and the type of texture requested.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteGlyphRunAnalysis::CreateAlphaTexture']/*"/>	
        /// <msdn-id>dd371189</msdn-id>	
        /// <unmanaged>HRESULT IDWriteGlyphRunAnalysis::CreateAlphaTexture([In] DWRITE_TEXTURE_TYPE textureType,[In] const RECT* textureBounds,[Out, Buffer] unsigned char* alphaValues,[In] unsigned int bufferSize)</unmanaged>	
        /// <unmanaged-short>IDWriteGlyphRunAnalysis::CreateAlphaTexture</unmanaged-short>	
        public void CreateAlphaTexture(SharpDX.DirectWrite.TextureType textureType, SharpDX.Mathematics.Interop.RawRectangle textureBounds, byte[] alphaValues, int bufferSize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* alphaValues_ = alphaValues)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)textureType), &textureBounds, alphaValues_, bufferSize, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets alpha blending properties required for ClearType blending. </p>	
        /// </summary>	
        /// <param name="renderingParams"><dd>  <p>An object that specifies the ClearType level and enhanced contrast, gamma, pixel geometry, and rendering mode. In most cases, the values returned by the output parameters of this method are based on the properties of this object, unless a GDI-compatible rendering mode was specified.</p> </dd></param>	
        /// <param name="blendGamma"><dd>  <p>When this method returns, contains  the gamma value to use for gamma correction.</p> </dd></param>	
        /// <param name="blendEnhancedContrast"><dd>  <p>When this method returns, contains the enhanced contrast value to be used for blending.</p> </dd></param>	
        /// <param name="blendClearTypeLevel"><dd>  <p>When this method returns, contains  the ClearType level used in the alpha blending.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteGlyphRunAnalysis::GetAlphaBlendParams']/*"/>	
        /// <msdn-id>dd371190</msdn-id>	
        /// <unmanaged>HRESULT IDWriteGlyphRunAnalysis::GetAlphaBlendParams([In] IDWriteRenderingParams* renderingParams,[Out] float* blendGamma,[Out] float* blendEnhancedContrast,[Out] float* blendClearTypeLevel)</unmanaged>	
        /// <unmanaged-short>IDWriteGlyphRunAnalysis::GetAlphaBlendParams</unmanaged-short>	
        public void GetAlphaBlendParams(SharpDX.DirectWrite.RenderingParams renderingParams, out float blendGamma, out float blendEnhancedContrast, out float blendClearTypeLevel)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* blendGamma_ = &blendGamma)
                    fixed (void* blendEnhancedContrast_ = &blendEnhancedContrast)
                        fixed (void* blendClearTypeLevel_ = &blendClearTypeLevel)
                            __result__ =
                            SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((renderingParams == null) ? IntPtr.Zero : renderingParams.NativePointer), blendGamma_, blendEnhancedContrast_, blendClearTypeLevel_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Wraps an application-defined inline graphic, allowing DWrite to query metrics as if the graphic were a glyph inline with the text.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteInlineObject']/*"/>	
    /// <msdn-id>dd371221</msdn-id>	
    /// <unmanaged>IDWriteInlineObject</unmanaged>	
    /// <unmanaged-short>IDWriteInlineObject</unmanaged-short>	
    [Guid("8339FDE3-106F-47ab-8373-1C6295EB10B3")]
    public partial interface InlineObject : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p> The application implemented rendering callback (<strong><see cref="SharpDX.DirectWrite.TextRenderer.DrawInlineObject_"/></strong>) can use this to draw the inline object without needing to cast or query the object type. The text layout does not call this method directly. </p>	
        /// </summary>	
        /// <param name="clientDrawingContext">No documentation.</param>	
        /// <param name="renderer">No documentation.</param>	
        /// <param name="originX">No documentation.</param>	
        /// <param name="originY">No documentation.</param>	
        /// <param name="isSideways">No documentation.</param>	
        /// <param name="isRightToLeft">No documentation.</param>	
        /// <param name="clientDrawingEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteInlineObject::Draw']/*"/>	
        /// <msdn-id>dd371225</msdn-id>	
        /// <unmanaged>HRESULT IDWriteInlineObject::Draw([In, Optional] void* clientDrawingContext,[In] IDWriteTextRenderer* renderer,[In] float originX,[In] float originY,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In, Optional] void* clientDrawingEffect)</unmanaged>	
        /// <unmanaged-short>IDWriteInlineObject::Draw</unmanaged-short>	
        /* internal void Draw_(System.IntPtr clientDrawingContext, System.IntPtr renderer, float originX, float originY, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.Mathematics.Interop.RawBool isRightToLeft, System.IntPtr clientDrawingEffect) */

        /// <summary>	
        /// <p> <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> calls this callback function to get the measurement of the inline object. </p>	
        /// </summary>	
        /// <param name="metrics">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteInlineObject::GetMetrics']/*"/>	
        /// <msdn-id>dd371232</msdn-id>	
        /// <unmanaged>HRESULT IDWriteInlineObject::GetMetrics([Out] DWRITE_INLINE_OBJECT_METRICS* metrics)</unmanaged>	
        /// <unmanaged-short>IDWriteInlineObject::GetMetrics</unmanaged-short>	
        /* public void GetMetrics(out SharpDX.DirectWrite.InlineObjectMetrics metrics) */

        /// <summary>	
        /// <p> <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> calls this callback function to get the visible extents (in DIPs) of the inline object. In the case of a simple bitmap, with no padding and no overhang, all the overhangs will simply be zeroes.</p><p>The overhangs should be returned relative to the reported size of the object (see <strong><see cref="SharpDX.DirectWrite.InlineObjectMetrics"/></strong>), and should not be baseline adjusted.</p>	
        /// </summary>	
        /// <param name="overhangs">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteInlineObject::GetOverhangMetrics']/*"/>	
        /// <msdn-id>dd371235</msdn-id>	
        /// <unmanaged>HRESULT IDWriteInlineObject::GetOverhangMetrics([Out] DWRITE_OVERHANG_METRICS* overhangs)</unmanaged>	
        /// <unmanaged-short>IDWriteInlineObject::GetOverhangMetrics</unmanaged-short>	
        /* public void GetOverhangMetrics(out SharpDX.DirectWrite.OverhangMetrics overhangs) */

        /// <summary>	
        /// <p> Layout uses this to determine the line-breaking behavior of the inline object among the text. </p>	
        /// </summary>	
        /// <param name="breakConditionBefore"><dd>  <p>When this method returns, contains a value which indicates the line-breaking condition between the object and the content immediately preceding it.</p> </dd></param>	
        /// <param name="breakConditionAfter"><dd>  <p>When this method returns, contains a value which indicates the line-breaking condition between the object and the content immediately following it.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteInlineObject::GetBreakConditions']/*"/>	
        /// <msdn-id>dd371229</msdn-id>	
        /// <unmanaged>HRESULT IDWriteInlineObject::GetBreakConditions([Out] DWRITE_BREAK_CONDITION* breakConditionBefore,[Out] DWRITE_BREAK_CONDITION* breakConditionAfter)</unmanaged>	
        /// <unmanaged-short>IDWriteInlineObject::GetBreakConditions</unmanaged-short>	
        /* public void GetBreakConditions(out SharpDX.DirectWrite.BreakCondition breakConditionBefore, out SharpDX.DirectWrite.BreakCondition breakConditionAfter) */
    }
    /// <summary>	
    /// <p> Wraps an application-defined inline graphic, allowing DWrite to query metrics as if the graphic were a glyph inline with the text.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteInlineObject']/*"/>	
    /// <msdn-id>dd371221</msdn-id>	
    /// <unmanaged>IDWriteInlineObject</unmanaged>	
    /// <unmanaged-short>IDWriteInlineObject</unmanaged-short>	
    [Guid("8339FDE3-106F-47ab-8373-1C6295EB10B3")]
    public partial class InlineObjectNative : SharpDX.ComObjectCallback, SharpDX.DirectWrite.InlineObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.InlineObjectNative"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public InlineObjectNative(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.InlineObjectNative"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.InlineObjectNative(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.InlineObjectNative(nativePointer);
        }


        /// <summary>	
        /// <p> The application implemented rendering callback (<strong><see cref="SharpDX.DirectWrite.TextRenderer.DrawInlineObject_"/></strong>) can use this to draw the inline object without needing to cast or query the object type. The text layout does not call this method directly. </p>	
        /// </summary>	
        /// <param name="clientDrawingContext">No documentation.</param>	
        /// <param name="renderer">No documentation.</param>	
        /// <param name="originX">No documentation.</param>	
        /// <param name="originY">No documentation.</param>	
        /// <param name="isSideways">No documentation.</param>	
        /// <param name="isRightToLeft">No documentation.</param>	
        /// <param name="clientDrawingEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteInlineObject::Draw']/*"/>	
        /// <msdn-id>dd371225</msdn-id>	
        /// <unmanaged>HRESULT IDWriteInlineObject::Draw([In, Optional] void* clientDrawingContext,[In] IDWriteTextRenderer* renderer,[In] float originX,[In] float originY,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In, Optional] void* clientDrawingEffect)</unmanaged>	
        /// <unmanaged-short>IDWriteInlineObject::Draw</unmanaged-short>	
        internal void Draw__(System.IntPtr clientDrawingContext, System.IntPtr renderer, float originX, float originY, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.Mathematics.Interop.RawBool isRightToLeft, System.IntPtr clientDrawingEffect)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint154(_nativePointer, (void*)clientDrawingContext, (void*)renderer, originX, originY, isSideways, isRightToLeft, (void*)clientDrawingEffect, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> calls this callback function to get the measurement of the inline object. </p>	
        /// </summary>	
        /// <param name="metrics">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteInlineObject::GetMetrics']/*"/>	
        /// <msdn-id>dd371232</msdn-id>	
        /// <unmanaged>HRESULT IDWriteInlineObject::GetMetrics([Out] DWRITE_INLINE_OBJECT_METRICS* metrics)</unmanaged>	
        /// <unmanaged-short>IDWriteInlineObject::GetMetrics</unmanaged-short>	
        internal void GetMetrics_(out SharpDX.DirectWrite.InlineObjectMetrics metrics)
        {
            unsafe
            {
                metrics = new SharpDX.DirectWrite.InlineObjectMetrics();
                SharpDX.Result __result__;
                fixed (void* metrics_ = &metrics)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, metrics_, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> calls this callback function to get the visible extents (in DIPs) of the inline object. In the case of a simple bitmap, with no padding and no overhang, all the overhangs will simply be zeroes.</p><p>The overhangs should be returned relative to the reported size of the object (see <strong><see cref="SharpDX.DirectWrite.InlineObjectMetrics"/></strong>), and should not be baseline adjusted.</p>	
        /// </summary>	
        /// <param name="overhangs">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteInlineObject::GetOverhangMetrics']/*"/>	
        /// <msdn-id>dd371235</msdn-id>	
        /// <unmanaged>HRESULT IDWriteInlineObject::GetOverhangMetrics([Out] DWRITE_OVERHANG_METRICS* overhangs)</unmanaged>	
        /// <unmanaged-short>IDWriteInlineObject::GetOverhangMetrics</unmanaged-short>	
        internal void GetOverhangMetrics_(out SharpDX.DirectWrite.OverhangMetrics overhangs)
        {
            unsafe
            {
                overhangs = new SharpDX.DirectWrite.OverhangMetrics();
                SharpDX.Result __result__;
                fixed (void* overhangs_ = &overhangs)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, overhangs_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Layout uses this to determine the line-breaking behavior of the inline object among the text. </p>	
        /// </summary>	
        /// <param name="breakConditionBefore"><dd>  <p>When this method returns, contains a value which indicates the line-breaking condition between the object and the content immediately preceding it.</p> </dd></param>	
        /// <param name="breakConditionAfter"><dd>  <p>When this method returns, contains a value which indicates the line-breaking condition between the object and the content immediately following it.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteInlineObject::GetBreakConditions']/*"/>	
        /// <msdn-id>dd371229</msdn-id>	
        /// <unmanaged>HRESULT IDWriteInlineObject::GetBreakConditions([Out] DWRITE_BREAK_CONDITION* breakConditionBefore,[Out] DWRITE_BREAK_CONDITION* breakConditionAfter)</unmanaged>	
        /// <unmanaged-short>IDWriteInlineObject::GetBreakConditions</unmanaged-short>	
        internal void GetBreakConditions_(out SharpDX.DirectWrite.BreakCondition breakConditionBefore, out SharpDX.DirectWrite.BreakCondition breakConditionAfter)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* breakConditionBefore_ = &breakConditionBefore)
                    fixed (void* breakConditionAfter_ = &breakConditionAfter)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, breakConditionBefore_, breakConditionAfter_, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A built-in implementation of the <strong><see cref="SharpDX.DirectWrite.FontFileLoader"/></strong> interface, that operates on local font files	
    /// and exposes local font file information from the font file reference key. Font file references created using <strong>CreateFontFileReference</strong> use this font file loader.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteLocalFontFileLoader']/*"/>	
    /// <msdn-id>dd371238</msdn-id>	
    /// <unmanaged>IDWriteLocalFontFileLoader</unmanaged>	
    /// <unmanaged-short>IDWriteLocalFontFileLoader</unmanaged-short>	
    [Guid("b2d9f3ec-c9fe-4a11-a2ec-d86208f7c0a2")]
    public partial class LocalFontFileLoader : SharpDX.DirectWrite.FontFileLoaderNative
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.LocalFontFileLoader"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public LocalFontFileLoader(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.LocalFontFileLoader"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.LocalFontFileLoader(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.LocalFontFileLoader(nativePointer);
        }


        /// <summary>	
        /// <p>Obtains the length of the absolute file path from the font file reference key.</p>	
        /// </summary>	
        /// <param name="fontFileReferenceKey"><dd>  <p>Font file reference key that uniquely identifies the local font file within the scope of the font loader being used.</p> </dd></param>	
        /// <param name="fontFileReferenceKeySize"><dd>  <p>Size of font file reference key in bytes.</p> </dd></param>	
        /// <returns><dd>  <p>Length of the file path string, not including the terminated <strong><c>null</c></strong> character.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteLocalFontFileLoader::GetFilePathLengthFromKey']/*"/>	
        /// <msdn-id>dd371244</msdn-id>	
        /// <unmanaged>HRESULT IDWriteLocalFontFileLoader::GetFilePathLengthFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out] unsigned int* filePathLength)</unmanaged>	
        /// <unmanaged-short>IDWriteLocalFontFileLoader::GetFilePathLengthFromKey</unmanaged-short>	
        internal int GetFilePathLengthFromKey(System.IntPtr fontFileReferenceKey, int fontFileReferenceKeySize)
        {
            unsafe
            {
                int filePathLength;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)fontFileReferenceKey, fontFileReferenceKeySize, &filePathLength, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
                return filePathLength;
            }
        }

        /// <summary>	
        /// <p>Obtains the absolute font file path from the font file reference key.</p>	
        /// </summary>	
        /// <param name="fontFileReferenceKey"><dd>  <p>The font file reference key that uniquely identifies the local font file within the scope of the font loader being used.</p> </dd></param>	
        /// <param name="fontFileReferenceKeySize"><dd>  <p>The size of font file reference key in bytes.</p> </dd></param>	
        /// <param name="filePath"><dd>  <p>The character array that receives the local file path.</p> </dd></param>	
        /// <param name="filePathSize"><dd>  <p>The length of the file path character array.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteLocalFontFileLoader::GetFilePathFromKey']/*"/>	
        /// <msdn-id>dd371241</msdn-id>	
        /// <unmanaged>HRESULT IDWriteLocalFontFileLoader::GetFilePathFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out, Buffer] wchar_t* filePath,[In] unsigned int filePathSize)</unmanaged>	
        /// <unmanaged-short>IDWriteLocalFontFileLoader::GetFilePathFromKey</unmanaged-short>	
        internal void GetFilePathFromKey(System.IntPtr fontFileReferenceKey, int fontFileReferenceKeySize, System.IntPtr filePath, int filePathSize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)fontFileReferenceKey, fontFileReferenceKeySize, (void*)filePath, filePathSize, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Obtains the last write time of the file from the font file reference key.</p>	
        /// </summary>	
        /// <param name="fontFileReferenceKey"><dd>  <p>The font file reference key that uniquely identifies the local font file within the scope of the font loader being used.</p> </dd></param>	
        /// <param name="fontFileReferenceKeySize"><dd>  <p>The size of font file reference key in bytes.</p> </dd></param>	
        /// <returns><dd>  <p>The time of the last font file modification.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteLocalFontFileLoader::GetLastWriteTimeFromKey']/*"/>	
        /// <msdn-id>dd371247</msdn-id>	
        /// <unmanaged>HRESULT IDWriteLocalFontFileLoader::GetLastWriteTimeFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out] FILETIME* lastWriteTime)</unmanaged>	
        /// <unmanaged-short>IDWriteLocalFontFileLoader::GetLastWriteTimeFromKey</unmanaged-short>	
        internal long GetLastWriteTimeFromKey(System.IntPtr fontFileReferenceKey, int fontFileReferenceKeySize)
        {
            unsafe
            {
                long lastWriteTime;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)fontFileReferenceKey, fontFileReferenceKeySize, &lastWriteTime, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
                return lastWriteTime;
            }
        }
    }
    /// <summary>	
    /// <p> Represents a collection of strings indexed by locale name.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The set of strings represented by an <strong><see cref="SharpDX.DirectWrite.LocalizedStrings"/></strong> are indexed by a zero based <em>UINT32</em> number that maps to a locale.  The numeric index for a specific locale is retreived by using the <strong>FindLocaleName</strong> method.</p><p>A common use for the <strong><see cref="SharpDX.DirectWrite.LocalizedStrings"/></strong> interface is to hold a list of localized font family names created by using the <strong><see cref="SharpDX.DirectWrite.FontFamily.GetFamilyNames"/></strong> method.  The following example shows how to get the family name for the "en-us" locale.</p><pre><see cref="SharpDX.DirectWrite.LocalizedStrings"/>* pFamilyNames = <c>null</c>; // Get a list of localized strings for the family name.	
    /// if (SUCCEEDED(hr))	
    /// { hr = pFontFamily-&gt;GetFamilyNames(&amp;pFamilyNames);	
    /// } UINT32 index = 0;	
    /// <see cref="SharpDX.Mathematics.Interop.RawBool"/> exists = false; wchar_t localeName[LOCALE_NAME_MAX_LENGTH]; if (SUCCEEDED(hr))	
    /// { // Get the default locale for this user. int defaultLocaleSuccess = GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH); // If the default locale is returned, find that locale name, otherwise use "en-us". if (defaultLocaleSuccess) { hr = pFamilyNames-&gt;FindLocaleName(localeName, &amp;index, &amp;exists); } if (SUCCEEDED(hr) &amp;&amp; !exists) // if the above find did not find a match, retry with US English { hr = pFamilyNames-&gt;FindLocaleName(L"en-us", &amp;index, &amp;exists); }	
    /// } // If the specified locale doesn't exist, select the first on the list.	
    /// if (!exists) index = 0; UINT32 length = 0; // Get the string length.	
    /// if (SUCCEEDED(hr))	
    /// { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);	
    /// } // Allocate a string big enough to hold the name.	
    /// wchar_t* name = new (std::nothrow) wchar_t[length+1];	
    /// if (name == <c>null</c>)	
    /// { hr = E_OUTOFMEMORY;	
    /// } // Get the family name.	
    /// if (SUCCEEDED(hr))	
    /// { hr = pFamilyNames-&gt;GetString(index, name, length+1);	
    /// }	
    /// </pre>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteLocalizedStrings']/*"/>	
    /// <msdn-id>dd371250</msdn-id>	
    /// <unmanaged>IDWriteLocalizedStrings</unmanaged>	
    /// <unmanaged-short>IDWriteLocalizedStrings</unmanaged-short>	
    [Guid("08256209-099a-4b34-b86d-c22b110e7771")]
    public partial class LocalizedStrings : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.LocalizedStrings"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public LocalizedStrings(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.LocalizedStrings"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.LocalizedStrings(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.LocalizedStrings(nativePointer);
        }


        /// <summary>	
        /// <p> Gets the number of language/string pairs. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteLocalizedStrings::GetCount']/*"/>	
        /// <msdn-id>dd371256</msdn-id>	
        /// <unmanaged>GetCount</unmanaged>	
        /// <unmanaged-short>GetCount</unmanaged-short>	
        /// <unmanaged>unsigned int IDWriteLocalizedStrings::GetCount()</unmanaged>
        public int Count
        {
            get { return GetCount(); }
        }

        /// <summary>	
        /// <p> Gets the number of language/string pairs. </p>	
        /// </summary>	
        /// <returns><p>The number of language/string pairs.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteLocalizedStrings::GetCount']/*"/>	
        /// <msdn-id>dd371256</msdn-id>	
        /// <unmanaged>unsigned int IDWriteLocalizedStrings::GetCount()</unmanaged>	
        /// <unmanaged-short>IDWriteLocalizedStrings::GetCount</unmanaged-short>	
        internal int GetCount()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the zero-based index of the locale name/string pair with the specified locale name. </p>	
        /// </summary>	
        /// <param name="localeName"><dd>  <p>A null-terminated array of characters containing the locale name to look for.</p> </dd></param>	
        /// <param name="index"><dd>  <p>The zero-based index of the locale name/string pair. This method initializes <em>index</em> to <strong>UINT_MAX</strong>.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains <strong>TRUE</strong> if the locale name exists; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>. This method initializes <em>exists</em> to <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></returns>	
        /// <remarks>	
        /// <p>Note that if the locale name does not exist, the return value is a success and the <em>exists</em> parameter is <strong><see cref="SharpDX.Result.False"/></strong>. If you are getting the font family name for a font and the specified locale name does not exist, one option is to set the index to 0 as shown below.  There is always at least one locale for a font family.</p><pre>UINT32 index = 0;	
        /// <see cref="SharpDX.Mathematics.Interop.RawBool"/> exists = false; wchar_t localeName[LOCALE_NAME_MAX_LENGTH]; if (SUCCEEDED(hr))	
        /// { // Get the default locale for this user. int defaultLocaleSuccess = GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH); // If the default locale is returned, find that locale name, otherwise use "en-us". if (defaultLocaleSuccess) { hr = pFamilyNames-&gt;FindLocaleName(localeName, &amp;index, &amp;exists); } if (SUCCEEDED(hr) &amp;&amp; !exists) // if the above find did not find a match, retry with US English { hr = pFamilyNames-&gt;FindLocaleName(L"en-us", &amp;index, &amp;exists); }	
        /// } // If the specified locale doesn't exist, select the first on the list.	
        /// if (!exists) index = 0;	
        /// </pre>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteLocalizedStrings::FindLocaleName']/*"/>	
        /// <msdn-id>dd371254</msdn-id>	
        /// <unmanaged>HRESULT IDWriteLocalizedStrings::FindLocaleName([In] const wchar_t* localeName,[Out] unsigned int* index,[Out] BOOL* exists)</unmanaged>	
        /// <unmanaged-short>IDWriteLocalizedStrings::FindLocaleName</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool FindLocaleName(string localeName, out int index)
        {
            unsafe
            {
                IntPtr localeName_ = Utilities.StringToHGlobalUni(localeName);
                SharpDX.Mathematics.Interop.RawBool exists;
                exists = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* index_ = &index)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)localeName_, index_, &exists, ((void**)(*(void**)_nativePointer))[4]);
                Marshal.FreeHGlobal(localeName_);
                __result__.CheckError();
                return exists;
            }
        }

        /// <summary>	
        /// <p> Gets the length in characters (not including the null terminator) of the locale name with the specified index. </p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Zero-based index of the locale name to be retrieved.</p> </dd></param>	
        /// <param name="length"><dd>  <p>When this method returns, contains the length in characters of the locale name, not including the null terminator.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteLocalizedStrings::GetLocaleNameLength']/*"/>	
        /// <msdn-id>dd371262</msdn-id>	
        /// <unmanaged>HRESULT IDWriteLocalizedStrings::GetLocaleNameLength([In] unsigned int index,[Out] unsigned int* length)</unmanaged>	
        /// <unmanaged-short>IDWriteLocalizedStrings::GetLocaleNameLength</unmanaged-short>	
        internal void GetLocaleNameLength(int index, out int length)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* length_ = &length)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, index, length_, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Copies the locale name with the specified index to the specified array. </p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Zero-based index of the locale name to be retrieved.</p> </dd></param>	
        /// <param name="localeName"><dd>  <p>When this method returns, contains a character array, which is null-terminated, that receives the locale name from the language/string pair.  The buffer allocated for this array must be at least the size of <em>size</em>, in element count.</p> </dd></param>	
        /// <param name="size"><dd>  <p>The size of the array in characters. The size must include space for the terminating null character.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteLocalizedStrings::GetLocaleName']/*"/>	
        /// <msdn-id>dd371259</msdn-id>	
        /// <unmanaged>HRESULT IDWriteLocalizedStrings::GetLocaleName([In] unsigned int index,[Out, Buffer] wchar_t* localeName,[In] unsigned int size)</unmanaged>	
        /// <unmanaged-short>IDWriteLocalizedStrings::GetLocaleName</unmanaged-short>	
        internal void GetLocaleName(int index, System.IntPtr localeName, int size)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, index, (void*)localeName, size, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the length in characters (not including the null terminator) of the string with the specified index. </p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>A zero-based index of the language/string pair.</p> </dd></param>	
        /// <param name="length"><dd>  <p>The length in characters of the string, not including the null terminator, from the language/string pair.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Use <strong>GetStringLength</strong> to get the string length before calling the <strong><see cref="SharpDX.DirectWrite.LocalizedStrings.GetString"/></strong> method, as shown in the following code.</p><pre>UINT32 length = 0; // Get the string length.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);	
        /// } // Allocate a string big enough to hold the name.	
        /// wchar_t* name = new (std::nothrow) wchar_t[length+1];	
        /// if (name == <c>null</c>)	
        /// { hr = E_OUTOFMEMORY;	
        /// } // Get the family name.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetString(index, name, length+1);	
        /// }	
        /// </pre>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteLocalizedStrings::GetStringLength']/*"/>	
        /// <msdn-id>dd371269</msdn-id>	
        /// <unmanaged>HRESULT IDWriteLocalizedStrings::GetStringLength([In] unsigned int index,[Out] unsigned int* length)</unmanaged>	
        /// <unmanaged-short>IDWriteLocalizedStrings::GetStringLength</unmanaged-short>	
        internal void GetStringLength(int index, out int length)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* length_ = &length)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, index, length_, ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Copies the string with the specified index to the specified array. </p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The zero-based index of the language/string pair to be examined.</p> </dd></param>	
        /// <param name="stringBuffer"><dd>  <p>The null terminated array of characters that receives the string from the language/string pair.  The buffer allocated for this array should be at least the size of <em>size</em>. <strong>GetStringLength</strong> can be used to get the size of the array before using this method.</p> </dd></param>	
        /// <param name="size"><dd>  <p>The size of the array in characters. The size must include space for the terminating null character. <strong>GetStringLength</strong> can be used to get the size of the array before using this method.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The string returned must be allocated by the caller.  You can get the size of the string by using the <strong>GetStringLength</strong> method prior to calling <strong>GetString</strong>, as shown in the following example.</p><pre>UINT32 length = 0; // Get the string length.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);	
        /// } // Allocate a string big enough to hold the name.	
        /// wchar_t* name = new (std::nothrow) wchar_t[length+1];	
        /// if (name == <c>null</c>)	
        /// { hr = E_OUTOFMEMORY;	
        /// } // Get the family name.	
        /// if (SUCCEEDED(hr))	
        /// { hr = pFamilyNames-&gt;GetString(index, name, length+1);	
        /// }	
        /// </pre>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteLocalizedStrings::GetString']/*"/>	
        /// <msdn-id>dd371267</msdn-id>	
        /// <unmanaged>HRESULT IDWriteLocalizedStrings::GetString([In] unsigned int index,[Out, Buffer] wchar_t* stringBuffer,[In] unsigned int size)</unmanaged>	
        /// <unmanaged-short>IDWriteLocalizedStrings::GetString</unmanaged-short>	
        internal void GetString(int index, System.IntPtr stringBuffer, int size)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, index, (void*)stringBuffer, size, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Holds the appropriate digits and numeric punctuation for a specified locale.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteNumberSubstitution']/*"/>	
    /// <msdn-id>dd371271</msdn-id>	
    /// <unmanaged>IDWriteNumberSubstitution</unmanaged>	
    /// <unmanaged-short>IDWriteNumberSubstitution</unmanaged-short>	
    [Guid("14885CC9-BAB0-4f90-B6ED-5C366A2CD03D")]
    public partial class NumberSubstitution : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.NumberSubstitution"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public NumberSubstitution(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.NumberSubstitution"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.NumberSubstitution(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.NumberSubstitution(nativePointer);
        }

    }
    /// <summary>	
    /// <p>Defines the pixel snapping properties such as pixels per DIP(device-independent pixel) and the current transform matrix of a text renderer.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWritePixelSnapping']/*"/>	
    /// <msdn-id>dd371274</msdn-id>	
    /// <unmanaged>IDWritePixelSnapping</unmanaged>	
    /// <unmanaged-short>IDWritePixelSnapping</unmanaged-short>	
    [Guid("eaf3a2da-ecf4-4d24-b644-b34f6842024b")]
    public partial interface PixelSnapping : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p>Defines the pixel snapping properties such as pixels per DIP(device-independent pixel) and the current transform matrix of a text renderer.</p>	
        /// </summary>	
        /// <param name="clientDrawingContext">No documentation.</param>	
        /// <param name="isDisabled">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWritePixelSnapping::IsPixelSnappingDisabled']/*"/>	
        /// <msdn-id>dd371274</msdn-id>	
        /// <unmanaged>HRESULT IDWritePixelSnapping::IsPixelSnappingDisabled([In, Optional] void* clientDrawingContext,[Out] BOOL* isDisabled)</unmanaged>	
        /// <unmanaged-short>IDWritePixelSnapping::IsPixelSnappingDisabled</unmanaged-short>	
        /* public void IsPixelSnappingDisabled(System.IntPtr clientDrawingContext, out SharpDX.Mathematics.Interop.RawBool isDisabled) */

        /// <summary>	
        /// <p> Gets a transform that maps abstract coordinates to DIPs. </p>	
        /// </summary>	
        /// <param name="clientDrawingContext"><dd>  <p>The drawing context passed to <strong><see cref="SharpDX.DirectWrite.TextLayout.Draw_"/></strong>.</p> </dd></param>	
        /// <param name="transform"><dd>  <p>When this method returns, contains a structure which has transform information for  pixel snapping.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWritePixelSnapping::GetCurrentTransform']/*"/>	
        /// <msdn-id>dd371277</msdn-id>	
        /// <unmanaged>HRESULT IDWritePixelSnapping::GetCurrentTransform([In, Optional] void* clientDrawingContext,[Out] DWRITE_MATRIX* transform)</unmanaged>	
        /// <unmanaged-short>IDWritePixelSnapping::GetCurrentTransform</unmanaged-short>	
        /* public void GetCurrentTransform(System.IntPtr clientDrawingContext, out SharpDX.Mathematics.Interop.RawMatrix3x2 transform) */

        /// <summary>	
        /// <p> Gets the number of physical pixels per DIP. </p>	
        /// </summary>	
        /// <param name="clientDrawingContext"><dd>  <p>The drawing context passed to <strong><see cref="SharpDX.DirectWrite.TextLayout.Draw_"/></strong>.</p> </dd></param>	
        /// <param name="ixelsPerDipRef"><dd>  <p>When this method returns, contains the number of physical pixels per DIP.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Because a DIP (device-independent pixel) is 1/96 inch,  the <em>pixelsPerDip</em> value is the number of logical pixels per inch divided by 96.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWritePixelSnapping::GetPixelsPerDip']/*"/>	
        /// <msdn-id>dd371280</msdn-id>	
        /// <unmanaged>HRESULT IDWritePixelSnapping::GetPixelsPerDip([In, Optional] void* clientDrawingContext,[Out] float* pixelsPerDip)</unmanaged>	
        /// <unmanaged-short>IDWritePixelSnapping::GetPixelsPerDip</unmanaged-short>	
        /* public void GetPixelsPerDip(System.IntPtr clientDrawingContext, out float ixelsPerDipRef) */
    }
    /// <summary>	
    /// <p> Represents text rendering settings such as ClearType level, enhanced contrast, and gamma correction for glyph rasterization and filtering.</p><p>An application typically obtains a rendering parameters object by calling the <strong><see cref="SharpDX.DirectWrite.Factory.CreateMonitorRenderingParams"/></strong> method.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteRenderingParams']/*"/>	
    /// <msdn-id>dd371285</msdn-id>	
    /// <unmanaged>IDWriteRenderingParams</unmanaged>	
    /// <unmanaged-short>IDWriteRenderingParams</unmanaged-short>	
    [Guid("2f0da53a-2add-47cd-82ee-d9ec34688e75")]
    public partial class RenderingParams : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.RenderingParams"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RenderingParams(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.RenderingParams"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.RenderingParams(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.RenderingParams(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the gamma value used for gamma correction. Valid values must be greater than zero and cannot exceed 256.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The gamma value is used for gamma correction, which compensates for the non-linear luminosity response of most monitors.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteRenderingParams::GetGamma']/*"/>	
        /// <msdn-id>dd371295</msdn-id>	
        /// <unmanaged>GetGamma</unmanaged>	
        /// <unmanaged-short>GetGamma</unmanaged-short>	
        /// <unmanaged>float IDWriteRenderingParams::GetGamma()</unmanaged>
        public float Gamma
        {
            get { return GetGamma(); }
        }

        /// <summary>	
        /// <p>Gets the enhanced contrast property of the rendering parameters object. Valid values are greater than or equal to zero.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Enhanced contrast is the amount to increase the darkness of text, and typically ranges from 0 to 1. Zero means no contrast enhancement.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteRenderingParams::GetEnhancedContrast']/*"/>	
        /// <msdn-id>dd371290</msdn-id>	
        /// <unmanaged>GetEnhancedContrast</unmanaged>	
        /// <unmanaged-short>GetEnhancedContrast</unmanaged-short>	
        /// <unmanaged>float IDWriteRenderingParams::GetEnhancedContrast()</unmanaged>
        public float EnhancedContrast
        {
            get { return GetEnhancedContrast(); }
        }

        /// <summary>	
        /// <p>Gets the ClearType level of the rendering parameters object. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The ClearType level represents the amount of ClearType ? that is, the degree to which the red, green, and blue subpixels of each pixel are treated differently. Valid values range from zero (meaning no ClearType, which is equivalent to grayscale anti-aliasing) to one (meaning full ClearType)</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteRenderingParams::GetClearTypeLevel']/*"/>	
        /// <msdn-id>dd371288</msdn-id>	
        /// <unmanaged>GetClearTypeLevel</unmanaged>	
        /// <unmanaged-short>GetClearTypeLevel</unmanaged-short>	
        /// <unmanaged>float IDWriteRenderingParams::GetClearTypeLevel()</unmanaged>
        public float ClearTypeLevel
        {
            get { return GetClearTypeLevel(); }
        }

        /// <summary>	
        /// <p>Gets the pixel geometry of the rendering parameters object.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteRenderingParams::GetPixelGeometry']/*"/>	
        /// <msdn-id>dd371297</msdn-id>	
        /// <unmanaged>GetPixelGeometry</unmanaged>	
        /// <unmanaged-short>GetPixelGeometry</unmanaged-short>	
        /// <unmanaged>DWRITE_PIXEL_GEOMETRY IDWriteRenderingParams::GetPixelGeometry()</unmanaged>
        public SharpDX.DirectWrite.PixelGeometry PixelGeometry
        {
            get { return GetPixelGeometry(); }
        }

        /// <summary>	
        /// <p>Gets the rendering mode of the rendering parameters object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>By default, the rendering mode is initialized to <see cref="SharpDX.DirectWrite.RenderingMode.Default"/>, which means the rendering mode is determined automatically based on the font and size. To determine the recommended rendering mode to use for a given font and size and rendering parameters object, use the <strong><see cref="SharpDX.DirectWrite.FontFace.GetRecommendedRenderingMode"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteRenderingParams::GetRenderingMode']/*"/>	
        /// <msdn-id>dd371300</msdn-id>	
        /// <unmanaged>GetRenderingMode</unmanaged>	
        /// <unmanaged-short>GetRenderingMode</unmanaged-short>	
        /// <unmanaged>DWRITE_RENDERING_MODE IDWriteRenderingParams::GetRenderingMode()</unmanaged>
        public SharpDX.DirectWrite.RenderingMode RenderingMode
        {
            get { return GetRenderingMode(); }
        }

        /// <summary>	
        /// <p>Gets the gamma value used for gamma correction. Valid values must be greater than zero and cannot exceed 256.</p>	
        /// </summary>	
        /// <returns><p>Returns the gamma value used for gamma correction. Valid values must be greater than zero and cannot exceed 256.</p></returns>	
        /// <remarks>	
        /// <p>The gamma value is used for gamma correction, which compensates for the non-linear luminosity response of most monitors.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteRenderingParams::GetGamma']/*"/>	
        /// <msdn-id>dd371295</msdn-id>	
        /// <unmanaged>float IDWriteRenderingParams::GetGamma()</unmanaged>	
        /// <unmanaged-short>IDWriteRenderingParams::GetGamma</unmanaged-short>	
        internal float GetGamma()
        {
            unsafe
            {
                float __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callifloat(_nativePointer, ((void**)(*(void**)_nativePointer))[3]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the enhanced contrast property of the rendering parameters object. Valid values are greater than or equal to zero.</p>	
        /// </summary>	
        /// <returns><p>Returns the amount of contrast enhancement. Valid values are greater than or equal to zero.</p></returns>	
        /// <remarks>	
        /// <p>Enhanced contrast is the amount to increase the darkness of text, and typically ranges from 0 to 1. Zero means no contrast enhancement.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteRenderingParams::GetEnhancedContrast']/*"/>	
        /// <msdn-id>dd371290</msdn-id>	
        /// <unmanaged>float IDWriteRenderingParams::GetEnhancedContrast()</unmanaged>	
        /// <unmanaged-short>IDWriteRenderingParams::GetEnhancedContrast</unmanaged-short>	
        internal float GetEnhancedContrast()
        {
            unsafe
            {
                float __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callifloat(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the ClearType level of the rendering parameters object. </p>	
        /// </summary>	
        /// <returns><p>The ClearType level of the rendering parameters object.</p></returns>	
        /// <remarks>	
        /// <p>The ClearType level represents the amount of ClearType ? that is, the degree to which the red, green, and blue subpixels of each pixel are treated differently. Valid values range from zero (meaning no ClearType, which is equivalent to grayscale anti-aliasing) to one (meaning full ClearType)</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteRenderingParams::GetClearTypeLevel']/*"/>	
        /// <msdn-id>dd371288</msdn-id>	
        /// <unmanaged>float IDWriteRenderingParams::GetClearTypeLevel()</unmanaged>	
        /// <unmanaged-short>IDWriteRenderingParams::GetClearTypeLevel</unmanaged-short>	
        internal float GetClearTypeLevel()
        {
            unsafe
            {
                float __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callifloat(_nativePointer, ((void**)(*(void**)_nativePointer))[5]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the pixel geometry of the rendering parameters object.</p>	
        /// </summary>	
        /// <returns><p> A value that indicates the type of  pixel geometry used in the rendering parameters object.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteRenderingParams::GetPixelGeometry']/*"/>	
        /// <msdn-id>dd371297</msdn-id>	
        /// <unmanaged>DWRITE_PIXEL_GEOMETRY IDWriteRenderingParams::GetPixelGeometry()</unmanaged>	
        /// <unmanaged-short>IDWriteRenderingParams::GetPixelGeometry</unmanaged-short>	
        internal SharpDX.DirectWrite.PixelGeometry GetPixelGeometry()
        {
            unsafe
            {
                SharpDX.DirectWrite.PixelGeometry __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWritePixelGeometry(_nativePointer, ((void**)(*(void**)_nativePointer))[6]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Gets the rendering mode of the rendering parameters object.</p>	
        /// </summary>	
        /// <returns><p>A value that indicates the rendering mode of the rendering parameters object.</p></returns>	
        /// <remarks>	
        /// <p>By default, the rendering mode is initialized to <see cref="SharpDX.DirectWrite.RenderingMode.Default"/>, which means the rendering mode is determined automatically based on the font and size. To determine the recommended rendering mode to use for a given font and size and rendering parameters object, use the <strong><see cref="SharpDX.DirectWrite.FontFace.GetRecommendedRenderingMode"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteRenderingParams::GetRenderingMode']/*"/>	
        /// <msdn-id>dd371300</msdn-id>	
        /// <unmanaged>DWRITE_RENDERING_MODE IDWriteRenderingParams::GetRenderingMode()</unmanaged>	
        /// <unmanaged-short>IDWriteRenderingParams::GetRenderingMode</unmanaged-short>	
        internal SharpDX.DirectWrite.RenderingMode GetRenderingMode()
        {
            unsafe
            {
                SharpDX.DirectWrite.RenderingMode __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteRenderingMode(_nativePointer, ((void**)(*(void**)_nativePointer))[7]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Represents text rendering settings for glyph rasterization and filtering.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteRenderingParams1']/*"/>	
    /// <msdn-id>hh780422</msdn-id>	
    /// <unmanaged>IDWriteRenderingParams1</unmanaged>	
    /// <unmanaged-short>IDWriteRenderingParams1</unmanaged-short>	
    [Guid("94413cf4-a6fc-4248-8b50-6674348fcad3")]
    public partial class RenderingParams1 : SharpDX.DirectWrite.RenderingParams
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.RenderingParams1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RenderingParams1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.RenderingParams1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.RenderingParams1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.RenderingParams1(nativePointer);
        }


        /// <summary>	
        /// <p>Gets the amount of contrast enhancement to use for grayscale antialiasing.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteRenderingParams1::GetGrayscaleEnhancedContrast']/*"/>	
        /// <msdn-id>Hh780423</msdn-id>	
        /// <unmanaged>GetGrayscaleEnhancedContrast</unmanaged>	
        /// <unmanaged-short>GetGrayscaleEnhancedContrast</unmanaged-short>	
        /// <unmanaged>float IDWriteRenderingParams1::GetGrayscaleEnhancedContrast()</unmanaged>
        public float GrayscaleEnhancedContrast
        {
            get { return GetGrayscaleEnhancedContrast(); }
        }

        /// <summary>	
        /// <p>Gets the amount of contrast enhancement to use for grayscale antialiasing.</p>	
        /// </summary>	
        /// <returns><p>The contrast enhancement value. Valid values are greater than or equal to zero.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteRenderingParams1::GetGrayscaleEnhancedContrast']/*"/>	
        /// <msdn-id>Hh780423</msdn-id>	
        /// <unmanaged>float IDWriteRenderingParams1::GetGrayscaleEnhancedContrast()</unmanaged>	
        /// <unmanaged-short>IDWriteRenderingParams1::GetGrayscaleEnhancedContrast</unmanaged-short>	
        internal float GetGrayscaleEnhancedContrast()
        {
            unsafe
            {
                float __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callifloat(_nativePointer, ((void**)(*(void**)_nativePointer))[8]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>This interface is implemented by the text analyzer's client to receive the output of a given text analysis. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The text analyzer disregards any current state of the analysis sink, therefore, a Set method call on a range overwrites the previously set analysis result of the same range.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalysisSink']/*"/>	
    /// <msdn-id>dd371303</msdn-id>	
    /// <unmanaged>IDWriteTextAnalysisSink</unmanaged>	
    /// <unmanaged-short>IDWriteTextAnalysisSink</unmanaged-short>	
    [Guid("5810cd44-0ca0-4701-b3fa-bec5182ae4f6")]
    public partial interface TextAnalysisSink : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p>Reports script analysis for the specified text range.</p>	
        /// </summary>	
        /// <param name="textPosition"><dd>  <p>The starting position from which to report.</p> </dd></param>	
        /// <param name="textLength"><dd>  <p>The number of UTF16 units of the reported range.</p> </dd></param>	
        /// <param name="scriptAnalysis"><dd>  <p>A reference to a structure that contains a zero-based index representation of a writing system script and a value indicating whether additional shaping of text is required.</p> </dd></param>	
        /// <returns><p>A successful code or error code to stop analysis.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalysisSink::SetScriptAnalysis']/*"/>	
        /// <msdn-id>dd371315</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalysisSink::SetScriptAnalysis([In] unsigned int textPosition,[In] unsigned int textLength,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalysisSink::SetScriptAnalysis</unmanaged-short>	
        /* public void SetScriptAnalysis(int textPosition, int textLength, SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis) */

        /// <summary>	
        /// <p>Sets line-break opportunities for each character, starting from the specified position.</p>	
        /// </summary>	
        /// <param name="textPosition"><dd>  <p>The starting text position from which to report.</p> </dd></param>	
        /// <param name="textLength"><dd>  <p>The number of UTF16 units of the reported range.</p> </dd></param>	
        /// <param name="lineBreakpoints"><dd>  <p>A reference to a structure that contains breaking conditions set for each character from the starting position to the end of the specified range.</p> </dd></param>	
        /// <returns><p>A successful code or error code to stop analysis.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalysisSink::SetLineBreakpoints']/*"/>	
        /// <msdn-id>dd371311</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalysisSink::SetLineBreakpoints([In] unsigned int textPosition,[In] unsigned int textLength,[In, Buffer] const DWRITE_LINE_BREAKPOINT* lineBreakpoints)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalysisSink::SetLineBreakpoints</unmanaged-short>	
        /* public void SetLineBreakpoints(int textPosition, int textLength, SharpDX.DirectWrite.LineBreakpoint[] lineBreakpoints) */

        /// <summary>	
        /// <p>Sets a bidirectional level on the range, which is  called once per  run change (either explicit or resolved implicit).</p>	
        /// </summary>	
        /// <param name="textPosition"><dd>  <p>The starting position from which to report.</p> </dd></param>	
        /// <param name="textLength"><dd>  <p>The number of UTF16 units of the reported range.</p> </dd></param>	
        /// <param name="explicitLevel"><dd>  <p>The explicit level from the paragraph reading direction and any embedded control codes RLE/RLO/LRE/LRO/PDF, which is determined before any additional rules.</p> </dd></param>	
        /// <param name="resolvedLevel"><dd>  <p>The final implicit level considering the explicit level and characters' natural directionality, after all Bidi rules have been applied.</p> </dd></param>	
        /// <returns><p>A successful code or error code to stop analysis.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalysisSink::SetBidiLevel']/*"/>	
        /// <msdn-id>dd371306</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalysisSink::SetBidiLevel([In] unsigned int textPosition,[In] unsigned int textLength,[In] unsigned char explicitLevel,[In] unsigned char resolvedLevel)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalysisSink::SetBidiLevel</unmanaged-short>	
        /* public void SetBidiLevel(int textPosition, int textLength, byte explicitLevel, byte resolvedLevel) */

        /// <summary>	
        /// <p>Sets the number substitution on the text range affected by the text analysis.</p>	
        /// </summary>	
        /// <param name="textPosition"><dd>  <p>The starting position from which to report.</p> </dd></param>	
        /// <param name="textLength"><dd>  <p>The number of UTF16 units of the reported range.</p> </dd></param>	
        /// <param name="numberSubstitution"><dd>  <p>An object that holds the appropriate digits and numeric punctuation for a given locale. Use <strong><see cref="SharpDX.DirectWrite.Factory.CreateNumberSubstitution"/></strong> to create this object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalysisSink::SetNumberSubstitution']/*"/>	
        /// <msdn-id>dd371312</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalysisSink::SetNumberSubstitution([In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteNumberSubstitution* numberSubstitution)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalysisSink::SetNumberSubstitution</unmanaged-short>	
        /* public void SetNumberSubstitution(int textPosition, int textLength, SharpDX.DirectWrite.NumberSubstitution numberSubstitution) */
    }
    /// <summary>	
    /// <p> The interface you implement to receive the  output of the text analyzers.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalysisSink1']/*"/>	
    /// <msdn-id>hh780424</msdn-id>	
    /// <unmanaged>IDWriteTextAnalysisSink1</unmanaged>	
    /// <unmanaged-short>IDWriteTextAnalysisSink1</unmanaged-short>	
    [Guid("B0D941A0-85E7-4D8B-9FD3-5CED9934482A")]
    public partial interface TextAnalysisSink1 : SharpDX.DirectWrite.TextAnalysisSink
    {


        /// <summary>	
        /// <p>The text analyzer calls back to this to report the actual orientation of each character for shaping and drawing.</p>	
        /// </summary>	
        /// <param name="textPosition"><dd>  <p>The starting position to report from.</p> </dd></param>	
        /// <param name="textLength"><dd>  <p>Number of UTF-16 units of the reported range.</p> </dd></param>	
        /// <param name="glyphOrientationAngle"><dd>  <p>A <strong><see cref="SharpDX.DirectWrite.GlyphOrientationAngle"/></strong>-typed value that specifies the angle of the glyphs within the text range (pass to <strong><see cref="SharpDX.DirectWrite.TextAnalyzer1.GetGlyphOrientationTransform"/></strong> to get the world relative transform).</p> </dd></param>	
        /// <param name="adjustedBidiLevel"><dd>  <p>The adjusted bidi level to be used by the client layout for reordering runs. This will differ from the resolved bidi level retrieved from the source for cases such as Arabic stacked top-to-bottom, where the glyphs are still shaped as RTL, but the runs are TTB along with any CJK or Latin.</p> </dd></param>	
        /// <param name="isSideways"><dd>  <p>Whether the glyphs are rotated on their side, which is the default case for CJK and the case stacked Latin</p> </dd></param>	
        /// <param name="isRightToLeft"><dd>  <p>Whether the script should be shaped as right-to-left. For Arabic stacked top-to-bottom, even when the adjusted bidi level is coerced to an even level, this will still be true.</p> </dd></param>	
        /// <returns><p>Returns a successful code or an error code to abort analysis.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalysisSink1::SetGlyphOrientation']/*"/>	
        /// <msdn-id>Hh780425</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalysisSink1::SetGlyphOrientation([In] unsigned int textPosition,[In] unsigned int textLength,[In] DWRITE_GLYPH_ORIENTATION_ANGLE glyphOrientationAngle,[In] unsigned char adjustedBidiLevel,[In] BOOL isSideways,[In] BOOL isRightToLeft)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalysisSink1::SetGlyphOrientation</unmanaged-short>	
        /* public void SetGlyphOrientation(int textPosition, int textLength, SharpDX.DirectWrite.GlyphOrientationAngle glyphOrientationAngle, byte adjustedBidiLevel, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.Mathematics.Interop.RawBool isRightToLeft) */
    }
    /// <summary>	
    /// <p>Implemented by the text analyzer's client to provide text to the analyzer. It allows the separation between the logical view of text as a continuous stream of characters identifiable by unique text positions, and the actual memory layout of potentially discrete blocks of text in the client's backing store. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If any of these callbacks returns an error, then the analysis functions will stop prematurely and return a callback error. Note that rather than return E_NOTIMPL, an application should stub the method and return a constant/null and <see cref="SharpDX.Result.Ok"/>.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalysisSource']/*"/>	
    /// <msdn-id>dd371318</msdn-id>	
    /// <unmanaged>IDWriteTextAnalysisSource</unmanaged>	
    /// <unmanaged-short>IDWriteTextAnalysisSource</unmanaged-short>	
    [Guid("688e1a58-5094-47c8-adc8-fbcea60ae92b")]
    public partial interface TextAnalysisSource : SharpDX.ICallbackable
    {


        /// <summary>	
        /// <p>Gets a block of text starting at the specified text position. </p>	
        /// </summary>	
        /// <param name="textPosition"><dd>  <p>The first position of the piece to obtain. All positions are in <strong>UTF16</strong> code units, not whole characters, which matters when supplementary characters are used.</p> </dd></param>	
        /// <param name="textString"><dd>  <p>When this method returns, contains an address of  the block of text as an array of characters to be retrieved from the text analysis.</p> </dd></param>	
        /// <param name="textLength"><dd>  <p>When this method returns, contains the number of <strong>UTF16</strong> units of the retrieved chunk. The returned length is not the length of the block, but the length     remaining in the block, from the specified position until its end. For example, querying for a position that is 75 positions into a 100-position block would return 25.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Returning <strong><c>null</c></strong> indicates the end of text, which is the position after the last character. This function is called iteratively for each consecutive block, tying together several fragmented blocks in the backing store into a virtual contiguous string.</p><p>Although applications can implement sparse textual content that  maps only part of the backing store, the application must map any text that is in the range passed to any analysis functions.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalysisSource::GetTextAtPosition']/*"/>	
        /// <msdn-id>dd371330</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalysisSource::GetTextAtPosition([In] unsigned int textPosition,[Out, Buffer] const wchar_t** textString,[Out] unsigned int* textLength)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalysisSource::GetTextAtPosition</unmanaged-short>	
        /* public void GetTextAtPosition(int textPosition, System.IntPtr textString, out int textLength) */

        /// <summary>	
        /// <p>Gets a block of text immediately preceding the specified position.</p>	
        /// </summary>	
        /// <param name="textPosition"><dd>  <p>The position immediately after the last position of the block of text to obtain.</p> </dd></param>	
        /// <param name="textString"><dd>  <p>When this method returns, contains an address of a reference to the block of text, as an array of characters from the specified range.  The text range will be from <em>textPosition</em> to the front of the block.</p> </dd></param>	
        /// <param name="textLength"><dd>  <p>Number of UTF16 units of the retrieved block. The length returned is from the specified position to the front of the block.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><c>null</c> indicates no chunk available at the specified position, either because <em>textPosition</em> equals 0,  <em>textPosition</em> is greater than the entire text content length, or the queried position is not mapped into the application's backing store.</p><p>Although applications can implement sparse textual content that  maps only part of the backing store, the application must map any text that is in the range passed to any analysis functions.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalysisSource::GetTextBeforePosition']/*"/>	
        /// <msdn-id>dd371332</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalysisSource::GetTextBeforePosition([In] unsigned int textPosition,[Out, Buffer] const wchar_t** textString,[Out] unsigned int* textLength)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalysisSource::GetTextBeforePosition</unmanaged-short>	
        /* public void GetTextBeforePosition(int textPosition, System.IntPtr textString, out int textLength) */

        /// <summary>	
        /// <p>Gets the paragraph reading direction.</p>	
        /// </summary>	
        /// <returns><p>The reading direction of the current paragraph.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalysisSource::GetParagraphReadingDirection']/*"/>	
        /// <msdn-id>dd371328</msdn-id>	
        /// <unmanaged>DWRITE_READING_DIRECTION IDWriteTextAnalysisSource::GetParagraphReadingDirection()</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalysisSource::GetParagraphReadingDirection</unmanaged-short>	
        /* internal SharpDX.DirectWrite.ReadingDirection GetParagraphReadingDirection() */

        /// <summary>	
        /// <p>Gets the locale name on the range affected by the text analysis.</p>	
        /// </summary>	
        /// <param name="textPosition"><dd>  <p>The text position to examine.</p> </dd></param>	
        /// <param name="textLength"><dd>  <p>Contains the length of the text being affected by the text analysis up to the next differing locale.</p> </dd></param>	
        /// <param name="localeName"><dd>  <p>Contains an address of a  reference to an array of characters which receives the locale name from the text affected by the text analysis. The array of characters is null-terminated.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <em>localeName</em> reference must remain valid until the next call or until the analysis returns.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalysisSource::GetLocaleName']/*"/>	
        /// <msdn-id>dd371322</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalysisSource::GetLocaleName([In] unsigned int textPosition,[Out] unsigned int* textLength,[Out] const wchar_t** localeName)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalysisSource::GetLocaleName</unmanaged-short>	
        /* public void GetLocaleName(int textPosition, out int textLength, System.IntPtr localeName) */

        /// <summary>	
        /// <p>Gets the number substitution from the text range affected by the text analysis.</p>	
        /// </summary>	
        /// <param name="textPosition"><dd>  <p>The starting position from which to report.</p> </dd></param>	
        /// <param name="textLength"><dd>  <p>Contains  the length of the text, in characters, remaining in the text range up to the next differing number substitution.</p> </dd></param>	
        /// <param name="numberSubstitution"><dd>  <p>Contains an address of a reference to an object, which was created with <strong><see cref="SharpDX.DirectWrite.Factory.CreateNumberSubstitution"/></strong>, that holds the appropriate digits and numeric punctuation for a given locale.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Any implementation should return the number substitution with an incremented reference count, and the analysis will release when finished with it (either before the next call or before it returns). However, the sink callback may hold onto it after that.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalysisSource::GetNumberSubstitution']/*"/>	
        /// <msdn-id>dd371325</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalysisSource::GetNumberSubstitution([In] unsigned int textPosition,[Out] unsigned int* textLength,[Out] IDWriteNumberSubstitution** numberSubstitution)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalysisSource::GetNumberSubstitution</unmanaged-short>	
        /* public void GetNumberSubstitution(int textPosition, out int textLength, out SharpDX.DirectWrite.NumberSubstitution numberSubstitution) */
    }
    /// <summary>	
    /// <p>The interface you implement to provide needed information to  the text analyzer, like the text and associated text properties.</p><p> </p><p><strong>Note</strong>?? If any of these callbacks return an error, the analysis functions will  stop prematurely and return a callback error.  </p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalysisSource1']/*"/>	
    /// <msdn-id>Hh780426</msdn-id>	
    /// <unmanaged>IDWriteTextAnalysisSource1</unmanaged>	
    /// <unmanaged-short>IDWriteTextAnalysisSource1</unmanaged-short>	
    [Guid("639CFAD8-0FB4-4B21-A58A-067920120009")]
    public partial interface TextAnalysisSource1 : SharpDX.DirectWrite.TextAnalysisSource
    {


        /// <summary>	
        /// <p>Used by the text analyzer to obtain the desired glyph orientation and resolved bidi level.</p>	
        /// </summary>	
        /// <param name="textPosition"><dd>  <p>The text position.</p> </dd></param>	
        /// <param name="textLength"><dd>  <p>A reference to the text length.</p> </dd></param>	
        /// <param name="glyphOrientation"><dd>  <p>A <strong><see cref="SharpDX.DirectWrite.VerticalGlyphOrientation"/></strong>-typed value that specifies the desired kind of glyph orientation for the text.</p> </dd></param>	
        /// <param name="bidiLevel"><dd>  <p>A reference to the resolved bidi level.</p> </dd></param>	
        /// <returns><p>Returning an error will abort the analysis.</p></returns>	
        /// <remarks>	
        /// <p>The text analyzer calls back to this to get the desired glyph orientation and resolved bidi level, which it uses along with the script properties of the text to determine the actual orientation of each character, which it reports back to the client via the sink SetGlyphOrientation method.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalysisSource1::GetVerticalGlyphOrientation']/*"/>	
        /// <msdn-id>Hh780427</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalysisSource1::GetVerticalGlyphOrientation([In] unsigned int textPosition,[Out] unsigned int* textLength,[Out] DWRITE_VERTICAL_GLYPH_ORIENTATION* glyphOrientation,[Out] unsigned char* bidiLevel)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalysisSource1::GetVerticalGlyphOrientation</unmanaged-short>	
        /* public void GetVerticalGlyphOrientation(int textPosition, out int textLength, out SharpDX.DirectWrite.VerticalGlyphOrientation glyphOrientation, out byte bidiLevel) */
    }
    /// <summary>	
    /// <p> Analyzes various text properties for complex script processing such as bidirectional (bidi) support for languages like Arabic, determination of line break opportunities, glyph placement, and number substitution.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer']/*"/>	
    /// <msdn-id>dd316607</msdn-id>	
    /// <unmanaged>IDWriteTextAnalyzer</unmanaged>	
    /// <unmanaged-short>IDWriteTextAnalyzer</unmanaged-short>	
    [Guid("b7e6163e-7f46-43b4-84b3-e4e6249c365d")]
    public partial class TextAnalyzer : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.TextAnalyzer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TextAnalyzer(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.TextAnalyzer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.TextAnalyzer(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.TextAnalyzer(nativePointer);
        }


        /// <summary>	
        /// <p> Analyzes a text range for script boundaries, reading text attributes from the source and reporting the Unicode script ID to the sink  callback <strong>SetScript</strong>. </p>	
        /// </summary>	
        /// <param name="analysisSource">No documentation.</param>	
        /// <param name="textPosition">No documentation.</param>	
        /// <param name="textLength">No documentation.</param>	
        /// <param name="analysisSink">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer::AnalyzeScript']/*"/>	
        /// <msdn-id>dd316620</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer::AnalyzeScript([In] IDWriteTextAnalysisSource* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteTextAnalysisSink* analysisSink)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer::AnalyzeScript</unmanaged-short>	
        internal void AnalyzeScript__(System.IntPtr analysisSource, int textPosition, int textLength, System.IntPtr analysisSink)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)analysisSource, textPosition, textLength, (void*)analysisSink, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Analyzes a text range for script directionality, reading attributes from the source and reporting levels to the sink callback <strong>SetBidiLevel</strong>. </p>	
        /// </summary>	
        /// <param name="analysisSource">No documentation.</param>	
        /// <param name="textPosition">No documentation.</param>	
        /// <param name="textLength">No documentation.</param>	
        /// <param name="analysisSink">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> While the function can handle multiple paragraphs, the text range should not arbitrarily split the middle of paragraphs. Otherwise, the returned levels may be wrong, because the Bidi algorithm is meant to apply to the paragraph as a whole. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer::AnalyzeBidi']/*"/>	
        /// <msdn-id>dd316610</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer::AnalyzeBidi([In] IDWriteTextAnalysisSource* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteTextAnalysisSink* analysisSink)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer::AnalyzeBidi</unmanaged-short>	
        internal void AnalyzeBidi__(System.IntPtr analysisSource, int textPosition, int textLength, System.IntPtr analysisSink)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)analysisSource, textPosition, textLength, (void*)analysisSink, ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Analyzes a text range for spans where number substitution is applicable, reading attributes from the source and reporting substitutable ranges to the sink callback <strong>SetNumberSubstitution</strong>. </p>	
        /// </summary>	
        /// <param name="analysisSource">No documentation.</param>	
        /// <param name="textPosition">No documentation.</param>	
        /// <param name="textLength">No documentation.</param>	
        /// <param name="analysisSink">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Although the function can handle multiple ranges of differing number substitutions, the text ranges should not arbitrarily split the middle of numbers. Otherwise, it will treat the numbers separately and will not translate any intervening punctuation. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer::AnalyzeNumberSubstitution']/*"/>	
        /// <msdn-id>dd316616</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer::AnalyzeNumberSubstitution([In] IDWriteTextAnalysisSource* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteTextAnalysisSink* analysisSink)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer::AnalyzeNumberSubstitution</unmanaged-short>	
        internal void AnalyzeNumberSubstitution__(System.IntPtr analysisSource, int textPosition, int textLength, System.IntPtr analysisSink)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)analysisSource, textPosition, textLength, (void*)analysisSink, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Analyzes a text range for potential breakpoint opportunities, reading attributes from the source and reporting breakpoint opportunities to the sink callback <strong>SetLineBreakpoints</strong>. </p>	
        /// </summary>	
        /// <param name="analysisSource">No documentation.</param>	
        /// <param name="textPosition">No documentation.</param>	
        /// <param name="textLength">No documentation.</param>	
        /// <param name="analysisSink">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Although the function can handle multiple paragraphs, the text range should not arbitrarily split the middle of paragraphs, unless the specified text span is considered a whole unit. Otherwise, the returned properties for the first and last characters will inappropriately allow breaks. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer::AnalyzeLineBreakpoints']/*"/>	
        /// <msdn-id>dd316613</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer::AnalyzeLineBreakpoints([In] IDWriteTextAnalysisSource* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteTextAnalysisSink* analysisSink)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer::AnalyzeLineBreakpoints</unmanaged-short>	
        internal void AnalyzeLineBreakpoints__(System.IntPtr analysisSource, int textPosition, int textLength, System.IntPtr analysisSink)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)analysisSource, textPosition, textLength, (void*)analysisSink, ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Parses the input text string and maps it to the set of glyphs and associated glyph data according to the font and the writing system's rendering rules. </p>	
        /// </summary>	
        /// <param name="textString"><dd>  <p>An array of characters to convert to glyphs.</p> </dd></param>	
        /// <param name="textLength"><dd>  <p>The length of <em>textString</em>.</p> </dd></param>	
        /// <param name="fontFace"><dd>  <p>The font face that is the source of the output glyphs.</p> </dd></param>	
        /// <param name="isSideways"><dd>  <p>A Boolean flag set to <strong>TRUE</strong> if the text is intended to be drawn vertically.</p> </dd></param>	
        /// <param name="isRightToLeft"><dd>  <p>A Boolean flag set to <strong>TRUE</strong> for right-to-left text.</p> </dd></param>	
        /// <param name="scriptAnalysis"><dd>  <p>A reference to a Script analysis result from an <strong>AnalyzeScript</strong> call.</p> </dd></param>	
        /// <param name="localeName"><dd>  <p>The locale to use when selecting glyphs. For example the same character may map to different glyphs for ja-jp versus zh-chs. If this is <strong><c>null</c></strong>, then the default mapping based on the script is used.</p> </dd></param>	
        /// <param name="numberSubstitution"><dd>  <p>A reference to an optional number substitution which selects the appropriate glyphs for digits and related numeric characters, depending on the results obtained from <strong>AnalyzeNumberSubstitution</strong>. Passing <strong><c>null</c></strong> indicates that no substitution is needed and that the digits should receive nominal glyphs.</p> </dd></param>	
        /// <param name="features"><dd>  <p>An array of references to the sets of typographic  features to use in each feature range.</p> </dd></param>	
        /// <param name="featureRangeLengths"><dd>  <p>The length of each feature range, in characters.   The sum of all lengths should be equal to <em>textLength</em>.</p> </dd></param>	
        /// <param name="featureRanges"><dd>  <p>The number of feature ranges.</p> </dd></param>	
        /// <param name="maxGlyphCount"><dd>  <p>The maximum number of glyphs that can be returned.</p> </dd></param>	
        /// <param name="clusterMap"><dd>  <p>When this method returns, contains the mapping from character ranges to glyph  ranges.</p> </dd></param>	
        /// <param name="textProps"><dd>  <p>When this method returns, contains a reference to an array of structures that contains  shaping properties for each character.</p> </dd></param>	
        /// <param name="glyphIndices"><dd>  <p>The output glyph indices.</p> </dd></param>	
        /// <param name="glyphProps"><dd>  <p>When this method returns, contains a reference to an array of structures that contain  shaping properties for each output glyph.</p> </dd></param>	
        /// <param name="actualGlyphCount"><dd>  <p>When this method returns, contains the actual number of glyphs returned if the call succeeds.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Note that the mapping from characters to glyphs is, in general, many-to-many.  The recommended estimate for the per-glyph output buffers is (3 * <em>textLength</em> / 2 + 16).  This is not guaranteed to be sufficient. The value of the <em>actualGlyphCount</em> parameter is only valid if the call succeeds.  In the event that <em>maxGlyphCount</em> is not big enough, <strong>HRESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.InsufficientBuffer"/>)</strong> will be returned.  The application should  allocate a larger buffer and try again. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer::GetGlyphs']/*"/>	
        /// <msdn-id>dd316625</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer::GetGlyphs([In, Buffer] const wchar_t* textString,[In] unsigned int textLength,[In] IDWriteFontFace* fontFace,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,[In, Optional] const wchar_t* localeName,[In, Optional] IDWriteNumberSubstitution* numberSubstitution,[In, Optional] const void** features,[In, Buffer, Optional] const unsigned int* featureRangeLengths,[In] unsigned int featureRanges,[In] unsigned int maxGlyphCount,[Out, Buffer] unsigned short* clusterMap,[Out, Buffer] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,[Out, Buffer] unsigned short* glyphIndices,[Out, Buffer] DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,[Out] unsigned int* actualGlyphCount)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer::GetGlyphs</unmanaged-short>	
        internal void GetGlyphs(string textString, int textLength, SharpDX.DirectWrite.FontFace fontFace, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.Mathematics.Interop.RawBool isRightToLeft, SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, string localeName, SharpDX.DirectWrite.NumberSubstitution numberSubstitution, System.IntPtr features, int[] featureRangeLengths, int featureRanges, int maxGlyphCount, short[] clusterMap, SharpDX.DirectWrite.ShapingTextProperties[] textProps, short[] glyphIndices, SharpDX.DirectWrite.ShapingGlyphProperties[] glyphProps, out int actualGlyphCount)
        {
            unsafe
            {
                IntPtr textString_ = Utilities.StringToHGlobalUni(textString);
                IntPtr localeName_ = Utilities.StringToHGlobalUni(localeName);
                int[] featureRangeLengths__ = featureRangeLengths;
                SharpDX.Result __result__;
                fixed (void* featureRangeLengths_ = featureRangeLengths__)
                    fixed (void* clusterMap_ = clusterMap)
                        fixed (void* textProps_ = textProps)
                            fixed (void* glyphIndices_ = glyphIndices)
                                fixed (void* glyphProps_ = glyphProps)
                                    fixed (void* actualGlyphCount_ = &actualGlyphCount)
                                        __result__ =
                                        SharpDX.Direct2D1.LocalInterop.Calliint170(_nativePointer, (void*)textString_, textLength, (void*)((fontFace == null) ? IntPtr.Zero : fontFace.NativePointer), isSideways, isRightToLeft, &scriptAnalysis, (void*)localeName_, (void*)((numberSubstitution == null) ? IntPtr.Zero : numberSubstitution.NativePointer), (void*)features, featureRangeLengths_, featureRanges, maxGlyphCount, clusterMap_, textProps_, glyphIndices_, glyphProps_, actualGlyphCount_, ((void**)(*(void**)_nativePointer))[7]);
                Marshal.FreeHGlobal(textString_);
                Marshal.FreeHGlobal(localeName_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Places glyphs output from the <strong>GetGlyphs</strong> method according to the font  and the writing system's rendering rules. </p>	
        /// </summary>	
        /// <param name="textString">No documentation.</param>	
        /// <param name="clusterMap">No documentation.</param>	
        /// <param name="textProps">No documentation.</param>	
        /// <param name="textLength">No documentation.</param>	
        /// <param name="glyphIndices">No documentation.</param>	
        /// <param name="glyphProps">No documentation.</param>	
        /// <param name="glyphCount">No documentation.</param>	
        /// <param name="fontFace">No documentation.</param>	
        /// <param name="fontEmSize">No documentation.</param>	
        /// <param name="isSideways">No documentation.</param>	
        /// <param name="isRightToLeft">No documentation.</param>	
        /// <param name="scriptAnalysis">No documentation.</param>	
        /// <param name="localeName">No documentation.</param>	
        /// <param name="features">No documentation.</param>	
        /// <param name="featureRangeLengths">No documentation.</param>	
        /// <param name="featureRanges">No documentation.</param>	
        /// <param name="glyphAdvances">No documentation.</param>	
        /// <param name="glyphOffsets">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer::GetGlyphPlacements']/*"/>	
        /// <msdn-id>dd316622</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer::GetGlyphPlacements([In, Buffer] const wchar_t* textString,[In, Buffer] const unsigned short* clusterMap,[In, Buffer] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,[In] unsigned int textLength,[In, Buffer] const unsigned short* glyphIndices,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,[In] unsigned int glyphCount,[In] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,[In, Optional] const wchar_t* localeName,[In, Optional] const void** features,[In, Buffer, Optional] const unsigned int* featureRangeLengths,[In] unsigned int featureRanges,[Out, Buffer] float* glyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* glyphOffsets)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer::GetGlyphPlacements</unmanaged-short>	
        internal void GetGlyphPlacements(string textString, short[] clusterMap, SharpDX.DirectWrite.ShapingTextProperties[] textProps, int textLength, short[] glyphIndices, SharpDX.DirectWrite.ShapingGlyphProperties[] glyphProps, int glyphCount, SharpDX.DirectWrite.FontFace fontFace, float fontEmSize, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.Mathematics.Interop.RawBool isRightToLeft, SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, string localeName, System.IntPtr features, int[] featureRangeLengths, int featureRanges, float[] glyphAdvances, SharpDX.DirectWrite.GlyphOffset[] glyphOffsets)
        {
            unsafe
            {
                IntPtr textString_ = Utilities.StringToHGlobalUni(textString);
                IntPtr localeName_ = Utilities.StringToHGlobalUni(localeName);
                int[] featureRangeLengths__ = featureRangeLengths;
                SharpDX.Result __result__;
                fixed (void* clusterMap_ = clusterMap)
                    fixed (void* textProps_ = textProps)
                        fixed (void* glyphIndices_ = glyphIndices)
                            fixed (void* glyphProps_ = glyphProps)
                                fixed (void* featureRangeLengths_ = featureRangeLengths__)
                                    fixed (void* glyphAdvances_ = glyphAdvances)
                                        fixed (void* glyphOffsets_ = glyphOffsets)
                                            __result__ =
                                            SharpDX.Direct2D1.LocalInterop.Calliint171(_nativePointer, (void*)textString_, clusterMap_, textProps_, textLength, glyphIndices_, glyphProps_, glyphCount, (void*)((fontFace == null) ? IntPtr.Zero : fontFace.NativePointer), fontEmSize, isSideways, isRightToLeft, &scriptAnalysis, (void*)localeName_, (void*)features, featureRangeLengths_, featureRanges, glyphAdvances_, glyphOffsets_, ((void**)(*(void**)_nativePointer))[8]);
                Marshal.FreeHGlobal(textString_);
                Marshal.FreeHGlobal(localeName_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Place glyphs output from the <strong>GetGlyphs</strong> method according to the font  and the writing system's rendering rules.</p>	
        /// </summary>	
        /// <param name="textString">No documentation.</param>	
        /// <param name="clusterMap">No documentation.</param>	
        /// <param name="textProps">No documentation.</param>	
        /// <param name="textLength">No documentation.</param>	
        /// <param name="glyphIndices">No documentation.</param>	
        /// <param name="glyphProps">No documentation.</param>	
        /// <param name="glyphCount">No documentation.</param>	
        /// <param name="fontFace">No documentation.</param>	
        /// <param name="fontEmSize">No documentation.</param>	
        /// <param name="pixelsPerDip">No documentation.</param>	
        /// <param name="transform">No documentation.</param>	
        /// <param name="useGdiNatural">No documentation.</param>	
        /// <param name="isSideways">No documentation.</param>	
        /// <param name="isRightToLeft">No documentation.</param>	
        /// <param name="scriptAnalysis">No documentation.</param>	
        /// <param name="localeName">No documentation.</param>	
        /// <param name="features">No documentation.</param>	
        /// <param name="featureRangeLengths">No documentation.</param>	
        /// <param name="featureRanges">No documentation.</param>	
        /// <param name="glyphAdvances">No documentation.</param>	
        /// <param name="glyphOffsets">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer::GetGdiCompatibleGlyphPlacements']/*"/>	
        /// <msdn-id>dd941790</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer::GetGdiCompatibleGlyphPlacements([In, Buffer] const wchar_t* textString,[In, Buffer] const unsigned short* clusterMap,[In, Buffer] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,[In] unsigned int textLength,[In, Buffer] const unsigned short* glyphIndices,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,[In] unsigned int glyphCount,[In] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL useGdiNatural,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,[In, Optional] const wchar_t* localeName,[In, Optional] const void** features,[In, Buffer, Optional] const unsigned int* featureRangeLengths,[In] unsigned int featureRanges,[Out, Buffer] float* glyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* glyphOffsets)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer::GetGdiCompatibleGlyphPlacements</unmanaged-short>	
        internal void GetGdiCompatibleGlyphPlacements(string textString, short[] clusterMap, SharpDX.DirectWrite.ShapingTextProperties[] textProps, int textLength, short[] glyphIndices, SharpDX.DirectWrite.ShapingGlyphProperties[] glyphProps, int glyphCount, SharpDX.DirectWrite.FontFace fontFace, float fontEmSize, float pixelsPerDip, SharpDX.Mathematics.Interop.RawMatrix3x2? transform, SharpDX.Mathematics.Interop.RawBool useGdiNatural, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.Mathematics.Interop.RawBool isRightToLeft, SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, string localeName, System.IntPtr features, int[] featureRangeLengths, int featureRanges, float[] glyphAdvances, SharpDX.DirectWrite.GlyphOffset[] glyphOffsets)
        {
            unsafe
            {
                IntPtr textString_ = Utilities.StringToHGlobalUni(textString);
                SharpDX.Mathematics.Interop.RawMatrix3x2 transform_;
                if (transform.HasValue)
                    transform_ = transform.Value;
                IntPtr localeName_ = Utilities.StringToHGlobalUni(localeName);
                int[] featureRangeLengths__ = featureRangeLengths;
                SharpDX.Result __result__;
                fixed (void* clusterMap_ = clusterMap)
                    fixed (void* textProps_ = textProps)
                        fixed (void* glyphIndices_ = glyphIndices)
                            fixed (void* glyphProps_ = glyphProps)
                                fixed (void* featureRangeLengths_ = featureRangeLengths__)
                                    fixed (void* glyphAdvances_ = glyphAdvances)
                                        fixed (void* glyphOffsets_ = glyphOffsets)
                                            __result__ =
                                            SharpDX.Direct2D1.LocalInterop.Calliint172(_nativePointer, (void*)textString_, clusterMap_, textProps_, textLength, glyphIndices_, glyphProps_, glyphCount, (void*)((fontFace == null) ? IntPtr.Zero : fontFace.NativePointer), fontEmSize, pixelsPerDip, (transform.HasValue) ? &transform_ : (void*)IntPtr.Zero, useGdiNatural, isSideways, isRightToLeft, &scriptAnalysis, (void*)localeName_, (void*)features, featureRangeLengths_, featureRanges, glyphAdvances_, glyphOffsets_, ((void**)(*(void**)_nativePointer))[9]);
                Marshal.FreeHGlobal(textString_);
                Marshal.FreeHGlobal(localeName_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Analyzes various text properties for complex script processing.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer1']/*"/>	
    /// <msdn-id>Hh780428</msdn-id>	
    /// <unmanaged>IDWriteTextAnalyzer1</unmanaged>	
    /// <unmanaged-short>IDWriteTextAnalyzer1</unmanaged-short>	
    [Guid("80DAD800-E21F-4E83-96CE-BFCCE500DB7C")]
    public partial class TextAnalyzer1 : SharpDX.DirectWrite.TextAnalyzer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.TextAnalyzer1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TextAnalyzer1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.TextAnalyzer1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.TextAnalyzer1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.TextAnalyzer1(nativePointer);
        }


        /// <summary>	
        /// <p>Applies spacing between characters, properly adjusting glyph clusters and diacritics.</p>	
        /// </summary>	
        /// <param name="leadingSpacing"><dd> <p>The spacing before each character, in reading order.</p> </dd></param>	
        /// <param name="trailingSpacing"><dd> <p>The spacing after each character, in reading order.</p> </dd></param>	
        /// <param name="minimumAdvanceWidth"><dd> <p>The minimum advance of each character, to prevent characters from becoming too thin or zero-width. This must be zero or greater.</p> </dd></param>	
        /// <param name="textLength"><dd> <p>The length of the clustermap and original text.</p> </dd></param>	
        /// <param name="glyphCount"><dd> <p>The number of glyphs.</p> </dd></param>	
        /// <param name="clusterMap"><dd> <p>Mapping from character ranges to glyph ranges.</p> </dd></param>	
        /// <param name="glyphAdvances"><dd> <p>The advance width of each glyph.</p> </dd></param>	
        /// <param name="glyphOffsets"><dd> <p>The offset of the origin of each glyph.</p> </dd></param>	
        /// <param name="glyphProperties"><dd> <p>Properties of each glyph, from GetGlyphs.</p> </dd></param>	
        /// <param name="modifiedGlyphAdvances"><dd> <p>The new advance width of each glyph.</p> </dd></param>	
        /// <param name="modifiedGlyphOffsets"><dd> <p>The new offset of the origin of each glyph.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The input and output advances/offsets are allowed to alias the same array.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer1::ApplyCharacterSpacing']/*"/>	
        /// <msdn-id>Hh780430</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::ApplyCharacterSpacing([In] float leadingSpacing,[In] float trailingSpacing,[In] float minimumAdvanceWidth,[In] unsigned int textLength,[In] unsigned int glyphCount,[In, Buffer] const unsigned short* clusterMap,[In, Buffer] const float* glyphAdvances,[In, Buffer] const DWRITE_GLYPH_OFFSET* glyphOffsets,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProperties,[Out, Buffer] float* modifiedGlyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* modifiedGlyphOffsets)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer1::ApplyCharacterSpacing</unmanaged-short>	
        public void ApplyCharacterSpacing(float leadingSpacing, float trailingSpacing, float minimumAdvanceWidth, int textLength, int glyphCount, short[] clusterMap, float[] glyphAdvances, SharpDX.DirectWrite.GlyphOffset[] glyphOffsets, SharpDX.DirectWrite.ShapingGlyphProperties[] glyphProperties, float[] modifiedGlyphAdvances, SharpDX.DirectWrite.GlyphOffset[] modifiedGlyphOffsets)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* clusterMap_ = clusterMap)
                    fixed (void* glyphAdvances_ = glyphAdvances)
                        fixed (void* glyphOffsets_ = glyphOffsets)
                            fixed (void* glyphProperties_ = glyphProperties)
                                fixed (void* modifiedGlyphAdvances_ = modifiedGlyphAdvances)
                                    fixed (void* modifiedGlyphOffsets_ = modifiedGlyphOffsets)
                                        __result__ =
                                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, leadingSpacing, trailingSpacing, minimumAdvanceWidth, textLength, glyphCount, clusterMap_, glyphAdvances_, glyphOffsets_, glyphProperties_, modifiedGlyphAdvances_, modifiedGlyphOffsets_, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Retrieves the given baseline from the font.</p>	
        /// </summary>	
        /// <param name="fontFace"><dd>  <p>The font face to read.</p> </dd></param>	
        /// <param name="baseline"><dd>  <p>A <strong><see cref="SharpDX.DirectWrite.Baseline"/></strong>-typed value that specifies the baseline of interest.</p> </dd></param>	
        /// <param name="isVertical"><dd>  <p>Whether the baseline is vertical or horizontal.</p> </dd></param>	
        /// <param name="isSimulationAllowed"><dd>  <p>Simulate the baseline if it is missing in the font.</p> </dd></param>	
        /// <param name="scriptAnalysis"><dd>  <p>Script analysis result from AnalyzeScript.</p> <p><strong>Note</strong>??You can pass an empty script analysis structure, like this <code><see cref="SharpDX.DirectWrite.ScriptAnalysis"/> scriptAnalysis = {};</code>, and this method will return the default baseline.</p> </dd></param>	
        /// <param name="localeName"><dd>  <p>The language of the run.</p> </dd></param>	
        /// <param name="baselineCoordinate"><dd>  <p>The baseline coordinate value in design units.</p> </dd></param>	
        /// <param name="exists"><dd>  <p>Whether the returned baseline exists in the font.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If the baseline does not exist in the font, it is not considered an error, but the function will return exists = false. You may then use heuristics to calculate the missing base, or, if the flag simulationAllowed is true, the function will compute a reasonable approximation for you.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer1::GetBaseline']/*"/>	
        /// <msdn-id>Hh780431</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::GetBaseline([In] IDWriteFontFace* fontFace,[In] DWRITE_BASELINE baseline,[In] BOOL isVertical,[In] BOOL isSimulationAllowed,[In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[In, Optional] const wchar_t* localeName,[Out] int* baselineCoordinate,[Out] BOOL* exists)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer1::GetBaseline</unmanaged-short>	
        public void GetBaseline(SharpDX.DirectWrite.FontFace fontFace, SharpDX.DirectWrite.Baseline baseline, SharpDX.Mathematics.Interop.RawBool isVertical, SharpDX.Mathematics.Interop.RawBool isSimulationAllowed, SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, string localeName, out int baselineCoordinate, out SharpDX.Mathematics.Interop.RawBool exists)
        {
            unsafe
            {
                IntPtr localeName_ = Utilities.StringToHGlobalUni(localeName);
                exists = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* baselineCoordinate_ = &baselineCoordinate)
                    fixed (void* exists_ = &exists)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint182(_nativePointer, (void*)((fontFace == null) ? IntPtr.Zero : fontFace.NativePointer), unchecked((int)baseline), isVertical, isSimulationAllowed, scriptAnalysis, (void*)localeName_, baselineCoordinate_, exists_, ((void**)(*(void**)_nativePointer))[11]);
                Marshal.FreeHGlobal(localeName_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Analyzes a text range for script orientation, reading text and attributes from the source and reporting results to the sink callback <strong>SetGlyphOrientation</strong>.</p>	
        /// </summary>	
        /// <param name="analysisSource">No documentation.</param>	
        /// <param name="textPosition">No documentation.</param>	
        /// <param name="textLength">No documentation.</param>	
        /// <param name="analysisSink">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer1::AnalyzeVerticalGlyphOrientation']/*"/>	
        /// <msdn-id>Hh780429</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::AnalyzeVerticalGlyphOrientation([In] IDWriteTextAnalysisSource1* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteTextAnalysisSink1* analysisSink)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer1::AnalyzeVerticalGlyphOrientation</unmanaged-short>	
        internal void AnalyzeVerticalGlyphOrientation__(System.IntPtr analysisSource, int textPosition, int textLength, System.IntPtr analysisSink)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)analysisSource, textPosition, textLength, (void*)analysisSink, ((void**)(*(void**)_nativePointer))[12]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Returns 2x3 transform matrix for the respective angle to draw the glyph run.</p>	
        /// </summary>	
        /// <param name="glyphOrientationAngle"><dd>  <p>A <strong><see cref="SharpDX.DirectWrite.GlyphOrientationAngle"/></strong>-typed value that specifies the angle that was reported into <strong><see cref="SharpDX.DirectWrite.TextAnalysisSink1.SetGlyphOrientation"/></strong>.</p> </dd></param>	
        /// <param name="isSideways"><dd>  <p>Whether the run's glyphs are sideways or not.</p> </dd></param>	
        /// <param name="transform"><dd>  <p>Returned transform.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The translation component of the transform returned is zero.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer1::GetGlyphOrientationTransform']/*"/>	
        /// <msdn-id>Hh780432</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::GetGlyphOrientationTransform([In] DWRITE_GLYPH_ORIENTATION_ANGLE glyphOrientationAngle,[In] BOOL isSideways,[Out] DWRITE_MATRIX* transform)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer1::GetGlyphOrientationTransform</unmanaged-short>	
        public void GetGlyphOrientationTransform(SharpDX.DirectWrite.GlyphOrientationAngle glyphOrientationAngle, SharpDX.Mathematics.Interop.RawBool isSideways, out SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            unsafe
            {
                transform = new SharpDX.Mathematics.Interop.RawMatrix3x2();
                SharpDX.Result __result__;
                fixed (void* transform_ = &transform)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint183(_nativePointer, unchecked((int)glyphOrientationAngle), isSideways, transform_, ((void**)(*(void**)_nativePointer))[13]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Retrieves the properties for a given script.</p>	
        /// </summary>	
        /// <param name="scriptAnalysis"><dd>  <p>The script for a run of text returned from <strong><see cref="SharpDX.DirectWrite.TextAnalyzer.AnalyzeScript__"/></strong>.</p> </dd></param>	
        /// <param name="scriptProperties"><dd>  <p>A reference to a <strong><see cref="SharpDX.DirectWrite.ScriptProperties"/></strong> structure that describes info for the script.</p> </dd></param>	
        /// <returns><p>Returns properties for the given script. If the script is invalid, it returns generic properties for the unknown script and E_INVALIDARG.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer1::GetScriptProperties']/*"/>	
        /// <msdn-id>Hh780435</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::GetScriptProperties([In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[Out] DWRITE_SCRIPT_PROPERTIES* scriptProperties)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer1::GetScriptProperties</unmanaged-short>	
        public void GetScriptProperties(SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, out SharpDX.DirectWrite.ScriptProperties scriptProperties)
        {
            unsafe
            {
                scriptProperties = new SharpDX.DirectWrite.ScriptProperties();
                SharpDX.Result __result__;
                fixed (void* scriptProperties_ = &scriptProperties)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint184(_nativePointer, scriptAnalysis, scriptProperties_, ((void**)(*(void**)_nativePointer))[14]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Determines the complexity of text, and whether you need to call <strong><see cref="SharpDX.DirectWrite.TextAnalyzer.GetGlyphs"/></strong> for full script shaping. </p>	
        /// </summary>	
        /// <param name="textString">No documentation.</param>	
        /// <param name="textLength">No documentation.</param>	
        /// <param name="fontFace">No documentation.</param>	
        /// <param name="isTextSimple">No documentation.</param>	
        /// <param name="textLengthRead">No documentation.</param>	
        /// <param name="glyphIndices">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Text is not simple if the characters are part of a script that has complex shaping requirements, require bidi analysis, combine with other characters, reside in the supplementary planes, or have glyphs that participate in standard OpenType features. The length returned will not split combining marks from their base characters.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer1::GetTextComplexity']/*"/>	
        /// <msdn-id>Hh780436</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::GetTextComplexity([In, Buffer] const wchar_t* textString,[In] unsigned int textLength,[In] IDWriteFontFace* fontFace,[Out] BOOL* isTextSimple,[In] unsigned int* textLengthRead,[Out, Buffer, Optional] unsigned short* glyphIndices)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer1::GetTextComplexity</unmanaged-short>	
        public void GetTextComplexity(string textString, int textLength, SharpDX.DirectWrite.FontFace fontFace, out SharpDX.Mathematics.Interop.RawBool isTextSimple, int textLengthRead, short[] glyphIndices)
        {
            unsafe
            {
                IntPtr textString_ = Utilities.StringToHGlobalUni(textString);
                isTextSimple = new SharpDX.Mathematics.Interop.RawBool();
                short[] glyphIndices__ = glyphIndices;
                SharpDX.Result __result__;
                fixed (void* isTextSimple_ = &isTextSimple)
                    fixed (void* glyphIndices_ = glyphIndices__)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)textString_, textLength, (void*)((fontFace == null) ? IntPtr.Zero : fontFace.NativePointer), isTextSimple_, &textLengthRead, glyphIndices_, ((void**)(*(void**)_nativePointer))[15]);
                Marshal.FreeHGlobal(textString_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Retrieves justification opportunity information for each of the glyphs given the text and shaping glyph properties.</p>	
        /// </summary>	
        /// <param name="fontFace"><dd>  <p>Font face that was used for shaping. This is mainly important for returning correct results of the kashida width. </p> <p>May be <c>null</c>. </p> </dd></param>	
        /// <param name="fontEmSize"><dd>  <p>Font em size used for the glyph run.</p> </dd></param>	
        /// <param name="scriptAnalysis"><dd>  <p>Script of the text from the itemizer.</p> </dd></param>	
        /// <param name="textLength"><dd>  <p>Length of the text.</p> </dd></param>	
        /// <param name="glyphCount"><dd>  <p>Number of glyphs.</p> </dd></param>	
        /// <param name="textString"><dd>  <p>Characters used to produce the glyphs.</p> </dd></param>	
        /// <param name="clusterMap"><dd>  <p>Clustermap produced from shaping.</p> </dd></param>	
        /// <param name="glyphProperties"><dd>  <p>Glyph properties produced from shaping.</p> </dd></param>	
        /// <param name="justificationOpportunities"><dd>  <p>A reference to a <strong><see cref="SharpDX.DirectWrite.JustificationOpportunity"/></strong> structure that receives info for the allowed justification expansion/compression for each glyph.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This function is called per-run, after shaping is done via the <strong><see cref="SharpDX.DirectWrite.TextAnalyzer.GetGlyphs"/></strong> method. </p><p><strong>Note</strong>??this function only supports natural metrics (<strong><see cref="SharpDX.Direct2D1.MeasuringMode.Natural"/></strong>).</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer1::GetJustificationOpportunities']/*"/>	
        /// <msdn-id>Hh780433</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::GetJustificationOpportunities([In, Optional] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[In] unsigned int textLength,[In] unsigned int glyphCount,[In, Buffer] const wchar_t* textString,[In, Buffer] const unsigned short* clusterMap,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProperties,[Out, Buffer] DWRITE_JUSTIFICATION_OPPORTUNITY* justificationOpportunities)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer1::GetJustificationOpportunities</unmanaged-short>	
        public void GetJustificationOpportunities(SharpDX.DirectWrite.FontFace fontFace, float fontEmSize, SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, int textLength, int glyphCount, string textString, short[] clusterMap, SharpDX.DirectWrite.ShapingGlyphProperties[] glyphProperties, SharpDX.DirectWrite.JustificationOpportunity[] justificationOpportunities)
        {
            unsafe
            {
                IntPtr textString_ = Utilities.StringToHGlobalUni(textString);
                SharpDX.Result __result__;
                fixed (void* clusterMap_ = clusterMap)
                    fixed (void* glyphProperties_ = glyphProperties)
                        fixed (void* justificationOpportunities_ = justificationOpportunities)
                            __result__ =
                            SharpDX.Direct2D1.LocalInterop.Calliint186(_nativePointer, (void*)((fontFace == null) ? IntPtr.Zero : fontFace.NativePointer), fontEmSize, scriptAnalysis, textLength, glyphCount, (void*)textString_, clusterMap_, glyphProperties_, justificationOpportunities_, ((void**)(*(void**)_nativePointer))[16]);
                Marshal.FreeHGlobal(textString_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Justifies an array of glyph advances to fit the line width.</p>	
        /// </summary>	
        /// <param name="lineWidth"><dd>  <p>The line width.</p> </dd></param>	
        /// <param name="glyphCount"><dd>  <p>The glyph count.</p> </dd></param>	
        /// <param name="justificationOpportunities"><dd>  <p>A reference to a <strong><see cref="SharpDX.DirectWrite.JustificationOpportunity"/></strong> structure that contains info for the allowed justification expansion/compression for each glyph. Get this info from <strong><see cref="SharpDX.DirectWrite.TextAnalyzer1.GetJustificationOpportunities"/></strong>. </p> </dd></param>	
        /// <param name="glyphAdvances"><dd>  <p>An array of glyph advances.</p> </dd></param>	
        /// <param name="glyphOffsets"><dd>  <p>An array of glyph offsets.</p> </dd></param>	
        /// <param name="justifiedGlyphAdvances"><dd>  <p>The returned array of justified glyph advances.</p> </dd></param>	
        /// <param name="justifiedGlyphOffsets"><dd>  <p>The returned array of justified glyph offsets.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>You call  <strong>JustifyGlyphAdvances</strong> after you call <strong><see cref="SharpDX.DirectWrite.TextAnalyzer1.GetJustificationOpportunities"/></strong> to collect all the opportunities, and <strong>JustifyGlyphAdvances</strong> spans across the entire line. The input and output arrays are allowed to alias each other, permitting in-place update.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer1::JustifyGlyphAdvances']/*"/>	
        /// <msdn-id>Hh780437</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::JustifyGlyphAdvances([In] float lineWidth,[In] unsigned int glyphCount,[In, Buffer] const DWRITE_JUSTIFICATION_OPPORTUNITY* justificationOpportunities,[In, Buffer] const float* glyphAdvances,[In, Buffer] const DWRITE_GLYPH_OFFSET* glyphOffsets,[Out, Buffer] float* justifiedGlyphAdvances,[Out, Buffer, Optional] DWRITE_GLYPH_OFFSET* justifiedGlyphOffsets)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer1::JustifyGlyphAdvances</unmanaged-short>	
        public void JustifyGlyphAdvances(float lineWidth, int glyphCount, SharpDX.DirectWrite.JustificationOpportunity[] justificationOpportunities, float[] glyphAdvances, SharpDX.DirectWrite.GlyphOffset[] glyphOffsets, float[] justifiedGlyphAdvances, SharpDX.DirectWrite.GlyphOffset[] justifiedGlyphOffsets)
        {
            unsafe
            {
                SharpDX.DirectWrite.GlyphOffset[] justifiedGlyphOffsets__ = justifiedGlyphOffsets;
                SharpDX.Result __result__;
                fixed (void* justificationOpportunities_ = justificationOpportunities)
                    fixed (void* glyphAdvances_ = glyphAdvances)
                        fixed (void* glyphOffsets_ = glyphOffsets)
                            fixed (void* justifiedGlyphAdvances_ = justifiedGlyphAdvances)
                                fixed (void* justifiedGlyphOffsets_ = justifiedGlyphOffsets__)
                                    __result__ =
                                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, lineWidth, glyphCount, justificationOpportunities_, glyphAdvances_, glyphOffsets_, justifiedGlyphAdvances_, justifiedGlyphOffsets_, ((void**)(*(void**)_nativePointer))[17]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Fills in new glyphs for complex scripts where justification increased the advances of glyphs, such as Arabic with kashida.</p>	
        /// </summary>	
        /// <param name="fontFace"><dd>  <p>Font face used for shaping.</p> <p>May be <c>null</c>.</p> </dd></param>	
        /// <param name="fontEmSize"><dd>  <p>Font em size used for the glyph run.</p> </dd></param>	
        /// <param name="scriptAnalysis"><dd>  <p>Script of the text from the itemizer.</p> </dd></param>	
        /// <param name="textLength"><dd>  <p>Length of the text.</p> </dd></param>	
        /// <param name="glyphCount"><dd>  <p>Number of glyphs.</p> </dd></param>	
        /// <param name="maxGlyphCount"><dd>  <p>Maximum number of output glyphs allocated by caller.</p> </dd></param>	
        /// <param name="clusterMap"><dd>  <p>Clustermap produced from shaping.</p> </dd></param>	
        /// <param name="glyphIndices"><dd>  <p>Original glyphs produced from shaping.</p> </dd></param>	
        /// <param name="glyphAdvances"><dd>  <p>Original glyph advances produced from shaping.</p> </dd></param>	
        /// <param name="justifiedGlyphAdvances"><dd>  <p>Justified glyph advances from <strong><see cref="SharpDX.DirectWrite.TextAnalyzer1.JustifyGlyphAdvances"/></strong>. </p> </dd></param>	
        /// <param name="justifiedGlyphOffsets"><dd>  <p>Justified glyph offsets from <strong><see cref="SharpDX.DirectWrite.TextAnalyzer1.JustifyGlyphAdvances"/></strong>. </p> </dd></param>	
        /// <param name="glyphProperties"><dd>  <p>Properties of each glyph, from <strong><see cref="SharpDX.DirectWrite.TextAnalyzer.GetGlyphs"/></strong>. </p> </dd></param>	
        /// <param name="actualGlyphCount"><dd>  <p>The new glyph count written to the modified arrays, or the needed glyph count if the size is not large enough.</p> </dd></param>	
        /// <param name="modifiedClusterMap"><dd>  <p>Updated clustermap.</p> </dd></param>	
        /// <param name="modifiedGlyphIndices"><dd>  <p>Updated glyphs with new glyphs inserted where needed.</p> </dd></param>	
        /// <param name="modifiedGlyphAdvances"><dd>  <p>Updated glyph advances.</p> </dd></param>	
        /// <param name="modifiedGlyphOffsets"><dd>  <p>Updated glyph offsets.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>You call <strong>GetJustifiedGlyphs</strong> after the line has been justified, and it is per-run. </p><p>You should call <strong>GetJustifiedGlyphs</strong> if <strong><see cref="SharpDX.DirectWrite.TextAnalyzer1.GetScriptProperties"/></strong> returns a non-null <strong><see cref="SharpDX.DirectWrite.ScriptProperties"/>.justificationCharacter</strong> for that script.</p><p> Use  <strong>GetJustifiedGlyphs</strong> mainly for cursive scripts like Arabic. If <em>maxGlyphCount</em> is not large enough, <strong>GetJustifiedGlyphs</strong> returns the error E_NOT_SUFFICIENT_BUFFER and fills the variable  to which <em>actualGlyphCount</em> points with the needed glyph count.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextAnalyzer1::GetJustifiedGlyphs']/*"/>	
        /// <msdn-id>Hh780434</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextAnalyzer1::GetJustifiedGlyphs([In, Optional] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[In] unsigned int textLength,[In] unsigned int glyphCount,[In] unsigned int maxGlyphCount,[In, Buffer, Optional] const unsigned short* clusterMap,[In, Buffer] const unsigned short* glyphIndices,[In, Buffer] const float* glyphAdvances,[In, Buffer] const float* justifiedGlyphAdvances,[In, Buffer] const DWRITE_GLYPH_OFFSET* justifiedGlyphOffsets,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProperties,[In] unsigned int* actualGlyphCount,[Out, Buffer, Optional] unsigned short* modifiedClusterMap,[Out, Buffer] unsigned short* modifiedGlyphIndices,[Out, Buffer] float* modifiedGlyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* modifiedGlyphOffsets)</unmanaged>	
        /// <unmanaged-short>IDWriteTextAnalyzer1::GetJustifiedGlyphs</unmanaged-short>	
        public void GetJustifiedGlyphs(SharpDX.DirectWrite.FontFace fontFace, float fontEmSize, SharpDX.DirectWrite.ScriptAnalysis scriptAnalysis, int textLength, int glyphCount, int maxGlyphCount, short[] clusterMap, short[] glyphIndices, float[] glyphAdvances, float[] justifiedGlyphAdvances, SharpDX.DirectWrite.GlyphOffset[] justifiedGlyphOffsets, SharpDX.DirectWrite.ShapingGlyphProperties[] glyphProperties, int actualGlyphCount, short[] modifiedClusterMap, short[] modifiedGlyphIndices, float[] modifiedGlyphAdvances, SharpDX.DirectWrite.GlyphOffset[] modifiedGlyphOffsets)
        {
            unsafe
            {
                short[] clusterMap__ = clusterMap;
                short[] modifiedClusterMap__ = modifiedClusterMap;
                SharpDX.Result __result__;
                fixed (void* clusterMap_ = clusterMap__)
                    fixed (void* glyphIndices_ = glyphIndices)
                        fixed (void* glyphAdvances_ = glyphAdvances)
                            fixed (void* justifiedGlyphAdvances_ = justifiedGlyphAdvances)
                                fixed (void* justifiedGlyphOffsets_ = justifiedGlyphOffsets)
                                    fixed (void* glyphProperties_ = glyphProperties)
                                        fixed (void* modifiedClusterMap_ = modifiedClusterMap__)
                                            fixed (void* modifiedGlyphIndices_ = modifiedGlyphIndices)
                                                fixed (void* modifiedGlyphAdvances_ = modifiedGlyphAdvances)
                                                    fixed (void* modifiedGlyphOffsets_ = modifiedGlyphOffsets)
                                                        __result__ =
                                                        SharpDX.Direct2D1.LocalInterop.Calliint188(_nativePointer, (void*)((fontFace == null) ? IntPtr.Zero : fontFace.NativePointer), fontEmSize, scriptAnalysis, textLength, glyphCount, maxGlyphCount, clusterMap_, glyphIndices_, glyphAdvances_, justifiedGlyphAdvances_, justifiedGlyphOffsets_, glyphProperties_, &actualGlyphCount, modifiedClusterMap_, modifiedGlyphIndices_, modifiedGlyphAdvances_, modifiedGlyphOffsets_, ((void**)(*(void**)_nativePointer))[18]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> The <strong><see cref="SharpDX.DirectWrite.TextFormat"/></strong> interface describes the font and paragraph properties used to format text, and it describes locale information. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p> To get a reference to the <strong><see cref="SharpDX.DirectWrite.TextFormat"/></strong> interface, the application must call the <strong><see cref="SharpDX.DirectWrite.Factory.CreateTextFormat"/></strong> method as shown in the following code.</p><pre> if (SUCCEEDED(hr))	
    /// { hr = pDWriteFactory_-&gt;CreateTextFormat( L"Gabriola", <c>null</c>, <see cref="SharpDX.DirectWrite.FontWeight.Regular"/>, <see cref="SharpDX.DirectWrite.FontStyle.Normal"/>, <see cref="SharpDX.DirectWrite.FontStretch.Normal"/>, 72.0f, L"en-us", &amp;pTextFormat_ );	
    /// } </pre><p>When creating an <strong><see cref="SharpDX.DirectWrite.TextFormat"/></strong> object using the <strong>CreateTextFormat</strong> function, the application specifies the  font family, font collection, font weight, font size, and locale name for the text format.</p><p>These properties cannot be changed after the <strong><see cref="SharpDX.DirectWrite.TextFormat"/></strong> object is created.  To change these properties, a new <strong><see cref="SharpDX.DirectWrite.TextFormat"/></strong> object must be created with the desired properties.</p><p> The <strong><see cref="SharpDX.DirectWrite.TextFormat"/></strong> interface is used to draw text with a single format</p><p> To draw text with multiple formats, or to use a custom text renderer, use the <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> interface.  <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> enables the application to change the format for ranges of text within the string.  The <strong><see cref="SharpDX.DirectWrite.Factory.CreateTextLayout"/></strong> takes an <strong><see cref="SharpDX.DirectWrite.TextFormat"/></strong> object as a parameter and initially applies the format information to the entire string. </p><p> This object may not be thread-safe, and it may carry the state of text format change. </p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat']/*"/>	
    /// <msdn-id>dd316628</msdn-id>	
    /// <unmanaged>IDWriteTextFormat</unmanaged>	
    /// <unmanaged-short>IDWriteTextFormat</unmanaged-short>	
    [Guid("9c906818-31d7-4fd3-a151-7c5e225db55a")]
    public partial class TextFormat : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.TextFormat"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TextFormat(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.TextFormat"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.TextFormat(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.TextFormat(nativePointer);
        }


        /// <summary>	
        /// <p>Gets or sets the alignment option of text relative to the layout box's leading and trailing edge. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetTextAlignment']/*"/>	
        /// <msdn-id>dd316681</msdn-id>	
        /// <unmanaged>GetTextAlignment / SetTextAlignment</unmanaged>	
        /// <unmanaged-short>GetTextAlignment</unmanaged-short>	
        /// <unmanaged>DWRITE_TEXT_ALIGNMENT IDWriteTextFormat::GetTextAlignment()</unmanaged>
        public SharpDX.DirectWrite.TextAlignment TextAlignment
        {
            get { return GetTextAlignment(); }
            set { SetTextAlignment(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the alignment option of a paragraph which is  relative to the top and bottom edges of a layout box. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetParagraphAlignment']/*"/>	
        /// <msdn-id>dd316675</msdn-id>	
        /// <unmanaged>GetParagraphAlignment / SetParagraphAlignment</unmanaged>	
        /// <unmanaged-short>GetParagraphAlignment</unmanaged-short>	
        /// <unmanaged>DWRITE_PARAGRAPH_ALIGNMENT IDWriteTextFormat::GetParagraphAlignment()</unmanaged>
        public SharpDX.DirectWrite.ParagraphAlignment ParagraphAlignment
        {
            get { return GetParagraphAlignment(); }
            set { SetParagraphAlignment(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the word wrapping option. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetWordWrapping']/*"/>	
        /// <msdn-id>dd316688</msdn-id>	
        /// <unmanaged>GetWordWrapping / SetWordWrapping</unmanaged>	
        /// <unmanaged-short>GetWordWrapping</unmanaged-short>	
        /// <unmanaged>DWRITE_WORD_WRAPPING IDWriteTextFormat::GetWordWrapping()</unmanaged>
        public SharpDX.DirectWrite.WordWrapping WordWrapping
        {
            get { return GetWordWrapping(); }
            set { SetWordWrapping(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the  current reading direction for text in a paragraph. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetReadingDirection']/*"/>	
        /// <msdn-id>dd316678</msdn-id>	
        /// <unmanaged>GetReadingDirection / SetReadingDirection</unmanaged>	
        /// <unmanaged-short>GetReadingDirection</unmanaged-short>	
        /// <unmanaged>DWRITE_READING_DIRECTION IDWriteTextFormat::GetReadingDirection()</unmanaged>
        public SharpDX.DirectWrite.ReadingDirection ReadingDirection
        {
            get { return GetReadingDirection(); }
            set { SetReadingDirection(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the direction that text lines flow. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetFlowDirection']/*"/>	
        /// <msdn-id>dd316631</msdn-id>	
        /// <unmanaged>GetFlowDirection / SetFlowDirection</unmanaged>	
        /// <unmanaged-short>GetFlowDirection</unmanaged-short>	
        /// <unmanaged>DWRITE_FLOW_DIRECTION IDWriteTextFormat::GetFlowDirection()</unmanaged>
        public SharpDX.DirectWrite.FlowDirection FlowDirection
        {
            get { return GetFlowDirection(); }
            set { SetFlowDirection(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the  incremental tab stop position. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetIncrementalTabStop']/*"/>	
        /// <msdn-id>dd316655</msdn-id>	
        /// <unmanaged>GetIncrementalTabStop / SetIncrementalTabStop</unmanaged>	
        /// <unmanaged-short>GetIncrementalTabStop</unmanaged-short>	
        /// <unmanaged>float IDWriteTextFormat::GetIncrementalTabStop()</unmanaged>
        public float IncrementalTabStop
        {
            get { return GetIncrementalTabStop(); }
            set { SetIncrementalTabStop(value); }
        }

        /// <summary>	
        /// <p> Gets the current font collection. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetFontCollection']/*"/>	
        /// <msdn-id>dd316633</msdn-id>	
        /// <unmanaged>GetFontCollection</unmanaged>	
        /// <unmanaged-short>GetFontCollection</unmanaged-short>	
        /// <unmanaged>HRESULT IDWriteTextFormat::GetFontCollection([Out] IDWriteFontCollection** fontCollection)</unmanaged>
        public SharpDX.DirectWrite.FontCollection FontCollection
        {
            get { SharpDX.DirectWrite.FontCollection __output__; GetFontCollection(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Gets the font weight of the text. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetFontWeight']/*"/>	
        /// <msdn-id>dd316652</msdn-id>	
        /// <unmanaged>GetFontWeight</unmanaged>	
        /// <unmanaged-short>GetFontWeight</unmanaged-short>	
        /// <unmanaged>DWRITE_FONT_WEIGHT IDWriteTextFormat::GetFontWeight()</unmanaged>
        public SharpDX.DirectWrite.FontWeight FontWeight
        {
            get { return GetFontWeight(); }
        }

        /// <summary>	
        /// <p> Gets the font style of the text.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetFontStyle']/*"/>	
        /// <msdn-id>dd316649</msdn-id>	
        /// <unmanaged>GetFontStyle</unmanaged>	
        /// <unmanaged-short>GetFontStyle</unmanaged-short>	
        /// <unmanaged>DWRITE_FONT_STYLE IDWriteTextFormat::GetFontStyle()</unmanaged>
        public SharpDX.DirectWrite.FontStyle FontStyle
        {
            get { return GetFontStyle(); }
        }

        /// <summary>	
        /// <p> Gets the font stretch of the text. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetFontStretch']/*"/>	
        /// <msdn-id>dd316646</msdn-id>	
        /// <unmanaged>GetFontStretch</unmanaged>	
        /// <unmanaged-short>GetFontStretch</unmanaged-short>	
        /// <unmanaged>DWRITE_FONT_STRETCH IDWriteTextFormat::GetFontStretch()</unmanaged>
        public SharpDX.DirectWrite.FontStretch FontStretch
        {
            get { return GetFontStretch(); }
        }

        /// <summary>	
        /// <p> Gets the font  size in DIP unites. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetFontSize']/*"/>	
        /// <msdn-id>dd316643</msdn-id>	
        /// <unmanaged>GetFontSize</unmanaged>	
        /// <unmanaged-short>GetFontSize</unmanaged-short>	
        /// <unmanaged>float IDWriteTextFormat::GetFontSize()</unmanaged>
        public float FontSize
        {
            get { return GetFontSize(); }
        }

        /// <summary>	
        /// <p>Sets the alignment of text in a paragraph, relative to the leading and trailing edge of a layout box for a <strong><see cref="SharpDX.DirectWrite.TextFormat"/></strong> interface.</p>	
        /// </summary>	
        /// <param name="textAlignment">No documentation.</param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The textAlignment argument is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> The text can be aligned to the leading or trailing edge of the layout box, or it can be centered.  The following illustration shows text with the alignment set to <strong><see cref="SharpDX.DirectWrite.TextAlignment.Leading"/></strong>, <strong><see cref="SharpDX.DirectWrite.TextAlignment.Center"/></strong>, and <strong><see cref="SharpDX.DirectWrite.TextAlignment.Trailing"/></strong>, respectively.  </p><p></p><p><strong>Note</strong>??The alignment is dependent on reading direction, the above is for left-to-right reading direction.  For right-to-left reading direction it would be the opposite.</p><p>See <strong><see cref="SharpDX.DirectWrite.TextAlignment"/></strong> for more information. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::SetTextAlignment']/*"/>	
        /// <msdn-id>dd316709</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextFormat::SetTextAlignment([In] DWRITE_TEXT_ALIGNMENT textAlignment)</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::SetTextAlignment</unmanaged-short>	
        internal void SetTextAlignment(SharpDX.DirectWrite.TextAlignment textAlignment)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)textAlignment), ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the alignment option of a paragraph relative to the layout box's top and bottom edge. </p>	
        /// </summary>	
        /// <param name="paragraphAlignment"><dd>  <p>The paragraph alignment option being set for a paragraph; see <strong><see cref="SharpDX.DirectWrite.ParagraphAlignment"/></strong> for more information.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::SetParagraphAlignment']/*"/>	
        /// <msdn-id>dd316702</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextFormat::SetParagraphAlignment([In] DWRITE_PARAGRAPH_ALIGNMENT paragraphAlignment)</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::SetParagraphAlignment</unmanaged-short>	
        internal void SetParagraphAlignment(SharpDX.DirectWrite.ParagraphAlignment paragraphAlignment)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)paragraphAlignment), ((void**)(*(void**)_nativePointer))[4]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the word wrapping option. </p>	
        /// </summary>	
        /// <param name="wordWrapping"><dd>  <p>The word wrapping option being set for a paragraph; see <strong><see cref="SharpDX.DirectWrite.WordWrapping"/></strong> for more information.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::SetWordWrapping']/*"/>	
        /// <msdn-id>dd316715</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextFormat::SetWordWrapping([In] DWRITE_WORD_WRAPPING wordWrapping)</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::SetWordWrapping</unmanaged-short>	
        internal void SetWordWrapping(SharpDX.DirectWrite.WordWrapping wordWrapping)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)wordWrapping), ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the paragraph reading direction. </p>	
        /// </summary>	
        /// <param name="readingDirection"><dd>  <p>The text reading direction (for example, <strong><see cref="SharpDX.DirectWrite.ReadingDirection.RightToLeft"/></strong> for languages, such as  Arabic, that read from right to left) for a paragraph.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::SetReadingDirection']/*"/>	
        /// <msdn-id>dd316705</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextFormat::SetReadingDirection([In] DWRITE_READING_DIRECTION readingDirection)</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::SetReadingDirection</unmanaged-short>	
        internal void SetReadingDirection(SharpDX.DirectWrite.ReadingDirection readingDirection)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)readingDirection), ((void**)(*(void**)_nativePointer))[6]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the  paragraph flow direction. </p>	
        /// </summary>	
        /// <param name="flowDirection"><dd>  <p>The paragraph flow direction; see <strong><see cref="SharpDX.DirectWrite.FlowDirection"/></strong> for more information.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::SetFlowDirection']/*"/>	
        /// <msdn-id>dd316691</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextFormat::SetFlowDirection([In] DWRITE_FLOW_DIRECTION flowDirection)</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::SetFlowDirection</unmanaged-short>	
        internal void SetFlowDirection(SharpDX.DirectWrite.FlowDirection flowDirection)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)flowDirection), ((void**)(*(void**)_nativePointer))[7]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets a fixed distance between two adjacent tab stops. </p>	
        /// </summary>	
        /// <param name="incrementalTabStop"><dd>  <p>The fixed distance between two adjacent tab stops.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::SetIncrementalTabStop']/*"/>	
        /// <msdn-id>dd316695</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextFormat::SetIncrementalTabStop([In] float incrementalTabStop)</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::SetIncrementalTabStop</unmanaged-short>	
        internal void SetIncrementalTabStop(float incrementalTabStop)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, incrementalTabStop, ((void**)(*(void**)_nativePointer))[8]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets trimming options for text overflowing the layout width. </p>	
        /// </summary>	
        /// <param name="trimmingOptions"><dd>  <p>Text trimming options.</p> </dd></param>	
        /// <param name="trimmingSign"><dd>  <p>Application-defined omission sign. This parameter may be <strong><c>null</c></strong>. See <strong><see cref="SharpDX.DirectWrite.InlineObject"/></strong> for more information.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::SetTrimming']/*"/>	
        /// <msdn-id>dd316712</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextFormat::SetTrimming([In] const DWRITE_TRIMMING* trimmingOptions,[In, Optional] IDWriteInlineObject* trimmingSign)</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::SetTrimming</unmanaged-short>	
        internal void SetTrimming_(SharpDX.DirectWrite.Trimming trimmingOptions, System.IntPtr trimmingSign)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &trimmingOptions, (void*)trimmingSign, ((void**)(*(void**)_nativePointer))[9]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the  line spacing. </p>	
        /// </summary>	
        /// <param name="lineSpacingMethod"><dd>  <p>Specifies how line height is being determined; see <strong><see cref="SharpDX.DirectWrite.LineSpacingMethod"/></strong> for more information.</p> </dd></param>	
        /// <param name="lineSpacing"><dd>  <p>The line height, or distance between one baseline to another.</p> </dd></param>	
        /// <param name="baseline"><dd>  <p>The distance from top of line to baseline. A reasonable ratio to <em>lineSpacing</em> is 80 percent.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> For the default method, spacing depends solely on the content. For uniform spacing, the specified line height overrides the content. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::SetLineSpacing']/*"/>	
        /// <msdn-id>dd316698</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextFormat::SetLineSpacing([In] DWRITE_LINE_SPACING_METHOD lineSpacingMethod,[In] float lineSpacing,[In] float baseline)</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::SetLineSpacing</unmanaged-short>	
        public void SetLineSpacing(SharpDX.DirectWrite.LineSpacingMethod lineSpacingMethod, float lineSpacing, float baseline)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)lineSpacingMethod), lineSpacing, baseline, ((void**)(*(void**)_nativePointer))[10]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the alignment option of text relative to the layout box's leading and trailing edge. </p>	
        /// </summary>	
        /// <returns><p>Returns the text alignment option of the current paragraph.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetTextAlignment']/*"/>	
        /// <msdn-id>dd316681</msdn-id>	
        /// <unmanaged>DWRITE_TEXT_ALIGNMENT IDWriteTextFormat::GetTextAlignment()</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetTextAlignment</unmanaged-short>	
        internal SharpDX.DirectWrite.TextAlignment GetTextAlignment()
        {
            unsafe
            {
                SharpDX.DirectWrite.TextAlignment __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteTextAlignment(_nativePointer, ((void**)(*(void**)_nativePointer))[11]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the alignment option of a paragraph which is  relative to the top and bottom edges of a layout box. </p>	
        /// </summary>	
        /// <returns><p>A value that indicates the current paragraph alignment option.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetParagraphAlignment']/*"/>	
        /// <msdn-id>dd316675</msdn-id>	
        /// <unmanaged>DWRITE_PARAGRAPH_ALIGNMENT IDWriteTextFormat::GetParagraphAlignment()</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetParagraphAlignment</unmanaged-short>	
        internal SharpDX.DirectWrite.ParagraphAlignment GetParagraphAlignment()
        {
            unsafe
            {
                SharpDX.DirectWrite.ParagraphAlignment __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteParagraphAlignment(_nativePointer, ((void**)(*(void**)_nativePointer))[12]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the word wrapping option. </p>	
        /// </summary>	
        /// <returns><p>Returns the word wrapping option; see <strong><see cref="SharpDX.DirectWrite.WordWrapping"/></strong> for more information.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetWordWrapping']/*"/>	
        /// <msdn-id>dd316688</msdn-id>	
        /// <unmanaged>DWRITE_WORD_WRAPPING IDWriteTextFormat::GetWordWrapping()</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetWordWrapping</unmanaged-short>	
        internal SharpDX.DirectWrite.WordWrapping GetWordWrapping()
        {
            unsafe
            {
                SharpDX.DirectWrite.WordWrapping __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteWordWrapping(_nativePointer, ((void**)(*(void**)_nativePointer))[13]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the  current reading direction for text in a paragraph. </p>	
        /// </summary>	
        /// <returns><p>A value that indicates the current reading direction for text in a  paragraph.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetReadingDirection']/*"/>	
        /// <msdn-id>dd316678</msdn-id>	
        /// <unmanaged>DWRITE_READING_DIRECTION IDWriteTextFormat::GetReadingDirection()</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetReadingDirection</unmanaged-short>	
        internal SharpDX.DirectWrite.ReadingDirection GetReadingDirection()
        {
            unsafe
            {
                SharpDX.DirectWrite.ReadingDirection __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteReadingDirection(_nativePointer, ((void**)(*(void**)_nativePointer))[14]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the direction that text lines flow. </p>	
        /// </summary>	
        /// <returns><p>The direction that text lines flow within their parent container.  For example, <strong><see cref="SharpDX.DirectWrite.FlowDirection.TopToBottom"/></strong> indicates that text lines are placed from top to bottom.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetFlowDirection']/*"/>	
        /// <msdn-id>dd316631</msdn-id>	
        /// <unmanaged>DWRITE_FLOW_DIRECTION IDWriteTextFormat::GetFlowDirection()</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetFlowDirection</unmanaged-short>	
        internal SharpDX.DirectWrite.FlowDirection GetFlowDirection()
        {
            unsafe
            {
                SharpDX.DirectWrite.FlowDirection __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteFlowDirection(_nativePointer, ((void**)(*(void**)_nativePointer))[15]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the  incremental tab stop position. </p>	
        /// </summary>	
        /// <returns><p>The incremental tab stop value.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetIncrementalTabStop']/*"/>	
        /// <msdn-id>dd316655</msdn-id>	
        /// <unmanaged>float IDWriteTextFormat::GetIncrementalTabStop()</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetIncrementalTabStop</unmanaged-short>	
        internal float GetIncrementalTabStop()
        {
            unsafe
            {
                float __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callifloat(_nativePointer, ((void**)(*(void**)_nativePointer))[16]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the trimming options for text that overflows the layout box. </p>	
        /// </summary>	
        /// <param name="trimmingOptions"><dd>  <p>When this method returns, it contains a reference to a <strong><see cref="SharpDX.DirectWrite.Trimming"/></strong> structure that holds the text trimming options for the overflowing text.</p> </dd></param>	
        /// <param name="trimmingSign"><dd>  <p>When this method returns, contains an address of a reference to a trimming omission sign. This parameter may be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetTrimming']/*"/>	
        /// <msdn-id>dd316684</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextFormat::GetTrimming([Out] DWRITE_TRIMMING* trimmingOptions,[Out] IDWriteInlineObject** trimmingSign)</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetTrimming</unmanaged-short>	
        public void GetTrimming(out SharpDX.DirectWrite.Trimming trimmingOptions, out SharpDX.DirectWrite.InlineObject trimmingSign)
        {
            unsafe
            {
                trimmingOptions = new SharpDX.DirectWrite.Trimming();
                IntPtr trimmingSign_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* trimmingOptions_ = &trimmingOptions)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, trimmingOptions_, &trimmingSign_, ((void**)(*(void**)_nativePointer))[17]);
                trimmingSign = (trimmingSign_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.InlineObjectNative(trimmingSign_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the line spacing adjustment set for a multiline text paragraph. </p>	
        /// </summary>	
        /// <param name="lineSpacingMethod"><dd>  <p>A value that indicates how line height is determined.</p> </dd></param>	
        /// <param name="lineSpacing"><dd>  <p>When this method returns, contains the line height, or  distance between one baseline to another.</p> </dd></param>	
        /// <param name="baseline"><dd>  <p>When this method returns, contains the distance from top of line to baseline. A reasonable ratio to <em>lineSpacing</em> is 80 percent.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetLineSpacing']/*"/>	
        /// <msdn-id>dd316657</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextFormat::GetLineSpacing([Out] DWRITE_LINE_SPACING_METHOD* lineSpacingMethod,[Out] float* lineSpacing,[Out] float* baseline)</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetLineSpacing</unmanaged-short>	
        public void GetLineSpacing(out SharpDX.DirectWrite.LineSpacingMethod lineSpacingMethod, out float lineSpacing, out float baseline)
        {
            unsafe
            {
                SharpDX.Result __result__;
                fixed (void* lineSpacingMethod_ = &lineSpacingMethod)
                    fixed (void* lineSpacing_ = &lineSpacing)
                        fixed (void* baseline_ = &baseline)
                            __result__ =
                            SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, lineSpacingMethod_, lineSpacing_, baseline_, ((void**)(*(void**)_nativePointer))[18]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the current font collection. </p>	
        /// </summary>	
        /// <param name="fontCollection"><dd>  <p>When this method returns, contains an address of a reference to the font collection being used for the current text.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetFontCollection']/*"/>	
        /// <msdn-id>dd316633</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextFormat::GetFontCollection([Out] IDWriteFontCollection** fontCollection)</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetFontCollection</unmanaged-short>	
        internal void GetFontCollection(out SharpDX.DirectWrite.FontCollection fontCollection)
        {
            unsafe
            {
                IntPtr fontCollection_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &fontCollection_, ((void**)(*(void**)_nativePointer))[19]);
                fontCollection = (fontCollection_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.FontCollection(fontCollection_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the length of the font family name. </p>	
        /// </summary>	
        /// <returns><p>The size of the character array, in character count, not including the terminated <strong><c>null</c></strong> character.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetFontFamilyNameLength']/*"/>	
        /// <msdn-id>dd316640</msdn-id>	
        /// <unmanaged>unsigned int IDWriteTextFormat::GetFontFamilyNameLength()</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetFontFamilyNameLength</unmanaged-short>	
        internal int GetFontFamilyNameLength()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[20]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets a copy of the font family name. </p>	
        /// </summary>	
        /// <param name="fontFamilyName"><dd>  <p>When this method returns, contains a reference to a character array, which is null-terminated, that receives the current font family name. The buffer allocated for this array should be at least the size, in elements, of <em>nameSize</em>.</p> </dd></param>	
        /// <param name="nameSize"><dd>  <p>The size of the <em>fontFamilyName</em> character array, in character count, including the terminated <strong><c>null</c></strong> character.  To find the size of <em>fontFamilyName</em>, use <strong>GetFontFamilyNameLength</strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetFontFamilyName']/*"/>	
        /// <msdn-id>dd316636</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextFormat::GetFontFamilyName([Out, Buffer] wchar_t* fontFamilyName,[In] unsigned int nameSize)</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetFontFamilyName</unmanaged-short>	
        internal void GetFontFamilyName(System.IntPtr fontFamilyName, int nameSize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)fontFamilyName, nameSize, ((void**)(*(void**)_nativePointer))[21]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the font weight of the text. </p>	
        /// </summary>	
        /// <returns><p>A value that indicates the type of weight (such as normal, bold, or black). </p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetFontWeight']/*"/>	
        /// <msdn-id>dd316652</msdn-id>	
        /// <unmanaged>DWRITE_FONT_WEIGHT IDWriteTextFormat::GetFontWeight()</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetFontWeight</unmanaged-short>	
        internal SharpDX.DirectWrite.FontWeight GetFontWeight()
        {
            unsafe
            {
                SharpDX.DirectWrite.FontWeight __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteFontWeight(_nativePointer, ((void**)(*(void**)_nativePointer))[22]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the font style of the text.</p>	
        /// </summary>	
        /// <returns><p>A value which indicates the type of font style (such as  slope or incline).</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetFontStyle']/*"/>	
        /// <msdn-id>dd316649</msdn-id>	
        /// <unmanaged>DWRITE_FONT_STYLE IDWriteTextFormat::GetFontStyle()</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetFontStyle</unmanaged-short>	
        internal SharpDX.DirectWrite.FontStyle GetFontStyle()
        {
            unsafe
            {
                SharpDX.DirectWrite.FontStyle __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteFontStyle(_nativePointer, ((void**)(*(void**)_nativePointer))[23]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the font stretch of the text. </p>	
        /// </summary>	
        /// <returns><p>A value which indicates the type of font stretch (such as  normal or condensed).</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetFontStretch']/*"/>	
        /// <msdn-id>dd316646</msdn-id>	
        /// <unmanaged>DWRITE_FONT_STRETCH IDWriteTextFormat::GetFontStretch()</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetFontStretch</unmanaged-short>	
        internal SharpDX.DirectWrite.FontStretch GetFontStretch()
        {
            unsafe
            {
                SharpDX.DirectWrite.FontStretch __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.CalliSharpDXDirectWriteFontStretch(_nativePointer, ((void**)(*(void**)_nativePointer))[24]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the font  size in DIP unites. </p>	
        /// </summary>	
        /// <returns><p>The current font size in DIP units.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetFontSize']/*"/>	
        /// <msdn-id>dd316643</msdn-id>	
        /// <unmanaged>float IDWriteTextFormat::GetFontSize()</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetFontSize</unmanaged-short>	
        internal float GetFontSize()
        {
            unsafe
            {
                float __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callifloat(_nativePointer, ((void**)(*(void**)_nativePointer))[25]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the length of the locale name. </p>	
        /// </summary>	
        /// <returns><p>The size of the character array in character count, not including the terminated <strong><c>null</c></strong> character.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetLocaleNameLength']/*"/>	
        /// <msdn-id>dd316674</msdn-id>	
        /// <unmanaged>unsigned int IDWriteTextFormat::GetLocaleNameLength()</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetLocaleNameLength</unmanaged-short>	
        internal int GetLocaleNameLength()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[26]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets a copy of the locale name. </p>	
        /// </summary>	
        /// <param name="localeName"><dd>  <p>Contains a character array that receives the current locale name.</p> </dd></param>	
        /// <param name="nameSize"><dd>  <p>The size of the character array, in character count, including the terminated <strong><c>null</c></strong> character. Use <strong>GetLocaleNameLength</strong> to get the size of the locale name character array.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextFormat::GetLocaleName']/*"/>	
        /// <msdn-id>dd316659</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextFormat::GetLocaleName([Out, Buffer] wchar_t* localeName,[In] unsigned int nameSize)</unmanaged>	
        /// <unmanaged-short>IDWriteTextFormat::GetLocaleName</unmanaged-short>	
        internal void GetLocaleName(System.IntPtr localeName, int nameSize)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)localeName, nameSize, ((void**)(*(void**)_nativePointer))[27]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> interface represents a block of text after it has been fully analyzed and formatted.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To get a reference to the <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> interface, the application must call the <strong><see cref="SharpDX.DirectWrite.Factory.CreateTextLayout"/></strong> method, as shown in the following code.  </p><pre> // Create a text layout using the text format.	
    /// if (SUCCEEDED(hr))	
    /// { <see cref="SharpDX.Mathematics.Interop.RawRectangle"/> rect; GetClientRect(hwnd_, &amp;rect);  float width  = rect.right  / dpiScaleX_; float height = rect.bottom / dpiScaleY_; hr = pDWriteFactory_-&gt;CreateTextLayout( wszText_,      // The string to be laid out and formatted. cTextLength_,  // The length of the string. pTextFormat_,  // The text format to apply to the string (contains font information, etc). width,         // The width of the layout box. height,        // The height of the layout box. &amp;pTextLayout_  // The <see cref="SharpDX.DirectWrite.TextLayout"/> interface reference. );	
    /// } </pre><p>The <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> interface allows the application to change the format for ranges of the text it represents, specified by a <strong><see cref="SharpDX.DirectWrite.TextRange"/></strong> structure.   The following example shows how to set the font weight for a text range.</p><pre> // Set the font weight to bold for the first 5 letters.	
    /// <see cref="SharpDX.DirectWrite.TextRange"/> textRange = {0, 4}; if (SUCCEEDED(hr))	
    /// { hr = pTextLayout_-&gt;SetFontWeight(<see cref="SharpDX.DirectWrite.FontWeight.Bold"/>, textRange);	
    /// } </pre><p><strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> also provides methods for adding strikethrough,  underline, and inline objects to the text.</p><p>To draw the block of text represented by an <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong> object, Direct2D provides the <strong><see cref="SharpDX.Direct2D1.RenderTarget.DrawTextLayout"/></strong> method. To draw using a custom renderer implement an <strong><see cref="SharpDX.DirectWrite.TextRenderer"/></strong> interface and  call the  <strong><see cref="SharpDX.DirectWrite.TextLayout.Draw_"/></strong> method</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout']/*"/>	
    /// <msdn-id>dd316718</msdn-id>	
    /// <unmanaged>IDWriteTextLayout</unmanaged>	
    /// <unmanaged-short>IDWriteTextLayout</unmanaged-short>	
    [Guid("53737037-6d14-410b-9bfe-0b182bb70961")]
    public partial class TextLayout : SharpDX.DirectWrite.TextFormat
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.TextLayout"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TextLayout(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.TextLayout"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.TextLayout(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.TextLayout(nativePointer);
        }


        /// <summary>	
        /// <p>Gets or sets the layout maximum width. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetMaxWidth']/*"/>	
        /// <msdn-id>dd316781</msdn-id>	
        /// <unmanaged>GetMaxWidth / SetMaxWidth</unmanaged>	
        /// <unmanaged-short>GetMaxWidth</unmanaged-short>	
        /// <unmanaged>float IDWriteTextLayout::GetMaxWidth()</unmanaged>
        public float MaxWidth
        {
            get { return GetMaxWidth(); }
            set { SetMaxWidth(value); }
        }

        /// <summary>	
        /// <p>Gets or sets the layout maximum height. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetMaxHeight']/*"/>	
        /// <msdn-id>dd316776</msdn-id>	
        /// <unmanaged>GetMaxHeight / SetMaxHeight</unmanaged>	
        /// <unmanaged-short>GetMaxHeight</unmanaged-short>	
        /// <unmanaged>float IDWriteTextLayout::GetMaxHeight()</unmanaged>
        public float MaxHeight
        {
            get { return GetMaxHeight(); }
            set { SetMaxHeight(value); }
        }

        /// <summary>	
        /// <p> Retrieves overall metrics for the formatted string. </p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetMetrics']/*"/>	
        /// <msdn-id>dd316785</msdn-id>	
        /// <unmanaged>GetMetrics</unmanaged>	
        /// <unmanaged-short>GetMetrics</unmanaged-short>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetMetrics([Out] DWRITE_TEXT_METRICS* textMetrics)</unmanaged>
        public SharpDX.DirectWrite.TextMetrics Metrics
        {
            get { SharpDX.DirectWrite.TextMetrics __output__; GetMetrics(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p>Returns the overhangs (in DIPs) of the layout and all objects contained in it, including text glyphs and inline objects.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Underlines and strikethroughs do not contribute to the black box determination, since these are actually drawn by the renderer, which is allowed to draw them in any variety of styles.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetOverhangMetrics']/*"/>	
        /// <msdn-id>dd316790</msdn-id>	
        /// <unmanaged>GetOverhangMetrics</unmanaged>	
        /// <unmanaged-short>GetOverhangMetrics</unmanaged-short>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetOverhangMetrics([Out] DWRITE_OVERHANG_METRICS* overhangs)</unmanaged>
        public SharpDX.DirectWrite.OverhangMetrics OverhangMetrics
        {
            get { SharpDX.DirectWrite.OverhangMetrics __output__; GetOverhangMetrics(out __output__); return __output__; }
        }

        /// <summary>	
        /// <p> Sets the layout maximum width.</p>	
        /// </summary>	
        /// <param name="maxWidth"><dd>  <p>A value that indicates the maximum width of the layout box.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::SetMaxWidth']/*"/>	
        /// <msdn-id>dd371511</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::SetMaxWidth([In] float maxWidth)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::SetMaxWidth</unmanaged-short>	
        internal void SetMaxWidth(float maxWidth)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, maxWidth, ((void**)(*(void**)_nativePointer))[28]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the layout maximum height. </p>	
        /// </summary>	
        /// <param name="maxHeight"><dd>  <p>A value that indicates the maximum height of the layout box. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::SetMaxHeight']/*"/>	
        /// <msdn-id>dd371507</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::SetMaxHeight([In] float maxHeight)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::SetMaxHeight</unmanaged-short>	
        internal void SetMaxHeight(float maxHeight)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, maxHeight, ((void**)(*(void**)_nativePointer))[29]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the font collection. </p>	
        /// </summary>	
        /// <param name="fontCollection"><dd>  <p>The font collection to set.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::SetFontCollection']/*"/>	
        /// <msdn-id>dd371481</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::SetFontCollection([In] IDWriteFontCollection* fontCollection,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::SetFontCollection</unmanaged-short>	
        public void SetFontCollection(SharpDX.DirectWrite.FontCollection fontCollection, SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint138(_nativePointer, (void*)((fontCollection == null) ? IntPtr.Zero : fontCollection.NativePointer), textRange, ((void**)(*(void**)_nativePointer))[30]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets null-terminated font family name for text within a specified  text range. </p>	
        /// </summary>	
        /// <param name="fontFamilyName"><dd>  <p>The font family name that applies to the entire text string within the range specified by <em>textRange</em>.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::SetFontFamilyName']/*"/>	
        /// <msdn-id>dd371487</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::SetFontFamilyName([In] const wchar_t* fontFamilyName,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::SetFontFamilyName</unmanaged-short>	
        public void SetFontFamilyName(string fontFamilyName, SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                IntPtr fontFamilyName_ = Utilities.StringToHGlobalUni(fontFamilyName);
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint138(_nativePointer, (void*)fontFamilyName_, textRange, ((void**)(*(void**)_nativePointer))[31]);
                Marshal.FreeHGlobal(fontFamilyName_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the font weight for text within a text range specified by a <strong><see cref="SharpDX.DirectWrite.TextRange"/></strong> structure. </p>	
        /// </summary>	
        /// <param name="fontWeight">No documentation.</param>	
        /// <param name="textRange">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The font weight can be set to one of the predefined font weight values provided in the <strong><see cref="SharpDX.DirectWrite.FontWeight"/></strong> enumeration or an integer from 1 to 999.  Values outside this range will cause the method to fail with an <strong>E_INVALIDARG</strong> return value.</p><p>The following illustration shows an example of Normal and UltraBold weights for the Palatino Linotype typeface.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::SetFontWeight']/*"/>	
        /// <msdn-id>dd371498</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::SetFontWeight([In] DWRITE_FONT_WEIGHT fontWeight,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::SetFontWeight</unmanaged-short>	
        public void SetFontWeight(SharpDX.DirectWrite.FontWeight fontWeight, SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint139(_nativePointer, unchecked((int)fontWeight), textRange, ((void**)(*(void**)_nativePointer))[32]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the font style for  text within a text range specified by a <strong><see cref="SharpDX.DirectWrite.TextRange"/></strong> structure.</p>	
        /// </summary>	
        /// <param name="fontStyle">No documentation.</param>	
        /// <param name="textRange">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The font style can be set to Normal, Italic or Oblique. The following illustration shows  three styles for the Palatino font.  For more information, see <strong><see cref="SharpDX.DirectWrite.FontStyle"/></strong>.</p><p></p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::SetFontStyle']/*"/>	
        /// <msdn-id>dd371495</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::SetFontStyle([In] DWRITE_FONT_STYLE fontStyle,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::SetFontStyle</unmanaged-short>	
        public void SetFontStyle(SharpDX.DirectWrite.FontStyle fontStyle, SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint139(_nativePointer, unchecked((int)fontStyle), textRange, ((void**)(*(void**)_nativePointer))[33]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the  font stretch for text within a specified text range. </p>	
        /// </summary>	
        /// <param name="fontStretch"><dd>  <p>A value which indicates the type of font stretch for text within the range specified by <em>textRange</em>.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::SetFontStretch']/*"/>	
        /// <msdn-id>dd371493</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::SetFontStretch([In] DWRITE_FONT_STRETCH fontStretch,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::SetFontStretch</unmanaged-short>	
        public void SetFontStretch(SharpDX.DirectWrite.FontStretch fontStretch, SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint139(_nativePointer, unchecked((int)fontStretch), textRange, ((void**)(*(void**)_nativePointer))[34]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the font size in DIP units for text within a specified text range. </p>	
        /// </summary>	
        /// <param name="fontSize"><dd>  <p>The  font size in DIP units to be set for   text in the range specified by <em>textRange</em>. </p> </dd></param>	
        /// <param name="textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::SetFontSize']/*"/>	
        /// <msdn-id>dd371490</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::SetFontSize([In] float fontSize,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::SetFontSize</unmanaged-short>	
        public void SetFontSize(float fontSize, SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint140(_nativePointer, fontSize, textRange, ((void**)(*(void**)_nativePointer))[35]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets underlining for text within a specified text range. </p>	
        /// </summary>	
        /// <param name="hasUnderline"><dd>  <p>A Boolean flag that indicates whether underline takes place within a specified text range.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::SetUnderline']/*"/>	
        /// <msdn-id>dd371518</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::SetUnderline([In] BOOL hasUnderline,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::SetUnderline</unmanaged-short>	
        public void SetUnderline(SharpDX.Mathematics.Interop.RawBool hasUnderline, SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint141(_nativePointer, hasUnderline, textRange, ((void**)(*(void**)_nativePointer))[36]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets strikethrough for text within a specified text range. </p>	
        /// </summary>	
        /// <param name="hasStrikethrough"><dd>  <p>A Boolean flag that indicates whether strikethrough takes place in the range specified by <em>textRange</em>.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::SetStrikethrough']/*"/>	
        /// <msdn-id>dd371514</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::SetStrikethrough([In] BOOL hasStrikethrough,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::SetStrikethrough</unmanaged-short>	
        public void SetStrikethrough(SharpDX.Mathematics.Interop.RawBool hasStrikethrough, SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint141(_nativePointer, hasStrikethrough, textRange, ((void**)(*(void**)_nativePointer))[37]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the application-defined drawing effect. </p>	
        /// </summary>	
        /// <param name="drawingEffect"><dd>  <p>Application-defined drawing effects that apply to the range. This data object will be passed back to the application's drawing callbacks for final rendering.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The text range to which this change applies.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>An <strong><see cref="SharpDX.Direct2D1.Brush"/></strong>, such as a color or gradient brush, can be set as a drawing effect if you are using the <strong><see cref="SharpDX.Direct2D1.RenderTarget.DrawTextLayout"/></strong> to draw text and that brush will be used to draw the specified range of text.</p><p> This drawing effect is associated with the specified range and will be passed back to the application by way of the callback when the range is drawn at drawing time. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::SetDrawingEffect']/*"/>	
        /// <msdn-id>dd371477</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::SetDrawingEffect([In] void* drawingEffect,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::SetDrawingEffect</unmanaged-short>	
        internal void SetDrawingEffect_(System.IntPtr drawingEffect, SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint138(_nativePointer, (void*)drawingEffect, textRange, ((void**)(*(void**)_nativePointer))[38]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the inline object. </p>	
        /// </summary>	
        /// <param name="inlineObject"><dd>  <p>An application-defined inline object. </p> </dd></param>	
        /// <param name="textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The application may call this function to specify the set of properties describing an application-defined inline object for specific range.</p><p> This inline object applies to the specified range and will be passed back to the application by way of the <strong>DrawInlineObject</strong> callback when the range is drawn. Any text in that range will be suppressed. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::SetInlineObject']/*"/>	
        /// <msdn-id>dd371500</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::SetInlineObject([In] IDWriteInlineObject* inlineObject,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::SetInlineObject</unmanaged-short>	
        internal void SetInlineObject_(System.IntPtr inlineObject, SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint138(_nativePointer, (void*)inlineObject, textRange, ((void**)(*(void**)_nativePointer))[39]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets  font typography features for text within a specified text range. </p>	
        /// </summary>	
        /// <param name="typography"><dd>  <p>Pointer to font typography settings. </p> </dd></param>	
        /// <param name="textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::SetTypography']/*"/>	
        /// <msdn-id>dd371517</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::SetTypography([In] IDWriteTypography* typography,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::SetTypography</unmanaged-short>	
        public void SetTypography(SharpDX.DirectWrite.Typography typography, SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint138(_nativePointer, (void*)((typography == null) ? IntPtr.Zero : typography.NativePointer), textRange, ((void**)(*(void**)_nativePointer))[40]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Sets the locale name for text within a specified text range.</p>	
        /// </summary>	
        /// <param name="localeName"><dd>  <p>A null-terminated locale name string.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::SetLocaleName']/*"/>	
        /// <msdn-id>dd371503</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::SetLocaleName([In] const wchar_t* localeName,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::SetLocaleName</unmanaged-short>	
        public void SetLocaleName(string localeName, SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                IntPtr localeName_ = Utilities.StringToHGlobalUni(localeName);
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint138(_nativePointer, (void*)localeName_, textRange, ((void**)(*(void**)_nativePointer))[41]);
                Marshal.FreeHGlobal(localeName_);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the layout maximum width. </p>	
        /// </summary>	
        /// <returns><p>Returns the layout maximum width.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetMaxWidth']/*"/>	
        /// <msdn-id>dd316781</msdn-id>	
        /// <unmanaged>float IDWriteTextLayout::GetMaxWidth()</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetMaxWidth</unmanaged-short>	
        internal float GetMaxWidth()
        {
            unsafe
            {
                float __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callifloat(_nativePointer, ((void**)(*(void**)_nativePointer))[42]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the layout maximum height. </p>	
        /// </summary>	
        /// <returns><p>The layout maximum height.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetMaxHeight']/*"/>	
        /// <msdn-id>dd316776</msdn-id>	
        /// <unmanaged>float IDWriteTextLayout::GetMaxHeight()</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetMaxHeight</unmanaged-short>	
        internal float GetMaxHeight()
        {
            unsafe
            {
                float __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Callifloat(_nativePointer, ((void**)(*(void**)_nativePointer))[43]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the font collection associated with the text at the specified position. </p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the underline.</p> </dd></param>	
        /// <returns><dd>  <p>Contains an address of a  reference to the current font collection.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetFontCollection']/*"/>	
        /// <msdn-id>dd316735</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetFontCollection([In] unsigned int currentPosition,[Out] IDWriteFontCollection** fontCollection,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetFontCollection</unmanaged-short>	
        public SharpDX.DirectWrite.FontCollection GetFontCollection(int currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.DirectWrite.FontCollection fontCollection;
                IntPtr fontCollection_ = IntPtr.Zero;
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, &fontCollection_, textRange_, ((void**)(*(void**)_nativePointer))[44]);
                fontCollection = (fontCollection_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.FontCollection(fontCollection_);
                __result__.CheckError();
                return fontCollection;
            }
        }

        /// <summary>	
        /// <p> Get the length of the font family name at the current position. </p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The current text position.</p> </dd></param>	
        /// <param name="nameLength"><dd>  <p>When this method returns, contains the size of the character array containing the font family name, in character count, not including the terminated <strong><c>null</c></strong> character.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font family.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetFontFamilyNameLength']/*"/>	
        /// <msdn-id>dd316741</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetFontFamilyNameLength([In] unsigned int currentPosition,[Out] unsigned int* nameLength,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetFontFamilyNameLength</unmanaged-short>	
        internal void GetFontFamilyNameLength(int currentPosition, out int nameLength, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* nameLength_ = &nameLength)
                    fixed (void* textRange_ = &textRange)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, nameLength_, textRange_, ((void**)(*(void**)_nativePointer))[45]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Copies the font family name of the text at the specified position. </p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The position of the text to examine.</p> </dd></param>	
        /// <param name="fontFamilyName"><dd>  <p>When this method returns, contains an array of characters that receives the current font family name. You must allocate storage for this parameter.</p> </dd></param>	
        /// <param name="nameSize"><dd>  <p>The size of the character array in character count including the terminated <strong><c>null</c></strong> character.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font family name.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetFontFamilyName']/*"/>	
        /// <msdn-id>dd316738</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetFontFamilyName([In] unsigned int currentPosition,[Out, Buffer] wchar_t* fontFamilyName,[In] unsigned int nameSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetFontFamilyName</unmanaged-short>	
        internal void GetFontFamilyName(int currentPosition, System.IntPtr fontFamilyName, int nameSize, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, (void*)fontFamilyName, nameSize, textRange_, ((void**)(*(void**)_nativePointer))[46]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the font weight of the text at the specified position. </p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font weight.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains a value which indicates the type of font weight being applied at the specified position.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetFontWeight']/*"/>	
        /// <msdn-id>dd316753</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetFontWeight([In] unsigned int currentPosition,[Out] DWRITE_FONT_WEIGHT* fontWeight,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetFontWeight</unmanaged-short>	
        public SharpDX.DirectWrite.FontWeight GetFontWeight(int currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.DirectWrite.FontWeight fontWeight;
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, &fontWeight, textRange_, ((void**)(*(void**)_nativePointer))[47]);
                __result__.CheckError();
                return fontWeight;
            }
        }

        /// <summary>	
        /// <p> Gets the font style (also known as slope) of the text at the specified position. </p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font style.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains a value which indicates the type of font style (also known as slope or incline) being applied at the specified position.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetFontStyle']/*"/>	
        /// <msdn-id>dd316750</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetFontStyle([In] unsigned int currentPosition,[Out] DWRITE_FONT_STYLE* fontStyle,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetFontStyle</unmanaged-short>	
        public SharpDX.DirectWrite.FontStyle GetFontStyle(int currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.DirectWrite.FontStyle fontStyle;
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, &fontStyle, textRange_, ((void**)(*(void**)_nativePointer))[48]);
                __result__.CheckError();
                return fontStyle;
            }
        }

        /// <summary>	
        /// <p> Gets the font stretch of the text at the specified position. </p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font stretch.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains a value which indicates the type of font stretch (also known as width) being applied at the specified position.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetFontStretch']/*"/>	
        /// <msdn-id>dd316747</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetFontStretch([In] unsigned int currentPosition,[Out] DWRITE_FONT_STRETCH* fontStretch,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetFontStretch</unmanaged-short>	
        public SharpDX.DirectWrite.FontStretch GetFontStretch(int currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.DirectWrite.FontStretch fontStretch;
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, &fontStretch, textRange_, ((void**)(*(void**)_nativePointer))[49]);
                __result__.CheckError();
                return fontStretch;
            }
        }

        /// <summary>	
        /// <p> Gets the font em height of the text at the specified position. </p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font size.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains the size of the font in ems  of the text at the specified position.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetFontSize']/*"/>	
        /// <msdn-id>dd316745</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetFontSize([In] unsigned int currentPosition,[Out] float* fontSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetFontSize</unmanaged-short>	
        public float GetFontSize(int currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                float fontSize;
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, &fontSize, textRange_, ((void**)(*(void**)_nativePointer))[50]);
                __result__.CheckError();
                return fontSize;
            }
        }

        /// <summary>	
        /// <p> Gets the underline presence of the text at the specified position. </p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The current text position.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the underline.</p> </dd></param>	
        /// <returns><dd>  <p>A Boolean  flag that indicates whether underline is present at the position indicated by <em>currentPosition</em>.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetUnderline']/*"/>	
        /// <msdn-id>dd371463</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetUnderline([In] unsigned int currentPosition,[Out] BOOL* hasUnderline,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetUnderline</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool HasUnderline(int currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool hasUnderline;
                hasUnderline = new SharpDX.Mathematics.Interop.RawBool();
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, &hasUnderline, textRange_, ((void**)(*(void**)_nativePointer))[51]);
                __result__.CheckError();
                return hasUnderline;
            }
        }

        /// <summary>	
        /// <p> Get the strikethrough presence of the text at the specified position. </p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>Contains the range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to strikethrough.</p> </dd></param>	
        /// <returns><dd>  <p>A Boolean  flag that indicates whether strikethrough is present at the position indicated by <em>currentPosition</em>.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetStrikethrough']/*"/>	
        /// <msdn-id>dd316793</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetStrikethrough([In] unsigned int currentPosition,[Out] BOOL* hasStrikethrough,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetStrikethrough</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool HasStrikethrough(int currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.Mathematics.Interop.RawBool hasStrikethrough;
                hasStrikethrough = new SharpDX.Mathematics.Interop.RawBool();
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, &hasStrikethrough, textRange_, ((void**)(*(void**)_nativePointer))[52]);
                __result__.CheckError();
                return hasStrikethrough;
            }
        }

        /// <summary>	
        /// <p> Gets the application-defined drawing effect at the specified text position. </p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The position of the text whose drawing effect is to be retrieved.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>Contains the range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the drawing effect.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains an address of a reference to  the current application-defined drawing effect. Usually this effect is a foreground brush that  is used in glyph drawing.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetDrawingEffect']/*"/>	
        /// <msdn-id>dd316732</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetDrawingEffect([In] unsigned int currentPosition,[Out] void** drawingEffect,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetDrawingEffect</unmanaged-short>	
        internal System.IntPtr GetDrawingEffect_(int currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                System.IntPtr drawingEffect;
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, &drawingEffect, textRange_, ((void**)(*(void**)_nativePointer))[53]);
                __result__.CheckError();
                return drawingEffect;
            }
        }

        /// <summary>	
        /// <p> Gets the inline object at the specified position. </p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The specified text position.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the inline object.</p> </dd></param>	
        /// <returns><dd>  <p>Contains the application-defined inline object.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetInlineObject']/*"/>	
        /// <msdn-id>dd316758</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetInlineObject([In] unsigned int currentPosition,[Out] IDWriteInlineObject** inlineObject,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetInlineObject</unmanaged-short>	
        public SharpDX.DirectWrite.InlineObject GetInlineObject(int currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.DirectWrite.InlineObject inlineObject;
                IntPtr inlineObject_ = IntPtr.Zero;
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, &inlineObject_, textRange_, ((void**)(*(void**)_nativePointer))[54]);
                inlineObject = (inlineObject_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.InlineObjectNative(inlineObject_);
                __result__.CheckError();
                return inlineObject;
            }
        }

        /// <summary>	
        /// <p> Gets the typography setting of the text at the specified position. </p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the typography.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains an address of a  reference to the current typography setting.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetTypography']/*"/>	
        /// <msdn-id>dd371459</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetTypography([In] unsigned int currentPosition,[Out] IDWriteTypography** typography,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetTypography</unmanaged-short>	
        public SharpDX.DirectWrite.Typography GetTypography(int currentPosition, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.DirectWrite.Typography typography;
                IntPtr typography_ = IntPtr.Zero;
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, &typography_, textRange_, ((void**)(*(void**)_nativePointer))[55]);
                typography = (typography_ == IntPtr.Zero) ? null : new SharpDX.DirectWrite.Typography(typography_);
                __result__.CheckError();
                return typography;
            }
        }

        /// <summary>	
        /// <p> Gets the length of the locale name of the text at the specified position. </p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>	
        /// <param name="nameLength"><dd>  <p>Size of the character array, in character count, not including the terminated <strong><c>null</c></strong> character.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the locale name.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetLocaleNameLength']/*"/>	
        /// <msdn-id>dd316771</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetLocaleNameLength([In] unsigned int currentPosition,[Out] unsigned int* nameLength,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetLocaleNameLength</unmanaged-short>	
        internal void GetLocaleNameLength(int currentPosition, out int nameLength, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* nameLength_ = &nameLength)
                    fixed (void* textRange_ = &textRange)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, nameLength_, textRange_, ((void**)(*(void**)_nativePointer))[56]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the locale name of the text at the specified position. </p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>	
        /// <param name="localeName"><dd>  <p>When this method returns, contains the character array receiving the current locale name.</p> </dd></param>	
        /// <param name="nameSize"><dd>  <p>Size of the character array, in character count, including the terminated <strong><c>null</c></strong> character.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the locale name.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetLocaleName']/*"/>	
        /// <msdn-id>dd316767</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetLocaleName([In] unsigned int currentPosition,[Out, Buffer] wchar_t* localeName,[In] unsigned int nameSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetLocaleName</unmanaged-short>	
        internal void GetLocaleName(int currentPosition, System.IntPtr localeName, int nameSize, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* textRange_ = &textRange)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, (void*)localeName, nameSize, textRange_, ((void**)(*(void**)_nativePointer))[57]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Draws text using the specified client drawing context.</p>	
        /// </summary>	
        /// <param name="clientDrawingContext"><dd>  <p>An application-defined drawing context. </p> </dd></param>	
        /// <param name="renderer"><dd>  <p>Pointer to the set of callback functions used to draw parts of a text string.</p> </dd></param>	
        /// <param name="originX"><dd>  <p>The x-coordinate of the layout's left side.</p> </dd></param>	
        /// <param name="originY"><dd>  <p>The y-coordinate of the layout's top side.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To draw text with this method, a <em>textLayout</em> object needs to be created by the application using <strong><see cref="SharpDX.DirectWrite.Factory.CreateTextLayout"/></strong>. </p><p>After the <em>textLayout</em> object is obtained, the application calls the  <strong><see cref="SharpDX.DirectWrite.TextLayout.Draw_"/></strong> method  to draw the text, decorations, and inline objects. The actual drawing is done through the callback interface passed in as the <em>textRenderer</em> argument; there, the corresponding <strong>DrawGlyphRun</strong> API is called. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::Draw']/*"/>	
        /// <msdn-id>dd316726</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::Draw([In, Optional] void* clientDrawingContext,[In] IDWriteTextRenderer* renderer,[In] float originX,[In] float originY)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::Draw</unmanaged-short>	
        internal void Draw_(System.IntPtr clientDrawingContext, System.IntPtr renderer, float originX, float originY)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)clientDrawingContext, (void*)renderer, originX, originY, ((void**)(*(void**)_nativePointer))[58]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Retrieves the information about each individual text line of the  text string. </p>	
        /// </summary>	
        /// <param name="lineMetrics"><dd>  <p>When this method returns, contains a reference to an array of structures containing various calculated length values of individual text lines.</p> </dd></param>	
        /// <param name="maxLineCount"><dd>  <p>The maximum size of the <em>lineMetrics</em> array.</p> </dd></param>	
        /// <param name="actualLineCount"><dd>  <p>When this method returns, contains the actual size of the <em>lineMetrics</em> array that is needed.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> If <em>maxLineCount</em> is not large enough E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.InsufficientBuffer"/>), is returned and <em>*actualLineCount</em> is set to the number of lines needed. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetLineMetrics']/*"/>	
        /// <msdn-id>dd316763</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetLineMetrics([Out, Buffer, Optional] DWRITE_LINE_METRICS* lineMetrics,[In] unsigned int maxLineCount,[Out] unsigned int* actualLineCount)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetLineMetrics</unmanaged-short>	
        internal SharpDX.Result GetLineMetrics(SharpDX.DirectWrite.LineMetrics[] lineMetrics, int maxLineCount, out int actualLineCount)
        {
            unsafe
            {
                SharpDX.DirectWrite.LineMetrics[] lineMetrics__ = lineMetrics;
                SharpDX.Result __result__;
                fixed (void* lineMetrics_ = lineMetrics__)
                    fixed (void* actualLineCount_ = &actualLineCount)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, lineMetrics_, maxLineCount, actualLineCount_, ((void**)(*(void**)_nativePointer))[59]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Retrieves overall metrics for the formatted string. </p>	
        /// </summary>	
        /// <param name="textMetrics"><dd>  <p>When this method returns, contains the measured distances of text and associated content after being formatted.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetMetrics']/*"/>	
        /// <msdn-id>dd316785</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetMetrics([Out] DWRITE_TEXT_METRICS* textMetrics)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetMetrics</unmanaged-short>	
        internal void GetMetrics(out SharpDX.DirectWrite.TextMetrics textMetrics)
        {
            unsafe
            {
                textMetrics = new SharpDX.DirectWrite.TextMetrics();
                SharpDX.Result __result__;
                fixed (void* textMetrics_ = &textMetrics)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, textMetrics_, ((void**)(*(void**)_nativePointer))[60]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Returns the overhangs (in DIPs) of the layout and all objects contained in it, including text glyphs and inline objects.</p>	
        /// </summary>	
        /// <param name="overhangs"><dd>  <p>Overshoots of visible extents (in DIPs) outside the layout.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Underlines and strikethroughs do not contribute to the black box determination, since these are actually drawn by the renderer, which is allowed to draw them in any variety of styles.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetOverhangMetrics']/*"/>	
        /// <msdn-id>dd316790</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetOverhangMetrics([Out] DWRITE_OVERHANG_METRICS* overhangs)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetOverhangMetrics</unmanaged-short>	
        internal void GetOverhangMetrics(out SharpDX.DirectWrite.OverhangMetrics overhangs)
        {
            unsafe
            {
                overhangs = new SharpDX.DirectWrite.OverhangMetrics();
                SharpDX.Result __result__;
                fixed (void* overhangs_ = &overhangs)
                    __result__ =
                    SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, overhangs_, ((void**)(*(void**)_nativePointer))[61]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Retrieves logical properties and measurements of each glyph cluster. </p>	
        /// </summary>	
        /// <param name="clusterMetrics"><dd>  <p>When this method returns, contains metrics, such as line-break or total advance width, for a glyph cluster.</p> </dd></param>	
        /// <param name="maxClusterCount"><dd>  <p>The maximum size of the <em>clusterMetrics</em> array.</p> </dd></param>	
        /// <param name="actualClusterCount"><dd>  <p>When this method returns, contains the actual size of the <em>clusterMetrics</em> array that is needed.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> If <em>maxClusterCount</em> is not large enough, then E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.InsufficientBuffer"/>), is returned and <em>actualClusterCount</em> is set to the number of clusters needed. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::GetClusterMetrics']/*"/>	
        /// <msdn-id>dd316729</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::GetClusterMetrics([Out, Buffer, Optional] DWRITE_CLUSTER_METRICS* clusterMetrics,[In] unsigned int maxClusterCount,[Out] unsigned int* actualClusterCount)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::GetClusterMetrics</unmanaged-short>	
        internal SharpDX.Result GetClusterMetrics(SharpDX.DirectWrite.ClusterMetrics[] clusterMetrics, int maxClusterCount, out int actualClusterCount)
        {
            unsafe
            {
                SharpDX.DirectWrite.ClusterMetrics[] clusterMetrics__ = clusterMetrics;
                SharpDX.Result __result__;
                fixed (void* clusterMetrics_ = clusterMetrics__)
                    fixed (void* actualClusterCount_ = &actualClusterCount)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, clusterMetrics_, maxClusterCount, actualClusterCount_, ((void**)(*(void**)_nativePointer))[62]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p>Determines the minimum possible width the layout can be set to without emergency breaking between the characters of whole words occurring.</p>	
        /// </summary>	
        /// <returns><dd>  <p>Minimum width.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::DetermineMinWidth']/*"/>	
        /// <msdn-id>dd316723</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::DetermineMinWidth([Out] float* minWidth)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::DetermineMinWidth</unmanaged-short>	
        public float DetermineMinWidth()
        {
            unsafe
            {
                float minWidth;
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &minWidth, ((void**)(*(void**)_nativePointer))[63]);
                __result__.CheckError();
                return minWidth;
            }
        }

        /// <summary>	
        /// <p> The application calls this function passing in a specific pixel location relative to the top-left location of the layout box and obtains the information about the correspondent hit-test metrics of the text string where the hit-test has occurred. When the specified pixel location is outside the text string, the function sets the output value <em>*isInside</em> to <strong><see cref="SharpDX.Result.False"/></strong>. </p>	
        /// </summary>	
        /// <param name="pointX"><dd>  <p>The pixel location X to hit-test, relative to the top-left location of the layout box.</p> </dd></param>	
        /// <param name="pointY"><dd>  <p>The pixel location Y to hit-test, relative to the top-left location of the layout box.</p> </dd></param>	
        /// <param name="isTrailingHit"><dd>  <p>An output flag that indicates whether the hit-test location is at the leading or the trailing side of the character. When the output <em>*isInside</em> value is set to <strong><see cref="SharpDX.Result.False"/></strong>, this value is set according to the output <em>hitTestMetrics-&gt;textPosition</em> value to represent the edge closest to the hit-test location.</p> </dd></param>	
        /// <param name="isInside"><dd>  <p>An output flag that indicates whether the hit-test location is inside the text string. When <strong><see cref="SharpDX.Result.False"/></strong>, the position nearest the text's edge is returned.</p> </dd></param>	
        /// <returns><dd>  <p>The output geometry fully enclosing the hit-test location. When the output <em>*isInside</em> value is set to <strong><see cref="SharpDX.Result.False"/></strong>, this structure represents the geometry enclosing the edge closest to the hit-test location.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::HitTestPoint']/*"/>	
        /// <msdn-id>dd371464</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::HitTestPoint([In] float pointX,[In] float pointY,[Out] BOOL* isTrailingHit,[Out] BOOL* isInside,[Out] DWRITE_HIT_TEST_METRICS* hitTestMetrics)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::HitTestPoint</unmanaged-short>	
        public SharpDX.DirectWrite.HitTestMetrics HitTestPoint(float pointX, float pointY, out SharpDX.Mathematics.Interop.RawBool isTrailingHit, out SharpDX.Mathematics.Interop.RawBool isInside)
        {
            unsafe
            {
                isTrailingHit = new SharpDX.Mathematics.Interop.RawBool();
                isInside = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.DirectWrite.HitTestMetrics hitTestMetrics;
                hitTestMetrics = new SharpDX.DirectWrite.HitTestMetrics();
                SharpDX.Result __result__;
                fixed (void* isTrailingHit_ = &isTrailingHit)
                    fixed (void* isInside_ = &isInside)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, pointX, pointY, isTrailingHit_, isInside_, &hitTestMetrics, ((void**)(*(void**)_nativePointer))[64]);
                __result__.CheckError();
                return hitTestMetrics;
            }
        }

        /// <summary>	
        /// <p> The application calls this function to get the pixel location relative to the top-left of the layout box given the text position and the logical side of the position. This function is normally used as part of caret positioning of text where the caret is drawn at the location corresponding to the current text editing position. It may also be used as a way to programmatically obtain the geometry of a particular text position in UI automation. </p>	
        /// </summary>	
        /// <param name="textPosition"><dd>  <p>The text position used to get the pixel location.</p> </dd></param>	
        /// <param name="isTrailingHit"><dd>  <p>A Boolean flag that indicates whether the pixel location is of the leading or the trailing side of the specified text position.</p> </dd></param>	
        /// <param name="ointXRef"><dd>  <p>When this method returns, contains the output pixel location X, relative to the top-left location of the layout box.</p> </dd></param>	
        /// <param name="ointYRef"><dd>  <p>When this method returns, contains the output pixel location Y, relative to the top-left location of the layout box.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains the output geometry fully enclosing the specified text position.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::HitTestTextPosition']/*"/>	
        /// <msdn-id>dd371469</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::HitTestTextPosition([In] unsigned int textPosition,[In] BOOL isTrailingHit,[Out] float* pointX,[Out] float* pointY,[Out] DWRITE_HIT_TEST_METRICS* hitTestMetrics)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::HitTestTextPosition</unmanaged-short>	
        public SharpDX.DirectWrite.HitTestMetrics HitTestTextPosition(int textPosition, SharpDX.Mathematics.Interop.RawBool isTrailingHit, out float ointXRef, out float ointYRef)
        {
            unsafe
            {
                SharpDX.DirectWrite.HitTestMetrics hitTestMetrics;
                hitTestMetrics = new SharpDX.DirectWrite.HitTestMetrics();
                SharpDX.Result __result__;
                fixed (void* ointXRef_ = &ointXRef)
                    fixed (void* ointYRef_ = &ointYRef)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint144(_nativePointer, textPosition, isTrailingHit, ointXRef_, ointYRef_, &hitTestMetrics, ((void**)(*(void**)_nativePointer))[65]);
                __result__.CheckError();
                return hitTestMetrics;
            }
        }

        /// <summary>	
        /// <p> The application calls this function to get a set of hit-test metrics corresponding to a range of text positions. One of the main usages is to implement highlight selection of the text string. The function returns E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(<see cref="SharpDX.Win32.ErrorCode.InsufficientBuffer"/>), when the buffer size of hitTestMetrics is too small to hold all the regions calculated by the function. In this situation, the function sets the output value *actualHitTestMetricsCount to the number of geometries calculated. The application is responsible for allocating a new buffer of greater size and calling the function again. A good value to use as an initial value for maxHitTestMetricsCount may be calculated from the following equation: maxHitTestMetricsCount = lineCount * maxBidiReorderingDepth where lineCount is obtained from the value of the output argument *actualLineCount (from the function <strong><see cref="SharpDX.DirectWrite.TextLayout"/></strong>::GetLineLengths), and the maxBidiReorderingDepth value from the <strong><see cref="SharpDX.DirectWrite.TextMetrics"/></strong> structure of the output argument *textMetrics (from the function <strong><see cref="SharpDX.DirectWrite.Factory"/></strong>::<strong>CreateTextLayout</strong>). </p>	
        /// </summary>	
        /// <param name="textPosition">No documentation.</param>	
        /// <param name="textLength">No documentation.</param>	
        /// <param name="originX">No documentation.</param>	
        /// <param name="originY">No documentation.</param>	
        /// <param name="hitTestMetrics">No documentation.</param>	
        /// <param name="maxHitTestMetricsCount">No documentation.</param>	
        /// <param name="actualHitTestMetricsCount">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout::HitTestTextRange']/*"/>	
        /// <msdn-id>dd371473</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout::HitTestTextRange([In] unsigned int textPosition,[In] unsigned int textLength,[In] float originX,[In] float originY,[Out, Buffer, Optional] DWRITE_HIT_TEST_METRICS* hitTestMetrics,[In] unsigned int maxHitTestMetricsCount,[Out] unsigned int* actualHitTestMetricsCount)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout::HitTestTextRange</unmanaged-short>	
        internal SharpDX.Result HitTestTextRange(int textPosition, int textLength, float originX, float originY, SharpDX.DirectWrite.HitTestMetrics[] hitTestMetrics, int maxHitTestMetricsCount, out int actualHitTestMetricsCount)
        {
            unsafe
            {
                SharpDX.DirectWrite.HitTestMetrics[] hitTestMetrics__ = hitTestMetrics;
                SharpDX.Result __result__;
                fixed (void* hitTestMetrics_ = hitTestMetrics__)
                    fixed (void* actualHitTestMetricsCount_ = &actualHitTestMetricsCount)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, textPosition, textLength, originX, originY, hitTestMetrics_, maxHitTestMetricsCount, actualHitTestMetricsCount_, ((void**)(*(void**)_nativePointer))[66]);
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>Represents a block of text after it has been fully analyzed and formatted.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout1']/*"/>	
    /// <msdn-id>hh780438</msdn-id>	
    /// <unmanaged>IDWriteTextLayout1</unmanaged>	
    /// <unmanaged-short>IDWriteTextLayout1</unmanaged-short>	
    [Guid("9064D822-80A7-465C-A986-DF65F78B8FEB")]
    public partial class TextLayout1 : SharpDX.DirectWrite.TextLayout
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.TextLayout1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TextLayout1(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.TextLayout1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.TextLayout1(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.TextLayout1(nativePointer);
        }


        /// <summary>	
        /// <p>Enables or disables pair-kerning on a given text range.</p>	
        /// </summary>	
        /// <param name="isPairKerningEnabled"><dd>  <p>The flag that indicates whether text is pair-kerned.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The text range to which the change applies.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout1::SetPairKerning']/*"/>	
        /// <msdn-id>Hh780442</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout1::SetPairKerning([In] BOOL isPairKerningEnabled,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout1::SetPairKerning</unmanaged-short>	
        public void SetPairKerning(SharpDX.Mathematics.Interop.RawBool isPairKerningEnabled, SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint141(_nativePointer, isPairKerningEnabled, textRange, ((void**)(*(void**)_nativePointer))[67]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets whether or not pair-kerning is enabled at given position.</p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The current text position.</p> </dd></param>	
        /// <param name="isPairKerningEnabled"><dd>  <p>The flag that indicates whether text is pair-kerned.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The position range of the current format.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout1::GetPairKerning']/*"/>	
        /// <msdn-id>Hh780440</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout1::GetPairKerning([In] unsigned int currentPosition,[Out] BOOL* isPairKerningEnabled,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout1::GetPairKerning</unmanaged-short>	
        public void GetPairKerning(int currentPosition, out SharpDX.Mathematics.Interop.RawBool isPairKerningEnabled, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                isPairKerningEnabled = new SharpDX.Mathematics.Interop.RawBool();
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* isPairKerningEnabled_ = &isPairKerningEnabled)
                    fixed (void* textRange_ = &textRange)
                        __result__ =
                        SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, isPairKerningEnabled_, textRange_, ((void**)(*(void**)_nativePointer))[68]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Sets the spacing between characters.</p>	
        /// </summary>	
        /// <param name="leadingSpacing"><dd>  <p>The spacing before each character, in reading order.</p> </dd></param>	
        /// <param name="trailingSpacing"><dd>  <p>The spacing after each character, in reading order.</p> </dd></param>	
        /// <param name="minimumAdvanceWidth"><dd>  <p>The minimum advance of each character, to prevent characters from becoming too thin or zero-width. This must be zero or greater.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout1::SetCharacterSpacing']/*"/>	
        /// <msdn-id>Hh780441</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout1::SetCharacterSpacing([In] float leadingSpacing,[In] float trailingSpacing,[In] float minimumAdvanceWidth,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout1::SetCharacterSpacing</unmanaged-short>	
        public void SetCharacterSpacing(float leadingSpacing, float trailingSpacing, float minimumAdvanceWidth, SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint179(_nativePointer, leadingSpacing, trailingSpacing, minimumAdvanceWidth, textRange, ((void**)(*(void**)_nativePointer))[69]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p>Gets the spacing between characters.</p>	
        /// </summary>	
        /// <param name="currentPosition"><dd>  <p>The current text position.</p> </dd></param>	
        /// <param name="leadingSpacing"><dd>  <p>The spacing before each character, in reading order.</p> </dd></param>	
        /// <param name="trailingSpacing"><dd>  <p>The spacing after each character, in reading order.</p> </dd></param>	
        /// <param name="minimumAdvanceWidth"><dd>  <p>The minimum advance of each character, to prevent characters from becoming too thin or zero-width. This must be zero or greater.</p> </dd></param>	
        /// <param name="textRange"><dd>  <p>The position range of the current format.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextLayout1::GetCharacterSpacing']/*"/>	
        /// <msdn-id>Hh780439</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextLayout1::GetCharacterSpacing([In] unsigned int currentPosition,[Out] float* leadingSpacing,[Out] float* trailingSpacing,[Out] float* minimumAdvanceWidth,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>	
        /// <unmanaged-short>IDWriteTextLayout1::GetCharacterSpacing</unmanaged-short>	
        public void GetCharacterSpacing(int currentPosition, out float leadingSpacing, out float trailingSpacing, out float minimumAdvanceWidth, out SharpDX.DirectWrite.TextRange textRange)
        {
            unsafe
            {
                textRange = new SharpDX.DirectWrite.TextRange();
                SharpDX.Result __result__;
                fixed (void* leadingSpacing_ = &leadingSpacing)
                    fixed (void* trailingSpacing_ = &trailingSpacing)
                        fixed (void* minimumAdvanceWidth_ = &minimumAdvanceWidth)
                            fixed (void* textRange_ = &textRange)
                                __result__ =
                                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, currentPosition, leadingSpacing_, trailingSpacing_, minimumAdvanceWidth_, textRange_, ((void**)(*(void**)_nativePointer))[70]);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Represents a set of application-defined callbacks that perform rendering of text, inline objects, and decorations such as underlines.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextRenderer']/*"/>	
    /// <msdn-id>dd371523</msdn-id>	
    /// <unmanaged>IDWriteTextRenderer</unmanaged>	
    /// <unmanaged-short>IDWriteTextRenderer</unmanaged-short>	
    [Guid("ef8a8135-5cc6-45fe-8825-c5a0724eb819")]
    public partial interface TextRenderer : SharpDX.DirectWrite.PixelSnapping
    {


        /// <summary>	
        /// <p> IDWriteTextLayout::<strong>Draw</strong> calls this function to instruct the client to render a run of glyphs. </p>	
        /// </summary>	
        /// <param name="clientDrawingContext">No documentation.</param>	
        /// <param name="baselineOriginX">No documentation.</param>	
        /// <param name="baselineOriginY">No documentation.</param>	
        /// <param name="measuringMode">No documentation.</param>	
        /// <param name="glyphRun">No documentation.</param>	
        /// <param name="glyphRunDescription">No documentation.</param>	
        /// <param name="clientDrawingEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.DirectWrite.TextLayout.Draw_"/></strong> function calls this callback function with all the information about glyphs to render. The application implements this callback by mostly delegating the call to the underlying platform's graphics API such as Direct2D to draw glyphs on the drawing context. An application that uses GDI can implement this callback in terms of the <strong><see cref="SharpDX.DirectWrite.BitmapRenderTarget.DrawGlyphRun"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextRenderer::DrawGlyphRun']/*"/>	
        /// <msdn-id>dd371526</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextRenderer::DrawGlyphRun([In, Optional] void* clientDrawingContext,[In] float baselineOriginX,[In] float baselineOriginY,[In] DWRITE_MEASURING_MODE measuringMode,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In, Optional] IUnknown* clientDrawingEffect)</unmanaged>	
        /// <unmanaged-short>IDWriteTextRenderer::DrawGlyphRun</unmanaged-short>	
        /* public void DrawGlyphRun(System.IntPtr clientDrawingContext, float baselineOriginX, float baselineOriginY, SharpDX.Direct2D1.MeasuringMode measuringMode, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.DirectWrite.GlyphRunDescription glyphRunDescription, SharpDX.ComObject clientDrawingEffect) */

        /// <summary>	
        /// <p> IDWriteTextLayout::<strong>Draw</strong> calls this function to instruct the client to draw an underline. </p>	
        /// </summary>	
        /// <param name="clientDrawingContext">No documentation.</param>	
        /// <param name="baselineOriginX">No documentation.</param>	
        /// <param name="baselineOriginY">No documentation.</param>	
        /// <param name="underline">No documentation.</param>	
        /// <param name="clientDrawingEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> A single underline can be broken into multiple calls, depending on how the formatting changes attributes. If font sizes/styles change within an underline, the thickness and offset will be averaged weighted according to characters. To get an appropriate starting pixel position, add underline::offset to the baseline. Otherwise there will be no spacing between the text. The x coordinate will always be passed as the left side, regardless of text directionality. This simplifies drawing and reduces the problem of round-off that could potentially cause gaps or a double stamped alpha blend. To avoid alpha overlap, round the end points to the nearest device pixel. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextRenderer::DrawUnderline']/*"/>	
        /// <msdn-id>dd371533</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextRenderer::DrawUnderline([In, Optional] void* clientDrawingContext,[In] float baselineOriginX,[In] float baselineOriginY,[In] const DWRITE_UNDERLINE* underline,[In, Optional] IUnknown* clientDrawingEffect)</unmanaged>	
        /// <unmanaged-short>IDWriteTextRenderer::DrawUnderline</unmanaged-short>	
        /* public void DrawUnderline(System.IntPtr clientDrawingContext, float baselineOriginX, float baselineOriginY, ref SharpDX.DirectWrite.Underline underline, SharpDX.ComObject clientDrawingEffect) */

        /// <summary>	
        /// <p> IDWriteTextLayout::<strong>Draw</strong> calls this function to instruct the client to draw a strikethrough. </p>	
        /// </summary>	
        /// <param name="clientDrawingContext">No documentation.</param>	
        /// <param name="baselineOriginX">No documentation.</param>	
        /// <param name="baselineOriginY">No documentation.</param>	
        /// <param name="strikethrough">No documentation.</param>	
        /// <param name="clientDrawingEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> A single strikethrough can be broken into multiple calls, depending on how the formatting changes attributes. Strikethrough is not averaged across font sizes/styles changes. To get an appropriate starting pixel position, add strikethrough::offset to the baseline. Like underlines, the x coordinate will always be passed as the left side, regardless of text directionality. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextRenderer::DrawStrikethrough']/*"/>	
        /// <msdn-id>dd371530</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextRenderer::DrawStrikethrough([In, Optional] void* clientDrawingContext,[In] float baselineOriginX,[In] float baselineOriginY,[In] const DWRITE_STRIKETHROUGH* strikethrough,[In, Optional] IUnknown* clientDrawingEffect)</unmanaged>	
        /// <unmanaged-short>IDWriteTextRenderer::DrawStrikethrough</unmanaged-short>	
        /* public void DrawStrikethrough(System.IntPtr clientDrawingContext, float baselineOriginX, float baselineOriginY, ref SharpDX.DirectWrite.Strikethrough strikethrough, SharpDX.ComObject clientDrawingEffect) */

        /// <summary>	
        /// <p> IDWriteTextLayout::<strong>Draw</strong> calls this application callback when it needs to draw an inline object. </p>	
        /// </summary>	
        /// <param name="clientDrawingContext">No documentation.</param>	
        /// <param name="originX">No documentation.</param>	
        /// <param name="originY">No documentation.</param>	
        /// <param name="inlineObject">No documentation.</param>	
        /// <param name="isSideways">No documentation.</param>	
        /// <param name="isRightToLeft">No documentation.</param>	
        /// <param name="clientDrawingEffect">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTextRenderer::DrawInlineObject']/*"/>	
        /// <msdn-id>dd371527</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTextRenderer::DrawInlineObject([In, Optional] void* clientDrawingContext,[In] float originX,[In] float originY,[In] IDWriteInlineObject* inlineObject,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In, Optional] IUnknown* clientDrawingEffect)</unmanaged>	
        /// <unmanaged-short>IDWriteTextRenderer::DrawInlineObject</unmanaged-short>	
        /* internal void DrawInlineObject_(System.IntPtr clientDrawingContext, float originX, float originY, System.IntPtr inlineObject, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.Mathematics.Interop.RawBool isRightToLeft, SharpDX.ComObject clientDrawingEffect) */
    }
    /// <summary>	
    /// <p> Represents a font typography setting.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTypography']/*"/>	
    /// <msdn-id>dd371541</msdn-id>	
    /// <unmanaged>IDWriteTypography</unmanaged>	
    /// <unmanaged-short>IDWriteTypography</unmanaged-short>	
    [Guid("55f1112b-1dc2-4b3c-9541-f46894ed85b6")]
    public partial class Typography : SharpDX.ComObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.DirectWrite.Typography"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Typography(IntPtr nativePtr) : base(nativePtr)
        {
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.DirectWrite.Typography"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        /// </summary>
        /// <param name="nativePointer">The native pointer.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static explicit operator SharpDX.DirectWrite.Typography(IntPtr nativePointer)
        {
            return nativePointer == IntPtr.Zero ? null : new SharpDX.DirectWrite.Typography(nativePointer);
        }


        /// <summary>	
        /// <p> Gets the number of OpenType font features for the current font. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p>A single run of text can be associated with more than one typographic feature. The <strong><see cref="SharpDX.DirectWrite.Typography"/></strong> object holds a list of these font features.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTypography::GetFontFeatureCount']/*"/>	
        /// <msdn-id>dd371549</msdn-id>	
        /// <unmanaged>GetFontFeatureCount</unmanaged>	
        /// <unmanaged-short>GetFontFeatureCount</unmanaged-short>	
        /// <unmanaged>unsigned int IDWriteTypography::GetFontFeatureCount()</unmanaged>
        public int FontFeatureCount
        {
            get { return GetFontFeatureCount(); }
        }

        /// <summary>	
        /// <p> Adds an OpenType font feature. </p>	
        /// </summary>	
        /// <param name="fontFeature"><dd>  <p>A structure that contains the OpenType name identifier and the execution parameter for the font feature being added.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTypography::AddFontFeature']/*"/>	
        /// <msdn-id>dd371545</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTypography::AddFontFeature([In] DWRITE_FONT_FEATURE fontFeature)</unmanaged>	
        /// <unmanaged-short>IDWriteTypography::AddFontFeature</unmanaged-short>	
        public void AddFontFeature(SharpDX.DirectWrite.FontFeature fontFeature)
        {
            unsafe
            {
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint174(_nativePointer, fontFeature, ((void**)(*(void**)_nativePointer))[3]);
                __result__.CheckError();
            }
        }

        /// <summary>	
        /// <p> Gets the number of OpenType font features for the current font. </p>	
        /// </summary>	
        /// <returns><p>The number of font features for the current text format.</p></returns>	
        /// <remarks>	
        /// <p>A single run of text can be associated with more than one typographic feature. The <strong><see cref="SharpDX.DirectWrite.Typography"/></strong> object holds a list of these font features.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTypography::GetFontFeatureCount']/*"/>	
        /// <msdn-id>dd371549</msdn-id>	
        /// <unmanaged>unsigned int IDWriteTypography::GetFontFeatureCount()</unmanaged>	
        /// <unmanaged-short>IDWriteTypography::GetFontFeatureCount</unmanaged-short>	
        internal int GetFontFeatureCount()
        {
            unsafe
            {
                int __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ((void**)(*(void**)_nativePointer))[4]);
                return __result__;
            }
        }

        /// <summary>	
        /// <p> Gets the font feature at the specified index. </p>	
        /// </summary>	
        /// <param name="fontFeatureIndex"><dd>  <p>The zero-based index of the font feature to retrieve.</p> </dd></param>	
        /// <returns><dd>  <p>When this method returns, contains the font feature which is at the specified index.</p> </dd></returns>	
        /// <remarks>	
        /// <p>A single run of text can be associated with more than one typographic feature. The <strong><see cref="SharpDX.DirectWrite.Typography"/></strong> object holds a list of these font features.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDWriteTypography::GetFontFeature']/*"/>	
        /// <msdn-id>dd371546</msdn-id>	
        /// <unmanaged>HRESULT IDWriteTypography::GetFontFeature([In] unsigned int fontFeatureIndex,[Out] DWRITE_FONT_FEATURE* fontFeature)</unmanaged>	
        /// <unmanaged-short>IDWriteTypography::GetFontFeature</unmanaged-short>	
        public SharpDX.DirectWrite.FontFeature GetFontFeature(int fontFeatureIndex)
        {
            unsafe
            {
                SharpDX.DirectWrite.FontFeature fontFeature;
                fontFeature = new SharpDX.DirectWrite.FontFeature();
                SharpDX.Result __result__;
                __result__ =
                SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, fontFeatureIndex, &fontFeature, ((void**)(*(void**)_nativePointer))[5]);
                __result__.CheckError();
                return fontFeature;
            }
        }
    }
}
