namespace Anathena.Source.Engine.Architecture.Disassembler.SharpDisasm.Translators
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using System.Text;
    using Udis86;

    /// <summary>
    /// All translators must inherit from the abstract class <see cref="Translator"/>. This base class provides a number of common methods, and defines two abstract methods that must be implemented.
    /// </summary>
    /// <threadsafety static="true" instance="false" />
    public abstract class Translator
    {
        /// <summary>
        /// A list of all registers names
        /// </summary>
        protected static readonly String[] Registers = syn.ud_reg_tab;

        /// <summary>
        /// Initializes a new instance of the <see cref="Translator" /> class
        /// </summary>
        public Translator()
        {
            this.Content = new StringBuilder();
        }

        /// <summary>
        /// Gets or sets a value indicating whether the generated output will include the instruction address
        /// </summary>
        public Boolean IncludeAddress { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether the generated output will include the original binary instruction
        /// </summary>
        public Boolean IncludeBinary { get; set; }

        /// <summary>
        /// Gets or sets an optional symbol resolver <see cref="SymbolResolverDelegate"/>.
        /// </summary>
        public SymbolResolverDelegate SymbolResolver { get; set; }

        /// <summary>
        /// Gets or sets the content being generated by the current call to the translator
        /// </summary>
        protected StringBuilder Content { get; set; }

        /// <summary>
        /// Abstract method to translate multiple instructions. Classes implementing this method must reset the protected <see cref="Content"/> member instance and cleanup.
        /// </summary>
        /// <param name="insns">Collection of instructions to be translated</param>
        /// <returns>The result of the translated instructions</returns>
        public abstract String Translate(IEnumerable<Instruction> insns);

        /// <summary>
        /// Abstract method to translate a single instruction. Classes implementing this method must reset the protected <see cref="Content"/> member instance and cleanup.
        /// </summary>
        /// <param name="insn">The instruction to translate</param>
        /// <returns>The result of the single translated instruction</returns>
        public abstract String Translate(Instruction insn);

        /// <summary>
        /// Converts a <see cref="ud_type"/> into an index into <see cref="Registers"/> and returns the result.
        /// </summary>
        /// <param name="type">The register <see cref="ud_type"/> to retrieve the corresponding string for. Note: only the UD_R_* types will result in a valid index.</param>
        /// <returns>The corresponding string value for the register.</returns>
        protected String RegisterForType(ud_type type)
        {
            // Adjust to be zero based (i.e. the first register in ud_type starts at 1 == UD_R_AL)
            Int32 indx = type - ud_type.UD_R_AL;
            return Registers[indx];
        }

        /// <summary>
        /// Writes the address of the instruction to <see cref="Content"/>. The width of the address is determined by the <see cref="ArchitectureMode"/> used during disassembly.
        /// </summary>
        /// <param name="insn">The instruction to append the address of.</param>
        protected void WriteAddress(Instruction insn)
        {
            switch (insn.DisMode)
            {
                case ArchitectureMode.x86_16:
                    this.Content.AppendFormat("{0:x4} ", insn.Offset);
                    break;
                case ArchitectureMode.x86_32:
                    this.Content.AppendFormat("{0:x8} ", insn.Offset);
                    break;
                case ArchitectureMode.x86_64:
                    this.Content.AppendFormat("{0:x16} ", insn.Offset);
                    break;
            }
        }

        /// <summary>
        /// Writes the instruction binary data to <see cref="Content"/>. The result is padded to 20 characters (supporting instructions up to 10-bytes long). If the instruction was disassembled without <see cref="Disassembler.CopyBinaryToInstruction"/> a blank 20 character string will be appended.
        /// </summary>
        /// <param name="insn">The instruction of which to append the binary data for</param>
        protected void WriteBinary(Instruction insn)
        {
            if (insn.Bytes != null)
            {
                this.Content.AppendFormat("{0,-30} ", String.Join(String.Empty, (from b in insn.Bytes select String.Format("{0:x2} ", b)).ToArray()));
            }
        }

        /// <summary>
        /// TODO: document and rename ported translator methods
        /// </summary>
        /// <param name="insn"></param>
        /// <param name="opr"></param>
        /// <returns></returns>
        protected UInt64 Ud_syn_rel_target(Instruction insn, Operand opr)
        {
            UInt64 trunc_mask = 0xffffffffffffffff >> (64 - insn.OprMode);
            switch (opr.Size)
            {
                case 8: return (insn.PC + (UInt64)opr.LvalSByte) & trunc_mask;
                case 16: return (insn.PC + (UInt64)opr.LvalSWord) & trunc_mask;
                case 32: return (insn.PC + (UInt64)opr.LvalSDWord) & trunc_mask;
                default:
                    Debug.Assert(false, "invalid relative offset size.");
                    return 0;
            }
        }

        /// <summary>
        /// TODO: document and rename ported translator methods
        /// </summary>
        /// <param name="insn"></param>
        /// <param name="addr"></param>
        protected void Ud_syn_print_addr(Instruction insn, Int64 addr)
        {
            String name = null;

            if (this.SymbolResolver != null)
            {
                Int64 offset = 0;
                name = this.SymbolResolver(insn, addr, ref offset);
                if (!String.IsNullOrEmpty(name))
                {
                    if (offset > 0)
                    {
                        this.Content.AppendFormat("{0}{1:+#;-#}", name, offset);
                    }
                    else
                    {
                        this.Content.AppendFormat("{0}", name);
                    }

                    return;
                }
            }

            this.Content.AppendFormat("0x{0:x}", addr);
        }

        /// <summary>
        /// TODO: document and rename ported translator methods
        /// </summary>
        /// <param name="insn"></param>
        /// <param name="op"></param>
        protected void Ud_syn_print_imm(Instruction insn, Operand op)
        {
            UInt64 v;
            if (op.Opcode == ud_operand_code.OP_sI && op.Size != insn.OprMode)
            {
                if (op.Size == 8)
                {
                    v = (UInt64)op.LvalSByte;
                }
                else
                {
                    Debug.Assert(op.Size == 32, "Size must be 32");
                    v = (UInt64)op.LvalSDWord;
                }

                if (insn.OprMode < 64)
                {
                    v = v & ((1ul << insn.OprMode) - 1ul);
                }
            }
            else
            {
                switch (op.Size)
                {
                    case 8:
                        v = op.LvalByte;
                        break;
                    case 16:
                        v = op.LvalUWord;
                        break;
                    case 32:
                        v = op.LvalUDWord;
                        break;
                    case 64:
                        v = op.LvalUQWord;
                        break;
                    default:
                        Debug.Assert(false, "invalid offset");
                        v = 0; /* keep cc happy */
                        break;
                }
            }

            this.Content.AppendFormat("0x{0:x}", v);
        }

        /// <summary>
        /// TODO: document and rename ported translator methods
        /// </summary>
        /// <param name="insn"></param>
        /// <param name="op"></param>
        /// <param name="sign"></param>
        protected void Ud_syn_print_mem_disp(Instruction insn, Operand op, Int32 sign)
        {
            Debug.Assert(op.Offset != 0, "Offset must be non-zero");
            if (op.Base == ud_type.UD_NONE && op.Index == ud_type.UD_NONE)
            {
                UInt64 v;
                Debug.Assert(op.Scale == 0 && op.Offset != 8, "TODO: REASON");
                /* unsigned mem-offset */
                switch (op.Offset)
                {
                    case 16:
                        v = op.LvalUWord;
                        break;
                    case 32:
                        v = op.LvalUDWord;
                        break;
                    case 64:
                        v = op.LvalUQWord;
                        break;
                    default:
                        Debug.Assert(false, "invalid offset");
                        v = 0; /* keep cc happy */
                        break;
                }

                this.Content.AppendFormat("0x{0:x}", v);
            }
            else
            {
                Int64 v;
                Debug.Assert(op.Offset != 64, "TODO: REASON");
                switch (op.Offset)
                {
                    case 8:
                        v = op.LvalSByte;
                        break;
                    case 16:
                        v = op.LvalSWord;
                        break;
                    case 32:
                        v = op.LvalSDWord;
                        break;
                    default:
                        Debug.Assert(false, "invalid offset");
                        v = 0; /* keep cc happy */
                        break;
                }

                if (v < 0)
                {
                    this.Content.AppendFormat("-0x{0:x}", -v);
                }
                else if (v > 0)
                {
                    this.Content.AppendFormat("{0}0x{1:x}", sign > 0 ? "+" : String.Empty, v);
                }
            }
        }
    }
    //// End class
}
//// End namespace