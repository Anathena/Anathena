using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

namespace Anathema.Source.SystemInternals.OperatingSystems.Windows.Debugger
{
    /// <summary>
    /// Debugger object responsable for controlling the target process
    /// 
    /// Capable of launching processin seperate desktop and auto clicking popup windows
    /// Controls process by invoking the windows debugging API
    /// </summary>
    class Debugger
    {
        #region Member_Variables

        // Settings value initiated by constructor.  These settings are a subset of the settings that come from the EngineSettings
        // and are all initialized by the values located in the main EngineSettings object.
        private DebuggerSettings Settings = null;

        // Process information.
        private Process Debuggee = null;
        private String DebuggeePath = null;
        private String ProcessArguments = null;
        private Boolean Is32bit = true;
        private Boolean DoneStarting = true;

        // Debugger information
        private StringBuilder ErrorInformation = new StringBuilder(String.Empty);

        // Positive Response Buttons to click - list of regex patterns to match against buttons on.
        private List<String> PositiveResponses = new List<String> { @"(&|)[Oo][Kk]", @"(&|)[Yy][Ee][Ss]", @"(&|)[Tt][Rr][Yy]", @"(&|)[Nn][Ee][Xx][Tt]", @"(&|)[Cc][Oo][Nn][Tt][Ii][Nn][Uu][Ee]" };

        // Event information.  Tracks time of each event and whether the program should initiate a termination sequence.
        private Int32 _LastEvent = 0;

        // Thread running the debuggee
        private Thread DebuggerThread = null;
        private Boolean EnterTerminateSequence = false;

        #endregion Member_Variables

        #region Public_Functions

        /// <summary>
        /// Initialize a new instance of the debugger.
        /// </summary>
        /// <param name="LoadCoverageModule"></param>
        public Debugger(DebuggerSettings DebuggerSettings /*, bool LoadCoverageModule = false*/)
        {
            this.Settings = DebuggerSettings;
        }

        /// <summary>
        /// Gets the state of the debugger, true if it is processing an active debuggee, false otherwise.
        /// </summary>
        public Boolean IsRunning
        {
            get
            {
                try
                {
                    if (this.Debuggee == null)
                        return false;

                    return !this.Debuggee.HasExited || !this.DoneStarting;
                }
                catch
                {
                    return false;
                }
            }
        }

        /// <summary>
        /// Gets the millisecond count that the last event occured at
        /// </summary>
        public Int32 LastEvent
        {
            get
            {
                return this._LastEvent;
            }
        }

        /// <summary>
        /// Gets any event information output from the debugger that was generated by the debuggee
        /// </summary>
        public String DebugMessages
        {
            get
            {
                String ReturnValue = this.ErrorInformation.ToString();
                if (!this.Settings.IgnoreExceptions || ReturnValue.Contains("***PROCESS EXIT WITH WATCHED CODE***"))
                    return ReturnValue;
                else
                    return "";
            }
        }

        /// <summary>
        /// Get the current CPU usage of the target process, uses a refresh rate of 0.5 seconds
        /// </summary>
        public Double GetCurrentProcessUse
        {
            get
            {
                Double Refresh = 500.0; // The lower the number, the more accurate.  however, a higher number gives a better, solid average.  
                                        // currently set to .5 sec as that is the fastest procexp will update in order to check the accuracy of this check.
                TimeSpan Start = this.Debuggee.TotalProcessorTime;
                Thread.Sleep((int)Refresh);
                Double Usage = ((Double)(this.Debuggee.TotalProcessorTime - Start).TotalMilliseconds * 100.0) / Refresh;

                return Usage;
            }
        }

        /// <summary>
        /// Clears the debug messages between fuzz runs.
        /// </summary>
        public void ClearDebugMessages()
        {
            this.ErrorInformation.Clear();
        }

        /// <summary>
        /// Destructor to clean up the debugee after the debugger has exited
        /// </summary>
        ~Debugger()
        {
            this.KillProcess();
        }

        /// <summary>
        /// Sets and starts the debugee.
        /// </summary>
        /// <param name="Path"></param>
        /// <param name="Arguments"></param>
        public void StartProcess(String Target, String Arguments = "")
        {
            this.ErrorInformation.Clear();
            this.DoneStarting = false;
            StringBuilder ShortPath = new StringBuilder(Target.Length);
            WinAPI.GetShortPathName(Target, ShortPath, (UInt32)ShortPath.Capacity);
            Target = "\"" + ShortPath.ToString() + "\"";

            this.DebuggeePath = Target;

            if (Arguments != "")
                this.ProcessArguments = "\"" + Arguments + "\"";

            this.DebuggerThread = new Thread(this.StartMultithreadedProcess);

            this.DebuggerThread.Start();

            // We need to wait for the program to actually startup before we return
            if (this.Settings.WaitForFullStartup)
                while (!this.DoneStarting) ;
        }

        /// <summary>
        /// Begins the termination sequence for the debuggee.
        /// </summary>
        public void KillProcess()
        {
            if (this.DebuggerThread != null)
            {
                this.EnterTerminateSequence = true;

                while (this.EnterTerminateSequence)
                    if (this.Debuggee.HasExited)
                        break;
                    else
                        this.Debuggee.WaitForExit();

                this.EnterTerminateSequence = false;
                this.Debuggee.Close();

                this.DebuggerThread = null;
                this._LastEvent = 0;
            }
        }

        #endregion Public_Functions

        #region private_Functions

        /// <summary>
        /// Private component to StartProcess, this is run in a seperate thread from the main thread.
        /// </summary>
        private void StartMultithreadedProcess()
        {
            WinAPI.STARTUP_INFO StartupInfo = new WinAPI.STARTUP_INFO();
            WinAPI.PROCESS_INFORMATION ProcessInfo = new WinAPI.PROCESS_INFORMATION();

            if (!WinAPI.CreateProcess(null, this.DebuggeePath + " " + this.ProcessArguments, IntPtr.Zero, IntPtr.Zero, false,
                (DEBUG_PROCESS | CREATE_DEFAULT_ERROR_MODE | CREATE_NEW_CONSOLE | CREATE_NEW_PROCESS_GROUP), IntPtr.Zero, null, ref StartupInfo, ref ProcessInfo))
            {
                throw new Exception("Error creating the process");
            }

            this.Debuggee = Process.GetProcessById(ProcessInfo.ProcessId);
            this.Debuggee.PriorityClass = ProcessPriorityClass.RealTime;

            this.ErrorInformation.Append("Debuggee: " + this.Debuggee.ProcessName + "\r\n");
            this.ErrorInformation.Append("ProcessID: " + this.Debuggee.Id.ToString() + "\r\n");

            if (!WinAPI.CloseHandle(ProcessInfo.Thread))
                throw new Exception("Error closing handle to created thread");
            if (!WinAPI.CloseHandle(ProcessInfo.Process))
                throw new Exception("Error closing handle to created process");

            this.CheckProcessArchitecture();
            this.MainDebuggerLoop();
        }

        /// <summary>
        /// Sets a global variable depending on if the debugee is 32 or 64 bit.
        /// </summary>
        private void CheckProcessArchitecture()
        {
            IntPtr Kernel32 = WinAPI.LoadLibrary("kernel32.dll");

            if (Kernel32 == IntPtr.Zero)
                return;

            if (!WinAPI.GetProcAddress(Kernel32, "IsWow64Process").Equals(IntPtr.Zero))
            {
                WinAPI.IsWow64Process(this.Debuggee.Handle, out this.Is32bit);
                this.Is32bit = !this.Is32bit;
            }
        }

        /// <summary>
        /// Returns the string representing the context of a given thread
        /// </summary>
        /// <param name="ThreadID"></param>
        /// <returns></returns>
        private String GetRegisterContext(UInt32 ThreadID)
        {
            String returnValue = "";

            CONTEXT context = new CONTEXT();
            context.ContextFlags = CONTEXT_FLAGS.CONTEXT_CONTROL | CONTEXT_FLAGS.CONTEXT_INTEGER;
            IntPtr ThreadHandle = WinAPI.OpenThread(WinAPI.ThreadAccessRights.THREAD_GET_CONTEXT, false, ThreadID);
            if (ThreadHandle == IntPtr.Zero)
                throw new Exception("Error 0x" + WinAPI.GetLastError().ToString("X") + " - " + Enum.GetName(typeof(WinAPI.SYSTEM_ERROR_CODE), WinAPI.GetLastError()) + " - when getting thread handle for context");
            if (!WinAPI.GetThreadContext(ThreadHandle, ref context))
                throw new Exception("Error 0x" + WinAPI.GetLastError().ToString("X") + " - " + Enum.GetName(typeof(WinAPI.SYSTEM_ERROR_CODE), WinAPI.GetLastError()) + " - when getting thread context");

            // NEEDS ATTENTION - not tested, should confirm register values against WinDbg
            Int32 paddingSize = ((this.Is32bit) ? 8 : 16); // This check will be needed when handling 64 bit processes, currently not tested.
            paddingSize = 8; // Temporary while 32 bit is worked on.
            returnValue += "EAX=0x" + context.Eax.ToString("X").PadLeft(paddingSize, '0') + "\t\t";
            returnValue += "EBX=0x" + context.Ebx.ToString("X").PadLeft(paddingSize, '0') + "\r\n";
            returnValue += "ECX=0x" + context.Ecx.ToString("X").PadLeft(paddingSize, '0') + "\t\t";
            returnValue += "EDX=0x" + context.Edx.ToString("X").PadLeft(paddingSize, '0') + "\r\n";
            returnValue += "EDI=0x" + context.Edi.ToString("X").PadLeft(paddingSize, '0') + "\t\t";
            returnValue += "ESI=0x" + context.Esi.ToString("X").PadLeft(paddingSize, '0') + "\r\n";
            returnValue += "EBP=0x" + context.Ebp.ToString("X").PadLeft(paddingSize, '0') + "\t\t";
            returnValue += "ESP=0x" + context.Esp.ToString("X").PadLeft(paddingSize, '0') + "\r\n\t";
            returnValue += "EIP=0x" + context.Eip.ToString("X").PadLeft(paddingSize, '0');

            WinAPI.CloseHandle(ThreadHandle);

            return returnValue;
        }

        #region Debug_Events

        /// <summary>
        /// The main loop of the debugger, waits for events and processes actions accordingly.
        /// </summary>
        private void MainDebuggerLoop()
        {
            while (true)
            {
                if (this.EnterTerminateSequence)
                {
                    if (!WinAPI.DebugActiveProcessStop((uint)this.Debuggee.Id))
                        throw new Exception("Error 0x" + WinAPI.GetLastError().ToString("X") + " - " + Enum.GetName(typeof(WinAPI.SYSTEM_ERROR_CODE), WinAPI.GetLastError()) + " - when detatching from process");

                    try
                    {
                        this.Debuggee.Kill();  // XP seems to be choking on this.  Errors out with permission denied, then the same call throws an exception that the process is already dead.
                                               // Adding a check to see if the process has exited yet before calling this did not seem to fix it.  best fix so far is an empty try/catch, sloppy but it worked

                        if (this.Settings.EnableKillAlso) // Allows the debugger to kill other processes when it kills the debugee
                        {
                            Process[] processes = Process.GetProcessesByName(this.Settings.KillAlso);

                            if (processes.Length > 0)
                            {
                                foreach (Process p in processes)
                                {
                                    if (p != this.Debuggee)
                                    {
                                        if (!p.HasExited)
                                        {
                                            p.Kill();
                                        }
                                    }
                                }
                            }
                        }

                        this.Debuggee.WaitForExit();
                    }
                    catch (Exception e)
                    {
                        try
                        {
                            if (!this.Debuggee.HasExited)
                                throw new Exception("Error - Debuggee Never Exited.  " + e.Message);
                        }
                        catch (Exception exception)
                        {
                            if (!(exception is InvalidOperationException) && !(exception.Message == "There is no process associated with the object"))
                                throw exception;
                        }
                    }
                    finally
                    {
                        this.EnterTerminateSequence = false;
                    }

                    return;
                }

                Debug_Event Event = new Debug_Event();
                if (!WinAPI.WaitForDebugEvent(out Event, 0))
                    if (WinAPI.GetLastError() == 121) // Error 121 is a timeout error, since we are not pausing at all for events.  We don't pause so that we can continue to launch threads to check windows.
                        continue;
                    else
                        throw new DebuggerException("Error 0x" + WinAPI.GetLastError().ToString("X") + " - " + Enum.GetName(typeof(WinAPI.SYSTEM_ERROR_CODE), WinAPI.GetLastError()) + " - while waiting for debug event");

                this._LastEvent = DateTime.Now.Millisecond;

                WinAPI.ContinueStatus action = this.ProcessEvent(Event);

                if (!WinAPI.ContinueDebugEvent(Event.ProcessID, Event.ThreadID, action))
                    throw new DebuggerException("Error 0x" + WinAPI.GetLastError().ToString("X") + " - " + Enum.GetName(typeof(WinAPI.SYSTEM_ERROR_CODE), WinAPI.GetLastError()) + " - while attempting to continue a debug event.");
            }
        }

        /// <summary>
        /// Process the event, this is where most of the work for the debugger is done at run time.
        /// </summary>
        /// <param name="E"></param>
        /// <returns></returns>
        private WinAPI.ContinueStatus ProcessEvent(Debug_Event E)
        {
            switch (E.Code)
            {
                case EventCode.CREATE_PROCESS_DEBUG_INFO:
                    return this.HandleCreateProcess(E);
                case EventCode.CREATE_THREAD_DEBUG_INFO:
                    return this.HandleThreadCreation(E);
                case EventCode.EXCEPTION_DEBUG_INFO:
                    return this.HandleExceptions(E);
                case EventCode.EXIT_PROCESS_DEBUG_INFO:
                    return this.HandleProcessExit(E);
                case EventCode.EXIT_THREAD_DEBUG_INFO:
                    return this.HandleExitThread(E);
                case EventCode.LOAD_DLL_DEBUG_INFO:
                    return HandleLoadDLL(E);
                case EventCode.UNLOAD_DLL_DEBUG_INFO:
                    return this.HandleUnloadDLL(E);
                case EventCode.RIP_INFO:
                    return this.HandleRIP(E);
                case EventCode.OUTPUT_DEBUG_STRING_INFO:
                    return this.HandleOutputString(E);
            }

            return WinAPI.ContinueStatus.DBG_CONTINUE;
        }

        /// <summary>
        /// Performs any actions necessary when an output string is encountered.
        /// </summary>
        /// <param name="E"></param>
        /// <returns></returns>
        private WinAPI.ContinueStatus HandleOutputString(Debug_Event E)
        {
            // This function doesn't much matter because strings and Debug_Event in C# doesn't seem to get along very well, should probably look into that.  Probably around the same time I start caring about debug strings.
            return WinAPI.ContinueStatus.DBG_CONTINUE;
        }

        /// <summary>
        /// Performs any actions necessary when a RIP event is encountered
        /// </summary>
        /// <param name="E"></param>
        /// <returns></returns>
        private WinAPI.ContinueStatus HandleRIP(Debug_Event E)
        {
            return WinAPI.ContinueStatus.DBG_CONTINUE;
        }

        /// <summary>
        /// Performs any actions necessary when a DLL is unloaded
        /// </summary>
        /// <param name="E"></param>
        /// <returns></returns>
        private WinAPI.ContinueStatus HandleUnloadDLL(Debug_Event E)
        {
            return WinAPI.ContinueStatus.DBG_CONTINUE;
        }

        /// <summary>
        /// Performs any actions necessary when a DLL is loaded
        /// </summary>
        /// <param name="E"></param>
        /// <returns></returns>
        private WinAPI.ContinueStatus HandleLoadDLL(Debug_Event E)
        {
            if (!WinAPI.CloseHandle(E.U.LoadDll.File))
                throw new Exception("Error closing file handle during dll load");

            return WinAPI.ContinueStatus.DBG_CONTINUE;
        }

        /// <summary>
        /// Performs any actions necessary when a thread exits
        /// </summary>
        /// <param name="E"></param>
        /// <returns></returns>
        private WinAPI.ContinueStatus HandleExitThread(Debug_Event E)
        {
            return WinAPI.ContinueStatus.DBG_CONTINUE;
        }

        /// <summary>
        /// Performs any actions necessary when the debuggee exits a process
        /// </summary>
        /// <param name="E"></param>
        /// <returns></returns>
        private WinAPI.ContinueStatus HandleProcessExit(Debug_Event E)
        {
            if (this.Debuggee.Id == E.ProcessID)
            {
                if (this.Settings.ErrorCodes.Contains((ErrorCode)E.U.ExitProcess.ExitCode))
                {
                    this.ErrorInformation.Append("***PROCESS EXIT WITH WATCHED CODE***" + "\r\n");
                }
                else
                {
                    this.ErrorInformation.Append("PROCESS EXIT" + "\r\n");
                }
            }
            else
            {
                this.ErrorInformation.Append("SPAWNED PROCESS EXIT" + "\r\n");
            }

            this.ErrorInformation.Append("=============================================" + "\r\n");
            this.ErrorInformation.Append("Process: " + E.ProcessID + "\r\n");
            this.ErrorInformation.Append("Thread: " + E.ThreadID + "\r\n");
            this.ErrorInformation.Append("Error: " + Enum.GetName(typeof(ErrorCode), E.U.ExitProcess.ExitCode) + " - " + E.U.ExitProcess.ExitCode.ToString("X") + "\r\n");
            this.ErrorInformation.Append("\r\n" + this.GetRegisterContext(E.ThreadID) + "\r\n");

            this.ErrorInformation.Append("\r\n\r\n" + "\r\n");

            if (this.Debuggee.Id == E.ProcessID)
            {
                this.Debuggee.Kill();
                this.Debuggee.WaitForExit();
            }

            return WinAPI.ContinueStatus.DBG_CONTINUE;
        }

        /// <summary>
        /// Performs any actions necessary when the debuggee raises an exception
        /// </summary>
        /// <param name="E"></param>
        /// <returns></returns>
        private WinAPI.ContinueStatus HandleExceptions(Debug_Event E)
        {
            // Handle the breakpoint exception at startup, this is where we hide the debugger if necessary
            if ((ErrorCode)E.U.Exception.ExceptionRecord.ExceptionCode == ErrorCode.STATUS_BREAKPOINT && !this.DoneStarting)
            {
                this.DoneStarting = true;

                if (this.Settings.HideDebugger)
                {
                    WinAPI.BasicProcessInformation ProcessInformation = new WinAPI.BasicProcessInformation();
                    Int32 ReturnLength;
                    WinAPI.SYSTEM_ERROR_CODE code = WinAPI.NtQueryInformationProcess(this.Debuggee.Handle, 0x00, ref ProcessInformation, (uint)Marshal.SizeOf(ProcessInformation), out ReturnLength);
                    if (code != 0)
                        throw new DebuggerException("Error 0x" + WinAPI.GetLastError().ToString("X") + " - " + Enum.GetName(typeof(WinAPI.SYSTEM_ERROR_CODE), WinAPI.GetLastError()) + " - while getting PEB address. - 0x" + code.ToString("X") + " - " + Enum.GetName(typeof(ErrorCode), code));

                    byte[] DebuggerPresent = new Byte[1];

                    Int32 Length;

                    DebuggerPresent[0] = 0;
                    WinAPI.WriteProcessMemory(this.Debuggee.Handle, ProcessInformation.PebBaseAddress + 2, DebuggerPresent, 1, out Length);
                }

                return WinAPI.ContinueStatus.DBG_CONTINUE;
            }

            this.ErrorInformation.Append("EXCEPTION" + "\r\n");
            this.ErrorInformation.Append("=============================================" + "\r\n");
            this.ErrorInformation.Append("Process: " + E.ProcessID + "\r\n");
            this.ErrorInformation.Append("Thread: " + E.ThreadID + "\r\n");
            this.ErrorInformation.Append("Error: " + Enum.GetName(typeof(ErrorCode), E.U.Exception.ExceptionRecord.ExceptionCode) + " - " + E.U.Exception.ExceptionRecord.ExceptionCode.ToString("X") + "\r\n");
            this.ErrorInformation.Append("\r\n" + this.GetRegisterContext(E.ThreadID) + "\r\n");
            this.ErrorInformation.Append("\r\n\r\n" + "\r\n");

            return WinAPI.ContinueStatus.DBG_EXCEPTION_NOT_HANDLED;
        }

        /// <summary>
        /// Performs any actions necessary when the debuggee creates a thread
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        private WinAPI.ContinueStatus HandleThreadCreation(Debug_Event e)
        {
            return WinAPI.ContinueStatus.DBG_CONTINUE;
        }

        /// <summary>
        /// Performs any actions necessary when a process is created.
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        private WinAPI.ContinueStatus HandleCreateProcess(Debug_Event e)
        {
            if (!WinAPI.CloseHandle(e.U.CreateProcessInfo.File))
                throw new Exception("Error closing file handle in create process event");

            return WinAPI.ContinueStatus.DBG_CONTINUE;
        }

        #endregion Debug_Events

        #endregion private_Functions

        #region DLL_Imports

        // Miscellaneous constants, should be folded into the WinAPI structures at some point
        private const UInt32 INFINITE = 0xFFFFFFFF;
        private const Int32 MAXIMUM_SUPPORTED_EXTENSION = 512;
        private const Int32 SIZE_OF_80387_REGISTERS = 80;
        private const UInt32 STANDARD_RIGHTS_REQUIRED = (UInt32)WinAPI.ThreadAccessRights.DELETE | (UInt32)WinAPI.ThreadAccessRights.READ_CONTROL | (UInt32)WinAPI.ThreadAccessRights.WRITE_DAC | (UInt32)WinAPI.ThreadAccessRights.WRITE_OWNER;
        private const UInt32 NORMAL_PRIORITY_CLASS = 0x20;
        private const UInt32 HIGH_PRIORITY_CLASS = 0x80;
        private const UInt32 DEBUG_PROCESS = 0x01;
        private const UInt32 CREATE_NEW_CONSOLE = 0x10;
        private const UInt32 CREATE_NEW_PROCESS_GROUP = 0x200;
        private const UInt32 CREATE_DEFAULT_ERROR_MODE = 0x04000000;

        /// <summary>
        /// Windows API Interface.
        /// </summary>
        private static class WinAPI
        {
            // Kernel32 DLL Imports
            #region Kernel32

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern Int32 GetLastError();

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern Boolean DebugActiveProcess([In] UInt32 dwProcessId);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern Boolean DebugBreakProcess([In] IntPtr ProcessHandle);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern Boolean ReadProcessMemory([In] IntPtr ProcessHandle, [In] IntPtr BaseAddress, [In, Out] Byte[] Buffer, [In] Int32 BufferSize, [Out] out Int32 BytesRead);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern Boolean WriteProcessMemory([In] IntPtr ProcessHandle, [In] IntPtr BaseAddress, [In] Byte[] Buffer, [In] Int32 BufferSize, [Out] out Int32 BytesWritten);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern IntPtr GetProcAddress([In] IntPtr Module, [In] String ProcedureName);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern Boolean IsWow64Process([In] IntPtr Module, [Out] out Boolean WoW64Process);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern IntPtr LoadLibrary([In] String LibraryName);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern Boolean WaitForDebugEvent([Out] out Debug_Event Event, [In] UInt32 Milliseconds);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
            public static extern Boolean ContinueDebugEvent([In] UInt32 ProcessId, [In] UInt32 ThreadId, [In] ContinueStatus ContinueStatus);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern IntPtr OpenThread([In] ThreadAccessRights DesiredAccess, [In] Boolean InheritHandle, [In] UInt32 ThreadID);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern Boolean CloseHandle([In] IntPtr Handle);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern Boolean CreateProcess(String ApplicationName, String CommandLine, IntPtr ProcessAttributes, IntPtr ThreadAttributes, Boolean InheritHandles, UInt32 CreationFlags, IntPtr Environment, String CurrentDirectory, ref STARTUP_INFO StartupInfo, ref PROCESS_INFORMATION ProcessInformation);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern Boolean TerminateThread(IntPtr Thread, UInt32 ExitCode);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern IntPtr OpenThread(UInt32 DesiredAccess, Boolean InheritHandle, UInt32 ThreadID);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern Boolean TerminateProcess([In] IntPtr Process, [In] UInt32 ExitCode);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern Boolean DebugActiveProcessStop([In] UInt32 ProcessId);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern Boolean SetThreadContext([In] IntPtr Thread, [In] ref CONTEXT Context);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern Boolean GetThreadContext([In] IntPtr Thread, [In, Out] ref CONTEXT Context);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern Boolean WriteProcessMemory([In] IntPtr Process, [In] IntPtr BaseAddress, [In] Byte[] Buffer, UInt32 Size, [Out] out UIntPtr NumberBytesWritten);

            [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern UInt32 GetShortPathName([In] String LongPath, [Out] StringBuilder ShortPath, [In] UInt32 BufferLength);

            #endregion Kernel32

            #region Ntdll

            [DllImport("Ntdll.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern SYSTEM_ERROR_CODE NtQueryInformationProcess(IntPtr ProcessHandle, Int32 ProcessInformationClass, ref BasicProcessInformation ProcessInformation, UInt32 ProcessInformationLength, out Int32 ReturnLength);

            #endregion Ntdll

            // User32 DLL Imports
            #region User32

            [DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern IntPtr CreateDesktop(String Desktop, IntPtr Device, IntPtr DevMode, UInt32 Flags, UInt32 DesiredAccess, IntPtr lpsa);

            [DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
            public static extern bool CloseDesktop([In] IntPtr Desktop);
            #endregion User32

            // Structures used by the Windows API
            #region Structs

            [StructLayout(LayoutKind.Sequential)]
            public struct BasicProcessInformation
            {
                public IntPtr Reserved1;
                public IntPtr PebBaseAddress;
                public IntPtr Reserved2;
                public IntPtr Reserved2_1;
                public IntPtr UniqueProcessId;
                public IntPtr InheritedFromUniqueProcessId;
            }

            [StructLayout(LayoutKind.Sequential)]
            public struct STARTUP_INFO
            {
                public Int32 cb;
                public String Reserved;
                public String Desktop;
                public String Title;
                public Int32 dwX;
                public Int32 dwY;
                public Int32 dwXSize;
                public Int32 dwYSize;
                public Int32 dwXCountChars;
                public Int32 dwYCountChars;
                public Int32 Flags;
                public Int16 ShowWindow;
                public Int16 cb2;
                public IntPtr Reserved2;
                public IntPtr StdInput;
                public IntPtr StdOutput;
                public IntPtr StdError;
            }

            [StructLayout(LayoutKind.Sequential)]
            public struct PROCESS_INFORMATION
            {
                public IntPtr Process;
                public IntPtr Thread;
                public Int32 ProcessId;
                public Int32 ThreadId;
            }

            #endregion Structs

            // Enumerated types used by the Windows API
            #region Enums

            public enum WindowFlags : UInt32
            {
                GW_HWNDFIRST = 0,
                GW_HWNDLAST = 1,
                GW_HWNDNEXT = 2,
                GW_HWNPREV = 3,
                GW_OWNER = 4,
                GW_CHILD = 5,
                GW_ENABLEDPOPUP = 6
            }

            public enum WINDOW_MESSAGE : UInt32
            {
                BN_CLICKED = 0x0000,
                BM_CLICK = 0x00F5,
                WM_CLOSE = 0x0010,
                SC_CLOSE = 0xF060
            }

            public enum ACCESS_MASK : UInt32
            {
                DESKTOP_CREATEMENU = 0x4,
                DESKTOP_CREATEWINDOW = 0x2,
                DESKTOP_ENUMERATE = 0x40,
                DESKTOP_HOOKCONTROL = 0x8,
                DESKTOP_JOURNALPLAYBACK = 0x20,
                DESKTOP_JOURNALRECORD = 0x10,
                DESKTOP_READOBJECTS = 0x1,
                DESKTOP_SWITCHDESKTOP = 0x100,
                DESKTOP_WRITEOBJECTS = 0x80,

                GENERIC_ALL = (DESKTOP_CREATEMENU | DESKTOP_CREATEWINDOW | DESKTOP_ENUMERATE | DESKTOP_HOOKCONTROL | DESKTOP_JOURNALPLAYBACK | DESKTOP_JOURNALRECORD | DESKTOP_READOBJECTS | DESKTOP_SWITCHDESKTOP | DESKTOP_WRITEOBJECTS | STANDARD_RIGHTS_REQUIRED)
            }

            public enum ThreadAccessRights : UInt32
            {
                DELETE = 0x00010000,
                READ_CONTROL = 0x00020000,
                SYNCHRONIZE = 0x00100000,
                WRITE_DAC = 0x00040000,
                WRITE_OWNER = 0x00080000,
                THREAD_GET_CONTEXT = 0x0008
            }

            public enum ContinueStatus : UInt32
            {
                DBG_CONTINUE = 0x00010002,
                DBG_EXCEPTION_NOT_HANDLED = 0x80010001
            }

            public enum SYSTEM_ERROR_CODE : UInt32
            {
                ERROR_SUCCESS = 0x0,
                ERROR_INVALID_FUNCTION = 0x1,
                ERROR_FILE_NOT_FOUND = 0x2,
                ERROR_PATH_NOT_FOUND = 0x3,
                ERROR_TOO_MANY_OPEN_FILES = 0x4,
                ERROR_ACCESS_DENIED = 0x5,
                ERROR_INVALID_HANDLE = 0x6,
                ERROR_ARENA_TRASHED = 0x7,
                ERROR_NOT_ENOUGH_MEMORY = 0x8,
                ERROR_INVALID_BLOCK = 0x9,
                ERROR_BAD_ENVIRONMENT = 0xA,
                ERROR_BAD_FORMAT = 0xB,
                ERROR_INVALID_ACCESS = 0xC,
                ERROR_INVALID_DATA = 0xD,
                ERROR_OUTOFMEMORY = 0xE,
                ERROR_INVALID_DRIVE = 0xF,
                ERROR_CURRENT_DIRECTORY = 0x10,
                ERROR_NOT_SAME_DEVICE = 0x11,
                ERROR_NO_MORE_FILES = 0x12,
                ERROR_WRITE_PROTECT = 0x13,
                ERROR_BAD_UNIT = 0x14,
                ERROR_NOT_READY = 0x15,
                ERROR_BAD_COMMAND = 0x16,
                ERROR_CRC = 0x17,
                ERROR_BAD_LENGTH = 0x18,
                ERROR_SEEK = 0x19,
                ERROR_NOT_DOS_DISK = 0x1A,
                ERROR_SECTOR_NOT_FOUND = 0x1B,
                ERROR_OUT_OF_PAPER = 0x1C,
                ERROR_WRITE_FAULT = 0x1D,
                ERROR_READ_FAULT = 0x1E,
                ERROR_GEN_FAILURE = 0x1F,
                ERROR_SHARING_VIOLATION = 0x20,
                ERROR_LOCK_VIOLATION = 0x21,
                ERROR_WRONG_DISK = 0x22,
                ERROR_SHARING_BUFFER_EXCEEDED = 0x24,
                ERROR_HANDLE_EOF = 0x26,
                ERROR_HANDLE_DISK_FULL = 0x27,
                ERROR_NOT_SUPPORTED = 0x32,
                ERROR_REM_NOT_LIST = 0x33,
                ERROR_DUP_NAME = 0x34,
                ERROR_BAD_NETPATH = 0x35,
                ERROR_NETWORK_BUSY = 0x36,
                ERROR_DEV_NOT_EXIST = 0x37,
                ERROR_TOO_MANY_CMDS = 0x38,
                ERROR_ADAP_HDW_ERR = 0x39,
                ERROR_BAD_NET_RESP = 0x3A,
                ERROR_UNEXP_NET_ERR = 0x3B,
                ERROR_BAD_REM_ADAP = 0x3C,
                ERROR_PRINTQ_FULL = 0x3D,
                ERROR_NO_SPOOL_SPACE = 0x3E,
                ERROR_PRINT_CANCELLED = 0x3F,
                ERROR_NETNAME_DELETED = 0x40,
                ERROR_NETWORK_ACCESS_DENIED = 0x41,
                ERROR_BAD_DEV_TYPE = 0x42,
                ERROR_BAD_NET_NAME = 0x43,
                ERROR_TOO_MANY_NAMES = 0x44,
                ERROR_TOO_MANY_SESS = 0x45,
                ERROR_SHARING_PAUSED = 0x46,
                ERROR_REQ_NOT_ACCEP = 0x47,
                ERROR_REDIR_PAUSED = 0x48,
                ERROR_FILE_EXISTS = 0x50,
                ERROR_CANNOT_MAKE = 0x52,
                ERROR_FAIL_I24 = 0x53,
                ERROR_OUT_OF_STRUCTURES = 0x54,
                ERROR_ALREADY_ASSIGNED = 0x55,
                ERROR_INVALID_PASSWORD = 0x56,
                ERROR_INVALID_PARAMETER = 0x57,
                ERROR_NET_WRITE_FAULT = 0x58,
                ERROR_NO_PROC_SLOTS = 0x59,
                ERROR_TOO_MANY_SEMAPHORES = 0x64,
                ERROR_EXCL_SEM_ALREADY_OWNED = 0x65,
                ERROR_SEM_IS_SET = 0x66,
                ERROR_TOO_MANY_SEM_REQUESTS = 0x67,
                ERROR_INVALID_AT_INTERRUPT_TIME = 0x68,
                ERROR_SEM_OWNER_DIED = 0x69,
                ERROR_SEM_USER_LIMIT = 0x6A,
                ERROR_DISK_CHANGE = 0x6B,
                ERROR_DRIVE_LOCKED = 0x6C,
                ERROR_BROKEN_PIPE = 0x6D,
                ERROR_OPEN_FAILED = 0x6E,
                ERROR_BUFFER_OVERFLOW = 0x6F,
                ERROR_DISK_FULL = 0x70,
                ERROR_NO_MORE_SEARCH_HANDLES = 0x71,
                ERROR_INVALID_TARGET_HANDLE = 0x72,
                ERROR_INVALID_CATEGORY = 0x75,
                ERROR_INVALID_VERIFY_SWITCH = 0x76,
                ERROR_BAD_DRIVER_LEVEL = 0x77,
                ERROR_CALL_NOT_IMPLEMENTED = 0x78,
                ERROR_SEM_TIMEOUT = 0x79,
                ERROR_INSUFFICIENT_BUFFER = 0x7A,
                ERROR_INVALID_NAME = 0x7B,
                ERROR_INVALID_LEVEL = 0x7C,
                ERROR_NO_VOLUME_LABEL = 0x7D,
                ERROR_MOD_NOT_FOUND = 0x7E,
                ERROR_PROC_NOT_FOUND = 0x7F,
                ERROR_WAIT_NO_CHILDREN = 0x80,
                ERROR_CHILD_NOT_COMPLETE = 0x81,
                ERROR_DIRECT_ACCESS_HANDLE = 0x82,
                ERROR_NEGATIVE_SEEK = 0x83,
                ERROR_SEEK_ON_DEVICE = 0x84,
                ERROR_IS_JOIN_TARGET = 0x85,
                ERROR_IS_JOINED = 0x86,
                ERROR_IS_SUBSTED = 0x87,
                ERROR_NOT_JOINED = 0x88,
                ERROR_NOT_SUBSTED = 0x89,
                ERROR_JOIN_TO_JOIN = 0x8A,
                ERROR_SUBST_TO_SUBST = 0x8B,
                ERROR_JOIN_TO_SUBST = 0x8C,
                ERROR_SUBST_TO_JOIN = 0x8D,
                ERROR_BUSY_DRIVE = 0x8E,
                ERROR_SAME_DRIVE = 0x8F,
                ERROR_DIR_NOT_ROOT = 0x90,
                ERROR_DIR_NOT_EMPTY = 0x91,
                ERROR_IS_SUBST_PATH = 0x92,
                ERROR_IS_JOIN_PATH = 0x93,
                ERROR_PATH_BUSY = 0x94,
                ERROR_IS_SUBST_TARGET = 0x95,
                ERROR_SYSTEM_TRACE = 0x96,
                ERROR_INVALID_EVENT_COUNT = 0x97,
                ERROR_TOO_MANY_MUXWAITERS = 0x98,
                ERROR_INVALID_LIST_FORMAT = 0x99,
                ERROR_LABEL_TOO_LONG = 0x9A,
                ERROR_TOO_MANY_TCBS = 0x9B,
                ERROR_SIGNAL_REFUSED = 0x9C,
                ERROR_DISCARDED = 0x9D,
                ERROR_NOT_LOCKED = 0x9E,
                ERROR_BAD_THREADID_ADDR = 0x9F,
                ERROR_BAD_ARGUMENTS = 0xA0,
                ERROR_BAD_PATHNAME = 0xA1,
                ERROR_SIGNAL_PENDING = 0xA2,
                ERROR_MAX_THRDS_REACHED = 0xA4,
                ERROR_LOCK_FAILED = 0xA7,
                ERROR_BUSY = 0xAA,
                ERROR_DEVICE_SUPPORT_IN_PROGRESS = 0xAB,
                ERROR_CANCEL_VIOLATION = 0xAD,
                ERROR_ATOMIC_LOCKS_NOT_SUPPORTED = 0xAE,
                ERROR_INVALID_SEGMENT_NUMBER = 0xB4,
                ERROR_INVALID_ORDINAL = 0xB6,
                ERROR_ALREADY_EXISTS = 0xB7,
                ERROR_INVALID_FLAG_NUMBER = 0xBA,
                ERROR_SEM_NOT_FOUND = 0xBB,
                ERROR_INVALID_STARTING_CODESEG = 0xBC,
                ERROR_INVALID_STACKSEG = 0xBD,
                ERROR_INVALID_MODULETYPE = 0xBE,
                ERROR_INVALID_EXE_SIGNATURE = 0xBF,
                ERROR_EXE_MARKED_INVALID = 0xC0,
                ERROR_BAD_EXE_FORMAT = 0xC1,
                ERROR_ITERATED_DATA_EXCEEDS_64k = 0xC2,
                ERROR_INVALID_MINALLOCSIZE = 0xC3,
                ERROR_DYNLINK_FROM_INVALID_RING = 0xC4,
                ERROR_IOPL_NOT_ENABLED = 0xC5,
                ERROR_INVALID_SEGDPL = 0xC6,
                ERROR_AUTODATASEG_EXCEEDS_64k = 0xC7,
                ERROR_RING2SEG_MUST_BE_MOVABLE = 0xC8,
                ERROR_RELOC_CHAIN_XEEDS_SEGLIM = 0xC9,
                ERROR_INFLOOP_IN_RELOC_CHAIN = 0xCA,
                ERROR_ENVVAR_NOT_FOUND = 0xCB,
                ERROR_NO_SIGNAL_SENT = 0xCD,
                ERROR_FILENAME_EXCED_RANGE = 0xCE,
                ERROR_RING2_STACK_IN_USE = 0xCF,
                ERROR_META_EXPANSION_TOO_LONG = 0xD0,
                ERROR_INVALID_SIGNAL_NUMBER = 0xD1,
                ERROR_THREAD_1_INACTIVE = 0xD2,
                ERROR_LOCKED = 0xD4,
                ERROR_TOO_MANY_MODULES = 0xD6,
                ERROR_NESTING_NOT_ALLOWED = 0xD7,
                ERROR_EXE_MACHINE_TYPE_MISMATCH = 0xD8,
                ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY = 0xD9,
                ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY = 0xDA,
                ERROR_FILE_CHECKED_OUT = 0xDC,
                ERROR_CHECKOUT_REQUIRED = 0xDD,
                ERROR_BAD_FILE_TYPE = 0xDE,
                ERROR_FILE_TOO_LARGE = 0xDF,
                ERROR_FORMS_AUTH_REQUIRED = 0xE0,
                ERROR_VIRUS_INFECTED = 0xE1,
                ERROR_VIRUS_DELETED = 0xE2,
                ERROR_PIPE_LOCAL = 0xE5,
                ERROR_BAD_PIPE = 0xE6,
                ERROR_PIPE_BUSY = 0xE7,
                ERROR_NO_DATA = 0xE8,
                ERROR_PIPE_NOT_CONNECTED = 0xE9,
                ERROR_MORE_DATA = 0xEA,
                ERROR_VC_DISCONNECTED = 0xF0,
                ERROR_INVALID_EA_NAME = 0xFE,
                ERROR_EA_LIST_INCONSISTENT = 0xFF,
                WAIT_TIMEOUT = 0x102,
                ERROR_NO_MORE_ITEMS = 0x103,
                ERROR_CANNOT_COPY = 0x10A,
                ERROR_DIRECTORY = 0x10B,
                ERROR_EAS_DIDNT_FIT = 0x113,
                ERROR_EA_FILE_CORRUPT = 0x114,
                ERROR_EA_TABLE_FULL = 0x115,
                ERROR_INVALID_EA_HANDLE = 0x116,
                ERROR_EAS_NOT_SUPPORTED = 0x11A,
                ERROR_NOT_OWNER = 0x120,
                ERROR_TOO_MANY_POSTS = 0x12A,
                ERROR_PARTIAL_COPY = 0x12B,
                ERROR_OPLOCK_NOT_GRANTED = 0x12C,
                ERROR_INVALID_OPLOCK_PROTOCOL = 0x12D,
                ERROR_DISK_TOO_FRAGMENTED = 0x12E,
                ERROR_DELETE_PENDING = 0x12F,
                ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = 0x130,
                ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME = 0x131,
                ERROR_SECURITY_STREAM_IS_INCONSISTENT = 0x132,
                ERROR_INVALID_LOCK_RANGE = 0x133,
                ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT = 0x134,
                ERROR_NOTIFICATION_GUID_ALREADY_DEFINED = 0x135,
                ERROR_INVALID_EXCEPTION_HANDLER = 0x136,
                ERROR_DUPLICATE_PRIVILEGES = 0x137,
                ERROR_NO_RANGES_PROCESSED = 0x138,
                ERROR_NOT_ALLOWED_ON_SYSTEM_FILE = 0x139,
                ERROR_DISK_RESOURCES_EXHAUSTED = 0x13A,
                ERROR_INVALID_TOKEN = 0x13B,
                ERROR_DEVICE_FEATURE_NOT_SUPPORTED = 0x13C,
                ERROR_MR_MID_NOT_FOUND = 0x13D,
                ERROR_SCOPE_NOT_FOUND = 0x13E,
                ERROR_UNDEFINED_SCOPE = 0x13F,
                ERROR_INVALID_CAP = 0x140,
                ERROR_DEVICE_UNREACHABLE = 0x141,
                ERROR_DEVICE_NO_RESOURCES = 0x142,
                ERROR_DATA_CHECKSUM_ERROR = 0x143,
                ERROR_INTERMIXED_SECURE_EA_OPERATION = 0x144,
                ERROR_SPECIFIED_COPY_READ = 0x145,
                ERROR_REPAIR_DEFERRED = 0x146,
                ERROR_OFFSET_ALIGNMENT_VIOLATION = 0x147,
                ERROR_INVALID_FIELD_IN_PARAMETER_LIST = 0x148,
                ERROR_OPERATION_IN_PROGRESS = 0x149,
                ERROR_BAD_DEVICE_PATH = 0x14A,
                ERROR_TOO_MANY_DESCRIPTORS = 0x14B,
                ERROR_SCRUB_DATA_DISABLED = 0x14C,
                ERROR_FAIL_NOACTION_REBOOT = 0x15E,
                ERROR_FAIL_SHUTDOWN = 0x15F,
                ERROR_FAIL_RESTART = 0x160,
                ERROR_MAX_SESSIONS_REACHED = 0x161,
                ERROR_THREAD_MODE_ALREADY_BACKGROUND = 0x190,
                ERROR_THREAD_MODE_NOT_BACKGROUND = 0x191,
                ERROR_PROCESS_MODE_ALREADY_BACKGROUND = 0x192,
                ERROR_PROCESS_MODE_NOT_BACKGROUND = 0x193,
                ERROR_INVALID_ADDRESS = 0x1E7
            }

            #endregion Enums
        }

        #endregion DLL_Imports

        #region private_Structure_Definitions

        /// <summary>
        /// Function Pointer to handle EnumWindow Callbacks
        /// </summary>
        /// <param name="WindowHandle"></param>
        /// <param name="Param"></param>
        /// <returns></returns>
        private delegate Boolean WindowCallback(IntPtr WindowHandle, IntPtr Param);

        /// <summary>
        /// The context of a thread running on a 32-bit platform
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        private struct CONTEXT
        {
            public CONTEXT_FLAGS ContextFlags;

            public UInt32 Dr0;
            public UInt32 Dr1;
            public UInt32 Dr2;
            public UInt32 Dr3;
            public UInt32 Dr6;
            public UInt32 Dr7;

            public FLOATING_SAVE_AREA FloatSave;

            public UInt32 SegGs;
            public UInt32 SegFs;
            public UInt32 SegEs;
            public UInt32 SegDs;

            public UInt32 Edi;
            public UInt32 Esi;
            public UInt32 Ebx;
            public UInt32 Edx;
            public UInt32 Ecx;
            public UInt32 Eax;

            public UInt32 Ebp;
            public UInt32 Eip;
            public UInt32 SegCs;
            public UInt32 EFLags;
            public UInt32 Esp;
            public UInt32 SegSs;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAXIMUM_SUPPORTED_EXTENSION)]
            public Byte[] ExtendedRegisters;
        }

        /// <summary>
        /// Flags to specify when getting a thread's context
        /// </summary>
        private enum CONTEXT_FLAGS : UInt32
        {
            CONTEXT_i386 = 0x10000,
            CONTEXT_CONTROL = CONTEXT_i386 | 0x01,
            CONTEXT_INTEGER = CONTEXT_i386 | 0x02,
            CONTEXT_SEGMENTS = CONTEXT_i386 | 0x04,
            CONTEXT_FLOATING_POINT = CONTEXT_i386 | 0x08,
            CONTEXT_DEBUG_REGISTERS = CONTEXT_i386 | 0x10,
            CONTEXT_EXTENDED_REGISTERS = CONTEXT_i386 | 0x20,
            CONTEXT_FULL = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS,
            CONTEXT_ALL = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS | CONTEXT_EXTENDED_REGISTERS
        }

        /// <summary>
        /// The floating point data, probably never be used
        /// </summary>
        private struct FLOATING_SAVE_AREA
        {
            public UInt32 ControlWord;
            public UInt32 StatusWord;
            public UInt32 TagWord;
            public UInt32 ErrorOffset;
            public UInt32 DataOffset;
            public UInt32 DataSelector;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = SIZE_OF_80387_REGISTERS)]
            public Byte[] RegisterArea;

            public UInt32 CrONpxState;
        }

        /// <summary>
        /// Represents what type of event was generated by the debuggee
        /// </summary>
        private enum EventCode : UInt32
        {
            EXCEPTION_DEBUG_INFO = 1,
            CREATE_THREAD_DEBUG_INFO = 2,
            CREATE_PROCESS_DEBUG_INFO = 3,
            EXIT_THREAD_DEBUG_INFO = 4,
            EXIT_PROCESS_DEBUG_INFO = 5,
            LOAD_DLL_DEBUG_INFO = 6,
            UNLOAD_DLL_DEBUG_INFO = 7,
            OUTPUT_DEBUG_STRING_INFO = 8,
            RIP_INFO = 9
        }

        /// <summary>
        /// Holds debug event data.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        private struct Debug_Event
        {
            public EventCode Code;
            public UInt32 ProcessID;
            public UInt32 ThreadID;
            public Union U;
        }

        /// <summary>
        /// Holds debug details, only used by Debug_Event and should not be created individually
        /// </summary>
        [StructLayout(LayoutKind.Explicit)]
        private struct Union
        {
            [FieldOffset(0)]
            public EXCEPTION_DEBUG_INFO Exception;

            [FieldOffset(0)]
            public CREATE_THREAD_DEBUG_INFO CreateThread;

            [FieldOffset(0)]
            public CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;

            [FieldOffset(0)]
            public EXIT_THREAD_DEBUG_INFO ExitThread;

            [FieldOffset(0)]
            public EXIT_PROCESS_DEBUG_INFO ExitProcess;

            [FieldOffset(0)]
            public LOAD_DLL_DEBUG_INFO LoadDll;

            [FieldOffset(0)]
            public UNLOAD_DLL_DEBUG_INFO UnloadDll;

            [FieldOffset(0)]
            public OUTPUT_DEBUG_STRING_INFO DebugString;

            [FieldOffset(0)]
            public RIP_INFO RipInfo;
        }

        /// <summary>
        /// Holds exception details, only used by Union and should not be created individually
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        private struct EXCEPTION_DEBUG_INFO
        {
            public EXCEPTION_RECORD ExceptionRecord;
            public UInt32 FirstChance;
        }

        /// <summary>
        /// Holds thread creation details, only used by Union and should not be created individually
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        private struct CREATE_THREAD_DEBUG_INFO
        {
            public IntPtr Thread;
            public IntPtr ThreadLocalBase;
            public IntPtr StartAddress;
        }

        /// <summary>
        /// Holds process creation details, only used by Union and should not be created individually
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        private struct CREATE_PROCESS_DEBUG_INFO
        {
            public IntPtr File;
            public IntPtr Process;
            public IntPtr Thread;
            public IntPtr BaseOfImage;
            public UInt32 DebugInfoFileOffset;
            public UInt32 DebugInfoSize;
            public IntPtr ThreadLocalBase;
            public IntPtr StartAddress;
            public IntPtr ImageName;
            public UInt16 Unicode;
        }

        /// <summary>
        /// Holds the exit code for the thread, only used by Union and should not be created individually
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        private struct EXIT_THREAD_DEBUG_INFO
        {
            public UInt32 ExitCode;
        }

        /// <summary>
        /// Holds the exit code for the process, only used by Union and should not be created individually
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        private struct EXIT_PROCESS_DEBUG_INFO
        {
            public UInt32 ExitCode;
        }

        /// <summary>
        /// Holds the loaded DLL information, only used by Union and should not be created individually
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        private struct LOAD_DLL_DEBUG_INFO
        {
            public IntPtr File;
            public IntPtr BaseOfDll;
            public UInt32 DebugInfoFileOffset;
            public UInt32 DebugInfoSize;
            public IntPtr ImageName;
            public UInt16 Unicode;
        }

        /// <summary>
        /// Holds the unloaded DLL information, only used by Union and should not be created individually
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        private struct UNLOAD_DLL_DEBUG_INFO
        {
            public IntPtr BaseOfDll;
        }

        /// <summary>
        /// Holds the output debug string information, only used by Union and should not be created individually
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        private struct OUTPUT_DEBUG_STRING_INFO
        {
            //[MarshalAs(UnmanagedType.LPStr)]
            //public string DebugStringData;
            public IntPtr DebugStringData;
            public UInt16 Unicode;
            public UInt16 DebugStringLength;
        }

        /// <summary>
        /// Holds the error information for the RIP debug event, only used by Union and should not be created individually
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        private struct RIP_INFO
        {
            public UInt32 Error;
            public UInt32 Type;
        }

        /// <summary>
        /// Holds individual exception information, only used by Exception_Debug_Info and should not be created individually
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        private struct EXCEPTION_RECORD
        {
            public UInt32 ExceptionCode;
            public UInt32 ExceptionFlags;
            public IntPtr ExceptionRecord;
            public IntPtr ExceptionAddress;
            public UInt32 NumberParameters;

            // NEEDS ATTENTION - this should be marshaled but it isn't supported yet, declared each element manually in order to make it work properly.

            //[MarshalAs(UnmanagedType.ByValArray, SizeConst = 15, ArraySubType = UnmanagedType.U4)]
            //public uint[] exceptioninformation;
            public IntPtr ExceptionInformation0;
            public IntPtr ExceptionInformation1;
            public IntPtr ExceptionInformation2;
            public IntPtr ExceptionInformation3;
            public IntPtr ExceptionInformation4;
            public IntPtr ExceptionInformation5;
            public IntPtr ExceptionInformation6;
            public IntPtr ExceptionInformation7;
            public IntPtr ExceptionInformation8;
            public IntPtr ExceptionInformation9;
            public IntPtr ExceptionInformation10;
            public IntPtr ExceptionInformation11;
            public IntPtr ExceptionInformation12;
            public IntPtr ExceptionInformation13;
            public IntPtr ExceptionInformation14;
        }

        #endregion private_Structure_Definitions

    } // End class

} // End namespace