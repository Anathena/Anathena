// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.Direct3D12 namespace.
//     This code was generated by a tool.
//     Date : 6/25/2016 10:38:14 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.Direct3D12 {

#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574

        /// <summary>	
        /// Functions	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.Direct3D12.D3D12']/*"/>	
    static  partial class D3D12 {   
        
        /// <summary>	
        /// <p> Deserializes a root signature so you can determine the layout definition (<strong><see cref="SharpDX.Direct3D12.RootSignatureDescription"/></strong>). </p>	
        /// </summary>	
        /// <param name="srcDataRef">No documentation.</param>	
        /// <param name="srcDataSizeInBytes">No documentation.</param>	
        /// <param name="rootSignatureDeserializerInterfaceRef">No documentation.</param>	
        /// <param name="rootSignatureDeserializerOut">No documentation.</param>	
        /// <returns><p> Returns <strong><see cref="SharpDX.Result.Ok"/></strong> if successful; otherwise, returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p> If an application has a serialized root signature already or has a compiled shader that contains a root signature and wants to determine the layout definition, it can call <strong><see cref="SharpDX.Direct3D12.D3D12.CreateRootSignatureDeserializer"/></strong> to generate a <strong><see cref="SharpDX.Direct3D12.RootSignatureDeserializer"/></strong> interface. <strong>ID3D12RootSignatureDeserializer::GetRootSignature</strong> can return the deserialized data structure (<strong><see cref="SharpDX.Direct3D12.RootSignatureDescription"/></strong>). <strong><see cref="SharpDX.Direct3D12.RootSignatureDeserializer"/></strong> just owns the lifetime of the memory for the deserialized data structure. </p><p> The <strong>REFIID</strong>, or <strong><see cref="System.Guid"/></strong>, of the interface to the root signature deserializer can be obtained by using the __uuidof() macro. For example, __uuidof(<strong><see cref="SharpDX.Direct3D12.RootSignatureDeserializer"/></strong>) will get the <strong><see cref="System.Guid"/></strong> of the interface to a root signature deserializer. </p><p> The function signature PFN_D3D12_CREATE_ROOT_SIGNATURE_DESERIALIZER is provided as a typedef, so that you can use dynamic linking techniques (GetProcAddress) instead of statically linking. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3D12CreateRootSignatureDeserializer']/*"/>	
        /// <msdn-id>dn859362</msdn-id>	
        /// <unmanaged>HRESULT D3D12CreateRootSignatureDeserializer([In, Buffer] const void* pSrcData,[In] SIZE_T SrcDataSizeInBytes,[In] const GUID&amp; pRootSignatureDeserializerInterface,[Out] void** ppRootSignatureDeserializer)</unmanaged>	
        /// <unmanaged-short>D3D12CreateRootSignatureDeserializer</unmanaged-short>	
        public static void CreateRootSignatureDeserializer(System.IntPtr srcDataRef, SharpDX.PointerSize srcDataSizeInBytes, System.Guid rootSignatureDeserializerInterfaceRef, out System.IntPtr rootSignatureDeserializerOut) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* rootSignatureDeserializerOut_ = &rootSignatureDeserializerOut)
                    __result__= 
    				D3D12CreateRootSignatureDeserializer_((void*)srcDataRef, (void*)srcDataSizeInBytes, &rootSignatureDeserializerInterfaceRef, rootSignatureDeserializerOut_);		
                __result__.CheckError();
            }
        }
        [DllImport("d3d12.dll", EntryPoint = "D3D12CreateRootSignatureDeserializer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3D12CreateRootSignatureDeserializer_(void* arg0,void* arg1,void* arg2,void* arg3);
        
        /// <summary>	
        /// <p>Creates a device that represents the display adapter.</p>	
        /// </summary>	
        /// <param name="adapterRef"><dd>  <p> A reference to the video adapter to use when creating a device. Pass <strong><c>null</c></strong> to use the default adapter, which is the first adapter that is enumerated by <strong>IDXGIFactory1::EnumAdapters</strong>. </p> <strong>Note</strong>?? Do not mix the use of DXGI 1.0 (<strong><see cref="SharpDX.DXGI.Factory"/></strong>) and DXGI 1.1 (<strong><see cref="SharpDX.DXGI.Factory1"/></strong>) in an application. Use <strong><see cref="SharpDX.DXGI.Factory"/></strong> or <strong><see cref="SharpDX.DXGI.Factory1"/></strong>, but not both in an application.  ? </dd></param>	
        /// <param name="minimumFeatureLevel"><dd>  <p> The <strong><see cref="SharpDX.Direct3D.DriverType"/></strong>, which represents the driver type to create. </p> </dd></param>	
        /// <param name="riid"><dd>  <p> A handle to a DLL that implements a software rasterizer. If <em>DriverType</em> is <em><see cref="SharpDX.Direct3D.DriverType.Software"/></em>, <em>Software</em> must not be <strong><c>null</c></strong>. Get the handle by calling LoadLibrary, LoadLibraryEx , or GetModuleHandle. </p> </dd></param>	
        /// <param name="deviceOut"><dd>  <p> Returns the address of a reference to an <strong><see cref="SharpDX.Direct3D11.Device"/></strong> object that represents the device created. If this parameter is <strong><c>null</c></strong>, no <see cref="SharpDX.Direct3D11.Device"/> will be returned. </p> </dd></param>	
        /// <returns><p> This method can return one of the Direct3D 11 Return Codes. </p><p> This method returns E_INVALIDARG if you set the <em>pAdapter</em> parameter to a non-<strong><c>null</c></strong> value and the <em>DriverType</em> parameter to the <see cref="SharpDX.Direct3D.DriverType.Hardware"/> value. </p><p> This method returns <strong><see cref="SharpDX.DXGI.ResultCode.SdkComponentMissing"/></strong> if you specify <strong><see cref="SharpDX.Direct3D11.DeviceCreationFlags.Debug"/></strong> in <em>Flags</em> and the incorrect version of the debug layer is installed on your computer. Install the latest Windows SDK to get the correct version. </p></returns>	
        /// <remarks>	
        /// <p> This entry-point is supported by the Direct3D 11 runtime, which is available on Windows 7, Windows Server 2008 R2, and as an update to Windows Vista (KB971644). </p><p> To create a Direct3D 11.1 device (<strong><see cref="SharpDX.Direct3D11.Device1"/></strong>), which is available on Windows?8, Windows Server?2012, and Windows?7 and Windows Server?2008?R2 with the Platform Update for Windows 7 installed, you first create a <strong><see cref="SharpDX.Direct3D11.Device"/></strong> with this function, and then call the <strong>QueryInterface</strong> method on the <strong><see cref="SharpDX.Direct3D11.Device"/></strong> object to obtain the <strong><see cref="SharpDX.Direct3D11.Device1"/></strong> interface. </p><p> To create a Direct3D 11.2 device (<strong><see cref="SharpDX.Direct3D11.Device2"/></strong>), which is available on Windows?8.1 and Windows Server?2012?R2, you first create a <strong><see cref="SharpDX.Direct3D11.Device"/></strong> with this function, and then call the <strong>QueryInterface</strong> method on the <strong><see cref="SharpDX.Direct3D11.Device"/></strong> object to obtain the <strong><see cref="SharpDX.Direct3D11.Device2"/></strong> interface. </p><p> Set <em>ppDevice</em> and <em>ppImmediateContext</em> to <strong><c>null</c></strong> to determine which feature level is supported by looking at <em>pFeatureLevel</em> without creating a device. </p><p> For an example, see How To: Create a Device and Immediate Context; to create a device and a swap chain at the same time, use <strong>D3D11CreateDeviceAndSwapChain</strong>. </p><p> If you set the <em>pAdapter</em> parameter to a non-<strong><c>null</c></strong> value, you must also set the <em>DriverType</em> parameter to the <see cref="SharpDX.Direct3D.DriverType.Unknown"/> value. If you set the <em>pAdapter</em> parameter to a non-<strong><c>null</c></strong> value and the <em>DriverType</em> parameter to the <see cref="SharpDX.Direct3D.DriverType.Hardware"/> value, <strong><see cref="SharpDX.Direct3D11.D3D11.CreateDevice"/></strong> returns an <strong><see cref="SharpDX.Result"/></strong> of E_INVALIDARG. </p><table> <tr><td> <p>Differences between Direct3D 10 and Direct3D 11:</p> <p> In Direct3D 10, the presence of <em>pAdapter</em> dictated which adapter to use and the <em>DriverType</em> could mismatch what the adapter was. </p> <p> In Direct3D 11, if you are trying to create a hardware or a software device, set <em>pAdapter</em> != <strong><c>null</c></strong> which constrains the other inputs to be: </p> <ul> <li><em>DriverType</em> must be <see cref="SharpDX.Direct3D.DriverType.Unknown"/> </li> <li><em>Software</em> must be <strong><c>null</c></strong>. </li> </ul> <p> On the other hand, if <em>pAdapter</em> == <strong><c>null</c></strong>, the <em>DriverType</em> cannot be set to <see cref="SharpDX.Direct3D.DriverType.Unknown"/>; it can be set to either: </p> <ul> <li> If <em>DriverType</em> == <see cref="SharpDX.Direct3D.DriverType.Software"/>,  <em>Software</em> cannot be <strong><c>null</c></strong>. </li> <li> If <em>DriverType</em> == <see cref="SharpDX.Direct3D.DriverType.Hardware"/>, the adapter used will be the default adapter, which is the first adapter that is enumerated by <strong>IDXGIFactory1::EnumAdapters</strong> </li> </ul> </td></tr> </table><p>?</p><p> The function signature PFN_D3D11_CREATE_DEVICE is provided as a typedef, so that you can use dynamic linking techniques (GetProcAddress) instead of statically linking. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p><p><strong>Windows Phone 8.1: </strong> This API is supported. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3D12CreateDevice']/*"/>	
        /// <msdn-id>ff476082</msdn-id>	
        /// <unmanaged>HRESULT D3D12CreateDevice([In, Optional] IUnknown* pAdapter,[In] D3D_FEATURE_LEVEL MinimumFeatureLevel,[In] const GUID&amp; riid,[Out, Fast] ID3D12Device** ppDevice)</unmanaged>	
        /// <unmanaged-short>D3D12CreateDevice</unmanaged-short>	
        public static SharpDX.Result CreateDevice(SharpDX.ComObject adapterRef, SharpDX.Direct3D.FeatureLevel minimumFeatureLevel, System.Guid riid, SharpDX.Direct3D12.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3D12CreateDevice_((void*)((adapterRef == null)?IntPtr.Zero:adapterRef.NativePointer), unchecked((int)minimumFeatureLevel), &riid, &deviceOut_);		
                ((SharpDX.Direct3D12.Device)deviceOut).NativePointer = deviceOut_;
                return __result__;
            }
        }
        [DllImport("d3d12.dll", EntryPoint = "D3D12CreateDevice", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3D12CreateDevice_(void* arg0,int arg1,void* arg2,void* arg3);
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="rootSignatureRef">No documentation.</param>	
        /// <param name="version">No documentation.</param>	
        /// <param name="blobOut">No documentation.</param>	
        /// <param name="errorBlobOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3D12SerializeRootSignature']/*"/>	
        /// <unmanaged>HRESULT D3D12SerializeRootSignature([In] const void* pRootSignature,[In] D3D_ROOT_SIGNATURE_VERSION Version,[Out] ID3D10Blob** ppBlob,[Out, Optional] ID3D10Blob** ppErrorBlob)</unmanaged>	
        /// <unmanaged-short>D3D12SerializeRootSignature</unmanaged-short>	
        public static SharpDX.Result SerializeRootSignature(System.IntPtr rootSignatureRef, SharpDX.Direct3D12.RootSignatureVersion version, out SharpDX.Direct3D.Blob blobOut, out SharpDX.Direct3D.Blob errorBlobOut) {
            unsafe {
                IntPtr blobOut_ = IntPtr.Zero;
                IntPtr errorBlobOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3D12SerializeRootSignature_((void*)rootSignatureRef, unchecked((int)version), &blobOut_, &errorBlobOut_);		
                blobOut= (blobOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(blobOut_);	
                errorBlobOut= (errorBlobOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorBlobOut_);	
                return __result__;
            }
        }
        [DllImport("d3d12.dll", EntryPoint = "D3D12SerializeRootSignature", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3D12SerializeRootSignature_(void* arg0,int arg1,void* arg2,void* arg3);
        
        /// <summary>	
        /// <p> Gets a debug interface. </p>	
        /// </summary>	
        /// <param name="riid"><dd>  <p> The globally unique identifier (<strong><see cref="System.Guid"/></strong>) for the debug interface. The <strong>REFIID</strong>, or <strong><see cref="System.Guid"/></strong>, of the debug interface can be obtained by using the __uuidof() macro. For example, __uuidof(<strong><see cref="SharpDX.Direct3D12.DebugInterface"/></strong>) will get the <strong><see cref="System.Guid"/></strong> of the debug interface. </p> </dd></param>	
        /// <param name="vDebugOut"><dd>  <p> The debug interface, as a reference to reference to void. See <strong><see cref="SharpDX.Direct3D12.DebugInterface"/></strong> and <strong><see cref="SharpDX.Direct3D12.DebugDevice"/></strong>. </p> </dd></param>	
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>	
        /// <remarks>	
        /// <p> The function signature PFN_D3D12_GET_DEBUG_INTERFACE is provided as a typedef, so that you can use dynamic linking techniques (GetProcAddress) instead of statically linking. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3D12GetDebugInterface']/*"/>	
        /// <msdn-id>dn986869</msdn-id>	
        /// <unmanaged>HRESULT D3D12GetDebugInterface([In] const GUID&amp; riid,[Out, Optional] void** ppvDebug)</unmanaged>	
        /// <unmanaged-short>D3D12GetDebugInterface</unmanaged-short>	
        public static void GetDebugInterface(System.Guid riid, out System.IntPtr vDebugOut) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* vDebugOut_ = &vDebugOut)
                    __result__= 
    				D3D12GetDebugInterface_(&riid, vDebugOut_);		
                __result__.CheckError();
            }
        }
        [DllImport("d3d12.dll", EntryPoint = "D3D12GetDebugInterface", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3D12GetDebugInterface_(void* arg0,void* arg1);
    }
}
