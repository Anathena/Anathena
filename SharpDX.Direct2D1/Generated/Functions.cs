// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.Direct2D1 namespace.
//     This code was generated by a tool.
//     Date : 6/25/2016 10:38:15 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.Direct2D1 {

#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574

        /// <summary>	
        /// Functions	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.Direct2D1.D2D1']/*"/>	
    static  partial class D2D1 {   
        
        /// <summary>	
        /// <p>Indicates whether the specified matrix is invertible.</p>	
        /// </summary>	
        /// <param name="matrix"><dd>  <p>The matrix to test.</p> </dd></param>	
        /// <returns><p><strong>true</strong> if the matrix was inverted; otherwise, <strong>false</strong>.</p></returns>	
        /// <remarks>	
        /// <p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D2D1IsMatrixInvertible']/*"/>	
        /// <msdn-id>dd368045</msdn-id>	
        /// <unmanaged>BOOL D2D1IsMatrixInvertible([In] const D2D_MATRIX_3X2_F* matrix)</unmanaged>	
        /// <unmanaged-short>D2D1IsMatrixInvertible</unmanaged-short>	
        public static SharpDX.Mathematics.Interop.RawBool IsMatrixInvertible(ref SharpDX.Mathematics.Interop.RawMatrix3x2 matrix) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                fixed (void* matrix_ = &matrix)
                    __result__= 
    				D2D1IsMatrixInvertible_(matrix_);		
                return __result__;
            }
        }
        [DllImport("d2d1.dll", EntryPoint = "D2D1IsMatrixInvertible", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern SharpDX.Mathematics.Interop.RawBool D2D1IsMatrixInvertible_(void* arg0);
        
        /// <summary>	
        /// <p>Tries to invert the specified matrix.</p>	
        /// </summary>	
        /// <param name="matrix"><dd>  <p>The matrix to invert.</p> </dd></param>	
        /// <returns><p><strong>true</strong> if the matrix was inverted; otherwise, <strong>false</strong>.</p></returns>	
        /// <remarks>	
        /// <p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D2D1InvertMatrix']/*"/>	
        /// <msdn-id>dd368044</msdn-id>	
        /// <unmanaged>BOOL D2D1InvertMatrix([InOut] D2D_MATRIX_3X2_F* matrix)</unmanaged>	
        /// <unmanaged-short>D2D1InvertMatrix</unmanaged-short>	
        public static SharpDX.Mathematics.Interop.RawBool InvertMatrix(ref SharpDX.Mathematics.Interop.RawMatrix3x2 matrix) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                fixed (void* matrix_ = &matrix)
                    __result__= 
    				D2D1InvertMatrix_(matrix_);		
                return __result__;
            }
        }
        [DllImport("d2d1.dll", EntryPoint = "D2D1InvertMatrix", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern SharpDX.Mathematics.Interop.RawBool D2D1InvertMatrix_(void* arg0);
        
        /// <summary>	
        /// <p>Creates a factory object  that can be used to create Direct2D resources.</p>	
        /// </summary>	
        /// <param name="factoryType"><dd>  <p>The threading model of the factory and the resources it creates.</p> </dd></param>	
        /// <param name="riid"><dd>  <p>A reference to the IID of <strong><see cref="SharpDX.Direct2D1.Factory"/></strong> that is obtained by using __uuidof(<see cref="SharpDX.Direct2D1.Factory"/>).</p> </dd></param>	
        /// <param name="factoryOptionsRef"><dd>  <p>The level of detail provided to the debugging layer.</p> </dd></param>	
        /// <param name="iFactoryOut"><dd>  <p>When this method returns, contains the address to a reference to the new factory.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.Direct2D1.Factory"/></strong> interface provides the starting point for  Direct2D. In general, objects created from a single instance of a factory object can be used with other resources created from that instance, but not with resources created by other factory instances.   </p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D2D1CreateFactory']/*"/>	
        /// <msdn-id>dd368034</msdn-id>	
        /// <unmanaged>HRESULT D2D1CreateFactory([In] D2D1_FACTORY_TYPE factoryType,[In] const GUID&amp; riid,[In, Optional] const D2D1_FACTORY_OPTIONS* pFactoryOptions,[Out] void** ppIFactory)</unmanaged>	
        /// <unmanaged-short>D2D1CreateFactory</unmanaged-short>	
        public static void CreateFactory(SharpDX.Direct2D1.FactoryType factoryType, System.Guid riid, SharpDX.Direct2D1.FactoryOptions? factoryOptionsRef, out System.IntPtr iFactoryOut) {
            unsafe {
                SharpDX.Direct2D1.FactoryOptions factoryOptionsRef_;
                if (factoryOptionsRef.HasValue)
                    factoryOptionsRef_ = factoryOptionsRef.Value;				
                SharpDX.Result __result__;
                fixed (void* iFactoryOut_ = &iFactoryOut)
                    __result__= 
    				D2D1CreateFactory_(unchecked((int)factoryType), &riid, (factoryOptionsRef.HasValue)?&factoryOptionsRef_:(void*)IntPtr.Zero, iFactoryOut_);		
                __result__.CheckError();
            }
        }
        [DllImport("d2d1.dll", EntryPoint = "D2D1CreateFactory", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D2D1CreateFactory_(int arg0,void* arg1,void* arg2,void* arg3);
        
        /// <summary>	
        /// <p>Creates a skew transformation that has the specified x-axis angle, y-axis angle, and center point. </p>	
        /// </summary>	
        /// <param name="angleX"><dd>  <p>The x-axis skew angle, which is measured in degrees counterclockwise from the y-axis.</p> </dd></param>	
        /// <param name="angleY"><dd>  <p>The y-axis skew angle, which is measured in degrees counterclockwise from the x-axis.</p> </dd></param>	
        /// <param name="center"><dd>  <p>The center point of the skew operation.</p> </dd></param>	
        /// <param name="matrix"><dd>  <p>When this method returns, contains the rotation transformation. You must allocate storate for this parameter.</p> </dd></param>	
        /// <remarks>	
        /// <p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D2D1MakeSkewMatrix']/*"/>	
        /// <msdn-id>dd368052</msdn-id>	
        /// <unmanaged>void D2D1MakeSkewMatrix([In] float angleX,[In] float angleY,[In] D2D_POINT_2F center,[Out] D2D_MATRIX_3X2_F* matrix)</unmanaged>	
        /// <unmanaged-short>D2D1MakeSkewMatrix</unmanaged-short>	
        public static void MakeSkewMatrix(float angleX, float angleY, SharpDX.Mathematics.Interop.RawVector2 center, out SharpDX.Mathematics.Interop.RawMatrix3x2 matrix) {
            unsafe {
                matrix = new SharpDX.Mathematics.Interop.RawMatrix3x2();
                fixed (void* matrix_ = &matrix)
                    D2D1MakeSkewMatrix_(angleX, angleY, center, matrix_);		
            }
        }
        [DllImport("d2d1.dll", EntryPoint = "D2D1MakeSkewMatrix", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern void D2D1MakeSkewMatrix_(float arg0,float arg1,SharpDX.Mathematics.Interop.RawVector2 arg2,void* arg3);
        
        /// <summary>	
        /// <p>Creates a rotation transformation that rotates by the specified angle about the specified point.</p>	
        /// </summary>	
        /// <param name="angle"><dd>  <p>The clockwise rotation angle, in degrees. </p> </dd></param>	
        /// <param name="center"><dd>  <p>The point about which to rotate.</p> </dd></param>	
        /// <param name="matrix"><dd>  <p>When this method returns, contains the new rotation transformation. You must allocate storage for this parameter.  </p> </dd></param>	
        /// <remarks>	
        /// <p>Rotation occurs in the plane of the 2-D surface.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D2D1MakeRotateMatrix']/*"/>	
        /// <msdn-id>dd368049</msdn-id>	
        /// <unmanaged>void D2D1MakeRotateMatrix([In] float angle,[In] D2D_POINT_2F center,[Out] D2D_MATRIX_3X2_F* matrix)</unmanaged>	
        /// <unmanaged-short>D2D1MakeRotateMatrix</unmanaged-short>	
        public static void MakeRotateMatrix(float angle, SharpDX.Mathematics.Interop.RawVector2 center, out SharpDX.Mathematics.Interop.RawMatrix3x2 matrix) {
            unsafe {
                matrix = new SharpDX.Mathematics.Interop.RawMatrix3x2();
                fixed (void* matrix_ = &matrix)
                    D2D1MakeRotateMatrix_(angle, center, matrix_);		
            }
        }
        [DllImport("d2d1.dll", EntryPoint = "D2D1MakeRotateMatrix", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern void D2D1MakeRotateMatrix_(float arg0,SharpDX.Mathematics.Interop.RawVector2 arg1,void* arg2);
        
        /// <summary>	
        /// <p>Returns the tangent of an angle.</p>	
        /// </summary>	
        /// <param name="angle"><dd>  <p>The angle to calculate the tangent for.</p> </dd></param>	
        /// <returns><p>The tangent of the angle.</p></returns>	
        /// <remarks>	
        /// <p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D2D1Tan']/*"/>	
        /// <msdn-id>hh847941</msdn-id>	
        /// <unmanaged>float D2D1Tan([In] float angle)</unmanaged>	
        /// <unmanaged-short>D2D1Tan</unmanaged-short>	
        public static float Tan(float angle) {
            unsafe {
                float __result__;
                __result__= 
				D2D1Tan_(angle);		
                return __result__;
            }
        }
        [DllImport("d2d1.dll", EntryPoint = "D2D1Tan", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern float D2D1Tan_(float arg0);
        
        /// <summary>	
        /// <p>Returns the length of a 3 dimensional vector.</p>	
        /// </summary>	
        /// <param name="x"><dd>  <p>The  x value of the vector.</p> </dd></param>	
        /// <param name="y"><dd>  <p>The  y value of the vector.</p> </dd></param>	
        /// <param name="z"><dd>  <p>The  z value of the vector.</p> </dd></param>	
        /// <returns><p>The length of the vector.</p></returns>	
        /// <remarks>	
        /// <p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D2D1Vec3Length']/*"/>	
        /// <msdn-id>hh847942</msdn-id>	
        /// <unmanaged>float D2D1Vec3Length([In] float x,[In] float y,[In] float z)</unmanaged>	
        /// <unmanaged-short>D2D1Vec3Length</unmanaged-short>	
        public static float Vec3Length(float x, float y, float z) {
            unsafe {
                float __result__;
                __result__= 
				D2D1Vec3Length_(x, y, z);		
                return __result__;
            }
        }
        [DllImport("d2d1.dll", EntryPoint = "D2D1Vec3Length", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern float D2D1Vec3Length_(float arg0,float arg1,float arg2);
        
        /// <summary>	
        /// <p>Returns the sine and cosine of an angle.</p>	
        /// </summary>	
        /// <param name="angle"><dd>  <p>The angle to calculate.</p> </dd></param>	
        /// <param name="s"><dd>  <p>The sine of the angle.</p> </dd></param>	
        /// <param name="c"><dd>  <p>The cosine of the angle.</p> </dd></param>	
        /// <remarks>	
        /// <p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D2D1SinCos']/*"/>	
        /// <msdn-id>hh847940</msdn-id>	
        /// <unmanaged>void D2D1SinCos([In] float angle,[Out] float* s,[Out] float* c)</unmanaged>	
        /// <unmanaged-short>D2D1SinCos</unmanaged-short>	
        public static void SinCos(float angle, out float s, out float c) {
            unsafe {
                fixed (void* s_ = &s)
                    fixed (void* c_ = &c)
                        D2D1SinCos_(angle, s_, c_);		
            }
        }
        [DllImport("d2d1.dll", EntryPoint = "D2D1SinCos", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern void D2D1SinCos_(float arg0,void* arg1,void* arg2);
        
        /// <summary>	
        /// <p>Creates a new Direct2D device associated with the provided DXGI device. </p>	
        /// </summary>	
        /// <param name="dxgiDevice"><dd> <p>The DXGI device the Direct2D device is associated with.</p> </dd></param>	
        /// <param name="creationProperties"><dd> <p>The properties to apply to the Direct2D device.</p> </dd></param>	
        /// <param name="d2dDevice"><dd> <p>When this function returns, contains the address of a reference to a Direct2D device.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This function will also create a new <strong><see cref="SharpDX.Direct2D1.Factory1"/></strong> that can be retrieved through <strong><see cref="SharpDX.Direct2D1.Resource.GetFactory"/></strong>.</p><p>If the creation properties are not specified, then <em>d2dDevice</em> will inherit its threading mode from <em>dxgiDevice</em> and debug tracing will not be enabled.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D2D1CreateDevice']/*"/>	
        /// <msdn-id>hh404272</msdn-id>	
        /// <unmanaged>HRESULT D2D1CreateDevice([In] IDXGIDevice* dxgiDevice,[In, Optional] const D2D1_CREATION_PROPERTIES* creationProperties,[Out, Fast] ID2D1Device** d2dDevice)</unmanaged>	
        /// <unmanaged-short>D2D1CreateDevice</unmanaged-short>	
        public static void CreateDevice(SharpDX.DXGI.Device dxgiDevice, SharpDX.Direct2D1.CreationProperties? creationProperties, SharpDX.Direct2D1.Device d2dDevice) {
            unsafe {
                SharpDX.Direct2D1.CreationProperties creationProperties_;
                if (creationProperties.HasValue)
                    creationProperties_ = creationProperties.Value;				
                IntPtr d2dDevice_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D2D1CreateDevice_((void*)((dxgiDevice == null)?IntPtr.Zero:dxgiDevice.NativePointer), (creationProperties.HasValue)?&creationProperties_:(void*)IntPtr.Zero, &d2dDevice_);		
                ((SharpDX.Direct2D1.Device)d2dDevice).NativePointer = d2dDevice_;
                __result__.CheckError();
            }
        }
        [DllImport("d2d1.dll", EntryPoint = "D2D1CreateDevice", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D2D1CreateDevice_(void* arg0,void* arg1,void* arg2);
        
        /// <summary>	
        /// <p>Converts the given color from one colorspace to another.</p>	
        /// </summary>	
        /// <param name="sourceColorSpace"><dd>  <p>The source color space.</p> </dd></param>	
        /// <param name="destinationColorSpace"><dd>  <p>The destination color space.</p> </dd></param>	
        /// <param name="color"><dd>  <p>The source color.</p> </dd></param>	
        /// <returns><p>The converted color.</p></returns>	
        /// <remarks>	
        /// <p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D2D1ConvertColorSpace']/*"/>	
        /// <msdn-id>hh847939</msdn-id>	
        /// <unmanaged>D2D_COLOR_F D2D1ConvertColorSpace([In] D2D1_COLOR_SPACE sourceColorSpace,[In] D2D1_COLOR_SPACE destinationColorSpace,[In] const D2D_COLOR_F* color)</unmanaged>	
        /// <unmanaged-short>D2D1ConvertColorSpace</unmanaged-short>	
        public static SharpDX.Mathematics.Interop.RawColor4 ConvertColorSpace(SharpDX.Direct2D1.ColorSpace sourceColorSpace, SharpDX.Direct2D1.ColorSpace destinationColorSpace, SharpDX.Mathematics.Interop.RawColor4 color) {
            unsafe {
                SharpDX.Mathematics.Interop.RawColor4 __result__;
                D2D1ConvertColorSpace_((void*)&__result__, unchecked((int)sourceColorSpace), unchecked((int)destinationColorSpace), &color);		
                return __result__;
            }
        }
        [DllImport("d2d1.dll", EntryPoint = "D2D1ConvertColorSpace", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern void* D2D1ConvertColorSpace_(void* arg0,int arg1,int arg2,void* arg3);
        
        /// <summary>	
        /// <p>Creates a new Direct2D device context associated with a DXGI surface. </p>	
        /// </summary>	
        /// <param name="dxgiSurface"><dd> <p>The DXGI surface the Direct2D device context is associated with.</p> </dd></param>	
        /// <param name="creationProperties"><dd> <p>The properties to apply to the Direct2D device context.</p> </dd></param>	
        /// <param name="d2dDeviceContext"><dd> <p>When this function returns, contains the address of a reference to a Direct2D device context.</p> </dd></param>	
        /// <returns><p>The function returns an <strong><see cref="SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref="SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>This function will also create a new <strong><see cref="SharpDX.Direct2D1.Factory1"/></strong> that can be retrieved through <strong><see cref="SharpDX.Direct2D1.Resource.GetFactory"/></strong>.</p><p>This function will also create a new <strong><see cref="SharpDX.Direct2D1.Device"/></strong> that can be retrieved through <strong><see cref="SharpDX.Direct2D1.DeviceContext.GetDevice"/></strong>.</p><p>The DXGI device will be specified implicitly through <em>dxgiSurface</em>.</p><p>The created device context will have exactly the same behavior as if <strong>ID2D1DeviceContext::SetTargetSurface</strong> were called with the corresponding surface.</p><p>If <em>creationProperties</em> are not specified, the Direct2D device will inherit its threading mode from the DXGI device implied by <em>dxgiSurface</em> and debug tracing will not be enabled.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D2D1CreateDeviceContext']/*"/>	
        /// <msdn-id>hh404273</msdn-id>	
        /// <unmanaged>HRESULT D2D1CreateDeviceContext([In] IDXGISurface* dxgiSurface,[In, Optional] const D2D1_CREATION_PROPERTIES* creationProperties,[Out, Fast] ID2D1DeviceContext** d2dDeviceContext)</unmanaged>	
        /// <unmanaged-short>D2D1CreateDeviceContext</unmanaged-short>	
        public static void CreateDeviceContext(SharpDX.DXGI.Surface dxgiSurface, SharpDX.Direct2D1.CreationProperties? creationProperties, SharpDX.Direct2D1.DeviceContext d2dDeviceContext) {
            unsafe {
                SharpDX.Direct2D1.CreationProperties creationProperties_;
                if (creationProperties.HasValue)
                    creationProperties_ = creationProperties.Value;				
                IntPtr d2dDeviceContext_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D2D1CreateDeviceContext_((void*)((dxgiSurface == null)?IntPtr.Zero:dxgiSurface.NativePointer), (creationProperties.HasValue)?&creationProperties_:(void*)IntPtr.Zero, &d2dDeviceContext_);		
                ((SharpDX.Direct2D1.DeviceContext)d2dDeviceContext).NativePointer = d2dDeviceContext_;
                __result__.CheckError();
            }
        }
        [DllImport("d2d1.dll", EntryPoint = "D2D1CreateDeviceContext", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D2D1CreateDeviceContext_(void* arg0,void* arg1,void* arg2);
        
        /// <summary>	
        /// <p>Computes the maximum factor by which a given transform can stretch any vector.</p>	
        /// </summary>	
        /// <param name="matrix"><dd> <p>The input transform matrix.</p> </dd></param>	
        /// <returns><p>The scale factor.</p></returns>	
        /// <remarks>	
        /// <p>Formally, if M is the input matrix, this method will return the maximum value of |V * M| / |V| for all vectors V, where |.| denotes length. </p><p><strong>Note</strong>??Since this describes how M affects vectors (rather than points), the translation components (_31 and _32) of M are ignored.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D2D1ComputeMaximumScaleFactor']/*"/>	
        /// <msdn-id>dn280381</msdn-id>	
        /// <unmanaged>float D2D1ComputeMaximumScaleFactor([In] const D2D_MATRIX_3X2_F* matrix)</unmanaged>	
        /// <unmanaged-short>D2D1ComputeMaximumScaleFactor</unmanaged-short>	
        public static float ComputeMaximumScaleFactor(ref SharpDX.Mathematics.Interop.RawMatrix3x2 matrix) {
            unsafe {
                float __result__;
                fixed (void* matrix_ = &matrix)
                    __result__= 
    				D2D1ComputeMaximumScaleFactor_(matrix_);		
                return __result__;
            }
        }
        [DllImport("d2d1.dll", EntryPoint = "D2D1ComputeMaximumScaleFactor", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern float D2D1ComputeMaximumScaleFactor_(void* arg0);
        
        /// <summary>	
        /// <p>Returns the interior points for a gradient mesh patch based on the points defining a Coons patch.</p><strong>Note</strong>??<p>This function is called by the <strong>GradientMeshPatchFromCoonsPatch</strong> function and is not intended to be used directly.</p>?	
        /// </summary>	
        /// <param name="point0Ref">No documentation.</param>	
        /// <param name="point1Ref">No documentation.</param>	
        /// <param name="point2Ref">No documentation.</param>	
        /// <param name="point3Ref">No documentation.</param>	
        /// <param name="point4Ref">No documentation.</param>	
        /// <param name="point5Ref">No documentation.</param>	
        /// <param name="point6Ref">No documentation.</param>	
        /// <param name="point7Ref">No documentation.</param>	
        /// <param name="point8Ref">No documentation.</param>	
        /// <param name="point9Ref">No documentation.</param>	
        /// <param name="point10Ref">No documentation.</param>	
        /// <param name="point11Ref">No documentation.</param>	
        /// <param name="tensorPoint11Ref">No documentation.</param>	
        /// <param name="tensorPoint12Ref">No documentation.</param>	
        /// <param name="tensorPoint21Ref">No documentation.</param>	
        /// <param name="tensorPoint22Ref">No documentation.</param>	
        /// <remarks>	
        /// <p>This function is called by the <strong>GradientMeshPatchFromCoonsPatch</strong> function and is not intended to be used directly.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D2D1GetGradientMeshInteriorPointsFromCoonsPatch']/*"/>	
        /// <msdn-id>mt149083</msdn-id>	
        /// <unmanaged>void D2D1GetGradientMeshInteriorPointsFromCoonsPatch([In] const D2D_POINT_2F* pPoint0,[In] const D2D_POINT_2F* pPoint1,[In] const D2D_POINT_2F* pPoint2,[In] const D2D_POINT_2F* pPoint3,[In] const D2D_POINT_2F* pPoint4,[In] const D2D_POINT_2F* pPoint5,[In] const D2D_POINT_2F* pPoint6,[In] const D2D_POINT_2F* pPoint7,[In] const D2D_POINT_2F* pPoint8,[In] const D2D_POINT_2F* pPoint9,[In] const D2D_POINT_2F* pPoint10,[In] const D2D_POINT_2F* pPoint11,[Out] D2D_POINT_2F* pTensorPoint11,[Out] D2D_POINT_2F* pTensorPoint12,[Out] D2D_POINT_2F* pTensorPoint21,[Out] D2D_POINT_2F* pTensorPoint22)</unmanaged>	
        /// <unmanaged-short>D2D1GetGradientMeshInteriorPointsFromCoonsPatch</unmanaged-short>	
        public static void GetGradientMeshInteriorPointsFromCoonsPatch(SharpDX.Mathematics.Interop.RawVector2 point0Ref, SharpDX.Mathematics.Interop.RawVector2 point1Ref, SharpDX.Mathematics.Interop.RawVector2 point2Ref, SharpDX.Mathematics.Interop.RawVector2 point3Ref, SharpDX.Mathematics.Interop.RawVector2 point4Ref, SharpDX.Mathematics.Interop.RawVector2 point5Ref, SharpDX.Mathematics.Interop.RawVector2 point6Ref, SharpDX.Mathematics.Interop.RawVector2 point7Ref, SharpDX.Mathematics.Interop.RawVector2 point8Ref, SharpDX.Mathematics.Interop.RawVector2 point9Ref, SharpDX.Mathematics.Interop.RawVector2 point10Ref, SharpDX.Mathematics.Interop.RawVector2 point11Ref, out SharpDX.Mathematics.Interop.RawVector2 tensorPoint11Ref, out SharpDX.Mathematics.Interop.RawVector2 tensorPoint12Ref, out SharpDX.Mathematics.Interop.RawVector2 tensorPoint21Ref, out SharpDX.Mathematics.Interop.RawVector2 tensorPoint22Ref) {
            unsafe {
                tensorPoint11Ref = new SharpDX.Mathematics.Interop.RawVector2();
                tensorPoint12Ref = new SharpDX.Mathematics.Interop.RawVector2();
                tensorPoint21Ref = new SharpDX.Mathematics.Interop.RawVector2();
                tensorPoint22Ref = new SharpDX.Mathematics.Interop.RawVector2();
                fixed (void* tensorPoint11Ref_ = &tensorPoint11Ref)
                    fixed (void* tensorPoint12Ref_ = &tensorPoint12Ref)
                        fixed (void* tensorPoint21Ref_ = &tensorPoint21Ref)
                            fixed (void* tensorPoint22Ref_ = &tensorPoint22Ref)
                                D2D1GetGradientMeshInteriorPointsFromCoonsPatch_(&point0Ref, &point1Ref, &point2Ref, &point3Ref, &point4Ref, &point5Ref, &point6Ref, &point7Ref, &point8Ref, &point9Ref, &point10Ref, &point11Ref, tensorPoint11Ref_, tensorPoint12Ref_, tensorPoint21Ref_, tensorPoint22Ref_);		
            }
        }
        [DllImport("d2d1.dll", EntryPoint = "D2D1GetGradientMeshInteriorPointsFromCoonsPatch", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern void D2D1GetGradientMeshInteriorPointsFromCoonsPatch_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,void* arg5,void* arg6,void* arg7,void* arg8,void* arg9,void* arg10,void* arg11,void* arg12,void* arg13,void* arg14,void* arg15);
    }
        /// <summary>	
        /// Functions	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.Direct2D1.ResultCode']/*"/>	
    public  partial class ResultCode {   
        
        /// <summary>Constant EffectIsNotRegistered.</summary>
        /// <unmanaged>D2DERR_EFFECT_IS_NOT_REGISTERED</unmanaged>
        public static readonly SharpDX.ResultDescriptor EffectIsNotRegistered = new SharpDX.ResultDescriptor(-0x07766ffd8, "SharpDX.Direct2D1", "D2DERR_EFFECT_IS_NOT_REGISTERED", "EffectIsNotRegistered");
        
        /// <summary>Constant WrongFactory.</summary>
        /// <unmanaged>D2DERR_WRONG_FACTORY</unmanaged>
        public static readonly SharpDX.ResultDescriptor WrongFactory = new SharpDX.ResultDescriptor(-0x07766ffee, "SharpDX.Direct2D1", "D2DERR_WRONG_FACTORY", "WrongFactory");
        
        /// <summary>Constant InvalidGraphConfiguration.</summary>
        /// <unmanaged>D2DERR_INVALID_GRAPH_CONFIGURATION</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidGraphConfiguration = new SharpDX.ResultDescriptor(-0x07766ffe2, "SharpDX.Direct2D1", "D2DERR_INVALID_GRAPH_CONFIGURATION", "InvalidGraphConfiguration");
        
        /// <summary>Constant MaximumTextureSizeExceeded.</summary>
        /// <unmanaged>D2DERR_MAX_TEXTURE_SIZE_EXCEEDED</unmanaged>
        public static readonly SharpDX.ResultDescriptor MaximumTextureSizeExceeded = new SharpDX.ResultDescriptor(-0x07766fff1, "SharpDX.Direct2D1", "D2DERR_MAX_TEXTURE_SIZE_EXCEEDED", "MaximumTextureSizeExceeded");
        
        /// <summary>Constant NoHardwareDevice.</summary>
        /// <unmanaged>D2DERR_NO_HARDWARE_DEVICE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoHardwareDevice = new SharpDX.ResultDescriptor(-0x07766fff5, "SharpDX.Direct2D1", "D2DERR_NO_HARDWARE_DEVICE", "NoHardwareDevice");
        
        /// <summary>Constant WrongResourceDomain.</summary>
        /// <unmanaged>D2DERR_WRONG_RESOURCE_DOMAIN</unmanaged>
        public static readonly SharpDX.ResultDescriptor WrongResourceDomain = new SharpDX.ResultDescriptor(-0x07766ffeb, "SharpDX.Direct2D1", "D2DERR_WRONG_RESOURCE_DOMAIN", "WrongResourceDomain");
        
        /// <summary>Constant InvalidCall.</summary>
        /// <unmanaged>D2DERR_INVALID_CALL</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidCall = new SharpDX.ResultDescriptor(-0x07766fff6, "SharpDX.Direct2D1", "D2DERR_INVALID_CALL", "InvalidCall");
        
        /// <summary>Constant Win32Error.</summary>
        /// <unmanaged>D2DERR_WIN32_ERROR</unmanaged>
        public static readonly SharpDX.ResultDescriptor Win32Error = new SharpDX.ResultDescriptor(-0x07766ffe7, "SharpDX.Direct2D1", "D2DERR_WIN32_ERROR", "Win32Error");
        
        /// <summary>Constant ExceedsMaximumBitmapSize.</summary>
        /// <unmanaged>D2DERR_EXCEEDS_MAX_BITMAP_SIZE</unmanaged>
        public static readonly SharpDX.ResultDescriptor ExceedsMaximumBitmapSize = new SharpDX.ResultDescriptor(-0x07766ffe3, "SharpDX.Direct2D1", "D2DERR_EXCEEDS_MAX_BITMAP_SIZE", "ExceedsMaximumBitmapSize");
        
        /// <summary>Constant PopCallDidNotMatchPush.</summary>
        /// <unmanaged>D2DERR_POP_CALL_DID_NOT_MATCH_PUSH</unmanaged>
        public static readonly SharpDX.ResultDescriptor PopCallDidNotMatchPush = new SharpDX.ResultDescriptor(-0x07766ffec, "SharpDX.Direct2D1", "D2DERR_POP_CALL_DID_NOT_MATCH_PUSH", "PopCallDidNotMatchPush");
        
        /// <summary>Constant OutstandingBitmapReferences.</summary>
        /// <unmanaged>D2DERR_OUTSTANDING_BITMAP_REFERENCES</unmanaged>
        public static readonly SharpDX.ResultDescriptor OutstandingBitmapReferences = new SharpDX.ResultDescriptor(-0x07766ffde, "SharpDX.Direct2D1", "D2DERR_OUTSTANDING_BITMAP_REFERENCES", "OutstandingBitmapReferences");
        
        /// <summary>Constant UnsupportedVersion.</summary>
        /// <unmanaged>D2DERR_UNSUPPORTED_VERSION</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedVersion = new SharpDX.ResultDescriptor(-0x07766fff0, "SharpDX.Direct2D1", "D2DERR_UNSUPPORTED_VERSION", "UnsupportedVersion");
        
        /// <summary>Constant IntermediateTooLarge.</summary>
        /// <unmanaged>D2DERR_INTERMEDIATE_TOO_LARGE</unmanaged>
        public static readonly SharpDX.ResultDescriptor IntermediateTooLarge = new SharpDX.ResultDescriptor(-0x07766ffd9, "SharpDX.Direct2D1", "D2DERR_INTERMEDIATE_TOO_LARGE", "IntermediateTooLarge");
        
        /// <summary>Constant NoSubProperties.</summary>
        /// <unmanaged>D2DERR_NO_SUBPROPERTIES</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoSubProperties = new SharpDX.ResultDescriptor(-0x07766ffd6, "SharpDX.Direct2D1", "D2DERR_NO_SUBPROPERTIES", "NoSubProperties");
        
        /// <summary>Constant ZeroVector.</summary>
        /// <unmanaged>D2DERR_ZERO_VECTOR</unmanaged>
        public static readonly SharpDX.ResultDescriptor ZeroVector = new SharpDX.ResultDescriptor(-0x07766fff9, "SharpDX.Direct2D1", "D2DERR_ZERO_VECTOR", "ZeroVector");
        
        /// <summary>Constant UnsupportedPixelFormat.</summary>
        /// <unmanaged>D2DERR_UNSUPPORTED_PIXEL_FORMAT</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedPixelFormat = new SharpDX.ResultDescriptor(-0x07767d080, "SharpDX.Direct2D1", "D2DERR_UNSUPPORTED_PIXEL_FORMAT", "UnsupportedPixelFormat");
        
        /// <summary>Constant ShaderCompileFailed.</summary>
        /// <unmanaged>D2DERR_SHADER_COMPILE_FAILED</unmanaged>
        public static readonly SharpDX.ResultDescriptor ShaderCompileFailed = new SharpDX.ResultDescriptor(-0x07766fff2, "SharpDX.Direct2D1", "D2DERR_SHADER_COMPILE_FAILED", "ShaderCompileFailed");
        
        /// <summary>Constant ScannerFailed.</summary>
        /// <unmanaged>D2DERR_SCANNER_FAILED</unmanaged>
        public static readonly SharpDX.ResultDescriptor ScannerFailed = new SharpDX.ResultDescriptor(-0x07766fffc, "SharpDX.Direct2D1", "D2DERR_SCANNER_FAILED", "ScannerFailed");
        
        /// <summary>Constant TooManyShaderElements.</summary>
        /// <unmanaged>D2DERR_TOO_MANY_SHADER_ELEMENTS</unmanaged>
        public static readonly SharpDX.ResultDescriptor TooManyShaderElements = new SharpDX.ResultDescriptor(-0x07766fff3, "SharpDX.Direct2D1", "D2DERR_TOO_MANY_SHADER_ELEMENTS", "TooManyShaderElements");
        
        /// <summary>Constant TextRendererNotReleased.</summary>
        /// <unmanaged>D2DERR_TEXT_RENDERER_NOT_RELEASED</unmanaged>
        public static readonly SharpDX.ResultDescriptor TextRendererNotReleased = new SharpDX.ResultDescriptor(-0x07766ffe4, "SharpDX.Direct2D1", "D2DERR_TEXT_RENDERER_NOT_RELEASED", "TextRendererNotReleased");
        
        /// <summary>Constant CyclicGraph.</summary>
        /// <unmanaged>D2DERR_CYCLIC_GRAPH</unmanaged>
        public static readonly SharpDX.ResultDescriptor CyclicGraph = new SharpDX.ResultDescriptor(-0x07766ffe0, "SharpDX.Direct2D1", "D2DERR_CYCLIC_GRAPH", "CyclicGraph");
        
        /// <summary>Constant BitmapCannotDraw.</summary>
        /// <unmanaged>D2DERR_BITMAP_CANNOT_DRAW</unmanaged>
        public static readonly SharpDX.ResultDescriptor BitmapCannotDraw = new SharpDX.ResultDescriptor(-0x07766ffdf, "SharpDX.Direct2D1", "D2DERR_BITMAP_CANNOT_DRAW", "BitmapCannotDraw");
        
        /// <summary>Constant IncompatibleBrushTypes.</summary>
        /// <unmanaged>D2DERR_INCOMPATIBLE_BRUSH_TYPES</unmanaged>
        public static readonly SharpDX.ResultDescriptor IncompatibleBrushTypes = new SharpDX.ResultDescriptor(-0x07766ffe8, "SharpDX.Direct2D1", "D2DERR_INCOMPATIBLE_BRUSH_TYPES", "IncompatibleBrushTypes");
        
        /// <summary>Constant ScreenAccessDenied.</summary>
        /// <unmanaged>D2DERR_SCREEN_ACCESS_DENIED</unmanaged>
        public static readonly SharpDX.ResultDescriptor ScreenAccessDenied = new SharpDX.ResultDescriptor(-0x07766fffb, "SharpDX.Direct2D1", "D2DERR_SCREEN_ACCESS_DENIED", "ScreenAccessDenied");
        
        /// <summary>Constant InvalidInternalGraphConfiguration.</summary>
        /// <unmanaged>D2DERR_INVALID_INTERNAL_GRAPH_CONFIGURATION</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidInternalGraphConfiguration = new SharpDX.ResultDescriptor(-0x07766ffe1, "SharpDX.Direct2D1", "D2DERR_INVALID_INTERNAL_GRAPH_CONFIGURATION", "InvalidInternalGraphConfiguration");
        
        /// <summary>Constant LayerAlreadyInUse.</summary>
        /// <unmanaged>D2DERR_LAYER_ALREADY_IN_USE</unmanaged>
        public static readonly SharpDX.ResultDescriptor LayerAlreadyInUse = new SharpDX.ResultDescriptor(-0x07766ffed, "SharpDX.Direct2D1", "D2DERR_LAYER_ALREADY_IN_USE", "LayerAlreadyInUse");
        
        /// <summary>Constant BitmapBoundAsTarget.</summary>
        /// <unmanaged>D2DERR_BITMAP_BOUND_AS_TARGET</unmanaged>
        public static readonly SharpDX.ResultDescriptor BitmapBoundAsTarget = new SharpDX.ResultDescriptor(-0x07766ffdb, "SharpDX.Direct2D1", "D2DERR_BITMAP_BOUND_AS_TARGET", "BitmapBoundAsTarget");
        
        /// <summary>Constant InternalError.</summary>
        /// <unmanaged>D2DERR_INTERNAL_ERROR</unmanaged>
        public static readonly SharpDX.ResultDescriptor InternalError = new SharpDX.ResultDescriptor(-0x07766fff8, "SharpDX.Direct2D1", "D2DERR_INTERNAL_ERROR", "InternalError");
        
        /// <summary>Constant TooManyTransformInputs.</summary>
        /// <unmanaged>D2DERR_TOO_MANY_TRANSFORM_INPUTS</unmanaged>
        public static readonly SharpDX.ResultDescriptor TooManyTransformInputs = new SharpDX.ResultDescriptor(-0x07766ffd3, "SharpDX.Direct2D1", "D2DERR_TOO_MANY_TRANSFORM_INPUTS", "TooManyTransformInputs");
        
        /// <summary>Constant InvalidProperty.</summary>
        /// <unmanaged>D2DERR_INVALID_PROPERTY</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidProperty = new SharpDX.ResultDescriptor(-0x07766ffd7, "SharpDX.Direct2D1", "D2DERR_INVALID_PROPERTY", "InvalidProperty");
        
        /// <summary>Constant PrintJobClosed.</summary>
        /// <unmanaged>D2DERR_PRINT_JOB_CLOSED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PrintJobClosed = new SharpDX.ResultDescriptor(-0x07766ffd5, "SharpDX.Direct2D1", "D2DERR_PRINT_JOB_CLOSED", "PrintJobClosed");
        
        /// <summary>Constant BadNumber.</summary>
        /// <unmanaged>D2DERR_BAD_NUMBER</unmanaged>
        public static readonly SharpDX.ResultDescriptor BadNumber = new SharpDX.ResultDescriptor(-0x07766ffef, "SharpDX.Direct2D1", "D2DERR_BAD_NUMBER", "BadNumber");
        
        /// <summary>Constant RenderTargetHasLayerOrCliprect.</summary>
        /// <unmanaged>D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT</unmanaged>
        public static readonly SharpDX.ResultDescriptor RenderTargetHasLayerOrCliprect = new SharpDX.ResultDescriptor(-0x07766ffe9, "SharpDX.Direct2D1", "D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT", "RenderTargetHasLayerOrCliprect");
        
        /// <summary>Constant InvalidTarget.</summary>
        /// <unmanaged>D2DERR_INVALID_TARGET</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidTarget = new SharpDX.ResultDescriptor(-0x07766ffdc, "SharpDX.Direct2D1", "D2DERR_INVALID_TARGET", "InvalidTarget");
        
        /// <summary>Constant WrongState.</summary>
        /// <unmanaged>D2DERR_WRONG_STATE</unmanaged>
        public static readonly SharpDX.ResultDescriptor WrongState = new SharpDX.ResultDescriptor(-0x07766ffff, "SharpDX.Direct2D1", "D2DERR_WRONG_STATE", "WrongState");
        
        /// <summary>Constant DisplayStateInvalid.</summary>
        /// <unmanaged>D2DERR_DISPLAY_STATE_INVALID</unmanaged>
        public static readonly SharpDX.ResultDescriptor DisplayStateInvalid = new SharpDX.ResultDescriptor(-0x07766fffa, "SharpDX.Direct2D1", "D2DERR_DISPLAY_STATE_INVALID", "DisplayStateInvalid");
        
        /// <summary>Constant RecreateTarget.</summary>
        /// <unmanaged>D2DERR_RECREATE_TARGET</unmanaged>
        public static readonly SharpDX.ResultDescriptor RecreateTarget = new SharpDX.ResultDescriptor(-0x07766fff4, "SharpDX.Direct2D1", "D2DERR_RECREATE_TARGET", "RecreateTarget");
        
        /// <summary>Constant TextEffectIsWrongType.</summary>
        /// <unmanaged>D2DERR_TEXT_EFFECT_IS_WRONG_TYPE</unmanaged>
        public static readonly SharpDX.ResultDescriptor TextEffectIsWrongType = new SharpDX.ResultDescriptor(-0x07766ffe5, "SharpDX.Direct2D1", "D2DERR_TEXT_EFFECT_IS_WRONG_TYPE", "TextEffectIsWrongType");
        
        /// <summary>Constant UnsupportedOperation.</summary>
        /// <unmanaged>D2DERR_UNSUPPORTED_OPERATION</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedOperation = new SharpDX.ResultDescriptor(-0x07766fffd, "SharpDX.Direct2D1", "D2DERR_UNSUPPORTED_OPERATION", "UnsupportedOperation");
        
        /// <summary>Constant PushPopUnbalanced.</summary>
        /// <unmanaged>D2DERR_PUSH_POP_UNBALANCED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PushPopUnbalanced = new SharpDX.ResultDescriptor(-0x07766ffea, "SharpDX.Direct2D1", "D2DERR_PUSH_POP_UNBALANCED", "PushPopUnbalanced");
        
        /// <summary>Constant DisplayFormatNotSupported.</summary>
        /// <unmanaged>D2DERR_DISPLAY_FORMAT_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor DisplayFormatNotSupported = new SharpDX.ResultDescriptor(-0x07766fff7, "SharpDX.Direct2D1", "D2DERR_DISPLAY_FORMAT_NOT_SUPPORTED", "DisplayFormatNotSupported");
        
        /// <summary>Constant OriginalTargetNotBound.</summary>
        /// <unmanaged>D2DERR_ORIGINAL_TARGET_NOT_BOUND</unmanaged>
        public static readonly SharpDX.ResultDescriptor OriginalTargetNotBound = new SharpDX.ResultDescriptor(-0x07766ffdd, "SharpDX.Direct2D1", "D2DERR_ORIGINAL_TARGET_NOT_BOUND", "OriginalTargetNotBound");
        
        /// <summary>Constant PrintFormatNotSupported.</summary>
        /// <unmanaged>D2DERR_PRINT_FORMAT_NOT_SUPPORTED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PrintFormatNotSupported = new SharpDX.ResultDescriptor(-0x07766ffd4, "SharpDX.Direct2D1", "D2DERR_PRINT_FORMAT_NOT_SUPPORTED", "PrintFormatNotSupported");
        
        /// <summary>Constant NotInitializeD.</summary>
        /// <unmanaged>D2DERR_NOT_INITIALIZED</unmanaged>
        public static readonly SharpDX.ResultDescriptor NotInitializeD = new SharpDX.ResultDescriptor(-0x07766fffe, "SharpDX.Direct2D1", "D2DERR_NOT_INITIALIZED", "NotInitializeD");
        
        /// <summary>Constant TargetNotGdiCompatible.</summary>
        /// <unmanaged>D2DERR_TARGET_NOT_GDI_COMPATIBLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor TargetNotGdiCompatible = new SharpDX.ResultDescriptor(-0x07766ffe6, "SharpDX.Direct2D1", "D2DERR_TARGET_NOT_GDI_COMPATIBLE", "TargetNotGdiCompatible");
        
        /// <summary>Constant InsufficientDeviceCapabilities.</summary>
        /// <unmanaged>D2DERR_INSUFFICIENT_DEVICE_CAPABILITIES</unmanaged>
        public static readonly SharpDX.ResultDescriptor InsufficientDeviceCapabilities = new SharpDX.ResultDescriptor(-0x07766ffda, "SharpDX.Direct2D1", "D2DERR_INSUFFICIENT_DEVICE_CAPABILITIES", "InsufficientDeviceCapabilities");
    }
}
