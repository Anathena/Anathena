// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.WIC namespace.
//     This code was generated by a tool.
//     Date : 6/25/2016 10:38:13 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.WIC {

// Disable warning : XML comment is not placed on a valid language element
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
    /// <summary>	
    /// <p>Defines methods that add the concept of writeability and static in-memory representations of bitmaps to <strong><see cref="SharpDX.WIC.BitmapSource"/></strong>. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p><strong><see cref="SharpDX.WIC.Bitmap"/></strong> inherits from <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> and therefore also inherits the <strong>CopyPixels</strong> method. When pixels need to be moved to a new memory location, <strong>CopyPixels</strong> is often the most efficient. </p><p> Because of to the internal memory representation implied by the <strong><see cref="SharpDX.WIC.Bitmap"/></strong>, in-place modification and processing using the <strong>Lock</strong> is more efficient than <strong>CopyPixels</strong>, usually reducing to a simple reference access directly into the memory owned by the bitmap rather than a as a copy.  This is contrasted to procedural bitmaps which implement only <strong>CopyPixels</strong> because there is no internal memory representation and one would need to be created on demand to satisfy a call to <strong>Lock</strong>.  </p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmap']/*"/>	
    /// <msdn-id>ee719675</msdn-id>	
    /// <unmanaged>IWICBitmap</unmanaged>	
    /// <unmanaged-short>IWICBitmap</unmanaged-short>	
    [Guid("00000121-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class Bitmap : SharpDX.WIC.BitmapSource {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.Bitmap"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Bitmap(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.Bitmap"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.Bitmap(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.Bitmap(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Provides access for palette modifications.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmap::SetPalette']/*"/>	
        /// <msdn-id>ee690189</msdn-id>	
        /// <unmanaged>SetPalette</unmanaged>	
        /// <unmanaged-short>SetPalette</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmap::SetPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>
        public SharpDX.WIC.Palette Palette {
                set { SetPalette(value); }
        }
        
        /// <summary>	
        /// <p>Provides access to a rectangular area of the bitmap.</p>	
        /// </summary>	
        /// <param name="rcLockRef"><dd>  <p>The rectangle to be accessed.</p> </dd></param>	
        /// <param name="flags"><dd>  <p>The access mode you wish to obtain for the lock. This is a bitwise combination of <strong><see cref="SharpDX.WIC.BitmapLockFlags"/></strong> for read, write, or read and write access.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.WIC.BitmapLockFlags.Read"/></strong></dt> </dl> </td><td> <p>The read access lock.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="SharpDX.WIC.BitmapLockFlags.Write"/></strong></dt> </dl> </td><td> <p>The write access lock.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><dd>  <p>A reference that receives the locked memory location.</p> </dd></returns>	
        /// <remarks>	
        /// <p>Locks are exclusive for writing but can be shared for reading. You cannot call <strong>CopyPixels</strong> while the <strong><see cref="SharpDX.WIC.Bitmap"/></strong> is locked for writing. Doing so will return an error, since locks are exclusive.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmap::Lock']/*"/>	
        /// <msdn-id>ee690187</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmap::Lock([In] const void* prcLock,[In] WICBitmapLockFlags flags,[Out] IWICBitmapLock** ppILock)</unmanaged>	
        /// <unmanaged-short>IWICBitmap::Lock</unmanaged-short>	
        internal SharpDX.WIC.BitmapLock Lock(System.IntPtr rcLockRef, SharpDX.WIC.BitmapLockFlags flags) {
            unsafe {
                SharpDX.WIC.BitmapLock lockOut;
                IntPtr lockOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)rcLockRef, unchecked((int)flags), &lockOut_,((void**)(*(void**)_nativePointer))[8]);		
                lockOut= (lockOut_ == IntPtr.Zero)?null:new SharpDX.WIC.BitmapLock(lockOut_);	
                __result__.CheckError();
                return lockOut;
            }
        }
        
        /// <summary>	
        /// <p>Provides access for palette modifications.</p>	
        /// </summary>	
        /// <param name="paletteRef"><dd>  <p>The palette to use for conversion.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmap::SetPalette']/*"/>	
        /// <msdn-id>ee690189</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmap::SetPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>	
        /// <unmanaged-short>IWICBitmap::SetPalette</unmanaged-short>	
        internal void SetPalette(SharpDX.WIC.Palette paletteRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((paletteRef == null)?IntPtr.Zero:paletteRef.NativePointer),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Changes the physical resolution of the image.</p>	
        /// </summary>	
        /// <param name="dpiX"><dd>  <p>The horizontal resolution.</p> </dd></param>	
        /// <param name="dpiY"><dd>  <p>The vertical resolution.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> This method has no effect on the actual pixels or samples stored in the bitmap.  Instead the interpretation of the sampling rate is modified.  This means that a 96 DPI image which is 96 pixels wide is one inch.  If the physical resolution is modified to 48 DPI, then the bitmap is considered to be 2 inches wide but has the same number of pixels.   If the resolution is less than <strong>REAL_EPSILON</strong> (1.192092896e-07F) the error code <strong><see cref="SharpDX.WIC.ResultCode.InvalidParameter"/></strong> is returned.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmap::SetResolution']/*"/>	
        /// <msdn-id>ee690191</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmap::SetResolution([In] double dpiX,[In] double dpiY)</unmanaged>	
        /// <unmanaged-short>IWICBitmap::SetResolution</unmanaged-short>	
        public void SetResolution(double dpiX, double dpiY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, dpiX, dpiY,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods that produce a clipped version of the input bitmap for a specified rectangular region of interest.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapClipper']/*"/>	
    /// <msdn-id>ee719676</msdn-id>	
    /// <unmanaged>IWICBitmapClipper</unmanaged>	
    /// <unmanaged-short>IWICBitmapClipper</unmanaged-short>	
    [Guid("E4FBCF03-223D-4e81-9333-D635556DD1B5")]
    public partial class BitmapClipper : SharpDX.WIC.BitmapSource {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.BitmapClipper"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapClipper(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.BitmapClipper"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.BitmapClipper(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.BitmapClipper(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Initializes the bitmap clipper with the provided parameters.</p>	
        /// </summary>	
        /// <param name="sourceRef"><dd>  <p>he input bitmap source.</p> </dd></param>	
        /// <param name="rectangleRef"><dd>  <p>The rectangle of the bitmap source to clip.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapClipper::Initialize']/*"/>	
        /// <msdn-id>ee719677</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapClipper::Initialize([In, Optional] IWICBitmapSource* pISource,[In] const void* prc)</unmanaged>	
        /// <unmanaged-short>IWICBitmapClipper::Initialize</unmanaged-short>	
        internal void Initialize(SharpDX.WIC.BitmapSource sourceRef, System.IntPtr rectangleRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((sourceRef == null)?IntPtr.Zero:sourceRef.NativePointer), (void*)rectangleRef,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods that provide information about a particular codec.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo']/*"/>	
    /// <msdn-id>ee719679</msdn-id>	
    /// <unmanaged>IWICBitmapCodecInfo</unmanaged>	
    /// <unmanaged-short>IWICBitmapCodecInfo</unmanaged-short>	
    [Guid("E87A44C4-B76E-4c47-8B09-298EB12A2714")]
    public partial class BitmapCodecInfo : SharpDX.WIC.ComponentInfo {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.BitmapCodecInfo"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapCodecInfo(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.BitmapCodecInfo"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.BitmapCodecInfo(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.BitmapCodecInfo(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the container <see cref="System.Guid"/> associated with the codec.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::GetContainerFormat']/*"/>	
        /// <msdn-id>ee719688</msdn-id>	
        /// <unmanaged>GetContainerFormat</unmanaged>	
        /// <unmanaged-short>GetContainerFormat</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>
        public System.Guid ContainerFormat {
                get { System.Guid __output__; GetContainerFormat(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves a value indicating whether the codec supports animation.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::DoesSupportAnimation']/*"/>	
        /// <msdn-id>ee719680</msdn-id>	
        /// <unmanaged>DoesSupportAnimation</unmanaged>	
        /// <unmanaged-short>DoesSupportAnimation</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportAnimation([Out] BOOL* pfSupportAnimation)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsAnimationSupported {
                get { SharpDX.Mathematics.Interop.RawBool __output__; IsAnimationSupported_(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves a value indicating whether the codec supports chromakeys.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::DoesSupportChromakey']/*"/>	
        /// <msdn-id>ee719682</msdn-id>	
        /// <unmanaged>DoesSupportChromakey</unmanaged>	
        /// <unmanaged-short>DoesSupportChromakey</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportChromakey([Out] BOOL* pfSupportChromakey)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsChromakeySupported {
                get { SharpDX.Mathematics.Interop.RawBool __output__; IsChromakeySupported_(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves a value indicating whether the codec supports lossless formats.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::DoesSupportLossless']/*"/>	
        /// <msdn-id>ee719683</msdn-id>	
        /// <unmanaged>DoesSupportLossless</unmanaged>	
        /// <unmanaged-short>DoesSupportLossless</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportLossless([Out] BOOL* pfSupportLossless)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsLosslessSupported {
                get { SharpDX.Mathematics.Interop.RawBool __output__; IsLosslessSupported_(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves a value indicating whether the codec supports multi frame images.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::DoesSupportMultiframe']/*"/>	
        /// <msdn-id>ee719685</msdn-id>	
        /// <unmanaged>DoesSupportMultiframe</unmanaged>	
        /// <unmanaged-short>DoesSupportMultiframe</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportMultiframe([Out] BOOL* pfSupportMultiframe)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsMultiframeSupported {
                get { SharpDX.Mathematics.Interop.RawBool __output__; IsMultiframeSupported_(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the container <see cref="System.Guid"/> associated with the codec.</p>	
        /// </summary>	
        /// <param name="guidContainerFormatRef"><dd>  <p>Receives the container <see cref="System.Guid"/>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::GetContainerFormat']/*"/>	
        /// <msdn-id>ee719688</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>	
        /// <unmanaged-short>IWICBitmapCodecInfo::GetContainerFormat</unmanaged-short>	
        internal void GetContainerFormat(out System.Guid guidContainerFormatRef) {
            unsafe {
                guidContainerFormatRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* guidContainerFormatRef_ = &guidContainerFormatRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, guidContainerFormatRef_,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the pixel formats the codec supports.</p>	
        /// </summary>	
        /// <param name="formats"><dd>  <p>The size of the <em>pguidPixelFormats</em> array. Use <code>0</code> on first call to determine the needed array size.</p> </dd></param>	
        /// <param name="guidPixelFormatsRef"><dd>  <p>Receives the supported pixel formats. Use <code><c>null</c></code> on first call to determine needed array size.</p> </dd></param>	
        /// <param name="actualRef"><dd>  <p>The array size needed to retrieve all supported pixel formats.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The usage pattern for this method is a two call process. The first call retrieves the array size needed to retrieve all the supported pixel formats by calling it with <em>cFormats</em> set to <code>0</code> and <em>pguidPixelFormats</em> set to <code><c>null</c></code>. This call sets <em>pcActual</em> to the array size needed. Once the needed array size is determined, a second <strong>GetPixelFormats</strong> call with <em>pguidPixelFormats</em> set to an array of the appropriate size will retrieve the pixel formats. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::GetPixelFormats']/*"/>	
        /// <msdn-id>ee690082</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::GetPixelFormats([In] unsigned int cFormats,[In, Buffer] GUID* pguidPixelFormats,[Out] unsigned int* pcActual)</unmanaged>	
        /// <unmanaged-short>IWICBitmapCodecInfo::GetPixelFormats</unmanaged-short>	
        internal void GetPixelFormats(int formats, System.Guid[] guidPixelFormatsRef, out int actualRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* guidPixelFormatsRef_ = guidPixelFormatsRef)
                    fixed (void* actualRef_ = &actualRef)
                        __result__= 
        				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, formats, guidPixelFormatsRef_, actualRef_,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the color manangement version number the codec supports.</p>	
        /// </summary>	
        /// <param name="cchColorManagementVersion"><dd>  <p>The size of the version buffer. Use <code>0</code> on first call to determine needed buffer size.</p> </dd></param>	
        /// <param name="colorManagementVersion"><dd>  <p>Receives the color management version number. Use <code><c>null</c></code> on first call to determine needed buffer size.</p> </dd></param>	
        /// <param name="cchActualRef"><dd>  <p>The actual buffer size needed to retrieve the full color management version number.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The usage pattern for this method is a two call process. The first call retrieves the buffer size needed to retrieve the full color management version number by calling it with <em>cchColorManagementVersion</em> set to <code>0</code> and <em>wzColorManagementVersion</em> set to <code><c>null</c></code>. This call sets <em>pcchActual</em> to the buffer size needed. Once the needed buffer size is determined, a second <strong>GetColorManagementVersion</strong> call with <em>cchColorManagementVersion</em> set to the buffer size and <em>wzColorManagementVersion</em> set to a buffer of the appropriate size will retrieve the pixel formats. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::GetColorManagementVersion']/*"/>	
        /// <msdn-id>ee719687</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::GetColorManagementVersion([In] unsigned int cchColorManagementVersion,[In] void* wzColorManagementVersion,[Out] unsigned int* pcchActual)</unmanaged>	
        /// <unmanaged-short>IWICBitmapCodecInfo::GetColorManagementVersion</unmanaged-short>	
        internal void GetColorManagementVersion(int cchColorManagementVersion, System.IntPtr colorManagementVersion, out int cchActualRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* cchActualRef_ = &cchActualRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, cchColorManagementVersion, (void*)colorManagementVersion, cchActualRef_,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the name of the device manufacture associated with the codec.</p>	
        /// </summary>	
        /// <param name="cchDeviceManufacturer"><dd>  <p>The size of the device manufacture's name. Use <code>0</code> on first call to determine needed buffer size.</p> </dd></param>	
        /// <param name="deviceManufacturer"><dd>  <p>Receives the device manufacture's name. Use <code><c>null</c></code> on first call to determine needed buffer size.</p> </dd></param>	
        /// <param name="cchActualRef"><dd>  <p>The actual buffer size needed to retrieve the device manufacture's name.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The usage pattern for this method is a two call process. The first call retrieves the buffer size needed to retrieve the full color management version number by calling it with <em>cchDeviceManufacturer</em> set to <code>0</code> and <em>wzDeviceManufacturer</em> set to <code><c>null</c></code>. This call sets <em>pcchActual</em> to the buffer size needed. Once the needed buffer size is determined, a second <strong>GetDeviceManufacturer</strong> call with <em>cchDeviceManufacturer</em> set to the buffer size and <em>wzDeviceManufacturer</em> set to a buffer of the appropriate size will retrieve the pixel formats. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::GetDeviceManufacturer']/*"/>	
        /// <msdn-id>ee719690</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::GetDeviceManufacturer([In] unsigned int cchDeviceManufacturer,[In] void* wzDeviceManufacturer,[Out] unsigned int* pcchActual)</unmanaged>	
        /// <unmanaged-short>IWICBitmapCodecInfo::GetDeviceManufacturer</unmanaged-short>	
        internal void GetDeviceManufacturer(int cchDeviceManufacturer, System.IntPtr deviceManufacturer, out int cchActualRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* cchActualRef_ = &cchActualRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, cchDeviceManufacturer, (void*)deviceManufacturer, cchActualRef_,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a comma delimited list of device models associated with the codec.</p>	
        /// </summary>	
        /// <param name="cchDeviceModels"><dd>  <p>The size of the device models buffer. Use <code>0</code> on first call to determine needed buffer size.</p> </dd></param>	
        /// <param name="deviceModels"><dd>  <p>Receives a comma delimited list of device model names associated with the codec. Use <code><c>null</c></code> on first call to determine needed buffer size.</p> </dd></param>	
        /// <param name="cchActualRef"><dd>  <p>The actual buffer size needed to retrieve all of the device model names.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The usage pattern for this method is a two call process. The first call retrieves the buffer size needed to retrieve the full color management version number by calling it with <em>cchDeviceModels</em> set to <code>0</code> and <em>wzDeviceModels</em> set to <code><c>null</c></code>. This call sets <em>pcchActual</em> to the buffer size needed. Once the needed buffer size is determined, a second <strong>GetDeviceModels</strong> call with <em>cchDeviceModels</em> set to the buffer size and <em>wzDeviceModels</em> set to a buffer of the appropriate size will retrieve the pixel formats. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::GetDeviceModels']/*"/>	
        /// <msdn-id>ee719692</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::GetDeviceModels([In] unsigned int cchDeviceModels,[In] void* wzDeviceModels,[Out] unsigned int* pcchActual)</unmanaged>	
        /// <unmanaged-short>IWICBitmapCodecInfo::GetDeviceModels</unmanaged-short>	
        internal void GetDeviceModels(int cchDeviceModels, System.IntPtr deviceModels, out int cchActualRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* cchActualRef_ = &cchActualRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, cchDeviceModels, (void*)deviceModels, cchActualRef_,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a comma delimited sequence of mime types associated with the codec.</p>	
        /// </summary>	
        /// <param name="cchMimeTypes"><dd>  <p>The size of the mime types buffer.  Use <code>0</code> on first call to determine needed buffer size.</p> </dd></param>	
        /// <param name="mimeTypes"><dd>  <p>Receives the mime types associated with the codec. Use <code><c>null</c></code> on first call to determine needed buffer size.</p> </dd></param>	
        /// <param name="cchActualRef"><dd>  <p>The actual buffer size needed to retrieve all mime types associated with the codec.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The usage pattern for this method is a two call process. The first call retrieves the buffer size needed to retrieve the full color management version number by calling it with <em>cchMimeTypes</em> set to <code>0</code> and <em>wzMimeTypes</em> set to <code><c>null</c></code>. This call sets <em>pcchActual</em> to the buffer size needed. Once the needed buffer size is determined, a second <strong>GetMimeTypes</strong> call with <em>cchMimeTypes</em> set to the buffer size and <em>wzMimeTypes</em> set to a buffer of the appropriate size will retrieve the pixel formats. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::GetMimeTypes']/*"/>	
        /// <msdn-id>ee719696</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::GetMimeTypes([In] unsigned int cchMimeTypes,[In] void* wzMimeTypes,[Out] unsigned int* pcchActual)</unmanaged>	
        /// <unmanaged-short>IWICBitmapCodecInfo::GetMimeTypes</unmanaged-short>	
        internal void GetMimeTypes(int cchMimeTypes, System.IntPtr mimeTypes, out int cchActualRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* cchActualRef_ = &cchActualRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, cchMimeTypes, (void*)mimeTypes, cchActualRef_,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a comma delimited list of the file name extensions associated with the codec.</p>	
        /// </summary>	
        /// <param name="cchFileExtensions"><dd>  <p>The size of the file name extension buffer. Use <code>0</code> on first call to determine needed buffer size.</p> </dd></param>	
        /// <param name="fileExtensions"><dd>  <p>Receives a comma delimited list  of file name extensions associated with the codec. Use <code><c>null</c></code> on first call to determine needed buffer size.</p> </dd></param>	
        /// <param name="cchActualRef"><dd>  <p>The actual buffer size needed to retrieve all file name extensions associated with the codec. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The default extension for an image encoder is the first item in the list of returned extensions.</p><p> The usage pattern for this method is a two call process. The first call retrieves the buffer size needed to retrieve the full color management version number by calling it with <em>cchFileExtensions</em> set to <code>0</code> and <em>wzFileExtensions</em> set to <code><c>null</c></code>. This call sets <em>pcchActual</em> to the buffer size needed. Once the needed buffer size is determined, a second <strong>GetFileExtensions</strong> call with <em>cchFileExtensions</em> set to the buffer size and <em>wzFileExtensions</em> set to a buffer of the appropriate size will retrieve the pixel formats. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::GetFileExtensions']/*"/>	
        /// <msdn-id>ee719694</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::GetFileExtensions([In] unsigned int cchFileExtensions,[In] void* wzFileExtensions,[Out] unsigned int* pcchActual)</unmanaged>	
        /// <unmanaged-short>IWICBitmapCodecInfo::GetFileExtensions</unmanaged-short>	
        internal void GetFileExtensions(int cchFileExtensions, System.IntPtr fileExtensions, out int cchActualRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* cchActualRef_ = &cchActualRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, cchFileExtensions, (void*)fileExtensions, cchActualRef_,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a value indicating whether the codec supports animation.</p>	
        /// </summary>	
        /// <param name="fSupportAnimationRef"><dd>  <p>Receives <strong>TRUE</strong> if the codec supports images with timing information; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::DoesSupportAnimation']/*"/>	
        /// <msdn-id>ee719680</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportAnimation([Out] BOOL* pfSupportAnimation)</unmanaged>	
        /// <unmanaged-short>IWICBitmapCodecInfo::DoesSupportAnimation</unmanaged-short>	
        internal void IsAnimationSupported_(out SharpDX.Mathematics.Interop.RawBool fSupportAnimationRef) {
            unsafe {
                fSupportAnimationRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fSupportAnimationRef_ = &fSupportAnimationRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, fSupportAnimationRef_,((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a value indicating whether the codec supports chromakeys.</p>	
        /// </summary>	
        /// <param name="fSupportChromakeyRef"><dd>  <p>Receives <strong>TRUE</strong> if the codec supports chromakeys; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::DoesSupportChromakey']/*"/>	
        /// <msdn-id>ee719682</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportChromakey([Out] BOOL* pfSupportChromakey)</unmanaged>	
        /// <unmanaged-short>IWICBitmapCodecInfo::DoesSupportChromakey</unmanaged-short>	
        internal void IsChromakeySupported_(out SharpDX.Mathematics.Interop.RawBool fSupportChromakeyRef) {
            unsafe {
                fSupportChromakeyRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fSupportChromakeyRef_ = &fSupportChromakeyRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, fSupportChromakeyRef_,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a value indicating whether the codec supports lossless formats.</p>	
        /// </summary>	
        /// <param name="fSupportLosslessRef"><dd>  <p>Receives <strong>TRUE</strong> if the codec supports lossless formats; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::DoesSupportLossless']/*"/>	
        /// <msdn-id>ee719683</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportLossless([Out] BOOL* pfSupportLossless)</unmanaged>	
        /// <unmanaged-short>IWICBitmapCodecInfo::DoesSupportLossless</unmanaged-short>	
        internal void IsLosslessSupported_(out SharpDX.Mathematics.Interop.RawBool fSupportLosslessRef) {
            unsafe {
                fSupportLosslessRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fSupportLosslessRef_ = &fSupportLosslessRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, fSupportLosslessRef_,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a value indicating whether the codec supports multi frame images.</p>	
        /// </summary>	
        /// <param name="fSupportMultiframeRef"><dd>  <p>Receives <strong>TRUE</strong> if the codec supports multi frame images; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::DoesSupportMultiframe']/*"/>	
        /// <msdn-id>ee719685</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportMultiframe([Out] BOOL* pfSupportMultiframe)</unmanaged>	
        /// <unmanaged-short>IWICBitmapCodecInfo::DoesSupportMultiframe</unmanaged-short>	
        internal void IsMultiframeSupported_(out SharpDX.Mathematics.Interop.RawBool fSupportMultiframeRef) {
            unsafe {
                fSupportMultiframeRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fSupportMultiframeRef_ = &fSupportMultiframeRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, fSupportMultiframeRef_,((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a value indicating whether the given mime type matches the mime type of the codec.</p>	
        /// </summary>	
        /// <param name="mimeType"><dd>  <p>The mime type to compare.</p> </dd></param>	
        /// <returns><dd>  <p>Receives <strong>TRUE</strong> if the mime types match; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??The Windows provided codecs do not implement this method and return E_NOTIMPL.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecInfo::MatchesMimeType']/*"/>	
        /// <msdn-id>ee690083</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapCodecInfo::MatchesMimeType([In] const wchar_t* wzMimeType,[Out] BOOL* pfMatches)</unmanaged>	
        /// <unmanaged-short>IWICBitmapCodecInfo::MatchesMimeType</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool MatchesMimeType(string mimeType) {
            unsafe {
                IntPtr mimeType_ = Utilities.StringToHGlobalUni(mimeType);
                SharpDX.Mathematics.Interop.RawBool fMatchesRef;
                fMatchesRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)mimeType_, &fMatchesRef,((void**)(*(void**)_nativePointer))[22]);		
                Marshal.FreeHGlobal(mimeType_ );
                __result__.CheckError();
                return fMatchesRef;
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods used for progress notification for encoders and decoders.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is not supported by the Windows provided codecs.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecProgressNotification']/*"/>	
    /// <msdn-id>ee690084</msdn-id>	
    /// <unmanaged>IWICBitmapCodecProgressNotification</unmanaged>	
    /// <unmanaged-short>IWICBitmapCodecProgressNotification</unmanaged-short>	
    [Guid("64C1024E-C3CF-4462-8078-88C2B11C46D9")]
    internal partial class BitmapCodecProgressNotification : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.BitmapCodecProgressNotification"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapCodecProgressNotification(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.BitmapCodecProgressNotification"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.BitmapCodecProgressNotification(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.BitmapCodecProgressNotification(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Registers a progress notification callback function.</p>	
        /// </summary>	
        /// <param name="fnProgressNotificationRef"><dd>  <p>A function reference to the application defined progress notification callback function. See <strong>ProgressNotificationCallback</strong> for the callback signature.</p> </dd></param>	
        /// <param name="vDataRef"><dd>  <p>A reference to component data for the callback method.</p> </dd></param>	
        /// <param name="progressFlags"><dd>  <p>The <strong><see cref="SharpDX.WIC.ProgressOperation"/></strong> and <strong><see cref="SharpDX.WIC.ProgressNotification"/></strong> flags to use for progress notification.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Applications can only register a single callback. Subsequent registration calls will replace the previously registered callback. To unregister a callback, pass in <strong><c>null</c></strong> or register a new callback function.</p><p> Progress is reported in an increasing order between 0.0 and 1.0.  If <em>dwProgressFlags</em> includes <strong><see cref="SharpDX.WIC.ProgressNotification.Begin"/></strong>, the callback is guaranteed to be called with progress 0.0. If <em>dwProgressFlags</em> includes <strong><see cref="SharpDX.WIC.ProgressNotification.End"/></strong>, the callback is guaranteed to be called with progress 1.0. </p><p><strong><see cref="SharpDX.WIC.ProgressNotification.Frequent"/></strong> increases the frequency in which the callback is called. If an operation is expected to take more than 30 seconds, <strong><see cref="SharpDX.WIC.ProgressNotification.Frequent"/></strong> should be added to <em>dwProgressFlags</em>. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapCodecProgressNotification::RegisterProgressNotification']/*"/>	
        /// <msdn-id>ee690085</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapCodecProgressNotification::RegisterProgressNotification([In, Optional] __function__stdcall* pfnProgressNotification,[In, Optional] void* pvData,[In] unsigned int dwProgressFlags)</unmanaged>	
        /// <unmanaged-short>IWICBitmapCodecProgressNotification::RegisterProgressNotification</unmanaged-short>	
        internal void RegisterProgressNotification(SharpDX.FunctionCallback fnProgressNotificationRef, System.IntPtr vDataRef, int progressFlags) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, fnProgressNotificationRef, (void*)vDataRef, progressFlags,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods that represent a decoder.</p><p>The interface provides access to the decoder's properties such as global thumbnails (if supported), frames, and palette. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>There are a number of concrete implemenations of this interface representing each of the standard decoders provided by the platform including bitmap (BMP), Portable Network Graphics (PNG), icon (ICO), Joint Photographic Experts Group (JPEG), Graphics Interchange Format (GIF), Tagged Image File Format (TIFF), and Microsoft?Windows Digital Photo (WDP). The following table includes the class identifier (CLSID) for each native decoder. </p><table> <tr><th>CLSID Name</th><th>CLSID</th></tr> <tr><td><see cref="SharpDX.WIC.BitmapDecoderGuids.Bmp"/></td><td>0x6b462062, 0x7cbf, 0x400d, 0x9f, 0xdb, 0x81, 0x3d, 0xd1, 0xf, 0x27, 0x78</td></tr> <tr><td><see cref="SharpDX.WIC.BitmapDecoderGuids.Png"/></td><td>0x389ea17b, 0x5078, 0x4cde, 0xb6, 0xef, 0x25, 0xc1, 0x51, 0x75, 0xc7, 0x51</td></tr> <tr><td><see cref="SharpDX.WIC.BitmapDecoderGuids.Ico"/></td><td>0xc61bfcdf, 0x2e0f, 0x4aad, 0xa8, 0xd7, 0xe0, 0x6b, 0xaf, 0xeb, 0xcd, 0xfe</td></tr> <tr><td><see cref="SharpDX.WIC.BitmapDecoderGuids.Jpeg"/></td><td>0x9456a480, 0xe88b, 0x43ea, 0x9e, 0x73, 0xb, 0x2d, 0x9b, 0x71, 0xb1, 0xca</td></tr> <tr><td><see cref="SharpDX.WIC.BitmapDecoderGuids.Gif"/></td><td>0x381dda3c, 0x9ce9, 0x4834, 0xa2, 0x3e, 0x1f, 0x98, 0xf8, 0xfc, 0x52, 0xbe</td></tr> <tr><td><see cref="SharpDX.WIC.BitmapDecoderGuids.Tiff"/></td><td>0xb54e85d9, 0xfe23, 0x499f, 0x8b, 0x88, 0x6a, 0xce, 0xa7, 0x13, 0x75, 0x2b</td></tr> <tr><td><see cref="SharpDX.WIC.BitmapDecoderGuids.Wmp"/></td><td>0xa26cec36, 0x234c, 0x4950, 0xae, 0x16, 0xe3, 0x4a, 0xac, 0xe7, 0x1d, 0x0d</td></tr> </table><p>?</p><p>This interface may be sub-classed to provide support for third party codecs as part of the extensibility model. See the AITCodec Sample CODEC.</p><p>Codecs written as TIFF container formats that are not register will decode as a TIFF image. Client applications should check for a zero frame count to determine if the codec is valid.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder']/*"/>	
    /// <msdn-id>ee690086</msdn-id>	
    /// <unmanaged>IWICBitmapDecoder</unmanaged>	
    /// <unmanaged-short>IWICBitmapDecoder</unmanaged-short>	
    [Guid("9EDDE9E7-8DEE-47ea-99DF-E6FAF2ED44BF")]
    public partial class BitmapDecoder : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.BitmapDecoder"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapDecoder(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.BitmapDecoder"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.BitmapDecoder(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.BitmapDecoder(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the image's container format.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetContainerFormat']/*"/>	
        /// <msdn-id>ee690095</msdn-id>	
        /// <unmanaged>GetContainerFormat</unmanaged>	
        /// <unmanaged-short>GetContainerFormat</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>
        public System.Guid ContainerFormat {
                get { System.Guid __output__; GetContainerFormat(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves an <strong><see cref="SharpDX.WIC.BitmapDecoderInfo"/></strong> for the image.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetDecoderInfo']/*"/>	
        /// <msdn-id>ee690096</msdn-id>	
        /// <unmanaged>GetDecoderInfo</unmanaged>	
        /// <unmanaged-short>GetDecoderInfo</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetDecoderInfo([Out] IWICBitmapDecoderInfo** ppIDecoderInfo)</unmanaged>
        public SharpDX.WIC.BitmapDecoderInfo DecoderInfo {
                get { SharpDX.WIC.BitmapDecoderInfo __output__; GetDecoderInfo(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the metadata query reader from the decoder.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If an image format does not support container-level metadata, this will return <see cref="SharpDX.WIC.ResultCode.UnsupportedOperation"/>. The only Windows provided image format that supports container-level metadata is GIF. Instead, use <strong><see cref="SharpDX.WIC.BitmapFrameDecode.GetMetadataQueryReader"/></strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetMetadataQueryReader']/*"/>	
        /// <msdn-id>ee690102</msdn-id>	
        /// <unmanaged>GetMetadataQueryReader</unmanaged>	
        /// <unmanaged-short>GetMetadataQueryReader</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetMetadataQueryReader([Out] IWICMetadataQueryReader** ppIMetadataQueryReader)</unmanaged>
        public SharpDX.WIC.MetadataQueryReader MetadataQueryReader {
                get { SharpDX.WIC.MetadataQueryReader __output__; GetMetadataQueryReader(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves a preview image, if supported.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Not all formats support previews. Only the native Microsoft?Windows Digital Photo (WDP) codec support previews.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetPreview']/*"/>	
        /// <msdn-id>ee690104</msdn-id>	
        /// <unmanaged>GetPreview</unmanaged>	
        /// <unmanaged-short>GetPreview</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetPreview([Out] IWICBitmapSource** ppIBitmapSource)</unmanaged>
        public SharpDX.WIC.BitmapSource Preview {
                get { SharpDX.WIC.BitmapSource __output__; GetPreview(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves a bitmap thumbnail of the image, if one exists</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The returned thumbnail can be of any size, so the caller should scale the thumbnail to the desired size. The only Windows provided image formats that support thumbnails are JPEG, TIFF, and JPEG-XR. If the thumbnail is not available, this will return <see cref="SharpDX.WIC.ResultCode.Codecnothumbnail"/>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetThumbnail']/*"/>	
        /// <msdn-id>ee690106</msdn-id>	
        /// <unmanaged>GetThumbnail</unmanaged>	
        /// <unmanaged-short>GetThumbnail</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetThumbnail([Out] IWICBitmapSource** ppIThumbnail)</unmanaged>
        public SharpDX.WIC.BitmapSource Thumbnail {
                get { SharpDX.WIC.BitmapSource __output__; GetThumbnail(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the total number of frames in the image.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetFrameCount']/*"/>	
        /// <msdn-id>ee690099</msdn-id>	
        /// <unmanaged>GetFrameCount</unmanaged>	
        /// <unmanaged-short>GetFrameCount</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetFrameCount([Out] unsigned int* pCount)</unmanaged>
        public int FrameCount {
                get { int __output__; GetFrameCount(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the capabilities of the decoder based on the specified stream.</p>	
        /// </summary>	
        /// <param name="streamRef"><dd>  <p>The stream to retrieve the decoder capabilities from.</p> </dd></param>	
        /// <returns><dd>  <p>The <strong><see cref="SharpDX.WIC.BitmapDecoderCapabilities"/></strong> of the decoder.</p> </dd></returns>	
        /// <remarks>	
        /// <p>Custom decoder implementations should save the current position of the specified <see cref="SharpDX.Win32.IStream"/>, read whatever information is necessary in order to determine which capabilities it can provide for the supplied stream, and restore the stream position.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::QueryCapability']/*"/>	
        /// <msdn-id>ee690109</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::QueryCapability([In, Optional] IStream* pIStream,[Out] WICBitmapDecoderCapabilities* pdwCapability)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoder::QueryCapability</unmanaged-short>	
        internal SharpDX.WIC.BitmapDecoderCapabilities QueryCapability_(System.IntPtr streamRef) {
            unsafe {
                SharpDX.WIC.BitmapDecoderCapabilities capabilityRef;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)streamRef, &capabilityRef,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
                return capabilityRef;
            }
        }
        
        /// <summary>	
        /// <p>Initializes the decoder with the provided stream.</p>	
        /// </summary>	
        /// <param name="streamRef"><dd>  <p>The stream to use for initialization.</p> <p>The stream contains the encoded pixels which are decoded each time the <strong>CopyPixels</strong> method on the <strong><see cref="SharpDX.WIC.BitmapFrameDecode"/></strong> interface (see <strong>GetFrame</strong>) is invoked.</p> </dd></param>	
        /// <param name="cacheOptions"><dd>  <p>The <strong><see cref="SharpDX.WIC.DecodeOptions"/></strong> to use for initialization.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::Initialize']/*"/>	
        /// <msdn-id>ee690108</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::Initialize([In, Optional] IStream* pIStream,[In] WICDecodeOptions cacheOptions)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoder::Initialize</unmanaged-short>	
        internal void Initialize_(System.IntPtr streamRef, SharpDX.WIC.DecodeOptions cacheOptions) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)streamRef, unchecked((int)cacheOptions),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the image's container format.</p>	
        /// </summary>	
        /// <param name="guidContainerFormatRef"><dd>  <p>A reference that receives the image's container format <see cref="System.Guid"/>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetContainerFormat']/*"/>	
        /// <msdn-id>ee690095</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoder::GetContainerFormat</unmanaged-short>	
        internal void GetContainerFormat(out System.Guid guidContainerFormatRef) {
            unsafe {
                guidContainerFormatRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* guidContainerFormatRef_ = &guidContainerFormatRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, guidContainerFormatRef_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves an <strong><see cref="SharpDX.WIC.BitmapDecoderInfo"/></strong> for the image.</p>	
        /// </summary>	
        /// <param name="decoderInfoOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetDecoderInfo']/*"/>	
        /// <msdn-id>ee690096</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetDecoderInfo([Out] IWICBitmapDecoderInfo** ppIDecoderInfo)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoder::GetDecoderInfo</unmanaged-short>	
        internal void GetDecoderInfo(out SharpDX.WIC.BitmapDecoderInfo decoderInfoOut) {
            unsafe {
                IntPtr decoderInfoOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &decoderInfoOut_,((void**)(*(void**)_nativePointer))[6]);		
                decoderInfoOut= (decoderInfoOut_ == IntPtr.Zero)?null:new SharpDX.WIC.BitmapDecoderInfo(decoderInfoOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Copies the decoder's <strong><see cref="SharpDX.WIC.Palette"/></strong> .</p>	
        /// </summary>	
        /// <param name="paletteRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><strong>CopyPalette</strong> returns a global palette (a palette that applies to all the frames in the image) if there is one; otherwise, it returns <see cref="SharpDX.WIC.ResultCode.Paletteunavailable"/>. If an image doesn't have a global palette, it may still have a frame-level palette, which can be retrieved using <strong>IWICBitmapFrameDecode::CopyPalette</strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::CopyPalette']/*"/>	
        /// <msdn-id>ee690091</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::CopyPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoder::CopyPalette</unmanaged-short>	
        public void CopyPalette(SharpDX.WIC.Palette paletteRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((paletteRef == null)?IntPtr.Zero:paletteRef.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the metadata query reader from the decoder.</p>	
        /// </summary>	
        /// <param name="metadataQueryReaderOut"><dd>  <p>Receives a reference to the decoder's <strong><see cref="SharpDX.WIC.MetadataQueryReader"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If an image format does not support container-level metadata, this will return <see cref="SharpDX.WIC.ResultCode.UnsupportedOperation"/>. The only Windows provided image format that supports container-level metadata is GIF. Instead, use <strong><see cref="SharpDX.WIC.BitmapFrameDecode.GetMetadataQueryReader"/></strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetMetadataQueryReader']/*"/>	
        /// <msdn-id>ee690102</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetMetadataQueryReader([Out] IWICMetadataQueryReader** ppIMetadataQueryReader)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoder::GetMetadataQueryReader</unmanaged-short>	
        internal void GetMetadataQueryReader(out SharpDX.WIC.MetadataQueryReader metadataQueryReaderOut) {
            unsafe {
                IntPtr metadataQueryReaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &metadataQueryReaderOut_,((void**)(*(void**)_nativePointer))[8]);		
                metadataQueryReaderOut= (metadataQueryReaderOut_ == IntPtr.Zero)?null:new SharpDX.WIC.MetadataQueryReader(metadataQueryReaderOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a preview image, if supported.</p>	
        /// </summary>	
        /// <param name="bitmapSourceOut"><dd>  <p>Receives a reference to the preview bitmap if supported.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Not all formats support previews. Only the native Microsoft?Windows Digital Photo (WDP) codec support previews.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetPreview']/*"/>	
        /// <msdn-id>ee690104</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetPreview([Out] IWICBitmapSource** ppIBitmapSource)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoder::GetPreview</unmanaged-short>	
        internal void GetPreview(out SharpDX.WIC.BitmapSource bitmapSourceOut) {
            unsafe {
                IntPtr bitmapSourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &bitmapSourceOut_,((void**)(*(void**)_nativePointer))[9]);		
                bitmapSourceOut= (bitmapSourceOut_ == IntPtr.Zero)?null:new SharpDX.WIC.BitmapSource(bitmapSourceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the <strong><see cref="SharpDX.WIC.ColorContext"/></strong> objects of the image.</p>	
        /// </summary>	
        /// <param name="count">No documentation.</param>	
        /// <param name="colorContextsOut">No documentation.</param>	
        /// <param name="actualCountRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetColorContexts']/*"/>	
        /// <msdn-id>ee690093</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoder::GetColorContexts</unmanaged-short>	
        internal SharpDX.Result GetColorContexts(int count, SharpDX.WIC.ColorContext[] colorContextsOut, out int actualCountRef) {
            unsafe {
                IntPtr* colorContextsOut_ = (IntPtr*)0;
                if ( colorContextsOut != null ) {
                    IntPtr* colorContextsOut__ = stackalloc IntPtr[colorContextsOut.Length];
                    colorContextsOut_ = colorContextsOut__;
                    for (int i = 0; i < colorContextsOut.Length; i++)                        
                        colorContextsOut_[i] =  (colorContextsOut[i] == null)? IntPtr.Zero : colorContextsOut[i].NativePointer;
                }
                SharpDX.Result __result__;
                fixed (void* actualCountRef_ = &actualCountRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, count, colorContextsOut_, actualCountRef_,((void**)(*(void**)_nativePointer))[10]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the <strong><see cref="SharpDX.WIC.ColorContext"/></strong> objects of the image.</p>	
        /// </summary>	
        /// <param name="count">No documentation.</param>	
        /// <param name="colorContextsOut">No documentation.</param>	
        /// <param name="actualCountRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetColorContexts']/*"/>	
        /// <msdn-id>ee690093</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoder::GetColorContexts</unmanaged-short>	
        internal SharpDX.Result GetColorContexts(int count, SharpDX.ComArray<SharpDX.WIC.ColorContext> colorContextsOut, out int actualCountRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* actualCountRef_ = &actualCountRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, count, (void*)((colorContextsOut == null)?IntPtr.Zero:colorContextsOut.NativePointer), actualCountRef_,((void**)(*(void**)_nativePointer))[10]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the <strong><see cref="SharpDX.WIC.ColorContext"/></strong> objects of the image.</p>	
        /// </summary>	
        /// <param name="count">No documentation.</param>	
        /// <param name="colorContextsOut">No documentation.</param>	
        /// <param name="actualCountRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetColorContexts']/*"/>	
        /// <msdn-id>ee690093</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoder::GetColorContexts</unmanaged-short>	
        private SharpDX.Result GetColorContexts(int count, System.IntPtr colorContextsOut, System.IntPtr actualCountRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, count, (void*)colorContextsOut, (void*)actualCountRef,((void**)(*(void**)_nativePointer))[10]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a bitmap thumbnail of the image, if one exists</p>	
        /// </summary>	
        /// <param name="thumbnailOut"><dd>  <p>Receives a reference to the <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> of the thumbnail.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The returned thumbnail can be of any size, so the caller should scale the thumbnail to the desired size. The only Windows provided image formats that support thumbnails are JPEG, TIFF, and JPEG-XR. If the thumbnail is not available, this will return <see cref="SharpDX.WIC.ResultCode.Codecnothumbnail"/>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetThumbnail']/*"/>	
        /// <msdn-id>ee690106</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetThumbnail([Out] IWICBitmapSource** ppIThumbnail)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoder::GetThumbnail</unmanaged-short>	
        internal void GetThumbnail(out SharpDX.WIC.BitmapSource thumbnailOut) {
            unsafe {
                IntPtr thumbnailOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &thumbnailOut_,((void**)(*(void**)_nativePointer))[11]);		
                thumbnailOut= (thumbnailOut_ == IntPtr.Zero)?null:new SharpDX.WIC.BitmapSource(thumbnailOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the total number of frames in the image.</p>	
        /// </summary>	
        /// <param name="countRef"><dd>  <p>A reference that receives the total number of frames in the image.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetFrameCount']/*"/>	
        /// <msdn-id>ee690099</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetFrameCount([Out] unsigned int* pCount)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoder::GetFrameCount</unmanaged-short>	
        internal void GetFrameCount(out int countRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* countRef_ = &countRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, countRef_,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the specified frame of the image.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The particular frame to retrieve.</p> </dd></param>	
        /// <returns><dd>  <p>A reference that receives a reference to the <strong><see cref="SharpDX.WIC.BitmapFrameDecode"/></strong>.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoder::GetFrame']/*"/>	
        /// <msdn-id>ee690098</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoder::GetFrame([In] unsigned int index,[Out] IWICBitmapFrameDecode** ppIBitmapFrame)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoder::GetFrame</unmanaged-short>	
        public SharpDX.WIC.BitmapFrameDecode GetFrame(int index) {
            unsafe {
                SharpDX.WIC.BitmapFrameDecode bitmapFrameOut;
                IntPtr bitmapFrameOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, index, &bitmapFrameOut_,((void**)(*(void**)_nativePointer))[13]);		
                bitmapFrameOut= (bitmapFrameOut_ == IntPtr.Zero)?null:new SharpDX.WIC.BitmapFrameDecode(bitmapFrameOut_);	
                __result__.CheckError();
                return bitmapFrameOut;
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods that provide information about a decoder.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoderInfo']/*"/>	
    /// <msdn-id>ee690087</msdn-id>	
    /// <unmanaged>IWICBitmapDecoderInfo</unmanaged>	
    /// <unmanaged-short>IWICBitmapDecoderInfo</unmanaged-short>	
    [Guid("D8CD007F-D08F-4191-9BFC-236EA7F0E4B5")]
    public partial class BitmapDecoderInfo : SharpDX.WIC.BitmapCodecInfo {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.BitmapDecoderInfo"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapDecoderInfo(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.BitmapDecoderInfo"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.BitmapDecoderInfo(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.BitmapDecoderInfo(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the file pattern signatures supported by the decoder.</p>	
        /// </summary>	
        /// <param name="sizePatterns"><dd>  <p>The array size of the <em>pPatterns</em> array.</p> </dd></param>	
        /// <param name="patternsRef"><dd>  <p>Receives a list of <strong><see cref="SharpDX.WIC.BitmapPattern"/></strong> objects supported by the decoder.</p> </dd></param>	
        /// <param name="atternCountRef"><dd>  <p>Receives the number of patterns the decoder supports.</p> </dd></param>	
        /// <param name="patternsActualRef"><dd>  <p>Receives the actual buffer size needed to retrieve all pattern signatures supported by the decoder. </p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> To retrieve all pattern signatures, this method should first be called with <em>pPatterns</em> set to <code><c>null</c></code> to retrieve the actual buffer size needed through <em>pcbPatternsActual</em>. Once the needed buffer size is known, allocate a buffer of the needed size and call <strong>GetPatterns</strong> again with the allocated buffer. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoderInfo::GetPatterns']/*"/>	
        /// <msdn-id>ee690089</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoderInfo::GetPatterns([In] unsigned int cbSizePatterns,[Out, Buffer, Optional] WICBitmapPattern* pPatterns,[Out] unsigned int* pcPatterns,[Out] unsigned int* pcbPatternsActual)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoderInfo::GetPatterns</unmanaged-short>	
        internal void GetPatterns(int sizePatterns, SharpDX.WIC.BitmapPattern[] patternsRef, out int atternCountRef, out int patternsActualRef) {
            unsafe {
                SharpDX.WIC.BitmapPattern[] patternsRef__ = patternsRef;
                SharpDX.Result __result__;
                fixed (void* patternsRef_ = patternsRef__)
                    fixed (void* atternCountRef_ = &atternCountRef)
                        fixed (void* patternsActualRef_ = &patternsActualRef)
                            __result__= 
            				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, sizePatterns, patternsRef_, atternCountRef_, patternsActualRef_,((void**)(*(void**)_nativePointer))[23]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a value that indicates whether the codec recognizes the pattern within a specified stream.</p>	
        /// </summary>	
        /// <param name="streamRef"><dd>  <p>The stream to pattern match within.</p> </dd></param>	
        /// <returns><dd>  <p>A reference that receives <strong>TRUE</strong> if the patterns match; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoderInfo::MatchesPattern']/*"/>	
        /// <msdn-id>ee690090</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoderInfo::MatchesPattern([In, Optional] IStream* pIStream,[Out] BOOL* pfMatches)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoderInfo::MatchesPattern</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool MatchesPattern_(System.IntPtr streamRef) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool fMatchesRef;
                fMatchesRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)streamRef, &fMatchesRef,((void**)(*(void**)_nativePointer))[24]);		
                __result__.CheckError();
                return fMatchesRef;
            }
        }
        
        /// <summary>	
        /// <p>Creates a new <strong><see cref="SharpDX.WIC.BitmapDecoder"/></strong> instance.</p>	
        /// </summary>	
        /// <param name="bitmapDecoderOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapDecoderInfo::CreateInstance']/*"/>	
        /// <msdn-id>ee690088</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapDecoderInfo::CreateInstance([Out, Fast] IWICBitmapDecoder** ppIBitmapDecoder)</unmanaged>	
        /// <unmanaged-short>IWICBitmapDecoderInfo::CreateInstance</unmanaged-short>	
        internal void CreateInstance(SharpDX.WIC.BitmapDecoder bitmapDecoderOut) {
            unsafe {
                IntPtr bitmapDecoderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &bitmapDecoderOut_,((void**)(*(void**)_nativePointer))[25]);		
                ((SharpDX.WIC.BitmapDecoder)bitmapDecoderOut).NativePointer = bitmapDecoderOut_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Defines methods for setting an encoder's properties such as thumbnails, frames, and palettes.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>There are a number of concrete implemenations of this interface representing each of the standard encoders provided by the platform including bitmap (BMP), Portable Network Graphics (PNG), Joint Photographic Experts Group (JPEG), Graphics Interchange Format (GIF), Tagged Image File Format (TIFF), and Microsoft?Windows Digital Photo (WDP). The following table includes the class identifier (CLSID) for each native encoder. </p><table> <tr><th>CLSID Name</th><th>CLSID</th></tr> <tr><td><see cref="SharpDX.WIC.BitmapEncoderGuids.Bmp"/></td><td>0x69be8bb4, 0xd66d, 0x47c8, 0x86, 0x5a, 0xed, 0x15, 0x89, 0x43, 0x37, 0x82</td></tr> <tr><td><see cref="SharpDX.WIC.BitmapEncoderGuids.Png"/></td><td>0x27949969, 0x876a, 0x41d7, 0x94, 0x47, 0x56, 0x8f, 0x6a, 0x35, 0xa4, 0xdc</td></tr> <tr><td><see cref="SharpDX.WIC.BitmapEncoderGuids.Jpeg"/></td><td>0x1a34f5c1, 0x4a5a, 0x46dc, 0xb6, 0x44, 0x1f, 0x45, 0x67, 0xe7, 0xa6, 0x76</td></tr> <tr><td><see cref="SharpDX.WIC.BitmapEncoderGuids.Gif"/></td><td>0x114f5598, 0xb22, 0x40a0, 0x86, 0xa1, 0xc8, 0x3e, 0xa4, 0x95, 0xad, 0xbd</td></tr> <tr><td><see cref="SharpDX.WIC.BitmapEncoderGuids.Tiff"/></td><td>0x0131be10, 0x2001, 0x4c5f, 0xa9, 0xb0, 0xcc, 0x88, 0xfa, 0xb6, 0x4c, 0xe8</td></tr> <tr><td><see cref="SharpDX.WIC.BitmapEncoderGuids.Wmp"/></td><td>0xac4ce3cb, 0xe1c1, 0x44cd, 0x82, 0x15, 0x5a, 0x16, 0x65, 0x50, 0x9e, 0xc2</td></tr> </table><p>?</p><p>Additionally this interface may be sub-classed to provide support for third party codecs as part of the extensibility model. See the AITCodec Sample CODEC.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder']/*"/>	
    /// <msdn-id>ee690110</msdn-id>	
    /// <unmanaged>IWICBitmapEncoder</unmanaged>	
    /// <unmanaged-short>IWICBitmapEncoder</unmanaged-short>	
    [Guid("00000103-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class BitmapEncoder : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.BitmapEncoder"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapEncoder(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.BitmapEncoder"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.BitmapEncoder(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.BitmapEncoder(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the encoder's container format.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::GetContainerFormat']/*"/>	
        /// <msdn-id>ee690118</msdn-id>	
        /// <unmanaged>GetContainerFormat</unmanaged>	
        /// <unmanaged-short>GetContainerFormat</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>
        public System.Guid ContainerFormat {
                get { System.Guid __output__; GetContainerFormat(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves an <strong><see cref="SharpDX.WIC.BitmapEncoderInfo"/></strong> for the encoder.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::GetEncoderInfo']/*"/>	
        /// <msdn-id>ee690119</msdn-id>	
        /// <unmanaged>GetEncoderInfo</unmanaged>	
        /// <unmanaged-short>GetEncoderInfo</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::GetEncoderInfo([Out] IWICBitmapEncoderInfo** ppIEncoderInfo)</unmanaged>
        public SharpDX.WIC.BitmapEncoderInfo EncoderInfo {
                get { SharpDX.WIC.BitmapEncoderInfo __output__; GetEncoderInfo(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Sets the global palette for the image.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Only GIF images support an optional global palette, and you must set the global palette before adding any frames to the image. You only need to set the palette for indexed pixel formats.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::SetPalette']/*"/>	
        /// <msdn-id>ee690126</msdn-id>	
        /// <unmanaged>SetPalette</unmanaged>	
        /// <unmanaged-short>SetPalette</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::SetPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>
        public SharpDX.WIC.Palette Palette {
                set { SetPalette(value); }
        }
        
        /// <summary>	
        /// <p>Sets the global thumbnail for the image.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::SetThumbnail']/*"/>	
        /// <msdn-id>ee690129</msdn-id>	
        /// <unmanaged>SetThumbnail</unmanaged>	
        /// <unmanaged-short>SetThumbnail</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::SetThumbnail([In, Optional] IWICBitmapSource* pIThumbnail)</unmanaged>
        public SharpDX.WIC.BitmapSource Thumbnail {
                set { SetThumbnail(value); }
        }
        
        /// <summary>	
        /// <p>Sets the global preview for the image.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::SetPreview']/*"/>	
        /// <msdn-id>ee690128</msdn-id>	
        /// <unmanaged>SetPreview</unmanaged>	
        /// <unmanaged-short>SetPreview</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::SetPreview([In, Optional] IWICBitmapSource* pIPreview)</unmanaged>
        public SharpDX.WIC.BitmapSource Preview {
                set { SetPreview(value); }
        }
        
        /// <summary>	
        /// <p>Retrieves a metadata query writer for the encoder.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::GetMetadataQueryWriter']/*"/>	
        /// <msdn-id>ee690121</msdn-id>	
        /// <unmanaged>GetMetadataQueryWriter</unmanaged>	
        /// <unmanaged-short>GetMetadataQueryWriter</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::GetMetadataQueryWriter([Out] IWICMetadataQueryWriter** ppIMetadataQueryWriter)</unmanaged>
        public SharpDX.WIC.MetadataQueryWriter MetadataQueryWriter {
                get { SharpDX.WIC.MetadataQueryWriter __output__; GetMetadataQueryWriter(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Proxy function for the <strong>Initialize</strong> method.</p>	
        /// </summary>	
        /// <param name="streamRef">No documentation.</param>	
        /// <param name="cacheOption">No documentation.</param>	
        /// <returns><p>If this function succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::Initialize']/*"/>	
        /// <msdn-id>ee690124</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::Initialize([In, Optional] IStream* pIStream,[In] WICBitmapEncoderCacheOption cacheOption)</unmanaged>	
        /// <unmanaged-short>IWICBitmapEncoder::Initialize</unmanaged-short>	
        internal void Initialize_(System.IntPtr streamRef, SharpDX.WIC.BitmapEncoderCacheOption cacheOption) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)streamRef, unchecked((int)cacheOption),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the encoder's container format.</p>	
        /// </summary>	
        /// <param name="guidContainerFormatRef"><dd>  <p>A reference that receives the encoder's container format <see cref="System.Guid"/>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::GetContainerFormat']/*"/>	
        /// <msdn-id>ee690118</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>	
        /// <unmanaged-short>IWICBitmapEncoder::GetContainerFormat</unmanaged-short>	
        internal void GetContainerFormat(out System.Guid guidContainerFormatRef) {
            unsafe {
                guidContainerFormatRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* guidContainerFormatRef_ = &guidContainerFormatRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, guidContainerFormatRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves an <strong><see cref="SharpDX.WIC.BitmapEncoderInfo"/></strong> for the encoder.</p>	
        /// </summary>	
        /// <param name="encoderInfoOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::GetEncoderInfo']/*"/>	
        /// <msdn-id>ee690119</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::GetEncoderInfo([Out] IWICBitmapEncoderInfo** ppIEncoderInfo)</unmanaged>	
        /// <unmanaged-short>IWICBitmapEncoder::GetEncoderInfo</unmanaged-short>	
        internal void GetEncoderInfo(out SharpDX.WIC.BitmapEncoderInfo encoderInfoOut) {
            unsafe {
                IntPtr encoderInfoOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &encoderInfoOut_,((void**)(*(void**)_nativePointer))[5]);		
                encoderInfoOut= (encoderInfoOut_ == IntPtr.Zero)?null:new SharpDX.WIC.BitmapEncoderInfo(encoderInfoOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the <strong><see cref="SharpDX.WIC.ColorContext"/></strong> objects for the encoder.</p>	
        /// </summary>	
        /// <param name="count">No documentation.</param>	
        /// <param name="colorContextOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::SetColorContexts']/*"/>	
        /// <msdn-id>ee690125</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>	
        /// <unmanaged-short>IWICBitmapEncoder::SetColorContexts</unmanaged-short>	
        internal void SetColorContexts(int count, SharpDX.WIC.ColorContext[] colorContextOut) {
            unsafe {
                IntPtr* colorContextOut_ = (IntPtr*)0;
                if ( colorContextOut != null ) {
                    IntPtr* colorContextOut__ = stackalloc IntPtr[colorContextOut.Length];
                    colorContextOut_ = colorContextOut__;
                    for (int i = 0; i < colorContextOut.Length; i++)                        
                        colorContextOut_[i] =  (colorContextOut[i] == null)? IntPtr.Zero : colorContextOut[i].NativePointer;
                }
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, count, colorContextOut_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the <strong><see cref="SharpDX.WIC.ColorContext"/></strong> objects for the encoder.</p>	
        /// </summary>	
        /// <param name="count">No documentation.</param>	
        /// <param name="colorContextOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::SetColorContexts']/*"/>	
        /// <msdn-id>ee690125</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>	
        /// <unmanaged-short>IWICBitmapEncoder::SetColorContexts</unmanaged-short>	
        internal void SetColorContexts(int count, SharpDX.ComArray<SharpDX.WIC.ColorContext> colorContextOut) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, count, (void*)((colorContextOut == null)?IntPtr.Zero:colorContextOut.NativePointer),((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the <strong><see cref="SharpDX.WIC.ColorContext"/></strong> objects for the encoder.</p>	
        /// </summary>	
        /// <param name="count">No documentation.</param>	
        /// <param name="colorContextOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::SetColorContexts']/*"/>	
        /// <msdn-id>ee690125</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>	
        /// <unmanaged-short>IWICBitmapEncoder::SetColorContexts</unmanaged-short>	
        private void SetColorContexts(int count, System.IntPtr colorContextOut) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, count, (void*)colorContextOut,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the global palette for the image.</p>	
        /// </summary>	
        /// <param name="paletteRef"><dd>  <p>The <strong><see cref="SharpDX.WIC.Palette"/></strong> to use as the global palette.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, or an error value otherwise. </p><p>Returns <see cref="SharpDX.WIC.ResultCode.UnsupportedOperation"/> if the feature is not supported by the encoder.</p></returns>	
        /// <remarks>	
        /// <p>Only GIF images support an optional global palette, and you must set the global palette before adding any frames to the image. You only need to set the palette for indexed pixel formats.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::SetPalette']/*"/>	
        /// <msdn-id>ee690126</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::SetPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>	
        /// <unmanaged-short>IWICBitmapEncoder::SetPalette</unmanaged-short>	
        internal void SetPalette(SharpDX.WIC.Palette paletteRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((paletteRef == null)?IntPtr.Zero:paletteRef.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the global thumbnail for the image.</p>	
        /// </summary>	
        /// <param name="thumbnailRef"><dd>  <p>The <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> to set as the global thumbnail.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, or an error value otherwise. </p><p>Returns <see cref="SharpDX.WIC.ResultCode.UnsupportedOperation"/> if the feature is not supported by the encoder.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::SetThumbnail']/*"/>	
        /// <msdn-id>ee690129</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::SetThumbnail([In, Optional] IWICBitmapSource* pIThumbnail)</unmanaged>	
        /// <unmanaged-short>IWICBitmapEncoder::SetThumbnail</unmanaged-short>	
        internal void SetThumbnail(SharpDX.WIC.BitmapSource thumbnailRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((thumbnailRef == null)?IntPtr.Zero:thumbnailRef.NativePointer),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the global preview for the image.</p>	
        /// </summary>	
        /// <param name="previewRef"><dd>  <p>The <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> to use as the global preview.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, or an error value otherwise. </p><p>Returns <see cref="SharpDX.WIC.ResultCode.UnsupportedOperation"/> if the feature is not supported by the encoder.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::SetPreview']/*"/>	
        /// <msdn-id>ee690128</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::SetPreview([In, Optional] IWICBitmapSource* pIPreview)</unmanaged>	
        /// <unmanaged-short>IWICBitmapEncoder::SetPreview</unmanaged-short>	
        internal void SetPreview(SharpDX.WIC.BitmapSource previewRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((previewRef == null)?IntPtr.Zero:previewRef.NativePointer),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new <strong><see cref="SharpDX.WIC.BitmapFrameEncode"/></strong> instance.</p>	
        /// </summary>	
        /// <param name="frameEncodeOut">No documentation.</param>	
        /// <param name="encoderOptionsOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The parameter <em>ppIEncoderOptions</em> can be used to receive an <see cref="SharpDX.Win32.PropertyBag"/> that can then be used to specify encoder options. This is done by passing a reference to a <strong><c>null</c></strong> <see cref="SharpDX.Win32.PropertyBag"/> reference in <em>ppIEncoderOptions</em>. The returned <see cref="SharpDX.Win32.PropertyBag"/> is initialized with all encoder options that are available for the given format, at their default values. To specify non-default encoding behavior, set the needed encoder options on the <see cref="SharpDX.Win32.PropertyBag"/> and pass it to <strong><see cref="SharpDX.WIC.BitmapFrameEncode.Initialize"/></strong>.</p><p><strong>Note</strong>??Do not pass in a reference to an initialized <see cref="SharpDX.Win32.PropertyBag"/>. The reference will be overwritten, and the original <see cref="SharpDX.Win32.PropertyBag"/> will not be freed.</p><p>Otherwise, you can pass <strong><c>null</c></strong> in <em>ppIEncoderOptions</em> if you do not intend to specify encoder options.</p><p>See Encoding Overview for an example of how to set encoder options.</p><p>For formats that support encoding multiple frames (for example, TIFF, JPEG-XR), you can work on only one frame at a time. This means that you must call <strong><see cref="SharpDX.WIC.BitmapFrameEncode.Commit"/></strong> before you call <strong>CreateNewFrame</strong> again.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::CreateNewFrame']/*"/>	
        /// <msdn-id>ee690116</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::CreateNewFrame([Out, Fast] IWICBitmapFrameEncode** ppIFrameEncode,[Out, Fast] IPropertyBag2** ppIEncoderOptions)</unmanaged>	
        /// <unmanaged-short>IWICBitmapEncoder::CreateNewFrame</unmanaged-short>	
        internal void CreateNewFrame(SharpDX.WIC.BitmapFrameEncode frameEncodeOut, SharpDX.Win32.PropertyBag encoderOptionsOut) {
            unsafe {
                IntPtr frameEncodeOut_ = IntPtr.Zero;
                IntPtr encoderOptionsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &frameEncodeOut_, &encoderOptionsOut_,((void**)(*(void**)_nativePointer))[10]);		
                ((SharpDX.WIC.BitmapFrameEncode)frameEncodeOut).NativePointer = frameEncodeOut_;
                ((SharpDX.Win32.PropertyBag)encoderOptionsOut).NativePointer = encoderOptionsOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Commits all changes for the image and closes the stream.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>To finalize an image, both the frame <strong>Commit</strong> and the encoder <strong>Commit</strong> must be called. However, only call the encoder  <strong>Commit</strong> method after all frames have been committed.</p><p>After the encoder has been committed, it can't be re-initialized or reused with another stream. A new encoder interface must be created, for example, with <strong><see cref="SharpDX.WIC.ImagingFactory.CreateEncoder"/></strong>.	
        /// </p><p>For the encoder <strong>Commit</strong> to succeed, you must at a minimum call  <strong><see cref="SharpDX.WIC.BitmapEncoder.Initialize_"/></strong> and either <strong><see cref="SharpDX.WIC.BitmapFrameEncode.WriteSource"/></strong> or <strong><see cref="SharpDX.WIC.BitmapFrameEncode.WritePixels"/></strong>.	
        /// </p><p> <strong><see cref="SharpDX.WIC.BitmapFrameEncode.WriteSource"/></strong> specifies all parameters needed to encode the image data. <strong><see cref="SharpDX.WIC.BitmapFrameEncode.WritePixels"/></strong> requires that you also call <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetSize"/></strong>, <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPixelFormat"/></strong>, and <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPalette"/></strong> (if the pixel format is indexed).	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::Commit']/*"/>	
        /// <msdn-id>ee690114</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::Commit()</unmanaged>	
        /// <unmanaged-short>IWICBitmapEncoder::Commit</unmanaged-short>	
        public void Commit() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a metadata query writer for the encoder.</p>	
        /// </summary>	
        /// <param name="metadataQueryWriterOut"><dd>  <p>When this method returns, contains a reference to the encoder's metadata query writer.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoder::GetMetadataQueryWriter']/*"/>	
        /// <msdn-id>ee690121</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapEncoder::GetMetadataQueryWriter([Out] IWICMetadataQueryWriter** ppIMetadataQueryWriter)</unmanaged>	
        /// <unmanaged-short>IWICBitmapEncoder::GetMetadataQueryWriter</unmanaged-short>	
        internal void GetMetadataQueryWriter(out SharpDX.WIC.MetadataQueryWriter metadataQueryWriterOut) {
            unsafe {
                IntPtr metadataQueryWriterOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &metadataQueryWriterOut_,((void**)(*(void**)_nativePointer))[12]);		
                metadataQueryWriterOut= (metadataQueryWriterOut_ == IntPtr.Zero)?null:new SharpDX.WIC.MetadataQueryWriter(metadataQueryWriterOut_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods that provide information about an encoder.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoderInfo']/*"/>	
    /// <msdn-id>ee690112</msdn-id>	
    /// <unmanaged>IWICBitmapEncoderInfo</unmanaged>	
    /// <unmanaged-short>IWICBitmapEncoderInfo</unmanaged-short>	
    [Guid("94C9B4EE-A09F-4f92-8A1E-4A9BCE7E76FB")]
    public partial class BitmapEncoderInfo : SharpDX.WIC.BitmapCodecInfo {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.BitmapEncoderInfo"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapEncoderInfo(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.BitmapEncoderInfo"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.BitmapEncoderInfo(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.BitmapEncoderInfo(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Creates a new <strong><see cref="SharpDX.WIC.BitmapEncoder"/></strong> instance.</p>	
        /// </summary>	
        /// <param name="bitmapEncoderOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapEncoderInfo::CreateInstance']/*"/>	
        /// <msdn-id>ee690113</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapEncoderInfo::CreateInstance([Out] IWICBitmapEncoder** ppIBitmapEncoder)</unmanaged>	
        /// <unmanaged-short>IWICBitmapEncoderInfo::CreateInstance</unmanaged-short>	
        public void CreateInstance(out SharpDX.WIC.BitmapEncoder bitmapEncoderOut) {
            unsafe {
                IntPtr bitmapEncoderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &bitmapEncoderOut_,((void**)(*(void**)_nativePointer))[23]);		
                bitmapEncoderOut= (bitmapEncoderOut_ == IntPtr.Zero)?null:new SharpDX.WIC.BitmapEncoder(bitmapEncoderOut_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods that produce a flipped (horizontal or vertical) and/or rotated (by 90 degree increments) bitmap source. Rotations are done before the flip.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>IWICBitmapFipRotator requests data on a per-pixel basis, while WIC codecs provide data on a per-scanline basis. This causes the fliprotator object to exhibit n2 behavior if there is no buffering.  This occures because each pixel in the transformed image requires an entire scanline to be decoded in the file. It is recommended that you buffer the image using <strong><see cref="SharpDX.WIC.Bitmap"/></strong>, or flip/rotate the image using Direct2D.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFlipRotator']/*"/>	
    /// <msdn-id>ee690131</msdn-id>	
    /// <unmanaged>IWICBitmapFlipRotator</unmanaged>	
    /// <unmanaged-short>IWICBitmapFlipRotator</unmanaged-short>	
    [Guid("5009834F-2D6A-41ce-9E1B-17C5AFF7A782")]
    public partial class BitmapFlipRotator : SharpDX.WIC.BitmapSource {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.BitmapFlipRotator"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapFlipRotator(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.BitmapFlipRotator"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.BitmapFlipRotator(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.BitmapFlipRotator(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Initializes the bitmap flip rotator with the provided parameters.</p>	
        /// </summary>	
        /// <param name="sourceRef"><dd>  <p>The input bitmap source.</p> </dd></param>	
        /// <param name="options"><dd>  <p>The <strong><see cref="SharpDX.WIC.BitmapTransformOptions"/></strong> to flip or rotate the image.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFlipRotator::Initialize']/*"/>	
        /// <msdn-id>ee690132</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFlipRotator::Initialize([In, Optional] IWICBitmapSource* pISource,[In] WICBitmapTransformOptions options)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFlipRotator::Initialize</unmanaged-short>	
        public void Initialize(SharpDX.WIC.BitmapSource sourceRef, SharpDX.WIC.BitmapTransformOptions options) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((sourceRef == null)?IntPtr.Zero:sourceRef.NativePointer), unchecked((int)options),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Defines methods for decoding individual image frames of an encoded file.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameDecode']/*"/>	
    /// <msdn-id>ee690134</msdn-id>	
    /// <unmanaged>IWICBitmapFrameDecode</unmanaged>	
    /// <unmanaged-short>IWICBitmapFrameDecode</unmanaged-short>	
    [Guid("3B16811B-6A43-4ec9-A813-3D930C13B940")]
    public partial class BitmapFrameDecode : SharpDX.WIC.BitmapSource {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.BitmapFrameDecode"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapFrameDecode(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.BitmapFrameDecode"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.BitmapFrameDecode(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.BitmapFrameDecode(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves a metadata query reader for the frame.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>For image formats with one frame (JPG, PNG, JPEG-XR), the frame-level query reader of the first frame is used to access all image metadata, and the decoder-level query reader isn?t used. For formats with more than one frame (GIF, TIFF), the frame-level query reader for a given frame is used to access metadata specific to that frame, and in the case of GIF a decoder-level metadata reader will be present. If the decoder doesn?t support metadata (BMP, ICO), this will return <see cref="SharpDX.WIC.ResultCode.UnsupportedOperation"/>.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameDecode::GetMetadataQueryReader']/*"/>	
        /// <msdn-id>ee690137</msdn-id>	
        /// <unmanaged>GetMetadataQueryReader</unmanaged>	
        /// <unmanaged-short>GetMetadataQueryReader</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapFrameDecode::GetMetadataQueryReader([Out] IWICMetadataQueryReader** ppIMetadataQueryReader)</unmanaged>
        public SharpDX.WIC.MetadataQueryReader MetadataQueryReader {
                get { SharpDX.WIC.MetadataQueryReader __output__; GetMetadataQueryReader(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves a small preview of the frame, if supported by the codec.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Not all formats support thumbnails. Joint Photographic Experts Group (JPEG), Tagged Image File Format (TIFF), and Microsoft?Windows Digital Photo (WDP) support thumbnails.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameDecode::GetThumbnail']/*"/>	
        /// <msdn-id>ee690139</msdn-id>	
        /// <unmanaged>GetThumbnail</unmanaged>	
        /// <unmanaged-short>GetThumbnail</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapFrameDecode::GetThumbnail([Out] IWICBitmapSource** ppIThumbnail)</unmanaged>
        public SharpDX.WIC.BitmapSource Thumbnail {
                get { SharpDX.WIC.BitmapSource __output__; GetThumbnail(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves a metadata query reader for the frame.</p>	
        /// </summary>	
        /// <param name="metadataQueryReaderOut"><dd>  <p>When this method returns, contains a reference to the frame's metadata query reader.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>For image formats with one frame (JPG, PNG, JPEG-XR), the frame-level query reader of the first frame is used to access all image metadata, and the decoder-level query reader isn?t used. For formats with more than one frame (GIF, TIFF), the frame-level query reader for a given frame is used to access metadata specific to that frame, and in the case of GIF a decoder-level metadata reader will be present. If the decoder doesn?t support metadata (BMP, ICO), this will return <see cref="SharpDX.WIC.ResultCode.UnsupportedOperation"/>.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameDecode::GetMetadataQueryReader']/*"/>	
        /// <msdn-id>ee690137</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameDecode::GetMetadataQueryReader([Out] IWICMetadataQueryReader** ppIMetadataQueryReader)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameDecode::GetMetadataQueryReader</unmanaged-short>	
        internal void GetMetadataQueryReader(out SharpDX.WIC.MetadataQueryReader metadataQueryReaderOut) {
            unsafe {
                IntPtr metadataQueryReaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &metadataQueryReaderOut_,((void**)(*(void**)_nativePointer))[8]);		
                metadataQueryReaderOut= (metadataQueryReaderOut_ == IntPtr.Zero)?null:new SharpDX.WIC.MetadataQueryReader(metadataQueryReaderOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the <strong><see cref="SharpDX.WIC.ColorContext"/></strong> associated with the image frame.</p>	
        /// </summary>	
        /// <param name="count">No documentation.</param>	
        /// <param name="colorContextsOut">No documentation.</param>	
        /// <param name="actualCountRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If <c>null</c> is passed for <em>ppIColorContexts</em>, and 0 is passed for <em>cCount</em>, this method will return the total number of color contexts in the image in <em>pcActualCount</em>. </p><p>The <em>ppIColorContexts</em> array must be filled with valid data: each <strong><see cref="SharpDX.WIC.ColorContext"/>*</strong> in the array must have been created using <strong><see cref="SharpDX.WIC.ImagingFactory.CreateColorContext"/></strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameDecode::GetColorContexts']/*"/>	
        /// <msdn-id>ee690135</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameDecode::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameDecode::GetColorContexts</unmanaged-short>	
        internal SharpDX.Result GetColorContexts(int count, SharpDX.WIC.ColorContext[] colorContextsOut, out int actualCountRef) {
            unsafe {
                IntPtr* colorContextsOut_ = (IntPtr*)0;
                if ( colorContextsOut != null ) {
                    IntPtr* colorContextsOut__ = stackalloc IntPtr[colorContextsOut.Length];
                    colorContextsOut_ = colorContextsOut__;
                    for (int i = 0; i < colorContextsOut.Length; i++)                        
                        colorContextsOut_[i] =  (colorContextsOut[i] == null)? IntPtr.Zero : colorContextsOut[i].NativePointer;
                }
                SharpDX.Result __result__;
                fixed (void* actualCountRef_ = &actualCountRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, count, colorContextsOut_, actualCountRef_,((void**)(*(void**)_nativePointer))[9]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the <strong><see cref="SharpDX.WIC.ColorContext"/></strong> associated with the image frame.</p>	
        /// </summary>	
        /// <param name="count">No documentation.</param>	
        /// <param name="colorContextsOut">No documentation.</param>	
        /// <param name="actualCountRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If <c>null</c> is passed for <em>ppIColorContexts</em>, and 0 is passed for <em>cCount</em>, this method will return the total number of color contexts in the image in <em>pcActualCount</em>. </p><p>The <em>ppIColorContexts</em> array must be filled with valid data: each <strong><see cref="SharpDX.WIC.ColorContext"/>*</strong> in the array must have been created using <strong><see cref="SharpDX.WIC.ImagingFactory.CreateColorContext"/></strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameDecode::GetColorContexts']/*"/>	
        /// <msdn-id>ee690135</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameDecode::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameDecode::GetColorContexts</unmanaged-short>	
        internal SharpDX.Result GetColorContexts(int count, SharpDX.ComArray<SharpDX.WIC.ColorContext> colorContextsOut, out int actualCountRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* actualCountRef_ = &actualCountRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, count, (void*)((colorContextsOut == null)?IntPtr.Zero:colorContextsOut.NativePointer), actualCountRef_,((void**)(*(void**)_nativePointer))[9]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the <strong><see cref="SharpDX.WIC.ColorContext"/></strong> associated with the image frame.</p>	
        /// </summary>	
        /// <param name="count">No documentation.</param>	
        /// <param name="colorContextsOut">No documentation.</param>	
        /// <param name="actualCountRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If <c>null</c> is passed for <em>ppIColorContexts</em>, and 0 is passed for <em>cCount</em>, this method will return the total number of color contexts in the image in <em>pcActualCount</em>. </p><p>The <em>ppIColorContexts</em> array must be filled with valid data: each <strong><see cref="SharpDX.WIC.ColorContext"/>*</strong> in the array must have been created using <strong><see cref="SharpDX.WIC.ImagingFactory.CreateColorContext"/></strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameDecode::GetColorContexts']/*"/>	
        /// <msdn-id>ee690135</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameDecode::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameDecode::GetColorContexts</unmanaged-short>	
        private SharpDX.Result GetColorContexts(int count, System.IntPtr colorContextsOut, System.IntPtr actualCountRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, count, (void*)colorContextsOut, (void*)actualCountRef,((void**)(*(void**)_nativePointer))[9]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a small preview of the frame, if supported by the codec.</p>	
        /// </summary>	
        /// <param name="thumbnailOut"><dd>  <p>A reference that receives a reference to the <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> of the thumbnail.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Not all formats support thumbnails. Joint Photographic Experts Group (JPEG), Tagged Image File Format (TIFF), and Microsoft?Windows Digital Photo (WDP) support thumbnails.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameDecode::GetThumbnail']/*"/>	
        /// <msdn-id>ee690139</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameDecode::GetThumbnail([Out] IWICBitmapSource** ppIThumbnail)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameDecode::GetThumbnail</unmanaged-short>	
        internal void GetThumbnail(out SharpDX.WIC.BitmapSource thumbnailOut) {
            unsafe {
                IntPtr thumbnailOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &thumbnailOut_,((void**)(*(void**)_nativePointer))[10]);		
                thumbnailOut= (thumbnailOut_ == IntPtr.Zero)?null:new SharpDX.WIC.BitmapSource(thumbnailOut_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents an encoder's individual image frames.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode']/*"/>	
    /// <msdn-id>ee690141</msdn-id>	
    /// <unmanaged>IWICBitmapFrameEncode</unmanaged>	
    /// <unmanaged-short>IWICBitmapFrameEncode</unmanaged-short>	
    [Guid("00000105-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class BitmapFrameEncode : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.BitmapFrameEncode"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapFrameEncode(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.BitmapFrameEncode"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.BitmapFrameEncode(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.BitmapFrameEncode(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets the <strong><see cref="SharpDX.WIC.Palette"/></strong> for indexed pixel formats.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method doesn't fail if called on a frame whose pixel format is set to a non-indexed pixel format. If the target pixel format is a non-indexed format, the palette will be ignored.</p><p>If you already called <strong><see cref="SharpDX.WIC.BitmapEncoder.SetPalette"/></strong> to set a global palette, this method overrides that palette for the current frame.</p><p>The palette must be specified before your first call to <strong>WritePixels</strong>/<strong>WriteSource</strong>. Doing so will cause <strong>WriteSource</strong> to use the specified palette when converting the source image to the encoder pixel format. If no palette is specified, a palette will be generated on the first call to <strong>WriteSource</strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::SetPalette']/*"/>	
        /// <msdn-id>ee690150</msdn-id>	
        /// <unmanaged>SetPalette</unmanaged>	
        /// <unmanaged-short>SetPalette</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>
        public SharpDX.WIC.Palette Palette {
                set { SetPalette(value); }
        }
        
        /// <summary>	
        /// <p>Sets the frame thumbnail if supported by the codec.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>We recommend that you call <strong>SetThumbnail</strong> before calling <strong>WritePixels</strong> or <strong>WriteSource</strong>. The thumbnail won't be added to the encoded file if <strong>SetThumbnail</strong> is called after a call to <strong>WritePixels</strong> or <strong>WriteSource</strong>. </p><ul> <li><strong>BMP, PNG</strong><p>Setting thumbnails is unsupported. This function will return <strong><see cref="SharpDX.WIC.ResultCode.UnsupportedOperation"/></strong>.</p> </li> <li><strong>JPEG</strong><p>Setting the thumbnail is supported. The source image will be re-encoded as either an 8bpp or 24bpp JPEG and will be written to the JPEG?s APP1 metadata block.	
        /// </p> </li> <li><strong>TIFF</strong><p> Setting the thumbnail is supported. The source image will be re-encoded as a TIFF and will be written to the frame?s SubIFD block.</p> </li> <li><strong>JPEG-XR</strong><p>Setting the thumbnail is supported. The source image will be re-encoded as an additional 8bpp or 24bpp frame.	
        /// </p> </li> </ul>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::SetThumbnail']/*"/>	
        /// <msdn-id>ee690156</msdn-id>	
        /// <unmanaged>SetThumbnail</unmanaged>	
        /// <unmanaged-short>SetThumbnail</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetThumbnail([In, Optional] IWICBitmapSource* pIThumbnail)</unmanaged>
        public SharpDX.WIC.BitmapSource Thumbnail {
                set { SetThumbnail(value); }
        }
        
        /// <summary>	
        /// <p>Gets the metadata query writer for the encoder frame.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If you are setting metadata on the frame, you must do this before you use <strong><see cref="SharpDX.WIC.BitmapFrameEncode.WritePixels"/></strong> or <strong><see cref="SharpDX.WIC.BitmapFrameEncode.WriteSource"/></strong> to write any image pixels to the frame</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::GetMetadataQueryWriter']/*"/>	
        /// <msdn-id>ee690144</msdn-id>	
        /// <unmanaged>GetMetadataQueryWriter</unmanaged>	
        /// <unmanaged-short>GetMetadataQueryWriter</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::GetMetadataQueryWriter([Out] IWICMetadataQueryWriter** ppIMetadataQueryWriter)</unmanaged>
        public SharpDX.WIC.MetadataQueryWriter MetadataQueryWriter {
                get { SharpDX.WIC.MetadataQueryWriter __output__; GetMetadataQueryWriter(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Initializes the frame encoder using the given properties.</p>	
        /// </summary>	
        /// <param name="encoderOptionsRef"><dd>  <p>The set of properties to use for <strong><see cref="SharpDX.WIC.BitmapFrameEncode"/></strong> initialization.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If you don't want any encoding options, pass <strong><c>null</c></strong> for <em>pIEncoderOptions</em>. Otherwise, pass the <see cref="SharpDX.Win32.PropertyBag"/> that was provided by <strong><see cref="SharpDX.WIC.BitmapEncoder.CreateNewFrame"/></strong> with updated values.	
        /// </p><p>For a complete list of encoding options supported by the Windows-provided codecs, see Native WIC Codecs. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::Initialize']/*"/>	
        /// <msdn-id>ee690146</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::Initialize([In, Optional] IPropertyBag2* pIEncoderOptions)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameEncode::Initialize</unmanaged-short>	
        internal void Initialize(SharpDX.Win32.PropertyBag encoderOptionsRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((encoderOptionsRef == null)?IntPtr.Zero:encoderOptionsRef.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the output image dimensions for the frame.</p>	
        /// </summary>	
        /// <param name="width"><dd>  <p>The width of the output image.</p> </dd></param>	
        /// <param name="height"><dd>  <p>The height of the output image.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::SetSize']/*"/>	
        /// <msdn-id>ee690154</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetSize([In] unsigned int uiWidth,[In] unsigned int uiHeight)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameEncode::SetSize</unmanaged-short>	
        public void SetSize(int width, int height) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, width, height,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the physical resolution of the output image.</p>	
        /// </summary>	
        /// <param name="dpiX"><dd>  <p>The horizontal resolution value.</p> </dd></param>	
        /// <param name="dpiY"><dd>  <p>The vertical resolution value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Windows Imaging Component (WIC) doesn't perform any special processing as a result of DPI resolution values. For example, data returned from <strong><see cref="SharpDX.WIC.BitmapSource.CopyPixels"/></strong> isn't scaled by the DPI. The app must handle DPI resolution.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::SetResolution']/*"/>	
        /// <msdn-id>ee690152</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetResolution([In] double dpiX,[In] double dpiY)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameEncode::SetResolution</unmanaged-short>	
        public void SetResolution(double dpiX, double dpiY) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, dpiX, dpiY,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Requests that the encoder use the specified pixel format.</p>	
        /// </summary>	
        /// <param name="pixelFormatRef"><dd>  <p>On input, the requested pixel format <see cref="System.Guid"/>. On output, the closest pixel format <see cref="System.Guid"/> supported by the encoder; this may be different than the requested format. For a list of pixel format GUIDs, see Native Pixel Formats.</p> </dd></param>	
        /// <returns><p>Possible return values include the following.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.WIC.ResultCode.WrongState"/></strong></dt> </dl> </td><td> <p>The <strong><see cref="SharpDX.WIC.BitmapFrameEncode.Initialize"/></strong> method was not called.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::SetPixelFormat']/*"/>	
        /// <msdn-id>ee690151</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetPixelFormat([InOut] GUID* pPixelFormat)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameEncode::SetPixelFormat</unmanaged-short>	
        public void SetPixelFormat(ref System.Guid pixelFormatRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* pixelFormatRef_ = &pixelFormatRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, pixelFormatRef_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a given number <strong><see cref="SharpDX.WIC.ColorContext"/></strong> profiles to the frame.</p>	
        /// </summary>	
        /// <param name="count">No documentation.</param>	
        /// <param name="colorContextOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <ul> <li><strong>BMP</strong><p>Setting color contexts is unsupported. This function will return <strong><see cref="SharpDX.WIC.ResultCode.UnsupportedOperation"/></strong>.</p> </li> <li><strong>PNG</strong><p>Setting at most one color context is supported, and additional color contexts will be ignored. This context must be a <strong><see cref="SharpDX.WIC.ColorContextType.Profile"/></strong>, and is used to encode the iCCP, gAMA, and cHRM chunks in the PNG file.</p> </li> <li><strong>JPEG, TIFF, JPEG-XR</strong><p>Setting up to one <strong><see cref="SharpDX.WIC.ColorContextType.Profile"/></strong> and one  <strong><see cref="SharpDX.WIC.ColorContextType.ExifColorSpace"/></strong> is supported. Users must not provide more than one of each type of color context, as all but the last context of each type will be ignored. In JPEG, the <strong><see cref="SharpDX.WIC.ColorContextType.Profile"/></strong> is encoded to JPEG APP2 ICC metadata block.</p> <p>In TIFF and JPEG-XR, the  <strong><see cref="SharpDX.WIC.ColorContextType.Profile"/></strong> is encoded to the IFD ICC profile metadata block (IFD tag 0x8773). In all three formats, the <strong><see cref="SharpDX.WIC.ColorContextType.ExifColorSpace"/></strong> is encoded to EXIF colorspace metadata block (EXIF tag 0xA001).	
        /// </p> </li> </ul>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::SetColorContexts']/*"/>	
        /// <msdn-id>ee690148</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameEncode::SetColorContexts</unmanaged-short>	
        internal void SetColorContexts(int count, SharpDX.WIC.ColorContext[] colorContextOut) {
            unsafe {
                IntPtr* colorContextOut_ = (IntPtr*)0;
                if ( colorContextOut != null ) {
                    IntPtr* colorContextOut__ = stackalloc IntPtr[colorContextOut.Length];
                    colorContextOut_ = colorContextOut__;
                    for (int i = 0; i < colorContextOut.Length; i++)                        
                        colorContextOut_[i] =  (colorContextOut[i] == null)? IntPtr.Zero : colorContextOut[i].NativePointer;
                }
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, count, colorContextOut_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a given number <strong><see cref="SharpDX.WIC.ColorContext"/></strong> profiles to the frame.</p>	
        /// </summary>	
        /// <param name="count">No documentation.</param>	
        /// <param name="colorContextOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <ul> <li><strong>BMP</strong><p>Setting color contexts is unsupported. This function will return <strong><see cref="SharpDX.WIC.ResultCode.UnsupportedOperation"/></strong>.</p> </li> <li><strong>PNG</strong><p>Setting at most one color context is supported, and additional color contexts will be ignored. This context must be a <strong><see cref="SharpDX.WIC.ColorContextType.Profile"/></strong>, and is used to encode the iCCP, gAMA, and cHRM chunks in the PNG file.</p> </li> <li><strong>JPEG, TIFF, JPEG-XR</strong><p>Setting up to one <strong><see cref="SharpDX.WIC.ColorContextType.Profile"/></strong> and one  <strong><see cref="SharpDX.WIC.ColorContextType.ExifColorSpace"/></strong> is supported. Users must not provide more than one of each type of color context, as all but the last context of each type will be ignored. In JPEG, the <strong><see cref="SharpDX.WIC.ColorContextType.Profile"/></strong> is encoded to JPEG APP2 ICC metadata block.</p> <p>In TIFF and JPEG-XR, the  <strong><see cref="SharpDX.WIC.ColorContextType.Profile"/></strong> is encoded to the IFD ICC profile metadata block (IFD tag 0x8773). In all three formats, the <strong><see cref="SharpDX.WIC.ColorContextType.ExifColorSpace"/></strong> is encoded to EXIF colorspace metadata block (EXIF tag 0xA001).	
        /// </p> </li> </ul>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::SetColorContexts']/*"/>	
        /// <msdn-id>ee690148</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameEncode::SetColorContexts</unmanaged-short>	
        internal void SetColorContexts(int count, SharpDX.ComArray<SharpDX.WIC.ColorContext> colorContextOut) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, count, (void*)((colorContextOut == null)?IntPtr.Zero:colorContextOut.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a given number <strong><see cref="SharpDX.WIC.ColorContext"/></strong> profiles to the frame.</p>	
        /// </summary>	
        /// <param name="count">No documentation.</param>	
        /// <param name="colorContextOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <ul> <li><strong>BMP</strong><p>Setting color contexts is unsupported. This function will return <strong><see cref="SharpDX.WIC.ResultCode.UnsupportedOperation"/></strong>.</p> </li> <li><strong>PNG</strong><p>Setting at most one color context is supported, and additional color contexts will be ignored. This context must be a <strong><see cref="SharpDX.WIC.ColorContextType.Profile"/></strong>, and is used to encode the iCCP, gAMA, and cHRM chunks in the PNG file.</p> </li> <li><strong>JPEG, TIFF, JPEG-XR</strong><p>Setting up to one <strong><see cref="SharpDX.WIC.ColorContextType.Profile"/></strong> and one  <strong><see cref="SharpDX.WIC.ColorContextType.ExifColorSpace"/></strong> is supported. Users must not provide more than one of each type of color context, as all but the last context of each type will be ignored. In JPEG, the <strong><see cref="SharpDX.WIC.ColorContextType.Profile"/></strong> is encoded to JPEG APP2 ICC metadata block.</p> <p>In TIFF and JPEG-XR, the  <strong><see cref="SharpDX.WIC.ColorContextType.Profile"/></strong> is encoded to the IFD ICC profile metadata block (IFD tag 0x8773). In all three formats, the <strong><see cref="SharpDX.WIC.ColorContextType.ExifColorSpace"/></strong> is encoded to EXIF colorspace metadata block (EXIF tag 0xA001).	
        /// </p> </li> </ul>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::SetColorContexts']/*"/>	
        /// <msdn-id>ee690148</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameEncode::SetColorContexts</unmanaged-short>	
        private void SetColorContexts(int count, System.IntPtr colorContextOut) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, count, (void*)colorContextOut,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the <strong><see cref="SharpDX.WIC.Palette"/></strong> for indexed pixel formats.</p>	
        /// </summary>	
        /// <param name="paletteRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method doesn't fail if called on a frame whose pixel format is set to a non-indexed pixel format. If the target pixel format is a non-indexed format, the palette will be ignored.</p><p>If you already called <strong><see cref="SharpDX.WIC.BitmapEncoder.SetPalette"/></strong> to set a global palette, this method overrides that palette for the current frame.</p><p>The palette must be specified before your first call to <strong>WritePixels</strong>/<strong>WriteSource</strong>. Doing so will cause <strong>WriteSource</strong> to use the specified palette when converting the source image to the encoder pixel format. If no palette is specified, a palette will be generated on the first call to <strong>WriteSource</strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::SetPalette']/*"/>	
        /// <msdn-id>ee690150</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameEncode::SetPalette</unmanaged-short>	
        internal void SetPalette(SharpDX.WIC.Palette paletteRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((paletteRef == null)?IntPtr.Zero:paletteRef.NativePointer),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the frame thumbnail if supported by the codec.</p>	
        /// </summary>	
        /// <param name="thumbnailRef"><dd>  <p>The bitmap source to use as the thumbnail.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if successful, or an error value otherwise. </p><p>Returns <see cref="SharpDX.WIC.ResultCode.UnsupportedOperation"/> if the feature is not supported by the encoder.</p></returns>	
        /// <remarks>	
        /// <p>We recommend that you call <strong>SetThumbnail</strong> before calling <strong>WritePixels</strong> or <strong>WriteSource</strong>. The thumbnail won't be added to the encoded file if <strong>SetThumbnail</strong> is called after a call to <strong>WritePixels</strong> or <strong>WriteSource</strong>. </p><ul> <li><strong>BMP, PNG</strong><p>Setting thumbnails is unsupported. This function will return <strong><see cref="SharpDX.WIC.ResultCode.UnsupportedOperation"/></strong>.</p> </li> <li><strong>JPEG</strong><p>Setting the thumbnail is supported. The source image will be re-encoded as either an 8bpp or 24bpp JPEG and will be written to the JPEG?s APP1 metadata block.	
        /// </p> </li> <li><strong>TIFF</strong><p> Setting the thumbnail is supported. The source image will be re-encoded as a TIFF and will be written to the frame?s SubIFD block.</p> </li> <li><strong>JPEG-XR</strong><p>Setting the thumbnail is supported. The source image will be re-encoded as an additional 8bpp or 24bpp frame.	
        /// </p> </li> </ul>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::SetThumbnail']/*"/>	
        /// <msdn-id>ee690156</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::SetThumbnail([In, Optional] IWICBitmapSource* pIThumbnail)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameEncode::SetThumbnail</unmanaged-short>	
        internal void SetThumbnail(SharpDX.WIC.BitmapSource thumbnailRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((thumbnailRef == null)?IntPtr.Zero:thumbnailRef.NativePointer),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="lineCount">No documentation.</param>	
        /// <param name="stride">No documentation.</param>	
        /// <param name="bufferSize">No documentation.</param>	
        /// <param name="pixelsRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::WritePixels']/*"/>	
        /// <msdn-id>ee719895</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::WritePixels([In] unsigned int lineCount,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In, Buffer] void* pbPixels)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameEncode::WritePixels</unmanaged-short>	
        internal void WritePixels(int lineCount, int stride, int bufferSize, System.IntPtr pixelsRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, lineCount, stride, bufferSize, (void*)pixelsRef,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Encodes a bitmap source.</p>	
        /// </summary>	
        /// <param name="bitmapSourceRef"><dd>  <p>The bitmap source to encode.</p> </dd></param>	
        /// <param name="rectangleRef"><dd>  <p>The size rectangle of the bitmap source.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If <strong>SetSize</strong> is not called prior to calling <strong>WriteSource</strong>, the size given in <em>prc</em> is used if not <strong><c>null</c></strong>. Otherwise, the size of the <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> given in <em>pIBitmapSource</em> is used. </p><p>If <strong>SetPixelFormat</strong> is not called prior to calling <strong>WriteSource</strong>, the pixel format of the <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> given in <em>pIBitmapSource</em> is used.</p><p>If <strong>SetResolution</strong> is not called prior to calling <strong>WriteSource</strong>, the pixel format of <em>pIBitmapSource</em> is used.</p><p>If <strong>SetPalette</strong> is not called prior to calling <strong>WriteSource</strong>, the target pixel format is indexed, and the pixel format of <em>pIBitmapSource</em> matches the encoder frame's pixel format, then the <em>pIBitmapSource</em> pixel format is used.</p><p>When encoding a GIF image, if the global palette is set and the frame level palette is not set directly by the user or by a custom independent software vendor (ISV) GIF codec, <strong>WriteSource</strong> will use the global palette to encode the frame even when <em>pIBitmapSource</em> has a frame level palette.</p><p>Starting with  Windows?Vista, repeated <strong>WriteSource</strong> calls can be made as long as the total accumulated source rect height is the same as set through <strong>SetSize</strong>.</p><p>Starting with Windows?8.1, the source rect must be at least the dimensions set through <strong>SetSize</strong>. If the source rect width exceeds the <strong>SetSize</strong> width, extra pixels on the right side are ignored. If the source rect height exceeds the remaining unfilled height, extra scan lines on the bottom are ignored.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::WriteSource']/*"/>	
        /// <msdn-id>ee690159</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::WriteSource([In, Optional] IWICBitmapSource* pIBitmapSource,[In] void* prc)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameEncode::WriteSource</unmanaged-short>	
        internal void WriteSource(SharpDX.WIC.BitmapSource bitmapSourceRef, System.IntPtr rectangleRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((bitmapSourceRef == null)?IntPtr.Zero:bitmapSourceRef.NativePointer), (void*)rectangleRef,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Commits the frame to the image.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>After the frame <strong>Commit</strong> has been called, you can't use or reinitialize the <strong><see cref="SharpDX.WIC.BitmapFrameEncode"/></strong> object and any objects created from it.	
        /// </p><p>To finalize the image, both the frame <strong>Commit</strong> and the encoder <strong>Commit</strong> must be called. However, only call the encoder  <strong>Commit</strong> method after all frames have been committed.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::Commit']/*"/>	
        /// <msdn-id>ee690142</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::Commit()</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameEncode::Commit</unmanaged-short>	
        public void Commit() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the metadata query writer for the encoder frame.</p>	
        /// </summary>	
        /// <param name="metadataQueryWriterOut"><dd>  <p>When this method returns, contains a reference to metadata query writer for the encoder frame.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If you are setting metadata on the frame, you must do this before you use <strong><see cref="SharpDX.WIC.BitmapFrameEncode.WritePixels"/></strong> or <strong><see cref="SharpDX.WIC.BitmapFrameEncode.WriteSource"/></strong> to write any image pixels to the frame</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapFrameEncode::GetMetadataQueryWriter']/*"/>	
        /// <msdn-id>ee690144</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapFrameEncode::GetMetadataQueryWriter([Out] IWICMetadataQueryWriter** ppIMetadataQueryWriter)</unmanaged>	
        /// <unmanaged-short>IWICBitmapFrameEncode::GetMetadataQueryWriter</unmanaged-short>	
        internal void GetMetadataQueryWriter(out SharpDX.WIC.MetadataQueryWriter metadataQueryWriterOut) {
            unsafe {
                IntPtr metadataQueryWriterOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &metadataQueryWriterOut_,((void**)(*(void**)_nativePointer))[13]);		
                metadataQueryWriterOut= (metadataQueryWriterOut_ == IntPtr.Zero)?null:new SharpDX.WIC.MetadataQueryWriter(metadataQueryWriterOut_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods that support the <strong>Lock</strong> method.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The bitmap lock is simply an abstraction for a rectangular memory window into the bitmap. For the simplest case, a system memory bitmap, this is simply a reference to the top left corner of the rectangle and a stride value.</p><p>To release the exclusive lock set by <strong>Lock</strong> method and the associated <strong><see cref="SharpDX.WIC.BitmapLock"/></strong> object, call IUnknown::Release on the <strong><see cref="SharpDX.WIC.BitmapLock"/></strong> object.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapLock']/*"/>	
    /// <msdn-id>ee690161</msdn-id>	
    /// <unmanaged>IWICBitmapLock</unmanaged>	
    /// <unmanaged-short>IWICBitmapLock</unmanaged-short>	
    [Guid("00000123-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class BitmapLock : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.BitmapLock"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapLock(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.BitmapLock"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.BitmapLock(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.BitmapLock(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Provides access to the stride value for the memory.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> Note the stride value is specific to the <strong><see cref="SharpDX.WIC.BitmapLock"/></strong>, not the bitmap.  For example, two consecutive locks on the same rectangle of a bitmap may return different references and stride values, depending on internal implementation.  </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapLock::GetStride']/*"/>	
        /// <msdn-id>ee690166</msdn-id>	
        /// <unmanaged>GetStride</unmanaged>	
        /// <unmanaged-short>GetStride</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapLock::GetStride([Out] unsigned int* pcbStride)</unmanaged>
        public int Stride {
                get { int __output__; GetStride(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the pixel format of for the locked area of pixels. This can be used to compute the number of bytes-per-pixel in the locked area.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapLock::GetPixelFormat']/*"/>	
        /// <msdn-id>ee690164</msdn-id>	
        /// <unmanaged>GetPixelFormat</unmanaged>	
        /// <unmanaged-short>GetPixelFormat</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapLock::GetPixelFormat([Out] GUID* pPixelFormat)</unmanaged>
        public System.Guid PixelFormat {
                get { System.Guid __output__; GetPixelFormat(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the width and height, in pixels, of the locked rectangle.</p>	
        /// </summary>	
        /// <param name="widthRef"><dd>  <p>A reference that receives the width of the locked rectangle.</p> </dd></param>	
        /// <param name="heightRef"><dd>  <p>A reference that receives the height of the locked rectangle.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapLock::GetSize']/*"/>	
        /// <msdn-id>ee690165</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapLock::GetSize([Out] unsigned int* puiWidth,[Out] unsigned int* puiHeight)</unmanaged>	
        /// <unmanaged-short>IWICBitmapLock::GetSize</unmanaged-short>	
        internal void GetSize(out int widthRef, out int heightRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* widthRef_ = &widthRef)
                    fixed (void* heightRef_ = &heightRef)
                        __result__= 
        				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, widthRef_, heightRef_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Provides access to the stride value for the memory.</p>	
        /// </summary>	
        /// <param name="strideRef"><dd>  </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Note the stride value is specific to the <strong><see cref="SharpDX.WIC.BitmapLock"/></strong>, not the bitmap.  For example, two consecutive locks on the same rectangle of a bitmap may return different references and stride values, depending on internal implementation.  </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapLock::GetStride']/*"/>	
        /// <msdn-id>ee690166</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapLock::GetStride([Out] unsigned int* pcbStride)</unmanaged>	
        /// <unmanaged-short>IWICBitmapLock::GetStride</unmanaged-short>	
        internal void GetStride(out int strideRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* strideRef_ = &strideRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, strideRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the reference to the top left pixel in the locked rectangle.</p>	
        /// </summary>	
        /// <param name="bufferSizeRef"><dd>  <p>A reference that receives the size of the buffer.</p> </dd></param>	
        /// <returns><dd>  <p>A reference that receives a reference to the top left pixel in the locked rectangle.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The reference provided by this method should not be used outside of the lifetime of the lock itself.</p><p><strong>GetDataPointer</strong> is not available in multi-threaded apartment applications.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapLock::GetDataPointer']/*"/>	
        /// <msdn-id>ee690162</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapLock::GetDataPointer([Out] unsigned int* pcbBufferSize,[Out] void** ppbData)</unmanaged>	
        /// <unmanaged-short>IWICBitmapLock::GetDataPointer</unmanaged-short>	
        internal System.IntPtr GetDataPointer(out int bufferSizeRef) {
            unsafe {
                System.IntPtr dataOut;
                SharpDX.Result __result__;
                fixed (void* bufferSizeRef_ = &bufferSizeRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, bufferSizeRef_, &dataOut,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
                return dataOut;
            }
        }
        
        /// <summary>	
        /// <p>Gets the pixel format of for the locked area of pixels. This can be used to compute the number of bytes-per-pixel in the locked area.</p>	
        /// </summary>	
        /// <param name="pixelFormatRef"><dd>  <p>A reference that receives the pixel format <see cref="System.Guid"/> of the locked area.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapLock::GetPixelFormat']/*"/>	
        /// <msdn-id>ee690164</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapLock::GetPixelFormat([Out] GUID* pPixelFormat)</unmanaged>	
        /// <unmanaged-short>IWICBitmapLock::GetPixelFormat</unmanaged-short>	
        internal void GetPixelFormat(out System.Guid pixelFormatRef) {
            unsafe {
                pixelFormatRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* pixelFormatRef_ = &pixelFormatRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, pixelFormatRef_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a resized version of the input bitmap using a resampling or filtering algorithm.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Images can be scaled to larger sizes; however, even with sophisticated scaling algorithms, there is only so much information in the image and artifacts tend to worsen the more you scale up.</p><p> The scaler will reapply the resampling algorithm every time <strong>CopyPixels</strong> is called.  If the scaled image is to be animated, the scaled image should be created once and cached in a new bitmap, after which the <strong><see cref="SharpDX.WIC.BitmapScaler"/></strong> may be released.  In this way the scaling algorithm - which may be computationally expensive relative to drawing - is performed only once and the result displayed many times. </p><p> The scaler is optimized to use the minimum amount of memory required to scale the image correctly.  The scaler may be used to produce parts of the image incrementally (banding) by calling <strong>CopyPixels</strong> with different rectangles representing the output bands of the image.  Resampling typically requires overlapping rectangles from the source image and thus may need to request the same pixels from the source bitmap multiple times.  Requesting scanlines out-of-order from some image decoders can have a significant performance penalty.  Because of this reason, the scaler is optimized to handle consecutive horizontal bands of scanlines (rectangle width equal to the bitmap width).  In this case the accumulator from the previous vertically adjacent rectangle is re-used to avoid duplicate scanline requests from the source.  This implies that banded output from the scaler may have better performance if the bands are requested sequentially.  Of course if the scaler is simply used to produce a single rectangle output, this concern is eliminated because the scaler will internally request scanlines in the correct order. </p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapScaler']/*"/>	
    /// <msdn-id>ee690168</msdn-id>	
    /// <unmanaged>IWICBitmapScaler</unmanaged>	
    /// <unmanaged-short>IWICBitmapScaler</unmanaged-short>	
    [Guid("00000302-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class BitmapScaler : SharpDX.WIC.BitmapSource {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.BitmapScaler"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapScaler(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.BitmapScaler"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.BitmapScaler(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.BitmapScaler(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Initializes the bitmap scaler with the provided parameters.</p>	
        /// </summary>	
        /// <param name="sourceRef"><dd>  <p>The input bitmap source.</p> </dd></param>	
        /// <param name="width"><dd>  <p>The destination width.</p> </dd></param>	
        /// <param name="height"><dd>  <p>The desination height.</p> </dd></param>	
        /// <param name="mode"><dd>  <p>The <strong><see cref="SharpDX.WIC.BitmapInterpolationMode"/></strong> to use when scaling.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> <strong><see cref="SharpDX.WIC.BitmapScaler"/></strong> can't be initialized multiple times. For example, when scaling every frame in a multi-frame image, a new <strong><see cref="SharpDX.WIC.BitmapScaler"/></strong> must be created and initialized for each frame.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapScaler::Initialize']/*"/>	
        /// <msdn-id>ee690169</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapScaler::Initialize([In, Optional] IWICBitmapSource* pISource,[In] unsigned int uiWidth,[In] unsigned int uiHeight,[In] WICBitmapInterpolationMode mode)</unmanaged>	
        /// <unmanaged-short>IWICBitmapScaler::Initialize</unmanaged-short>	
        public void Initialize(SharpDX.WIC.BitmapSource sourceRef, int width, int height, SharpDX.WIC.BitmapInterpolationMode mode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((sourceRef == null)?IntPtr.Zero:sourceRef.NativePointer), width, height, unchecked((int)mode),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods that refers to a source from which pixels are retrieved, but cannot be written back to.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface provides a common way of accessing and linking together bitmaps, decoders, format converters, and scalers. Components that implement this interface can be connected together in a graph to pull imaging data through.</p><p>This interface defines only the notion of readability or being able to produce pixels. Modifying or writing to a bitmap is considered to be a specialization specific to bitmaps which have storage and is defined in the descendant interface <strong><see cref="SharpDX.WIC.Bitmap"/></strong>.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapSource']/*"/>	
    /// <msdn-id>ee690171</msdn-id>	
    /// <unmanaged>IWICBitmapSource</unmanaged>	
    /// <unmanaged-short>IWICBitmapSource</unmanaged-short>	
    [Guid("00000120-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class BitmapSource : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.BitmapSource"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapSource(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.BitmapSource"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.BitmapSource(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.BitmapSource(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the pixel format of the bitmap source.. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p> The pixel format returned by this method is not necessarily the pixel format the image is stored as. The codec may perform a format conversion from the storage pixel format to an output pixel format. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapSource::GetPixelFormat']/*"/>	
        /// <msdn-id>ee690181</msdn-id>	
        /// <unmanaged>GetPixelFormat</unmanaged>	
        /// <unmanaged-short>GetPixelFormat</unmanaged-short>	
        /// <unmanaged>HRESULT IWICBitmapSource::GetPixelFormat([Out] GUID* pPixelFormat)</unmanaged>
        public System.Guid PixelFormat {
                get { System.Guid __output__; GetPixelFormat(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the pixel width and height of the bitmap.</p>	
        /// </summary>	
        /// <param name="widthRef"><dd>  <p>A reference that receives the pixel width of the bitmap.</p> </dd></param>	
        /// <param name="heightRef"><dd>  <p>A reference that receives the pixel height of the bitmap</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapSource::GetSize']/*"/>	
        /// <msdn-id>ee690185</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapSource::GetSize([Out] unsigned int* puiWidth,[Out] unsigned int* puiHeight)</unmanaged>	
        /// <unmanaged-short>IWICBitmapSource::GetSize</unmanaged-short>	
        internal void GetSize(out int widthRef, out int heightRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* widthRef_ = &widthRef)
                    fixed (void* heightRef_ = &heightRef)
                        __result__= 
        				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, widthRef_, heightRef_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the pixel format of the bitmap source.. </p>	
        /// </summary>	
        /// <param name="pixelFormatRef"><dd>  <p>Receives the pixel format <see cref="System.Guid"/> the bitmap is stored in. For a list of available pixel formats, see the Native Pixel Formats topic.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The pixel format returned by this method is not necessarily the pixel format the image is stored as. The codec may perform a format conversion from the storage pixel format to an output pixel format. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapSource::GetPixelFormat']/*"/>	
        /// <msdn-id>ee690181</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapSource::GetPixelFormat([Out] GUID* pPixelFormat)</unmanaged>	
        /// <unmanaged-short>IWICBitmapSource::GetPixelFormat</unmanaged-short>	
        internal void GetPixelFormat(out System.Guid pixelFormatRef) {
            unsafe {
                pixelFormatRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* pixelFormatRef_ = &pixelFormatRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, pixelFormatRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the sampling rate between pixels and physical world measurements.</p>	
        /// </summary>	
        /// <param name="dpiXRef"><dd>  <p>A reference that receives the x-axis dpi resolution.</p> </dd></param>	
        /// <param name="dpiYRef"><dd>  <p>A reference that receives the y-axis dpi resolution.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Some formats, such as GIF and ICO, do not have full DPI support. For GIF, this method calculates the DPI values from the aspect ratio, using a base DPI of (96.0, 96.0). The ICO format does not support DPI at all, and the method always returns (96.0,96.0) for ICO images. </p><p> Additionally, WIC itself does not transform images based on the DPI values in an image. It is up to the caller to transform an image based on the resolution returned. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapSource::GetResolution']/*"/>	
        /// <msdn-id>ee690183</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapSource::GetResolution([Out] double* pDpiX,[Out] double* pDpiY)</unmanaged>	
        /// <unmanaged-short>IWICBitmapSource::GetResolution</unmanaged-short>	
        public void GetResolution(out double dpiXRef, out double dpiYRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dpiXRef_ = &dpiXRef)
                    fixed (void* dpiYRef_ = &dpiYRef)
                        __result__= 
        				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, dpiXRef_, dpiYRef_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the color table for indexed pixel formats.</p>	
        /// </summary>	
        /// <param name="paletteRef"><dd>  <p>An <strong><see cref="SharpDX.WIC.Palette"/></strong>. A palette can be created using the <strong>CreatePalette</strong> method.</p> </dd></param>	
        /// <returns><p>Returns one of the following values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.WIC.ResultCode.Paletteunavailable"/></strong></dt> </dl> </td><td> <p>The palette was unavailable.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The palette was successfully copied.</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p> If the <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> is an <strong><see cref="SharpDX.WIC.BitmapFrameDecode"/></strong>, the function may return the image's global palette if a frame-level palette is not available. The global palette may also be retrieved using the <strong>CopyPalette</strong> method. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapSource::CopyPalette']/*"/>	
        /// <msdn-id>ee690177</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapSource::CopyPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>	
        /// <unmanaged-short>IWICBitmapSource::CopyPalette</unmanaged-short>	
        public void CopyPalette(SharpDX.WIC.Palette paletteRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((paletteRef == null)?IntPtr.Zero:paletteRef.NativePointer),((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Instructs the object to produce pixels.</p>	
        /// </summary>	
        /// <param name="rectangleRef"><dd>  <p>The rectangle to copy. A <strong><c>null</c></strong> value specifies the entire bitmap.</p> </dd></param>	
        /// <param name="stride"><dd>  <p>The stride of the bitmap</p> </dd></param>	
        /// <param name="bufferSize"><dd>  <p>The size of the buffer.</p> </dd></param>	
        /// <param name="bufferRef"><dd>  <p>A reference to the buffer.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><strong>CopyPixels</strong> is one of the two main image processing routines (the other being <strong>Lock</strong>) triggering the actual processing.  It instructs the object to produce pixels according to its algorithm - this may involve decoding a portion of a JPEG stored on disk, copying a block of memory, or even analytically computing a complex gradient.  The algorithm is completely dependent on the object implementing the interface. </p><p> The caller can restrict the operation to a rectangle of interest (ROI) using the prc parameter.  The ROI sub-rectangle must be fully contained in the bounds of the bitmap.  Specifying a <strong><c>null</c></strong> ROI implies that the whole bitmap should be returned. 	
        /// </p><p> The caller controls the memory management and must provide an output buffer (<em>pbBuffer</em>) for the results of the copy along with the buffer's bounds (<em>cbBufferSize</em>).  The cbStride parameter defines the count of bytes between two vertically adjacent pixels in the output buffer.  The caller must ensure that there is sufficient buffer to complete the call based on the width, height and pixel format of the bitmap and the sub-rectangle provided to the copy method. </p><p> If the caller needs to perform numerous copies of an expensive <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> such as a JPEG, it is recommended to create an in-memory <strong><see cref="SharpDX.WIC.Bitmap"/></strong> first. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapSource::CopyPixels']/*"/>	
        /// <msdn-id>ee690179</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapSource::CopyPixels([In] const void* prc,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer)</unmanaged>	
        /// <unmanaged-short>IWICBitmapSource::CopyPixels</unmanaged-short>	
        internal void CopyPixels(System.IntPtr rectangleRef, int stride, int bufferSize, System.IntPtr bufferRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)rectangleRef, stride, bufferSize, (void*)bufferRef,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapSourceTransform']/*"/>	
    /// <msdn-id>ee719897</msdn-id>	
    /// <unmanaged>IWICBitmapSourceTransform</unmanaged>	
    /// <unmanaged-short>IWICBitmapSourceTransform</unmanaged-short>	
    [Guid("3B16811B-6A43-4ec9-B713-3D5A0C13B940")]
    public partial class BitmapSourceTransform : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.BitmapSourceTransform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BitmapSourceTransform(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.BitmapSourceTransform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.BitmapSourceTransform(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.BitmapSourceTransform(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Copies pixel data using the supplied input parameters.</p>	
        /// </summary>	
        /// <param name="rectangleRef"><dd>  <p>The rectangle of pixels to copy.</p> </dd></param>	
        /// <param name="width"><dd>  <p>The width to scale the source bitmap. This parameter must equal the value obtainable through <strong><see cref="SharpDX.WIC.BitmapSourceTransform.GetClosestSize"/></strong>.</p> </dd></param>	
        /// <param name="height"><dd>  <p>The height to scale the source bitmap. This parameter must equal the value obtainable through <strong><see cref="SharpDX.WIC.BitmapSourceTransform.GetClosestSize"/></strong>.</p> </dd></param>	
        /// <param name="guidDstFormatRef"><dd>  <p> The <see cref="System.Guid"/> of desired pixel format in which the pixels should be returned.  </p> <p>This <see cref="System.Guid"/> must be a format obtained through an <strong>GetClosestPixelFormat</strong> call.</p> </dd></param>	
        /// <param name="dstTransform"><dd>  <p> The desired rotation or flip to perform prior to the pixel copy. </p> <p>The transform must be an operation supported by an <strong>DoesSupportTransform</strong> call.</p> <p>If a <em>dstTransform</em> is specified, <em>nStride</em> is the <em>transformed stride</em> and is based on the <em>pguidDstFormat</em> pixel format, not the original source's pixel format.</p> </dd></param>	
        /// <param name="nStride"><dd>  <p>The stride of the destination buffer.</p> </dd></param>	
        /// <param name="bufferSize"><dd>  <p>The size of the destination buffer.</p> </dd></param>	
        /// <param name="bufferRef"><dd>  <p>The output buffer.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapSourceTransform::CopyPixels']/*"/>	
        /// <msdn-id>ee690173</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapSourceTransform::CopyPixels([In] const void* prc,[In] unsigned int uiWidth,[In] unsigned int uiHeight,[In, Optional] GUID* pguidDstFormat,[In] WICBitmapTransformOptions dstTransform,[In] unsigned int nStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer)</unmanaged>	
        /// <unmanaged-short>IWICBitmapSourceTransform::CopyPixels</unmanaged-short>	
        internal void CopyPixels(System.IntPtr rectangleRef, int width, int height, System.Guid? guidDstFormatRef, SharpDX.WIC.BitmapTransformOptions dstTransform, int nStride, int bufferSize, System.IntPtr bufferRef) {
            unsafe {
                System.Guid guidDstFormatRef_;
                if (guidDstFormatRef.HasValue)
                    guidDstFormatRef_ = guidDstFormatRef.Value;				
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)rectangleRef, width, height, (guidDstFormatRef.HasValue)?&guidDstFormatRef_:(void*)IntPtr.Zero, unchecked((int)dstTransform), nStride, bufferSize, (void*)bufferRef,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Returns the closest dimensions the implementation can natively scale to given the desired dimensions.</p>	
        /// </summary>	
        /// <param name="widthRef"><dd>  <p>The desired width. A reference that receives the closest supported width.</p> </dd></param>	
        /// <param name="heightRef"><dd>  <p>The desired height. A reference that receives the closest supported height.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The Windows provided codecs provide the following support for native scaling:	
        /// </p><ul> <li>BMP, ICO, GIF, TIFF: No implementation of <see cref="SharpDX.WIC.BitmapSourceTransform"/>.</li> <li>PNG: No scaling support.</li> <li>JPEG: Native down-scaling by a factor of 8, 4, or 2.</li> <li>JPEG-XR:  Native scaling of the original image by powers of 2.	
        /// </li> </ul>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapSourceTransform::GetClosestSize']/*"/>	
        /// <msdn-id>ee690176</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapSourceTransform::GetClosestSize([InOut] unsigned int* puiWidth,[InOut] unsigned int* puiHeight)</unmanaged>	
        /// <unmanaged-short>IWICBitmapSourceTransform::GetClosestSize</unmanaged-short>	
        internal void GetClosestSize(ref int widthRef, ref int heightRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* widthRef_ = &widthRef)
                    fixed (void* heightRef_ = &heightRef)
                        __result__= 
        				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, widthRef_, heightRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the closest pixel format to which the implementation of <strong><see cref="SharpDX.WIC.BitmapSourceTransform"/></strong> can natively copy pixels, given a desired format.</p>	
        /// </summary>	
        /// <param name="guidDstFormatRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The Windows provided codecs provide the following support:</p><ul> <li>BMP, ICO, GIF, TIFF: No implementation of <strong><see cref="SharpDX.WIC.BitmapSourceTransform"/></strong>.</li> <li>JPEG, PNG, JPEG-XR: Trivial support (always returns the same value as <strong>IWICBitmapFrameDecode::GetPixelFormat</strong>).</li> </ul>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapSourceTransform::GetClosestPixelFormat']/*"/>	
        /// <msdn-id>ee690175</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapSourceTransform::GetClosestPixelFormat([InOut] GUID* pguidDstFormat)</unmanaged>	
        /// <unmanaged-short>IWICBitmapSourceTransform::GetClosestPixelFormat</unmanaged-short>	
        public void GetClosestPixelFormat(ref System.Guid guidDstFormatRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* guidDstFormatRef_ = &guidDstFormatRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, guidDstFormatRef_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Determines whether a specific transform option is supported natively by the implementation of the <strong><see cref="SharpDX.WIC.BitmapSourceTransform"/></strong> interface.</p>	
        /// </summary>	
        /// <param name="dstTransform">No documentation.</param>	
        /// <param name="fIsSupportedRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The Windows provided codecs provide the following level of support:</p><ul> <li>BMP, ICO, GIF, TIFF: No implementation of <see cref="SharpDX.WIC.BitmapSourceTransform"/>.</li> <li>JPEG, PNG: Trivial support (<see cref="SharpDX.WIC.BitmapTransformOptions.Rotate0"/> only).</li> <li>JPEG-XR: Support for all transformation/rotations.	
        /// </li> </ul>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICBitmapSourceTransform::DoesSupportTransform']/*"/>	
        /// <msdn-id>ee690174</msdn-id>	
        /// <unmanaged>HRESULT IWICBitmapSourceTransform::DoesSupportTransform([In] WICBitmapTransformOptions dstTransform,[Out] BOOL* pfIsSupported)</unmanaged>	
        /// <unmanaged-short>IWICBitmapSourceTransform::DoesSupportTransform</unmanaged-short>	
        public void IsSupportingTransform(SharpDX.WIC.BitmapTransformOptions dstTransform, out SharpDX.Mathematics.Interop.RawBool fIsSupportedRef) {
            unsafe {
                fIsSupportedRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fIsSupportedRef_ = &fIsSupportedRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)dstTransform), fIsSupportedRef_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods for color management.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A Color Context is an abstraction for a color profile. The profile can either be loaded from a file (like "sRGB Color Space Profile.icm"), read from a memory buffer, or can be defined by an EXIF color space. The system color profile directory can be obtained by calling <strong>GetColorDirectory</strong>.</p><p>Once a color context has been initialized, it cannot be re-initialized.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICColorContext']/*"/>	
    /// <msdn-id>ee690193</msdn-id>	
    /// <unmanaged>IWICColorContext</unmanaged>	
    /// <unmanaged-short>IWICColorContext</unmanaged-short>	
    [Guid("3C613A02-34B2-44ea-9A7C-45AEA9C6FD6D")]
    public partial class ColorContext : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.ColorContext"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ColorContext(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.ColorContext"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.ColorContext(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.ColorContext(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the color context type.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICColorContext::GetType']/*"/>	
        /// <msdn-id>ee690196</msdn-id>	
        /// <unmanaged>GetType</unmanaged>	
        /// <unmanaged-short>GetType</unmanaged-short>	
        /// <unmanaged>HRESULT IWICColorContext::GetType([Out] WICColorContextType* pType)</unmanaged>
        public SharpDX.WIC.ColorContextType TypeInfo {
                get { SharpDX.WIC.ColorContextType __output__; GetTypeInfo(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the Exchangeable Image File (EXIF) color space color context.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method should only be used when <strong><see cref="SharpDX.WIC.ColorContext.GetTypeInfo"/></strong> indicates <strong><see cref="SharpDX.WIC.ColorContextType.ExifColorSpace"/></strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICColorContext::GetExifColorSpace']/*"/>	
        /// <msdn-id>ee690194</msdn-id>	
        /// <unmanaged>GetExifColorSpace</unmanaged>	
        /// <unmanaged-short>GetExifColorSpace</unmanaged-short>	
        /// <unmanaged>HRESULT IWICColorContext::GetExifColorSpace([Out] unsigned int* pValue)</unmanaged>
        public int ExifColorSpace {
                get { int __output__; GetExifColorSpace(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Initializes the color context from the given file.</p>	
        /// </summary>	
        /// <param name="filename"><dd>  <p>The name of the file.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Once a color context has been initialized, it can't be re-initialized.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICColorContext::InitializeFromFilename']/*"/>	
        /// <msdn-id>ee690198</msdn-id>	
        /// <unmanaged>HRESULT IWICColorContext::InitializeFromFilename([In] const wchar_t* wzFilename)</unmanaged>	
        /// <unmanaged-short>IWICColorContext::InitializeFromFilename</unmanaged-short>	
        public void InitializeFromFilename(string filename) {
            unsafe {
                IntPtr filename_ = Utilities.StringToHGlobalUni(filename);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)filename_,((void**)(*(void**)_nativePointer))[3]);		
                Marshal.FreeHGlobal(filename_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Initializes the color context from a memory block.</p>	
        /// </summary>	
        /// <param name="bufferRef"><dd>  <p>The buffer used to initialize the <strong><see cref="SharpDX.WIC.ColorContext"/></strong>.</p> </dd></param>	
        /// <param name="bufferSize"><dd>  <p>The size of the <em>pbBuffer</em> buffer.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Once a color context has been initialized, it can't be re-initialized.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICColorContext::InitializeFromMemory']/*"/>	
        /// <msdn-id>ee690199</msdn-id>	
        /// <unmanaged>HRESULT IWICColorContext::InitializeFromMemory([In] const void* pbBuffer,[In] unsigned int cbBufferSize)</unmanaged>	
        /// <unmanaged-short>IWICColorContext::InitializeFromMemory</unmanaged-short>	
        internal void InitializeFromMemory(System.IntPtr bufferRef, int bufferSize) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)bufferRef, bufferSize,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Initializes the color context using an Exchangeable Image File (EXIF) color space.</p>	
        /// </summary>	
        /// <param name="value"><dd>  <p>The value of the EXIF color space.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>1</dt> </dl> </td><td> <p>A sRGB color space.</p> </td></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>2</dt> </dl> </td><td> <p>An Adobe RGB color space.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Once a color context has been initialized, it can't be re-initialized.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICColorContext::InitializeFromExifColorSpace']/*"/>	
        /// <msdn-id>ee690197</msdn-id>	
        /// <unmanaged>HRESULT IWICColorContext::InitializeFromExifColorSpace([In] unsigned int value)</unmanaged>	
        /// <unmanaged-short>IWICColorContext::InitializeFromExifColorSpace</unmanaged-short>	
        public void InitializeFromExifColorSpace(int value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, value,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the color context type.</p>	
        /// </summary>	
        /// <param name="typeRef"><dd>  <p>A reference that receives the <strong><see cref="SharpDX.WIC.ColorContextType"/></strong> of the color context.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICColorContext::GetType']/*"/>	
        /// <msdn-id>ee690196</msdn-id>	
        /// <unmanaged>HRESULT IWICColorContext::GetType([Out] WICColorContextType* pType)</unmanaged>	
        /// <unmanaged-short>IWICColorContext::GetType</unmanaged-short>	
        internal void GetTypeInfo(out SharpDX.WIC.ColorContextType typeRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* typeRef_ = &typeRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, typeRef_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the color context profile.</p>	
        /// </summary>	
        /// <param name="buffer"><dd>  <p>The size of the <em>pbBuffer</em> buffer.</p> </dd></param>	
        /// <param name="bufferRef"><dd>  <p>A reference that receives the color context profile.</p> </dd></param>	
        /// <param name="actualRef"><dd>  <p>A reference that receives the actual buffer size needed to retrieve the entire color context profile.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Only use this method if the context type is <strong><see cref="SharpDX.WIC.ColorContextType.Profile"/></strong>.	
        /// </p><p>Calling this method with <em>pbBuffer</em> set to <strong><c>null</c></strong> will cause it to return the required buffer size in <em>pcbActual</em>.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICColorContext::GetProfileBytes']/*"/>	
        /// <msdn-id>ee690195</msdn-id>	
        /// <unmanaged>HRESULT IWICColorContext::GetProfileBytes([In] unsigned int cbBuffer,[In] void* pbBuffer,[Out] unsigned int* pcbActual)</unmanaged>	
        /// <unmanaged-short>IWICColorContext::GetProfileBytes</unmanaged-short>	
        internal void GetProfileBytes(int buffer, System.IntPtr bufferRef, out int actualRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* actualRef_ = &actualRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, buffer, (void*)bufferRef, actualRef_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the Exchangeable Image File (EXIF) color space color context.</p>	
        /// </summary>	
        /// <param name="valueRef"><dd>  <p>A reference that receives the EXIF color space color context.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>1</dt> </dl> </td><td> <p>A sRGB color space.</p> </td></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>2</dt> </dl> </td><td> <p>An Adobe RGB color space.</p> </td></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>3 through 65534</dt> </dl> </td><td> <p>Unused.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method should only be used when <strong><see cref="SharpDX.WIC.ColorContext.GetTypeInfo"/></strong> indicates <strong><see cref="SharpDX.WIC.ColorContextType.ExifColorSpace"/></strong>.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICColorContext::GetExifColorSpace']/*"/>	
        /// <msdn-id>ee690194</msdn-id>	
        /// <unmanaged>HRESULT IWICColorContext::GetExifColorSpace([Out] unsigned int* pValue)</unmanaged>	
        /// <unmanaged-short>IWICColorContext::GetExifColorSpace</unmanaged-short>	
        internal void GetExifColorSpace(out int valueRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* valueRef_ = &valueRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, valueRef_,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods that transforms an <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> from one color context to another.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A <strong><see cref="SharpDX.WIC.ColorTransform"/></strong> is an imaging pipeline component that knows how to pull pixels obtained from a given <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> through a color transform. The color transform is defined by mapping colors from the source color context to the destination color context in a given output pixel format.</p><p>Once initialized, a color transform cannot be reinitialized. Because of this, a color transform cannot be used with multiple sources or varying parameters.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICColorTransform']/*"/>	
    /// <msdn-id>ee690201</msdn-id>	
    /// <unmanaged>IWICColorTransform</unmanaged>	
    /// <unmanaged-short>IWICColorTransform</unmanaged-short>	
    [Guid("B66F034F-D0E2-40ab-B436-6DE39E321A94")]
    public partial class ColorTransform : SharpDX.WIC.BitmapSource {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.ColorTransform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ColorTransform(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.ColorTransform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.ColorTransform(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.ColorTransform(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Initializes an <strong><see cref="SharpDX.WIC.ColorTransform"/></strong> with a <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> and transforms it from one <strong><see cref="SharpDX.WIC.ColorContext"/></strong> to another. </p>	
        /// </summary>	
        /// <param name="bitmapSourceRef">No documentation.</param>	
        /// <param name="contextSourceRef">No documentation.</param>	
        /// <param name="contextDestRef">No documentation.</param>	
        /// <param name="ixelFmtDestRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The currently supported formats for the <em>pIContextSource</em> and <em>pixelFmtDest</em> parameters are: 	
        /// </p><ul> <li><see cref="SharpDX.WIC.PixelFormat.Format8bppGray"/></li> <li><see cref="SharpDX.WIC.PixelFormat.Format16bppGray"/></li> <li><see cref="SharpDX.WIC.PixelFormat.Format16bppBGR555"/></li> <li><see cref="SharpDX.WIC.PixelFormat.Format16bppBGR565"/></li> <li><see cref="SharpDX.WIC.PixelFormat.Format24bppBGR"/></li> <li><see cref="SharpDX.WIC.PixelFormat.Format24bppRGB"/></li> <li><see cref="SharpDX.WIC.PixelFormat.Format32bppBGR"/></li> <li><see cref="SharpDX.WIC.PixelFormat.Format32bppBGRA"/></li> <li><see cref="SharpDX.WIC.PixelFormat.Format32bppPBGRA"/></li> <li><see cref="SharpDX.WIC.PixelFormat.Format32bppPRGBA"/> (Windows?8 and later)</li> <li><see cref="SharpDX.WIC.PixelFormat.Format32bppRGBA"/></li> <li><see cref="SharpDX.WIC.PixelFormat.Format32bppBGR101010"/></li> <li><see cref="SharpDX.WIC.PixelFormat.Format32bppCMYK"/></li> <li><see cref="SharpDX.WIC.PixelFormat.Format48bppBGR"/></li> <li><see cref="SharpDX.WIC.PixelFormat.Format64bppBGRA"/> 		(Windows?8 and later)</li> <li> <see cref="SharpDX.WIC.PixelFormat.Format64bppPBGRA"/> (Windows?8 and later)</li> <li> <see cref="SharpDX.WIC.PixelFormat.Format64bppPRGBA"/> (Windows?8 and later)</li> <li> <see cref="SharpDX.WIC.PixelFormat.Format64bppRGBA"/> 		 (Windows?8 and later)</li> </ul><p>In order to get correct behavior from a color transform, the input and output pixel formats must be compatible with the source and destination color profiles. For example, an sRGB destination color profile will produce incorrect results when used with a CMYK destination pixel format.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICColorTransform::Initialize']/*"/>	
        /// <msdn-id>ee690202</msdn-id>	
        /// <unmanaged>HRESULT IWICColorTransform::Initialize([In, Optional] IWICBitmapSource* pIBitmapSource,[In, Optional] IWICColorContext* pIContextSource,[In, Optional] IWICColorContext* pIContextDest,[In] const GUID&amp; pixelFmtDest)</unmanaged>	
        /// <unmanaged-short>IWICColorTransform::Initialize</unmanaged-short>	
        public void Initialize(SharpDX.WIC.BitmapSource bitmapSourceRef, SharpDX.WIC.ColorContext contextSourceRef, SharpDX.WIC.ColorContext contextDestRef, System.Guid ixelFmtDestRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((bitmapSourceRef == null)?IntPtr.Zero:bitmapSourceRef.NativePointer), (void*)((contextSourceRef == null)?IntPtr.Zero:contextSourceRef.NativePointer), (void*)((contextDestRef == null)?IntPtr.Zero:contextDestRef.NativePointer), &ixelFmtDestRef,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods that provide component information.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICComponentInfo']/*"/>	
    /// <msdn-id>ee690213</msdn-id>	
    /// <unmanaged>IWICComponentInfo</unmanaged>	
    /// <unmanaged-short>IWICComponentInfo</unmanaged-short>	
    [Guid("23BC3F0A-698B-4357-886B-F24D50671334")]
    public partial class ComponentInfo : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.ComponentInfo"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ComponentInfo(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.ComponentInfo"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.ComponentInfo(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.ComponentInfo(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the component's <strong><see cref="SharpDX.WIC.ComponentType"/></strong>.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICComponentInfo::GetComponentType']/*"/>	
        /// <msdn-id>ee690218</msdn-id>	
        /// <unmanaged>GetComponentType</unmanaged>	
        /// <unmanaged-short>GetComponentType</unmanaged-short>	
        /// <unmanaged>HRESULT IWICComponentInfo::GetComponentType([Out] WICComponentType* pType)</unmanaged>
        public SharpDX.WIC.ComponentType ComponentType {
                get { SharpDX.WIC.ComponentType __output__; GetComponentType(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the component's class identifier (CLSID)</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICComponentInfo::GetCLSID']/*"/>	
        /// <msdn-id>ee690216</msdn-id>	
        /// <unmanaged>GetCLSID</unmanaged>	
        /// <unmanaged-short>GetCLSID</unmanaged-short>	
        /// <unmanaged>HRESULT IWICComponentInfo::GetCLSID([Out] GUID* pclsid)</unmanaged>
        public System.Guid CLSID {
                get { System.Guid __output__; GetCLSID(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the signing status of the component.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Signing is unused by WIC. Therefore, all components <see cref="SharpDX.WIC.ComponentSigning.Signed"/>.</p><p>This function can be used to determine whether a component has no binary component or has been added to the disabled components list in the registry.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICComponentInfo::GetSigningStatus']/*"/>	
        /// <msdn-id>ee690221</msdn-id>	
        /// <unmanaged>GetSigningStatus</unmanaged>	
        /// <unmanaged-short>GetSigningStatus</unmanaged-short>	
        /// <unmanaged>HRESULT IWICComponentInfo::GetSigningStatus([Out] unsigned int* pStatus)</unmanaged>
        public int SigningStatus {
                get { int __output__; GetSigningStatus(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the vendor <see cref="System.Guid"/>.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICComponentInfo::GetVendorGUID']/*"/>	
        /// <msdn-id>ee690225</msdn-id>	
        /// <unmanaged>GetVendorGUID</unmanaged>	
        /// <unmanaged-short>GetVendorGUID</unmanaged-short>	
        /// <unmanaged>HRESULT IWICComponentInfo::GetVendorGUID([Out] GUID* pguidVendor)</unmanaged>
        public System.Guid VendorGUID {
                get { System.Guid __output__; GetVendorGUID(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the component's <strong><see cref="SharpDX.WIC.ComponentType"/></strong>.</p>	
        /// </summary>	
        /// <param name="typeRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICComponentInfo::GetComponentType']/*"/>	
        /// <msdn-id>ee690218</msdn-id>	
        /// <unmanaged>HRESULT IWICComponentInfo::GetComponentType([Out] WICComponentType* pType)</unmanaged>	
        /// <unmanaged-short>IWICComponentInfo::GetComponentType</unmanaged-short>	
        internal void GetComponentType(out SharpDX.WIC.ComponentType typeRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* typeRef_ = &typeRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, typeRef_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the component's class identifier (CLSID)</p>	
        /// </summary>	
        /// <param name="clsidRef"><dd>  <p>A reference that receives the component's CLSID.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICComponentInfo::GetCLSID']/*"/>	
        /// <msdn-id>ee690216</msdn-id>	
        /// <unmanaged>HRESULT IWICComponentInfo::GetCLSID([Out] GUID* pclsid)</unmanaged>	
        /// <unmanaged-short>IWICComponentInfo::GetCLSID</unmanaged-short>	
        internal void GetCLSID(out System.Guid clsidRef) {
            unsafe {
                clsidRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* clsidRef_ = &clsidRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, clsidRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the signing status of the component.</p>	
        /// </summary>	
        /// <param name="statusRef"><dd>  <p>A reference that receives the <strong><see cref="SharpDX.WIC.ComponentSigning"/></strong> status of the component.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Signing is unused by WIC. Therefore, all components <see cref="SharpDX.WIC.ComponentSigning.Signed"/>.</p><p>This function can be used to determine whether a component has no binary component or has been added to the disabled components list in the registry.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICComponentInfo::GetSigningStatus']/*"/>	
        /// <msdn-id>ee690221</msdn-id>	
        /// <unmanaged>HRESULT IWICComponentInfo::GetSigningStatus([Out] unsigned int* pStatus)</unmanaged>	
        /// <unmanaged-short>IWICComponentInfo::GetSigningStatus</unmanaged-short>	
        internal void GetSigningStatus(out int statusRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* statusRef_ = &statusRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, statusRef_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the name of component's author.</p>	
        /// </summary>	
        /// <param name="cchAuthor"><dd>  <p>The size of the <em>wzAuthor</em> buffer.</p> </dd></param>	
        /// <param name="author"><dd>  <p>A reference that receives the name of the component's author. The locale of the string depends on the value that the codec wrote to the registry at install time. For built-in components, these strings are always in English.</p> </dd></param>	
        /// <param name="cchActualRef"><dd>  <p>A reference that receives the actual length of the component's authors name. The author name is optional; if an author name is not specified by the component, the length returned is 0.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If <em>cchAuthor</em> is 0 and <em>wzAuthor</em> is <strong><c>null</c></strong>, the required buffer size is returned in <em>pccchActual</em>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICComponentInfo::GetAuthor']/*"/>	
        /// <msdn-id>ee690214</msdn-id>	
        /// <unmanaged>HRESULT IWICComponentInfo::GetAuthor([In] unsigned int cchAuthor,[In] void* wzAuthor,[Out] unsigned int* pcchActual)</unmanaged>	
        /// <unmanaged-short>IWICComponentInfo::GetAuthor</unmanaged-short>	
        internal void GetAuthor(int cchAuthor, System.IntPtr author, out int cchActualRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* cchActualRef_ = &cchActualRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, cchAuthor, (void*)author, cchActualRef_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the vendor <see cref="System.Guid"/>.</p>	
        /// </summary>	
        /// <param name="guidVendorRef"><dd>  <p>A reference that receives the component's vendor <see cref="System.Guid"/>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICComponentInfo::GetVendorGUID']/*"/>	
        /// <msdn-id>ee690225</msdn-id>	
        /// <unmanaged>HRESULT IWICComponentInfo::GetVendorGUID([Out] GUID* pguidVendor)</unmanaged>	
        /// <unmanaged-short>IWICComponentInfo::GetVendorGUID</unmanaged-short>	
        internal void GetVendorGUID(out System.Guid guidVendorRef) {
            unsafe {
                guidVendorRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* guidVendorRef_ = &guidVendorRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, guidVendorRef_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the component's version. </p>	
        /// </summary>	
        /// <param name="cchVersion"><dd>  <p>The size of the <em>wzVersion</em> buffer.</p> </dd></param>	
        /// <param name="version"><dd>  <p>A reference that receives a culture invariant string of the component's version.</p> </dd></param>	
        /// <param name="cchActualRef"><dd>  <p>A reference that receives the actual length of the component's version. The version is optional; if a value is not specified by the component, the length returned is 0.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>All built-in components return "1.0.0.0", except for pixel formats, which do not have a version.</p><p>If <em>cchAuthor</em> is 0 and <em>wzAuthor</em> is <strong><c>null</c></strong>, the required buffer size is returned in <em>pccchActual</em>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICComponentInfo::GetVersion']/*"/>	
        /// <msdn-id>ee690226</msdn-id>	
        /// <unmanaged>HRESULT IWICComponentInfo::GetVersion([In] unsigned int cchVersion,[In] void* wzVersion,[Out] unsigned int* pcchActual)</unmanaged>	
        /// <unmanaged-short>IWICComponentInfo::GetVersion</unmanaged-short>	
        internal void GetVersion(int cchVersion, System.IntPtr version, out int cchActualRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* cchActualRef_ = &cchActualRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, cchVersion, (void*)version, cchActualRef_,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the component's specification version.</p>	
        /// </summary>	
        /// <param name="cchSpecVersion"><dd>  <p>The size of the <em>wzSpecVersion</em> buffer.</p> </dd></param>	
        /// <param name="specVersion"><dd>  <p>When this method returns, contain a culture invarient string of the component's specification version. The version form is NN.NN.NN.NN.</p> </dd></param>	
        /// <param name="cchActualRef"><dd>  <p>A reference that receives the actual length of the component's specification version. The specification version is optional; if a value is not specified by the component, the length returned is 0.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>All built-in components return "1.0.0.0", except for pixel formats, which do not have a spec version.</p><p>If <em>cchAuthor</em> is 0 and <em>wzAuthor</em> is <strong><c>null</c></strong>, the required buffer size is returned in <em>pccchActual</em>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICComponentInfo::GetSpecVersion']/*"/>	
        /// <msdn-id>ee690223</msdn-id>	
        /// <unmanaged>HRESULT IWICComponentInfo::GetSpecVersion([In] unsigned int cchSpecVersion,[In] void* wzSpecVersion,[Out] unsigned int* pcchActual)</unmanaged>	
        /// <unmanaged-short>IWICComponentInfo::GetSpecVersion</unmanaged-short>	
        internal void GetSpecVersion(int cchSpecVersion, System.IntPtr specVersion, out int cchActualRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* cchActualRef_ = &cchActualRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, cchSpecVersion, (void*)specVersion, cchActualRef_,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the component's friendly name, which is a human-readable display name for the component.</p>	
        /// </summary>	
        /// <param name="cchFriendlyName"><dd>  <p>The size of the <em>wzFriendlyName</em> buffer.</p> </dd></param>	
        /// <param name="friendlyName"><dd>  <p>A reference that receives the friendly name of the component. The locale of the string depends on the value that the codec wrote to the registry at install time. For built-in components, these strings are always in English.</p> </dd></param>	
        /// <param name="cchActualRef"><dd>  <p>A reference that receives the actual length of the component's friendly name.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If <em>cchFriendlyName</em> is 0 and <em>wzFriendlyName</em> is <strong><c>null</c></strong>, the required buffer size is returned in <em>pccchActual</em>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICComponentInfo::GetFriendlyName']/*"/>	
        /// <msdn-id>ee690219</msdn-id>	
        /// <unmanaged>HRESULT IWICComponentInfo::GetFriendlyName([In] unsigned int cchFriendlyName,[In] void* wzFriendlyName,[Out] unsigned int* pcchActual)</unmanaged>	
        /// <unmanaged-short>IWICComponentInfo::GetFriendlyName</unmanaged-short>	
        internal void GetFriendlyName(int cchFriendlyName, System.IntPtr friendlyName, out int cchActualRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* cchActualRef_ = &cchActualRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, cchFriendlyName, (void*)friendlyName, cchActualRef_,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides information and functionality specific to the DDS image format.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is implemented by the WIC DDS codec. To obtain this interface, create an <strong><see cref="SharpDX.WIC.BitmapDecoder"/></strong> using the DDS codec and QueryInterface for <strong><see cref="SharpDX.WIC.DdsDecoder"/></strong>.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDdsDecoder']/*"/>	
    /// <msdn-id>dn302079</msdn-id>	
    /// <unmanaged>IWICDdsDecoder</unmanaged>	
    /// <unmanaged-short>IWICDdsDecoder</unmanaged-short>	
    [Guid("409cd537-8532-40cb-9774-e2feb2df4e9c")]
    public partial class DdsDecoder : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.DdsDecoder"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DdsDecoder(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.DdsDecoder"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.DdsDecoder(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.DdsDecoder(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets DDS-specific data.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDdsDecoder::GetParameters']/*"/>	
        /// <msdn-id>dn302081</msdn-id>	
        /// <unmanaged>GetParameters</unmanaged>	
        /// <unmanaged-short>GetParameters</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDdsDecoder::GetParameters([Out] WICDdsParameters* pParameters)</unmanaged>
        public SharpDX.WIC.DdsParameters Parameters {
                get { SharpDX.WIC.DdsParameters __output__; GetParameters(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets DDS-specific data.</p>	
        /// </summary>	
        /// <param name="parametersRef"><dd>  <p>A reference to the structure where the information is returned.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDdsDecoder::GetParameters']/*"/>	
        /// <msdn-id>dn302081</msdn-id>	
        /// <unmanaged>HRESULT IWICDdsDecoder::GetParameters([Out] WICDdsParameters* pParameters)</unmanaged>	
        /// <unmanaged-short>IWICDdsDecoder::GetParameters</unmanaged-short>	
        internal void GetParameters(out SharpDX.WIC.DdsParameters parametersRef) {
            unsafe {
                parametersRef = new SharpDX.WIC.DdsParameters();
                SharpDX.Result __result__;
                fixed (void* parametersRef_ = &parametersRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, parametersRef_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the specified frame of the DDS image.</p>	
        /// </summary>	
        /// <param name="arrayIndex"><dd>  <p> The requested index within the texture array.</p> </dd></param>	
        /// <param name="mipLevel"><dd>  <p> The requested mip level.</p> </dd></param>	
        /// <param name="sliceIndex"><dd>  <p>The requested slice within the 3D texture.</p> </dd></param>	
        /// <param name="bitmapFrameOut"><dd>  <p>A reference to a  <strong><see cref="SharpDX.WIC.BitmapFrameDecode"/></strong> object.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>A DDS file can contain multiple images that are organized into a three level hierarchy. First, DDS file may contain multiple textures in a texture array. Second, each texture can have multiple mip levels. Finally, the texture may be a 3D (volume) texture and have multiple slices, each of which is a 2D texture. See the DDS documentation for more information.</p><p>WIC maps this three level hierarchy into a linear array of <strong><see cref="SharpDX.WIC.BitmapFrameDecode"/></strong>, accessible via <strong><see cref="SharpDX.WIC.BitmapDecoder.GetFrame"/></strong>. However, determining which frame corresponds to a triad of <em>arrayIndex</em>, <em>mipLevel</em>, and <em>sliceIndex</em> value is not trivial because each mip level of a 3D texture has a different depth (number of slices). This method provides additional convenience over <strong><see cref="SharpDX.WIC.BitmapDecoder.GetFrame"/></strong> for DDS images by calculating the correct frame given the three indices.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDdsDecoder::GetFrame']/*"/>	
        /// <msdn-id>dn302080</msdn-id>	
        /// <unmanaged>HRESULT IWICDdsDecoder::GetFrame([In] unsigned int arrayIndex,[In] unsigned int mipLevel,[In] unsigned int sliceIndex,[Out] IWICBitmapFrameDecode** ppIBitmapFrame)</unmanaged>	
        /// <unmanaged-short>IWICDdsDecoder::GetFrame</unmanaged-short>	
        public void GetFrame(int arrayIndex, int mipLevel, int sliceIndex, out SharpDX.WIC.BitmapFrameDecode bitmapFrameOut) {
            unsafe {
                IntPtr bitmapFrameOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, arrayIndex, mipLevel, sliceIndex, &bitmapFrameOut_,((void**)(*(void**)_nativePointer))[4]);		
                bitmapFrameOut= (bitmapFrameOut_ == IntPtr.Zero)?null:new SharpDX.WIC.BitmapFrameDecode(bitmapFrameOut_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Enables writing DDS format specific information to an encoder.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is implemented by the WIC DDS codec. To obtain this interface, create an <strong><see cref="SharpDX.WIC.BitmapEncoder"/></strong> using the DDS codec and QueryInterface for <strong><see cref="SharpDX.WIC.DdsEncoder"/></strong>.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDdsEncoder']/*"/>	
    /// <msdn-id>dn302082</msdn-id>	
    /// <unmanaged>IWICDdsEncoder</unmanaged>	
    /// <unmanaged-short>IWICDdsEncoder</unmanaged-short>	
    [Guid("5cacdb4c-407e-41b3-b936-d0f010cd6732")]
    public partial class DdsEncoder : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.DdsEncoder"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DdsEncoder(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.DdsEncoder"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.DdsEncoder(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.DdsEncoder(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets or sets DDS-specific data.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>An application can call <strong>GetParameters</strong> to obtain the default DDS parameters, modify some or all of them, and then call <strong>SetParameters</strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDdsEncoder::GetParameters']/*"/>	
        /// <msdn-id>dn302084</msdn-id>	
        /// <unmanaged>GetParameters / SetParameters</unmanaged>	
        /// <unmanaged-short>GetParameters</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDdsEncoder::GetParameters([Out] WICDdsParameters* pParameters)</unmanaged>
        public SharpDX.WIC.DdsParameters Parameters {
                get { SharpDX.WIC.DdsParameters __output__; GetParameters(out __output__); return __output__; }
                set { SetParameters(ref value); }
        }
        
        /// <summary>	
        /// <p>Sets DDS-specific data.</p>	
        /// </summary>	
        /// <param name="parametersRef"><dd>  <p>Points to the structure where the information is described.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>You cannot call this method after you have started to write frame data, for example by calling <strong><see cref="SharpDX.WIC.DdsEncoder.CreateNewFrame"/></strong>. </p><p>Setting DDS parameters using this method provides the DDS encoder with information about the expected number of frames and the dimensions and other parameters of each frame. The DDS encoder will fail if you do not set frame data that matches these expectations. For example, if you set <strong>WICDdsParameters::Width</strong> and <strong>Height</strong> to 32, and <strong>MipLevels</strong> to 6, the DDS encoder will expect 6 frames with the following dimensions:</p><ul> <li>32x32 pixels.</li> <li>16x16 pixels.</li> <li>8x8 pixels.</li> <li>4x4 pixels.</li> <li>2x2 pixels.</li> <li>1x1 pixels.</li> </ul>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDdsEncoder::SetParameters']/*"/>	
        /// <msdn-id>dn302085</msdn-id>	
        /// <unmanaged>HRESULT IWICDdsEncoder::SetParameters([In] WICDdsParameters* pParameters)</unmanaged>	
        /// <unmanaged-short>IWICDdsEncoder::SetParameters</unmanaged-short>	
        internal void SetParameters(ref SharpDX.WIC.DdsParameters parametersRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* parametersRef_ = &parametersRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, parametersRef_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets DDS-specific data.</p>	
        /// </summary>	
        /// <param name="parametersRef"><dd>  <p>Points to the structure where the information is returned.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>An application can call <strong>GetParameters</strong> to obtain the default DDS parameters, modify some or all of them, and then call <strong>SetParameters</strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDdsEncoder::GetParameters']/*"/>	
        /// <msdn-id>dn302084</msdn-id>	
        /// <unmanaged>HRESULT IWICDdsEncoder::GetParameters([Out] WICDdsParameters* pParameters)</unmanaged>	
        /// <unmanaged-short>IWICDdsEncoder::GetParameters</unmanaged-short>	
        internal void GetParameters(out SharpDX.WIC.DdsParameters parametersRef) {
            unsafe {
                parametersRef = new SharpDX.WIC.DdsParameters();
                SharpDX.Result __result__;
                fixed (void* parametersRef_ = &parametersRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, parametersRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new frame to encode.</p>	
        /// </summary>	
        /// <param name="frameEncodeOut"><dd> <p>A reference to the newly created frame object.</p> </dd></param>	
        /// <param name="arrayIndexRef"><dd> <p>Points to the location where the array index is returned.</p> </dd></param>	
        /// <param name="mipLevelRef"><dd> <p>Points to the location where the mip level index is returned.</p> </dd></param>	
        /// <param name="sliceIndexRef"><dd> <p>Points to the location where the slice index is returned.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This is equivalent to <strong><see cref="SharpDX.WIC.BitmapEncoder.CreateNewFrame"/></strong>, but returns additional information about the array index, mip level and slice of the newly created frame. In contrast to <strong><see cref="SharpDX.WIC.BitmapEncoder.CreateNewFrame"/></strong>, there is no <strong><see cref="SharpDX.Win32.PropertyBag"/></strong>* parameter because individual DDS frames do not have separate properties.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDdsEncoder::CreateNewFrame']/*"/>	
        /// <msdn-id>dn302083</msdn-id>	
        /// <unmanaged>HRESULT IWICDdsEncoder::CreateNewFrame([Out] IWICBitmapFrameEncode** ppIFrameEncode,[Out] unsigned int* pArrayIndex,[Out] unsigned int* pMipLevel,[Out] unsigned int* pSliceIndex)</unmanaged>	
        /// <unmanaged-short>IWICDdsEncoder::CreateNewFrame</unmanaged-short>	
        public void CreateNewFrame(out SharpDX.WIC.BitmapFrameEncode frameEncodeOut, out int arrayIndexRef, out int mipLevelRef, out int sliceIndexRef) {
            unsafe {
                IntPtr frameEncodeOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* arrayIndexRef_ = &arrayIndexRef)
                    fixed (void* mipLevelRef_ = &mipLevelRef)
                        fixed (void* sliceIndexRef_ = &sliceIndexRef)
                            __result__= 
            				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &frameEncodeOut_, arrayIndexRef_, mipLevelRef_, sliceIndexRef_,((void**)(*(void**)_nativePointer))[5]);		
                frameEncodeOut= (frameEncodeOut_ == IntPtr.Zero)?null:new SharpDX.WIC.BitmapFrameEncode(frameEncodeOut_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides access to a single frame of DDS image data in its native <strong><see cref="SharpDX.DXGI.Format"/></strong> form, as well as information about the image data.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is implemented by the WIC DDS codec. To obtain this interface, create an <strong><see cref="SharpDX.WIC.BitmapFrameDecode"/></strong> using the DDS codec and QueryInterface for IID_IWICDdsFrameDecode.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDdsFrameDecode']/*"/>	
    /// <msdn-id>dn302086</msdn-id>	
    /// <unmanaged>IWICDdsFrameDecode</unmanaged>	
    /// <unmanaged-short>IWICDdsFrameDecode</unmanaged-short>	
    [Guid("3d4c0c61-18a4-41e4-bd80-481a4fc9f464")]
    public partial class DdsFrameDecode : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.DdsFrameDecode"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DdsFrameDecode(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.DdsFrameDecode"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.DdsFrameDecode(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.DdsFrameDecode(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets information about the format in which the DDS image is stored.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This information can be used for allocating memory or constructing Direct3D or Direct2D resources, for example by using <strong><see cref="SharpDX.Direct3D11.Device.CreateTexture2D"/></strong> or <strong><see cref="SharpDX.Direct2D1.DeviceContext.CreateBitmap"/></strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDdsFrameDecode::GetFormatInfo']/*"/>	
        /// <msdn-id>dn302088</msdn-id>	
        /// <unmanaged>GetFormatInfo</unmanaged>	
        /// <unmanaged-short>GetFormatInfo</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDdsFrameDecode::GetFormatInfo([Out] WICDdsFormatInfo* pFormatInfo)</unmanaged>
        public SharpDX.WIC.DdsFormatInfo FormatInfo {
                get { SharpDX.WIC.DdsFormatInfo __output__; GetFormatInfo(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the width and height, in blocks, of the DDS image.</p>	
        /// </summary>	
        /// <param name="widthInBlocksRef"><dd>  <p>The width of the DDS image in blocks.</p> </dd></param>	
        /// <param name="heightInBlocksRef"><dd>  <p>The height of the DDS image in blocks.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>For block compressed textures, the returned width and height values do not completely define the texture size because the image is padded to fit the closest whole block size. For example, three BC1 textures with pixel dimensions of 1x1, 2x2 and 4x4 will all report <em>pWidthInBlocks</em> = 1 and <em>pHeightInBlocks</em> = 1. </p><p>If the texture does not use a block-compressed <strong><see cref="SharpDX.DXGI.Format"/></strong>, this method returns the texture size in pixels; for these formats the block size returned by <strong>IWICDdsFrameDecoder::GetFormatInfo</strong> is 1x1.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDdsFrameDecode::GetSizeInBlocks']/*"/>	
        /// <msdn-id>dn302089</msdn-id>	
        /// <unmanaged>HRESULT IWICDdsFrameDecode::GetSizeInBlocks([Out] unsigned int* pWidthInBlocks,[Out] unsigned int* pHeightInBlocks)</unmanaged>	
        /// <unmanaged-short>IWICDdsFrameDecode::GetSizeInBlocks</unmanaged-short>	
        internal void GetSizeInBlocks(out int widthInBlocksRef, out int heightInBlocksRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* widthInBlocksRef_ = &widthInBlocksRef)
                    fixed (void* heightInBlocksRef_ = &heightInBlocksRef)
                        __result__= 
        				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, widthInBlocksRef_, heightInBlocksRef_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets information about the format in which the DDS image is stored.</p>	
        /// </summary>	
        /// <param name="formatInfoRef"><dd>  <p>Information about the DDS format.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This information can be used for allocating memory or constructing Direct3D or Direct2D resources, for example by using <strong><see cref="SharpDX.Direct3D11.Device.CreateTexture2D"/></strong> or <strong><see cref="SharpDX.Direct2D1.DeviceContext.CreateBitmap"/></strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDdsFrameDecode::GetFormatInfo']/*"/>	
        /// <msdn-id>dn302088</msdn-id>	
        /// <unmanaged>HRESULT IWICDdsFrameDecode::GetFormatInfo([Out] WICDdsFormatInfo* pFormatInfo)</unmanaged>	
        /// <unmanaged-short>IWICDdsFrameDecode::GetFormatInfo</unmanaged-short>	
        internal void GetFormatInfo(out SharpDX.WIC.DdsFormatInfo formatInfoRef) {
            unsafe {
                formatInfoRef = new SharpDX.WIC.DdsFormatInfo();
                SharpDX.Result __result__;
                fixed (void* formatInfoRef_ = &formatInfoRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, formatInfoRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Requests pixel data as it is natively stored within the DDS file.</p>	
        /// </summary>	
        /// <param name="rcBoundsInBlocksRef"><dd>  <p>The rectangle to copy from the source. A <c>null</c> value specifies the entire texture.</p> <p>If the texture uses a block-compressed <strong><see cref="SharpDX.DXGI.Format"/></strong>, all values of the rectangle are expressed in number of blocks, not pixels.</p> </dd></param>	
        /// <param name="stride"><dd>  <p>The stride, in bytes, of the destination buffer. This represents the number of bytes from the buffer reference to the next row of data. If the texture uses a block-compressed <strong><see cref="SharpDX.DXGI.Format"/></strong>, a "row of data" is defined as a row of blocks which contains multiple pixel scanlines.</p> </dd></param>	
        /// <param name="bufferSize"><dd>  <p>The size, in bytes, of the destination buffer.</p> </dd></param>	
        /// <param name="bufferRef"><dd>  <p>A reference to the destination buffer.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If the texture does not use a block-compressed <strong><see cref="SharpDX.DXGI.Format"/></strong>, this method behaves similarly to <strong><see cref="SharpDX.WIC.BitmapSource.CopyPixels"/></strong>. However, it does not perform any pixel format conversion, and instead produces the raw data from the DDS file.</p><p>If the texture uses a block-compressed <strong><see cref="SharpDX.DXGI.Format"/></strong>, this method copies the block data directly into the provided buffer. In this case, the <em>prcBoundsInBlocks</em> parameter is defined in blocks, not pixels. To determine if this is the case, call <strong>GetFormatInfo</strong> and read the <strong>DxgiFormat</strong> member of the returned <strong><see cref="SharpDX.WIC.DdsFormatInfo"/></strong> structure.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDdsFrameDecode::CopyBlocks']/*"/>	
        /// <msdn-id>dn302087</msdn-id>	
        /// <unmanaged>HRESULT IWICDdsFrameDecode::CopyBlocks([In, Optional] const WICRect* prcBoundsInBlocks,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer)</unmanaged>	
        /// <unmanaged-short>IWICDdsFrameDecode::CopyBlocks</unmanaged-short>	
        internal void CopyBlocks(SharpDX.Mathematics.Interop.RawBox? rcBoundsInBlocksRef, int stride, int bufferSize, System.IntPtr bufferRef) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBox rcBoundsInBlocksRef_;
                if (rcBoundsInBlocksRef.HasValue)
                    rcBoundsInBlocksRef_ = rcBoundsInBlocksRef.Value;				
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (rcBoundsInBlocksRef.HasValue)?&rcBoundsInBlocksRef_:(void*)IntPtr.Zero, stride, bufferSize, (void*)bufferRef,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods that provide access to the capabilites of a raw codec format.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw']/*"/>	
    /// <msdn-id>ee690228</msdn-id>	
    /// <unmanaged>IWICDevelopRaw</unmanaged>	
    /// <unmanaged-short>IWICDevelopRaw</unmanaged-short>	
    [Guid("fbec5e44-f7be-4b65-b7f8-c0c81fef026d")]
    public partial class DevelopRaw : SharpDX.WIC.BitmapFrameDecode {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.DevelopRaw"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DevelopRaw(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.DevelopRaw"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.DevelopRaw(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.DevelopRaw(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the current set of parameters.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetCurrentParameterSet']/*"/>	
        /// <msdn-id>ee690233</msdn-id>	
        /// <unmanaged>GetCurrentParameterSet</unmanaged>	
        /// <unmanaged-short>GetCurrentParameterSet</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetCurrentParameterSet([Out] IPropertyBag2** ppCurrentParameterSet)</unmanaged>
        public SharpDX.Win32.PropertyBag CurrentParameterSet {
                get { SharpDX.Win32.PropertyBag __output__; GetCurrentParameterSet(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets or sets the exposure compensation stop value of the raw image.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetExposureCompensation']/*"/>	
        /// <msdn-id>ee690234</msdn-id>	
        /// <unmanaged>GetExposureCompensation / SetExposureCompensation</unmanaged>	
        /// <unmanaged-short>GetExposureCompensation</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetExposureCompensation([Out] double* pEV)</unmanaged>
        public double ExposureCompensation {
                get { double __output__; GetExposureCompensation(out __output__); return __output__; }
                set { SetExposureCompensation(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the named white point of the raw image.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>If the named white points are not supported by the raw image or the raw file contains named white points that are not supported by this API, the codec implementer should still mark this capability as supported.</p><p>If the named white points are not supported by the raw image, a best effort should be made to adjust the image to the named white point even when it isn't a pre-defined white point of the raw file.</p><p>If the raw file containes named white points not supported by this API, the codec implementer should support the named white points in <strong><see cref="SharpDX.WIC.NamedWhitePoint"/></strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetNamedWhitePoint']/*"/>	
        /// <msdn-id>ee690237</msdn-id>	
        /// <unmanaged>GetNamedWhitePoint / SetNamedWhitePoint</unmanaged>	
        /// <unmanaged-short>GetNamedWhitePoint</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetNamedWhitePoint([Out] WICNamedWhitePoint* pWhitePoint)</unmanaged>
        public SharpDX.WIC.NamedWhitePoint NamedWhitePoint {
                get { SharpDX.WIC.NamedWhitePoint __output__; GetNamedWhitePoint(out __output__); return __output__; }
                set { SetNamedWhitePoint(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the white point Kelvin temperature of the raw image.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetWhitePointKelvin']/*"/>	
        /// <msdn-id>ee690245</msdn-id>	
        /// <unmanaged>GetWhitePointKelvin / SetWhitePointKelvin</unmanaged>	
        /// <unmanaged-short>GetWhitePointKelvin</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetWhitePointKelvin([Out] unsigned int* pWhitePointKelvin)</unmanaged>
        public int WhitePointKelvin {
                get { int __output__; GetWhitePointKelvin(out __output__); return __output__; }
                set { SetWhitePointKelvin(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the contrast value of the raw image.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetContrast']/*"/>	
        /// <msdn-id>ee690232</msdn-id>	
        /// <unmanaged>GetContrast / SetContrast</unmanaged>	
        /// <unmanaged-short>GetContrast</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetContrast([Out] double* pContrast)</unmanaged>
        public double Contrast {
                get { double __output__; GetContrast(out __output__); return __output__; }
                set { SetContrast(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the current gamma setting of the raw image.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetGamma']/*"/>	
        /// <msdn-id>ee690235</msdn-id>	
        /// <unmanaged>GetGamma / SetGamma</unmanaged>	
        /// <unmanaged-short>GetGamma</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetGamma([Out] double* pGamma)</unmanaged>
        public double Gamma {
                get { double __output__; GetGamma(out __output__); return __output__; }
                set { SetGamma(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the sharpness value of the raw image.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetSharpness']/*"/>	
        /// <msdn-id>ee690242</msdn-id>	
        /// <unmanaged>GetSharpness / SetSharpness</unmanaged>	
        /// <unmanaged-short>GetSharpness</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetSharpness([Out] double* pSharpness)</unmanaged>
        public double Sharpness {
                get { double __output__; GetSharpness(out __output__); return __output__; }
                set { SetSharpness(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the saturation value of the raw image.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetSaturation']/*"/>	
        /// <msdn-id>ee690241</msdn-id>	
        /// <unmanaged>GetSaturation / SetSaturation</unmanaged>	
        /// <unmanaged-short>GetSaturation</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetSaturation([Out] double* pSaturation)</unmanaged>
        public double Saturation {
                get { double __output__; GetSaturation(out __output__); return __output__; }
                set { SetSaturation(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the tint value of the raw image.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetTint']/*"/>	
        /// <msdn-id>ee690243</msdn-id>	
        /// <unmanaged>GetTint / SetTint</unmanaged>	
        /// <unmanaged-short>GetTint</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetTint([Out] double* pTint)</unmanaged>
        public double Tint {
                get { double __output__; GetTint(out __output__); return __output__; }
                set { SetTint(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the noise reduction value of the raw image.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetNoiseReduction']/*"/>	
        /// <msdn-id>ee690238</msdn-id>	
        /// <unmanaged>GetNoiseReduction / SetNoiseReduction</unmanaged>	
        /// <unmanaged-short>GetNoiseReduction</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetNoiseReduction([Out] double* pNoiseReduction)</unmanaged>
        public double NoiseReduction {
                get { double __output__; GetNoiseReduction(out __output__); return __output__; }
                set { SetNoiseReduction(value); }
        }
        
        /// <summary>	
        /// <p>Sets the destination color context.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetDestinationColorContext']/*"/>	
        /// <msdn-id>ee690250</msdn-id>	
        /// <unmanaged>SetDestinationColorContext</unmanaged>	
        /// <unmanaged-short>SetDestinationColorContext</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetDestinationColorContext([In, Optional] IWICColorContext* pColorContext)</unmanaged>
        public SharpDX.WIC.ColorContext DestinationColorContext {
                set { SetDestinationColorContext(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the current rotation angle.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetRotation']/*"/>	
        /// <msdn-id>ee690240</msdn-id>	
        /// <unmanaged>GetRotation / SetRotation</unmanaged>	
        /// <unmanaged-short>GetRotation</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetRotation([Out] double* pRotation)</unmanaged>
        public double Rotation {
                get { double __output__; GetRotation(out __output__); return __output__; }
                set { SetRotation(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the current <strong><see cref="SharpDX.WIC.RawRenderMode"/></strong>.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetRenderMode']/*"/>	
        /// <msdn-id>ee690239</msdn-id>	
        /// <unmanaged>GetRenderMode / SetRenderMode</unmanaged>	
        /// <unmanaged-short>GetRenderMode</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetRenderMode([Out] WICRawRenderMode* pRenderMode)</unmanaged>
        public SharpDX.WIC.RawRenderMode RenderMode {
                get { SharpDX.WIC.RawRenderMode __output__; GetRenderMode(out __output__); return __output__; }
                set { SetRenderMode(value); }
        }
        
        /// <summary>	
        /// <p>Sets the notification callback method.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetNotificationCallback']/*"/>	
        /// <msdn-id>ee690255</msdn-id>	
        /// <unmanaged>SetNotificationCallback</unmanaged>	
        /// <unmanaged-short>SetNotificationCallback</unmanaged-short>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetNotificationCallback([In, Optional] IWICDevelopRawNotificationCallback* pCallback)</unmanaged>
        internal SharpDX.WIC.DevelopRawNotificationCallback NotificationCallback {
                set { SetNotificationCallback(value); }
        }
        
        /// <summary>	
        /// <p>Retrieves information about which capabilities are supported for a raw image.</p>	
        /// </summary>	
        /// <param name="infoRef"><dd>  <p>A reference that receives <strong><see cref="SharpDX.WIC.RawCapabilitiesInfo"/></strong> that provides the capabilities supported by the raw image.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>It is recommended that a codec report that a capability is supported even if the results at the outer range limits are not of perfect quality.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::QueryRawCapabilitiesInfo']/*"/>	
        /// <msdn-id>ee690248</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::QueryRawCapabilitiesInfo([In] WICRawCapabilitiesInfo* pInfo)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::QueryRawCapabilitiesInfo</unmanaged-short>	
        public void QueryRawCapabilitiesInfo(ref SharpDX.WIC.RawCapabilitiesInfo infoRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* infoRef_ = &infoRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, infoRef_,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the desired <strong><see cref="SharpDX.WIC.RawParameterSet"/></strong> option.</p>	
        /// </summary>	
        /// <param name="parameterSet">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::LoadParameterSet']/*"/>	
        /// <msdn-id>ee690247</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::LoadParameterSet([In] WICRawParameterSet ParameterSet)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::LoadParameterSet</unmanaged-short>	
        public void LoadParameterSet(SharpDX.WIC.RawParameterSet parameterSet) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)parameterSet),((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the current set of parameters.</p>	
        /// </summary>	
        /// <param name="currentParameterSetOut"><dd>  <p>A reference that receives a reference to the current set of parameters.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetCurrentParameterSet']/*"/>	
        /// <msdn-id>ee690233</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetCurrentParameterSet([Out] IPropertyBag2** ppCurrentParameterSet)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::GetCurrentParameterSet</unmanaged-short>	
        internal void GetCurrentParameterSet(out SharpDX.Win32.PropertyBag currentParameterSetOut) {
            unsafe {
                IntPtr currentParameterSetOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &currentParameterSetOut_,((void**)(*(void**)_nativePointer))[13]);		
                currentParameterSetOut= (currentParameterSetOut_ == IntPtr.Zero)?null:new SharpDX.Win32.PropertyBag(currentParameterSetOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the exposure compensation stop value.</p>	
        /// </summary>	
        /// <param name="ev"><dd>  <p>The exposure compensation value. The value range for exposure compensation is -5.0 through +5.0, which equates to 10 full stops.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>It is recommended that a codec report that this method is supported even if the results at the outer range limits are not of perfect quality.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetExposureCompensation']/*"/>	
        /// <msdn-id>ee690251</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetExposureCompensation([In] double ev)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::SetExposureCompensation</unmanaged-short>	
        internal void SetExposureCompensation(double ev) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ev,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the exposure compensation stop value of the raw image.</p>	
        /// </summary>	
        /// <param name="eVRef"><dd>  <p>A reference that receives the exposure compensation stop value. The default is the "as-shot" setting.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetExposureCompensation']/*"/>	
        /// <msdn-id>ee690234</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetExposureCompensation([Out] double* pEV)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::GetExposureCompensation</unmanaged-short>	
        internal void GetExposureCompensation(out double eVRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* eVRef_ = &eVRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, eVRef_,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the white point RGB values.</p>	
        /// </summary>	
        /// <param name="red"><dd>  <p>The red white point value.</p> </dd></param>	
        /// <param name="green"><dd>  <p>The green white point value.</p> </dd></param>	
        /// <param name="blue"><dd>  <p>The blue white point value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Due to other white point setting methods (e.g. <strong>SetWhitePointKelvin</strong>), care must be taken by codec implementers to ensure proper interoperability. For instance, if the caller sets via a named white point then the codec implementer may whis to disable reading back the correspoinding Kelvin temperature. In specific cases where the codec implementer wishes to deny a given action because of previous calls, <strong><see cref="SharpDX.WIC.ResultCode.WrongState"/></strong> should be returned.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetWhitePointRGB']/*"/>	
        /// <msdn-id>ee690263</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetWhitePointRGB([In] unsigned int Red,[In] unsigned int Green,[In] unsigned int Blue)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::SetWhitePointRGB</unmanaged-short>	
        public void SetWhitePointRGB(int red, int green, int blue) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, red, green, blue,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the white point RGB values.</p>	
        /// </summary>	
        /// <param name="redRef"><dd>  <p>A reference that receives the red white point value.</p> </dd></param>	
        /// <param name="greenRef"><dd>  <p>A reference that receives the green white point value.</p> </dd></param>	
        /// <param name="blueRef"><dd>  <p>A reference that receives the blue white point value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetWhitePointRGB']/*"/>	
        /// <msdn-id>ee690246</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetWhitePointRGB([Out] unsigned int* pRed,[Out] unsigned int* pGreen,[Out] unsigned int* pBlue)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::GetWhitePointRGB</unmanaged-short>	
        public void GetWhitePointRGB(out int redRef, out int greenRef, out int blueRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* redRef_ = &redRef)
                    fixed (void* greenRef_ = &greenRef)
                        fixed (void* blueRef_ = &blueRef)
                            __result__= 
            				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, redRef_, greenRef_, blueRef_,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the named white point of the raw file.</p>	
        /// </summary>	
        /// <param name="whitePoint"><dd>  <p>A bitwise combination of the enumeration values.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If the named white points are not supported by the raw image or the raw file contains named white points that are not supported by this API, the codec implementer should still mark this capability as supported.</p><p>If the named white points are not supported by the raw image, a best effort should be made to adjust the image to the named white point even when it isn't a pre-defined white point of the raw file.</p><p>If the raw file containes named white points not supported by this API, the codec implementer should support the named white points in the API.</p><p>Due to other white point setting methods (e.g. <strong>SetWhitePointKelvin</strong>), care must be taken by codec implementers to ensure proper interoperability. For instance, if the caller sets via a named white point then the codec implementer may whis to disable reading back the correspoinding Kelvin temperature. In specific cases where the codec implementer wishes to deny a given action because of previous calls, <strong><see cref="SharpDX.WIC.ResultCode.WrongState"/></strong> should be returned.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetNamedWhitePoint']/*"/>	
        /// <msdn-id>ee690253</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetNamedWhitePoint([In] WICNamedWhitePoint WhitePoint)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::SetNamedWhitePoint</unmanaged-short>	
        internal void SetNamedWhitePoint(SharpDX.WIC.NamedWhitePoint whitePoint) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)whitePoint),((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the named white point of the raw image.</p>	
        /// </summary>	
        /// <param name="whitePointRef"><dd>  <p>A reference that receives the bitwise combination of the enumeration values.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If the named white points are not supported by the raw image or the raw file contains named white points that are not supported by this API, the codec implementer should still mark this capability as supported.</p><p>If the named white points are not supported by the raw image, a best effort should be made to adjust the image to the named white point even when it isn't a pre-defined white point of the raw file.</p><p>If the raw file containes named white points not supported by this API, the codec implementer should support the named white points in <strong><see cref="SharpDX.WIC.NamedWhitePoint"/></strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetNamedWhitePoint']/*"/>	
        /// <msdn-id>ee690237</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetNamedWhitePoint([Out] WICNamedWhitePoint* pWhitePoint)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::GetNamedWhitePoint</unmanaged-short>	
        internal void GetNamedWhitePoint(out SharpDX.WIC.NamedWhitePoint whitePointRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* whitePointRef_ = &whitePointRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, whitePointRef_,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the white point Kelvin value.</p>	
        /// </summary>	
        /// <param name="whitePointKelvin"><dd>  <p>The white point Kelvin value. Acceptable Kelvin values are 1,500 through 30,000.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Codec implementers should faithfully adjust the color temperature within the range supported natively by the raw image. For values outside the native support range, the codec implementer should provide a best effort representation of the image at that color temperature.</p><p>Codec implementers should return <strong><see cref="SharpDX.WIC.ResultCode.Valueoutofrange"/></strong> if the value is out of defined acceptable range.</p><p>Codec implementers must ensure proper interoperability with other white point setting methods such as <strong>SetWhitePointRGB</strong>. For example, if the caller sets the white point via <strong>SetNamedWhitePoint</strong> then the codec implementer may want to disable reading back the correspoinding Kelvin temperature. In specific cases where the codec implementer wants to deny a given action because of previous calls, <strong><see cref="SharpDX.WIC.ResultCode.WrongState"/></strong> should be returned.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetWhitePointKelvin']/*"/>	
        /// <msdn-id>ee690262</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetWhitePointKelvin([In] unsigned int WhitePointKelvin)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::SetWhitePointKelvin</unmanaged-short>	
        internal void SetWhitePointKelvin(int whitePointKelvin) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, whitePointKelvin,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the white point Kelvin temperature of the raw image.</p>	
        /// </summary>	
        /// <param name="whitePointKelvinRef"><dd>  <p>A reference that receives the white point Kelvin temperature of the raw image. The default is the "as-shot" setting value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetWhitePointKelvin']/*"/>	
        /// <msdn-id>ee690245</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetWhitePointKelvin([Out] unsigned int* pWhitePointKelvin)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::GetWhitePointKelvin</unmanaged-short>	
        internal void GetWhitePointKelvin(out int whitePointKelvinRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* whitePointKelvinRef_ = &whitePointKelvinRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, whitePointKelvinRef_,((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the information about the current Kelvin range of the raw image.</p>	
        /// </summary>	
        /// <param name="minKelvinTempRef"><dd>  <p>A reference that receives the minimum Kelvin temperature.</p> </dd></param>	
        /// <param name="maxKelvinTempRef"><dd>  <p>A reference that receives the maximum Kelvin temperature. </p> </dd></param>	
        /// <param name="kelvinTempStepValueRef"><dd>  <p>A reference that receives the Kelvin step value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetKelvinRangeInfo']/*"/>	
        /// <msdn-id>ee690236</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetKelvinRangeInfo([Out] unsigned int* pMinKelvinTemp,[Out] unsigned int* pMaxKelvinTemp,[Out] unsigned int* pKelvinTempStepValue)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::GetKelvinRangeInfo</unmanaged-short>	
        public void GetKelvinRangeInfo(out int minKelvinTempRef, out int maxKelvinTempRef, out int kelvinTempStepValueRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* minKelvinTempRef_ = &minKelvinTempRef)
                    fixed (void* maxKelvinTempRef_ = &maxKelvinTempRef)
                        fixed (void* kelvinTempStepValueRef_ = &kelvinTempStepValueRef)
                            __result__= 
            				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, minKelvinTempRef_, maxKelvinTempRef_, kelvinTempStepValueRef_,((void**)(*(void**)_nativePointer))[22]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the contrast value of the raw image.</p>	
        /// </summary>	
        /// <param name="contrast"><dd>  <p>The contrast value of the raw image.  The default value is the "as-shot" setting. The value range for contrast is 0.0 through 1.0. The 0.0 lower limit represents no contrast applied to the image, while the 1.0 upper limit represents the highest amount of contrast that can be applied.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The codec implementer must determine what the upper range value represents and must determine how to map the value to their image processing routines.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetContrast']/*"/>	
        /// <msdn-id>ee690249</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetContrast([In] double Contrast)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::SetContrast</unmanaged-short>	
        internal void SetContrast(double contrast) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, contrast,((void**)(*(void**)_nativePointer))[23]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the contrast value of the raw image.</p>	
        /// </summary>	
        /// <param name="contrastRef"><dd>  <p>A reference that receives the contrast value of the raw image. The default value is the "as-shot" setting. The value range for contrast is 0.0 through 1.0. The 0.0 lower limit represents no contrast applied to the image, while the 1.0 upper limit represents the highest amount of contrast that can be applied.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetContrast']/*"/>	
        /// <msdn-id>ee690232</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetContrast([Out] double* pContrast)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::GetContrast</unmanaged-short>	
        internal void GetContrast(out double contrastRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* contrastRef_ = &contrastRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, contrastRef_,((void**)(*(void**)_nativePointer))[24]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the desired gamma value.</p>	
        /// </summary>	
        /// <param name="gamma"><dd>  <p>The desired gamma value.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetGamma']/*"/>	
        /// <msdn-id>ee690252</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetGamma([In] double Gamma)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::SetGamma</unmanaged-short>	
        internal void SetGamma(double gamma) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, gamma,((void**)(*(void**)_nativePointer))[25]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the current gamma setting of the raw image.</p>	
        /// </summary>	
        /// <param name="gammaRef"><dd>  <p>A reference that receives the current gamma setting.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetGamma']/*"/>	
        /// <msdn-id>ee690235</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetGamma([Out] double* pGamma)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::GetGamma</unmanaged-short>	
        internal void GetGamma(out double gammaRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* gammaRef_ = &gammaRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, gammaRef_,((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the sharpness value of the raw image.</p>	
        /// </summary>	
        /// <param name="sharpness"><dd>  <p>The sharpness value of the raw image. The default value is the "as-shot" setting. The value range for sharpness is 0.0 through 1.0. The 0.0 lower limit represents no sharpening applied to the image, while the 1.0 upper limit represents the highest amount of sharpness that can be applied.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The codec implementer must determine what the upper range value represents and must determine how to map the value to their image processing routines.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetSharpness']/*"/>	
        /// <msdn-id>ee690259</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetSharpness([In] double Sharpness)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::SetSharpness</unmanaged-short>	
        internal void SetSharpness(double sharpness) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, sharpness,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the sharpness value of the raw image.</p>	
        /// </summary>	
        /// <param name="sharpnessRef"><dd>  <p>A reference that receives the sharpness value of the raw image. The default value is the "as-shot" setting. The value range for sharpness is 0.0 through 1.0. The 0.0 lower limit represents no sharpening applied to the image, while the 1.0 upper limit represents the highest amount of sharpness that can be applied.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetSharpness']/*"/>	
        /// <msdn-id>ee690242</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetSharpness([Out] double* pSharpness)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::GetSharpness</unmanaged-short>	
        internal void GetSharpness(out double sharpnessRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* sharpnessRef_ = &sharpnessRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, sharpnessRef_,((void**)(*(void**)_nativePointer))[28]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the saturation value of the raw image.</p>	
        /// </summary>	
        /// <param name="saturation"><dd>  <p>The saturation value of the raw image. The value range for saturation is 0.0 through 1.0. A value of 0.0 represents an image with a fully de-saturated image, while a value of 1.0 represents the highest amount of saturation that can be applied.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The codec implementer must determine what the upper range value represents and must determine how to map the value to their image processing routines.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetSaturation']/*"/>	
        /// <msdn-id>ee690258</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetSaturation([In] double Saturation)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::SetSaturation</unmanaged-short>	
        internal void SetSaturation(double saturation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, saturation,((void**)(*(void**)_nativePointer))[29]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the saturation value of the raw image.</p>	
        /// </summary>	
        /// <param name="saturationRef"><dd>  <p>A reference that receives the saturation value of the raw image. The default value is the "as-shot" setting. The value range for saturation is 0.0 through 1.0. A value of 0.0 represents an image with a fully de-saturated image, while a value of 1.0 represents the highest amount of saturation that can be applied.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetSaturation']/*"/>	
        /// <msdn-id>ee690241</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetSaturation([Out] double* pSaturation)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::GetSaturation</unmanaged-short>	
        internal void GetSaturation(out double saturationRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* saturationRef_ = &saturationRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, saturationRef_,((void**)(*(void**)_nativePointer))[30]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the tint value of the raw image.</p>	
        /// </summary>	
        /// <param name="tint"><dd>  <p>The tint value of the raw image. The default value is the "as-shot" setting if it exists or 0.0. The value range for sharpness is -1.0 through +1.0. The -1.0 lower limit represents a full green bias to the image, while the 1.0 upper limit represents a full magenta bias.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The codec implementer must determine what the outer range values represent and must determine how to map the values to their image processing routines.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetTint']/*"/>	
        /// <msdn-id>ee690260</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetTint([In] double Tint)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::SetTint</unmanaged-short>	
        internal void SetTint(double tint) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, tint,((void**)(*(void**)_nativePointer))[31]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the tint value of the raw image.</p>	
        /// </summary>	
        /// <param name="tintRef"><dd>  <p>A reference that receives the tint value of the raw image. The default value is the "as-shot" setting if it exists or 0.0. The value range for sharpness is -1.0 through +1.0. The -1.0 lower limit represents a full green bias to the image, while the 1.0 upper limit represents a full magenta bias.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetTint']/*"/>	
        /// <msdn-id>ee690243</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetTint([Out] double* pTint)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::GetTint</unmanaged-short>	
        internal void GetTint(out double tintRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* tintRef_ = &tintRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, tintRef_,((void**)(*(void**)_nativePointer))[32]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the noise reduction value of the raw image.</p>	
        /// </summary>	
        /// <param name="noiseReduction"><dd>  <p>The noise reduction value of the raw image.  The default value is the "as-shot" setting if it exists or 0.0. The value range for noise reduction is 0.0 through 1.0. The 0.0 lower limit represents no noise reduction applied to the image, while the 1.0 upper limit represents highest noise reduction amount that can be applied.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The codec implementer must determine what the upper range value represents and must determine how to map the value to their image processing routines.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetNoiseReduction']/*"/>	
        /// <msdn-id>ee690254</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetNoiseReduction([In] double NoiseReduction)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::SetNoiseReduction</unmanaged-short>	
        internal void SetNoiseReduction(double noiseReduction) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, noiseReduction,((void**)(*(void**)_nativePointer))[33]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the noise reduction value of the raw image.</p>	
        /// </summary>	
        /// <param name="noiseReductionRef"><dd>  <p>A reference that receives the noise reduction value of the raw image.  The default value is the "as-shot" setting if it exists or 0.0. The value range for noise reduction is 0.0 through 1.0. The 0.0 lower limit represents no noise reduction applied to the image, while the 1.0 upper limit represents full highest noise reduction amount that can be applied.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetNoiseReduction']/*"/>	
        /// <msdn-id>ee690238</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetNoiseReduction([Out] double* pNoiseReduction)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::GetNoiseReduction</unmanaged-short>	
        internal void GetNoiseReduction(out double noiseReductionRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* noiseReductionRef_ = &noiseReductionRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, noiseReductionRef_,((void**)(*(void**)_nativePointer))[34]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the destination color context.</p>	
        /// </summary>	
        /// <param name="colorContextRef"><dd>  <p>The destination color context.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetDestinationColorContext']/*"/>	
        /// <msdn-id>ee690250</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetDestinationColorContext([In, Optional] IWICColorContext* pColorContext)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::SetDestinationColorContext</unmanaged-short>	
        internal void SetDestinationColorContext(SharpDX.WIC.ColorContext colorContextRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((colorContextRef == null)?IntPtr.Zero:colorContextRef.NativePointer),((void**)(*(void**)_nativePointer))[35]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the tone curve for the raw image.</p>	
        /// </summary>	
        /// <param name="toneCurveSize"><dd>  <p>The size of the <em>pToneCurve</em> structure.</p> </dd></param>	
        /// <param name="toneCurveRef"><dd>  <p>The desired tone curve.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetToneCurve']/*"/>	
        /// <msdn-id>ee690261</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetToneCurve([In] unsigned int cbToneCurveSize,[In, Buffer] const WICRawToneCurve* pToneCurve)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::SetToneCurve</unmanaged-short>	
        public void SetToneCurve(int toneCurveSize, SharpDX.WIC.RawToneCurve[] toneCurveRef) {
            unsafe {
                SharpDX.WIC.RawToneCurve.__Native[] toneCurveRef__ = new SharpDX.WIC.RawToneCurve.__Native[toneCurveRef.Length];
                for (int i = 0; i < toneCurveRef.Length; i++)
                    toneCurveRef[i].__MarshalTo(ref toneCurveRef__[i]);				
                SharpDX.Result __result__;
                fixed (void* toneCurveRef_ = toneCurveRef__)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, toneCurveSize, toneCurveRef_,((void**)(*(void**)_nativePointer))[36]);		
                for (int i = 0; i < toneCurveRef.Length; i++)
                    toneCurveRef[i].__MarshalFree(ref toneCurveRef__[i]);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the tone curve of the raw image.</p>	
        /// </summary>	
        /// <param name="toneCurveBufferSize"><dd>  <p>The size of the <em>pToneCurve</em> buffer.</p> </dd></param>	
        /// <param name="toneCurveRef"><dd>  <p>A reference that receives the <strong><see cref="SharpDX.WIC.RawToneCurve"/></strong> of the raw image.</p> </dd></param>	
        /// <param name="actualToneCurveBufferSizeRef"><dd>  <p>A reference that receives the size needed to obtain the tone curve structure.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetToneCurve']/*"/>	
        /// <msdn-id>ee690244</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetToneCurve([In] unsigned int cbToneCurveBufferSize,[Out, Buffer, Optional] WICRawToneCurve* pToneCurve,[InOut, Optional] unsigned int* pcbActualToneCurveBufferSize)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::GetToneCurve</unmanaged-short>	
        public void GetToneCurve(int toneCurveBufferSize, SharpDX.WIC.RawToneCurve[] toneCurveRef, System.IntPtr actualToneCurveBufferSizeRef) {
            unsafe {
                SharpDX.WIC.RawToneCurve.__Native[] toneCurveRef__ = (toneCurveRef == null)? null : new SharpDX.WIC.RawToneCurve.__Native[toneCurveRef.Length];
                SharpDX.Result __result__;
                fixed (void* toneCurveRef_ = toneCurveRef__)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, toneCurveBufferSize, toneCurveRef_, (void*)actualToneCurveBufferSizeRef,((void**)(*(void**)_nativePointer))[37]);		
                for (int i = 0; i < toneCurveRef.Length; i++)
                    toneCurveRef[i].__MarshalFrom(ref toneCurveRef__[i]);				
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the desired rotation angle.</p>	
        /// </summary>	
        /// <param name="rotation"><dd>  <p>The desired rotation angle.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetRotation']/*"/>	
        /// <msdn-id>ee690257</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetRotation([In] double Rotation)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::SetRotation</unmanaged-short>	
        internal void SetRotation(double rotation) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, rotation,((void**)(*(void**)_nativePointer))[38]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the current rotation angle.</p>	
        /// </summary>	
        /// <param name="rotationRef"><dd>  <p>A reference that receives the current rotation angle.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetRotation']/*"/>	
        /// <msdn-id>ee690240</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetRotation([Out] double* pRotation)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::GetRotation</unmanaged-short>	
        internal void GetRotation(out double rotationRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* rotationRef_ = &rotationRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, rotationRef_,((void**)(*(void**)_nativePointer))[39]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the current <strong><see cref="SharpDX.WIC.RawRenderMode"/></strong>.</p>	
        /// </summary>	
        /// <param name="renderMode">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetRenderMode']/*"/>	
        /// <msdn-id>ee690256</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetRenderMode([In] WICRawRenderMode RenderMode)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::SetRenderMode</unmanaged-short>	
        internal void SetRenderMode(SharpDX.WIC.RawRenderMode renderMode) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)renderMode),((void**)(*(void**)_nativePointer))[40]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the current <strong><see cref="SharpDX.WIC.RawRenderMode"/></strong>.</p>	
        /// </summary>	
        /// <param name="renderModeRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::GetRenderMode']/*"/>	
        /// <msdn-id>ee690239</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::GetRenderMode([Out] WICRawRenderMode* pRenderMode)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::GetRenderMode</unmanaged-short>	
        internal void GetRenderMode(out SharpDX.WIC.RawRenderMode renderModeRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* renderModeRef_ = &renderModeRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, renderModeRef_,((void**)(*(void**)_nativePointer))[41]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the notification callback method.</p>	
        /// </summary>	
        /// <param name="callbackRef"><dd>  <p>Pointer to the notification callback method.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRaw::SetNotificationCallback']/*"/>	
        /// <msdn-id>ee690255</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRaw::SetNotificationCallback([In, Optional] IWICDevelopRawNotificationCallback* pCallback)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRaw::SetNotificationCallback</unmanaged-short>	
        internal void SetNotificationCallback(SharpDX.WIC.DevelopRawNotificationCallback callbackRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((callbackRef == null)?IntPtr.Zero:callbackRef.NativePointer),((void**)(*(void**)_nativePointer))[42]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes a callback method for raw image change nofications.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRawNotificationCallback']/*"/>	
    /// <msdn-id>ee690229</msdn-id>	
    /// <unmanaged>IWICDevelopRawNotificationCallback</unmanaged>	
    /// <unmanaged-short>IWICDevelopRawNotificationCallback</unmanaged-short>	
    [Guid("95c75a6e-3e8c-4ec2-85a8-aebcc551e59b")]
    internal partial class DevelopRawNotificationCallback : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.DevelopRawNotificationCallback"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DevelopRawNotificationCallback(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.DevelopRawNotificationCallback"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.DevelopRawNotificationCallback(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.DevelopRawNotificationCallback(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>An application-defined callback method used for raw image parameter change notifications.</p>	
        /// </summary>	
        /// <param name="notificationMask"><dd>  <p>A set of <strong><see cref="SharpDX.WIC.DevelopRawNotificationCallback"/> Constants</strong> parameter notification flags.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICDevelopRawNotificationCallback::Notify']/*"/>	
        /// <msdn-id>ee690230</msdn-id>	
        /// <unmanaged>HRESULT IWICDevelopRawNotificationCallback::Notify([In] unsigned int NotificationMask)</unmanaged>	
        /// <unmanaged-short>IWICDevelopRawNotificationCallback::Notify</unmanaged-short>	
        public void Notify(int notificationMask) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, notificationMask,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods that provide enumeration services for individual metadata items.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICEnumMetadataItem']/*"/>	
    /// <msdn-id>ee690264</msdn-id>	
    /// <unmanaged>IWICEnumMetadataItem</unmanaged>	
    /// <unmanaged-short>IWICEnumMetadataItem</unmanaged-short>	
    [Guid("DC2BB46D-3F07-481E-8625-220C4AEDBB33")]
    internal partial class EnumMetadataItem : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.EnumMetadataItem"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EnumMetadataItem(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.EnumMetadataItem"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.EnumMetadataItem(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.EnumMetadataItem(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Skips to given number of objects.</p>	
        /// </summary>	
        /// <param name="celt"><dd>  <p>The number of objects to skip.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICEnumMetadataItem::Skip']/*"/>	
        /// <msdn-id>ee690268</msdn-id>	
        /// <unmanaged>HRESULT IWICEnumMetadataItem::Skip([In] unsigned int celt)</unmanaged>	
        /// <unmanaged-short>IWICEnumMetadataItem::Skip</unmanaged-short>	
        public void Skip(int celt) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, celt,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Resets the current position to the beginning of the enumeration.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICEnumMetadataItem::Reset']/*"/>	
        /// <msdn-id>ee690267</msdn-id>	
        /// <unmanaged>HRESULT IWICEnumMetadataItem::Reset()</unmanaged>	
        /// <unmanaged-short>IWICEnumMetadataItem::Reset</unmanaged-short>	
        public void Reset() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a copy of the current <strong><see cref="SharpDX.WIC.EnumMetadataItem"/></strong>.</p>	
        /// </summary>	
        /// <param name="enumMetadataItemOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICEnumMetadataItem::Clone']/*"/>	
        /// <msdn-id>ee690265</msdn-id>	
        /// <unmanaged>HRESULT IWICEnumMetadataItem::Clone([Out] IWICEnumMetadataItem** ppIEnumMetadataItem)</unmanaged>	
        /// <unmanaged-short>IWICEnumMetadataItem::Clone</unmanaged-short>	
        public void Clone(out SharpDX.WIC.EnumMetadataItem enumMetadataItemOut) {
            unsafe {
                IntPtr enumMetadataItemOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &enumMetadataItemOut_,((void**)(*(void**)_nativePointer))[6]);		
                enumMetadataItemOut= (enumMetadataItemOut_ == IntPtr.Zero)?null:new SharpDX.WIC.EnumMetadataItem(enumMetadataItemOut_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods used for in-place metadata editing. A fast metadata encoder enables you to add and remove metadata to an image without having to fully re-encode the image.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p> A decoder must be created using the <strong><see cref="SharpDX.WIC.DecodeOptions"/></strong> value <strong><see cref="SharpDX.WIC.DecodeOptions.CacheOnDemand"/></strong> to perform in-place metadata updates.  Using the <strong><see cref="SharpDX.WIC.DecodeOptions.CacheOnLoad"/></strong> option causes the decoder to release the file stream necessary to perform the metadata updates.  </p><p> Not all metadata formats support fast metadata encoding. The native metadata handlers that support metadata are IFD, Exif, XMP, and GPS. </p><p> If a fast metadata encoder fails, the image will need to be fully re-encoded to add the metadata. </p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICFastMetadataEncoder']/*"/>	
    /// <msdn-id>ee690269</msdn-id>	
    /// <unmanaged>IWICFastMetadataEncoder</unmanaged>	
    /// <unmanaged-short>IWICFastMetadataEncoder</unmanaged-short>	
    [Guid("B84E2C09-78C9-4AC4-8BD3-524AE1663A2F")]
    public partial class FastMetadataEncoder : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.FastMetadataEncoder"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FastMetadataEncoder(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.FastMetadataEncoder"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.FastMetadataEncoder(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.FastMetadataEncoder(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves a metadata query writer for fast metadata encoding.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICFastMetadataEncoder::GetMetadataQueryWriter']/*"/>	
        /// <msdn-id>ee690272</msdn-id>	
        /// <unmanaged>GetMetadataQueryWriter</unmanaged>	
        /// <unmanaged-short>GetMetadataQueryWriter</unmanaged-short>	
        /// <unmanaged>HRESULT IWICFastMetadataEncoder::GetMetadataQueryWriter([Out] IWICMetadataQueryWriter** ppIMetadataQueryWriter)</unmanaged>
        public SharpDX.WIC.MetadataQueryWriter MetadataQueryWriter {
                get { SharpDX.WIC.MetadataQueryWriter __output__; GetMetadataQueryWriter(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Finalizes metadata changes to the image stream.</p>	
        /// </summary>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If the commit fails and returns <strong><see cref="SharpDX.WIC.ResultCode.StreamNotAvailable"/></strong>, ensure that the image decoder was loaded using the <strong><see cref="SharpDX.WIC.DecodeOptions.CacheOnDemand"/></strong> option. A fast metadata encoder is not supported when the decoder is created using the <strong><see cref="SharpDX.WIC.DecodeOptions.CacheOnLoad"/></strong> option. </p><p>If the commit fails for any reason, you will need to re-encode the image to ensure the new metadata is added to the image.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICFastMetadataEncoder::Commit']/*"/>	
        /// <msdn-id>ee690270</msdn-id>	
        /// <unmanaged>HRESULT IWICFastMetadataEncoder::Commit()</unmanaged>	
        /// <unmanaged-short>IWICFastMetadataEncoder::Commit</unmanaged-short>	
        public void Commit() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a metadata query writer for fast metadata encoding.</p>	
        /// </summary>	
        /// <param name="metadataQueryWriterOut"><dd>  <p>When this method returns, contains a reference to the fast metadata encoder's metadata query writer.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICFastMetadataEncoder::GetMetadataQueryWriter']/*"/>	
        /// <msdn-id>ee690272</msdn-id>	
        /// <unmanaged>HRESULT IWICFastMetadataEncoder::GetMetadataQueryWriter([Out] IWICMetadataQueryWriter** ppIMetadataQueryWriter)</unmanaged>	
        /// <unmanaged-short>IWICFastMetadataEncoder::GetMetadataQueryWriter</unmanaged-short>	
        internal void GetMetadataQueryWriter(out SharpDX.WIC.MetadataQueryWriter metadataQueryWriterOut) {
            unsafe {
                IntPtr metadataQueryWriterOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &metadataQueryWriterOut_,((void**)(*(void**)_nativePointer))[4]);		
                metadataQueryWriterOut= (metadataQueryWriterOut_ == IntPtr.Zero)?null:new SharpDX.WIC.MetadataQueryWriter(metadataQueryWriterOut_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p> Represents an <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> that provides converts the image data from one pixel format to another, handling dithering and halftoning to indexed formats, palette translation and alpha thresholding. </p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICFormatConverter']/*"/>	
    /// <msdn-id>ee690274</msdn-id>	
    /// <unmanaged>IWICFormatConverter</unmanaged>	
    /// <unmanaged-short>IWICFormatConverter</unmanaged-short>	
    [Guid("00000301-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class FormatConverter : SharpDX.WIC.BitmapSource {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.FormatConverter"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FormatConverter(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.FormatConverter"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.FormatConverter(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.FormatConverter(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Initializes the format converter.</p>	
        /// </summary>	
        /// <param name="sourceRef"><dd>  <p>The input bitmap to convert</p> </dd></param>	
        /// <param name="dstFormat"><dd>  <p>The destination pixel format <see cref="System.Guid"/>.</p> </dd></param>	
        /// <param name="dither"><dd>  <p>The <strong><see cref="SharpDX.WIC.BitmapDitherType"/></strong> used for conversion.</p> </dd></param>	
        /// <param name="paletteRef"><dd>  <p>The palette to use for conversion.</p> </dd></param>	
        /// <param name="alphaThresholdPercent"><dd>  <p>The alpha threshold to use for conversion.</p> </dd></param>	
        /// <param name="paletteTranslate"><dd>  <p>The palette translation type to use for conversion.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> If you do not have a predefined palette, you must first create one. Use <strong>InitializeFromBitmap</strong> to create the palette object, then pass it in along with your other parameters. </p><p><em>dither</em>, <em>pIPalette</em>, <em>alphaThresholdPercent</em>, and <em>paletteTranslate</em> are used to mitigate color loss when converting to a reduced bit-depth format. For conversions that do not need these settings, the following parameters values should be used: <em>dither</em> set to <strong><see cref="SharpDX.WIC.BitmapDitherType.None"/></strong>, <em>pIPalette</em> set to <strong><c>null</c></strong>, <em>alphaThresholdPercent</em> set to <strong>0.0f</strong>, and <em>paletteTranslate</em> set to <strong><see cref="SharpDX.WIC.BitmapPaletteType.Custom"/></strong>.   </p><p> The basic algorithm involved when using an ordered dither requires a fixed palette, found in the <strong><see cref="SharpDX.WIC.BitmapPaletteType"/></strong> enumeration, in a specific order. Often, the actual palette provided for the output may have a different ordering or some slight variation in the actual colors.  This is the case when using the Microsoft?Windows palette which has slight differences among versions of Windows. To provide for this, a palette and a palette translation are given to the format converter.  The <em>pIPalette</em> is the actual destination palette to be used and the <em>paletteTranslate</em> is a fixed palette.  Once the conversion is complete, the colors are mapped from the fixed palette to the actual colors in <em>pIPalette</em> using a nearest color matching algorithm.  </p><p> If colors in <em>pIPalette</em> do not closely match those in <em>paletteTranslate</em>, the mapping may produce undesireable results. </p><p><strong><see cref="SharpDX.WIC.BitmapDitherType.Ordered4x4"/></strong> can be useful in format conversions from 8-bit formats to 5- or 6-bit formats as there is no way to accurately convert color data. </p><p><strong><see cref="SharpDX.WIC.BitmapDitherType.ErrorDiffusion"/></strong> selects the error diffusion algorithm and may be used with any palette.  If an arbitrary palette is provided, <strong>WICBitmapPaletteCustom</strong> should be passed in as the <em>paletteTranslate</em>.  Error diffusion often provides superior results compared to the ordered dithering algorithms especially when combined with the optimized palette generation functionality on the <strong><see cref="SharpDX.WIC.Palette"/></strong>. </p><p> When converting a bitmap which has an alpha channel, such as a Portable Network Graphics (PNG), to 8bpp, the alpha channel is normally ignored.  Any pixels which were transparent in the original bitmap show up as black in the final output because both transparent and black have pixel values of zero in the respective formats.  </p><p> Some 8bpp content can contains an alpha color; for instance, the Graphics Interchange Format (GIF) format allows for a single palette entry to be used as a transparent color. For this type of content, <em>alphaThresholdPercent</em> specifies what percentage of transparency should map to the transparent color. Because the alpha value is directly proportional to the opacity (not transparency) of a pixel, the <em>alphaThresholdPercent</em> indicates what level of opacity is mapped to the fully transparent color.  For instance, 9.8% implies that any pixel with an alpha value of less than 25 will be mapped to the transparent color.  A value of 100% maps all pixels which are not fully opaque to the transparent color. Note that the palette should provide a transparent color. If it does not, the 'transparent' color will be the one closest to zero - often black. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICFormatConverter::Initialize']/*"/>	
        /// <msdn-id>ee690279</msdn-id>	
        /// <unmanaged>HRESULT IWICFormatConverter::Initialize([In, Optional] IWICBitmapSource* pISource,[In] const GUID&amp; dstFormat,[In] WICBitmapDitherType dither,[In, Optional] IWICPalette* pIPalette,[In] double alphaThresholdPercent,[In] WICBitmapPaletteType paletteTranslate)</unmanaged>	
        /// <unmanaged-short>IWICFormatConverter::Initialize</unmanaged-short>	
        public void Initialize(SharpDX.WIC.BitmapSource sourceRef, System.Guid dstFormat, SharpDX.WIC.BitmapDitherType dither, SharpDX.WIC.Palette paletteRef, double alphaThresholdPercent, SharpDX.WIC.BitmapPaletteType paletteTranslate) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((sourceRef == null)?IntPtr.Zero:sourceRef.NativePointer), &dstFormat, unchecked((int)dither), (void*)((paletteRef == null)?IntPtr.Zero:paletteRef.NativePointer), alphaThresholdPercent, unchecked((int)paletteTranslate),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Determines if the source pixel format can be converted to the destination pixel format.</p>	
        /// </summary>	
        /// <param name="srcPixelFormat"><dd>  <p>The source pixel format.</p> </dd></param>	
        /// <param name="dstPixelFormat"><dd>  <p>The destionation pixel format.</p> </dd></param>	
        /// <returns><dd>  <p>A reference that receives a value indicating whether the source pixel format can be converted to the destination pixel format.</p> </dd></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICFormatConverter::CanConvert']/*"/>	
        /// <msdn-id>ee690278</msdn-id>	
        /// <unmanaged>HRESULT IWICFormatConverter::CanConvert([In] const GUID&amp; srcPixelFormat,[In] const GUID&amp; dstPixelFormat,[Out] BOOL* pfCanConvert)</unmanaged>	
        /// <unmanaged-short>IWICFormatConverter::CanConvert</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool CanConvert(System.Guid srcPixelFormat, System.Guid dstPixelFormat) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool fCanConvertRef;
                fCanConvertRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &srcPixelFormat, &dstPixelFormat, &fCanConvertRef,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
                return fCanConvertRef;
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods that provide information about a pixel format converter.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICFormatConverterInfo']/*"/>	
    /// <msdn-id>ee690275</msdn-id>	
    /// <unmanaged>IWICFormatConverterInfo</unmanaged>	
    /// <unmanaged-short>IWICFormatConverterInfo</unmanaged-short>	
    [Guid("9F34FB65-13F4-4f15-BC57-3726B5E53D9F")]
    public partial class FormatConverterInfo : SharpDX.WIC.ComponentInfo {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.FormatConverterInfo"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public FormatConverterInfo(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.FormatConverterInfo"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.FormatConverterInfo(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.FormatConverterInfo(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves a list of GUIDs that signify which pixel formats the converter supports.</p>	
        /// </summary>	
        /// <param name="formats"><dd>  <p>The size of the <em>pPixelFormatGUIDs</em> array.</p> </dd></param>	
        /// <param name="pixelFormatGUIDsRef"><dd>  <p>Pointer to a <see cref="System.Guid"/> array that receives the pixel formats the converter supports.</p> </dd></param>	
        /// <param name="actualRef"><dd>  <p>The actual array size needed to retrieve all pixel formats supported by the converter.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The format converter does not necessarily guarantee symmetricality with respect to conversion; that is, a converter may be able to convert FROM a particular format without actually being able to convert TO a particular format. In order to test symmetricality, use <strong>CanConvert</strong>.</p><p>To determine the number of pixel formats a coverter can handle, set <em>cFormats</em> to <code>0</code> and <em>pPixelFormatGUIDs</em> to <code><c>null</c></code>. The converter will fill <em>pcActual</em> with the number of formats supported by that converter.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICFormatConverterInfo::GetPixelFormats']/*"/>	
        /// <msdn-id>ee690277</msdn-id>	
        /// <unmanaged>HRESULT IWICFormatConverterInfo::GetPixelFormats([In] unsigned int cFormats,[In] void* pPixelFormatGUIDs,[Out] unsigned int* pcActual)</unmanaged>	
        /// <unmanaged-short>IWICFormatConverterInfo::GetPixelFormats</unmanaged-short>	
        internal void GetPixelFormats(int formats, System.IntPtr pixelFormatGUIDsRef, out int actualRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* actualRef_ = &actualRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, formats, (void*)pixelFormatGUIDsRef, actualRef_,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new <strong><see cref="SharpDX.WIC.FormatConverter"/></strong> instance.</p>	
        /// </summary>	
        /// <param name="converterOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICFormatConverterInfo::CreateInstance']/*"/>	
        /// <msdn-id>ee690276</msdn-id>	
        /// <unmanaged>HRESULT IWICFormatConverterInfo::CreateInstance([Out, Fast] IWICFormatConverter** ppIConverter)</unmanaged>	
        /// <unmanaged-short>IWICFormatConverterInfo::CreateInstance</unmanaged-short>	
        internal void CreateInstance(SharpDX.WIC.FormatConverter converterOut) {
            unsafe {
                IntPtr converterOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &converterOut_,((void**)(*(void**)_nativePointer))[12]);		
                ((SharpDX.WIC.FormatConverter)converterOut).NativePointer = converterOut_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Encodes <strong><see cref="SharpDX.Direct2D1.Image"/></strong> interfaces to an <strong><see cref="SharpDX.WIC.BitmapEncoder"/></strong>.  The input images can be larger than the maximum device texture size.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImageEncoder']/*"/>	
    /// <msdn-id>hh880844</msdn-id>	
    /// <unmanaged>IWICImageEncoder</unmanaged>	
    /// <unmanaged-short>IWICImageEncoder</unmanaged-short>	
    [Guid("04C75BF8-3CE1-473B-ACC5-3CC4F5E94999")]
    public partial class ImageEncoder : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.ImageEncoder"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ImageEncoder(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.ImageEncoder"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.ImageEncoder(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.ImageEncoder(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Encodes the image to the frame given by the <strong><see cref="SharpDX.WIC.BitmapFrameEncode"/></strong>.</p>	
        /// </summary>	
        /// <param name="imageRef">No documentation.</param>	
        /// <param name="frameEncodeRef">No documentation.</param>	
        /// <param name="imageParametersRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The image passed in must be created on the same device as in <strong><see cref="SharpDX.WIC.ImagingFactory2.CreateImageEncoder"/></strong>. If the <em>pImageParameters</em> are not specified, a set of useful defaults will be assumed, see <strong><see cref="SharpDX.WIC.ImageParameters"/></strong> for more info. </p><p>You must correctly and independently have set up the <see cref="SharpDX.WIC.BitmapFrameEncode"/> before calling this API.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImageEncoder::WriteFrame']/*"/>	
        /// <msdn-id>hh880845</msdn-id>	
        /// <unmanaged>HRESULT IWICImageEncoder::WriteFrame([In] ID2D1Image* pImage,[In] IWICBitmapFrameEncode* pFrameEncode,[In, Value] const WICImageParameters* pImageParameters)</unmanaged>	
        /// <unmanaged-short>IWICImageEncoder::WriteFrame</unmanaged-short>	
        public void WriteFrame(SharpDX.Direct2D1.Image imageRef, SharpDX.WIC.BitmapFrameEncode frameEncodeRef, SharpDX.WIC.ImageParameters imageParametersRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((imageRef == null)?IntPtr.Zero:imageRef.NativePointer), (void*)((frameEncodeRef == null)?IntPtr.Zero:frameEncodeRef.NativePointer), &imageParametersRef,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Encodes the image as a thumbnail to the frame given by the <strong><see cref="SharpDX.WIC.BitmapFrameEncode"/></strong>. </p>	
        /// </summary>	
        /// <param name="imageRef">No documentation.</param>	
        /// <param name="frameEncodeRef">No documentation.</param>	
        /// <param name="imageParametersRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The image passed in must be created on the same device as in <strong><see cref="SharpDX.WIC.ImagingFactory2.CreateImageEncoder"/></strong>. If the <em>pImageParameters</em> are not specified, a set of useful defaults will be assumed, see <strong><see cref="SharpDX.WIC.ImageParameters"/></strong> for more info. </p><p>You must correctly and independently have set up the <strong><see cref="SharpDX.WIC.BitmapFrameEncode"/></strong> before calling this API.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImageEncoder::WriteFrameThumbnail']/*"/>	
        /// <msdn-id>hh880846</msdn-id>	
        /// <unmanaged>HRESULT IWICImageEncoder::WriteFrameThumbnail([In] ID2D1Image* pImage,[In] IWICBitmapFrameEncode* pFrameEncode,[In, Value] const WICImageParameters* pImageParameters)</unmanaged>	
        /// <unmanaged-short>IWICImageEncoder::WriteFrameThumbnail</unmanaged-short>	
        public void WriteFrameThumbnail(SharpDX.Direct2D1.Image imageRef, SharpDX.WIC.BitmapFrameEncode frameEncodeRef, SharpDX.WIC.ImageParameters imageParametersRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((imageRef == null)?IntPtr.Zero:imageRef.NativePointer), (void*)((frameEncodeRef == null)?IntPtr.Zero:frameEncodeRef.NativePointer), &imageParametersRef,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Encodes the given image as the thumbnail to the given WIC bitmap encoder.</p>	
        /// </summary>	
        /// <param name="imageRef"><dd>  <p>The Direct2D image that will be encoded.</p> </dd></param>	
        /// <param name="encoderRef"><dd>  <p>The encoder on which the thumbnail is set.</p> </dd></param>	
        /// <param name="imageParametersRef"><dd>  <p>Additional parameters to control encoding.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>You must create the image that you pass in on the same device as in <strong><see cref="SharpDX.WIC.ImagingFactory2.CreateImageEncoder"/></strong>. If you don't specify additional parameters in the variable that <em>pImageParameters</em> points to, the encoder uses a set of useful defaults. For info about these defaults, see <strong><see cref="SharpDX.WIC.ImageParameters"/></strong>. </p><p>Before you call <strong>WriteThumbnail</strong>, you must set up the <strong><see cref="SharpDX.WIC.BitmapEncoder"/></strong> interface for the encoder on which you want to set the thumbnail. </p><p>If <strong>WriteThumbnail</strong> fails, it might return E_OUTOFMEMORY, <see cref="SharpDX.Direct2D1.ResultCode.WrongResourceDomain"/>, or other error codes from the encoder.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImageEncoder::WriteThumbnail']/*"/>	
        /// <msdn-id>hh880847</msdn-id>	
        /// <unmanaged>HRESULT IWICImageEncoder::WriteThumbnail([In] ID2D1Image* pImage,[In] IWICBitmapEncoder* pEncoder,[In, Value] const WICImageParameters* pImageParameters)</unmanaged>	
        /// <unmanaged-short>IWICImageEncoder::WriteThumbnail</unmanaged-short>	
        public void WriteThumbnail(SharpDX.Direct2D1.Image imageRef, SharpDX.WIC.BitmapEncoder encoderRef, SharpDX.WIC.ImageParameters imageParametersRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((imageRef == null)?IntPtr.Zero:imageRef.NativePointer), (void*)((encoderRef == null)?IntPtr.Zero:encoderRef.NativePointer), &imageParametersRef,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods used to create components for the Windows Imaging Component (WIC) such as decoders, encoders and pixel format converters.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory']/*"/>	
    /// <msdn-id>ee690281</msdn-id>	
    /// <unmanaged>IWICImagingFactory</unmanaged>	
    /// <unmanaged-short>IWICImagingFactory</unmanaged-short>	
    [Guid("ec5ec8a9-c395-4314-9c77-54d7a935ff70")]
    public partial class ImagingFactory : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.ImagingFactory"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ImagingFactory(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.ImagingFactory"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.ImagingFactory(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.ImagingFactory(nativePointer);
		}
        
        
        /// <summary>Constant WICImagingFactoryClsid.</summary>
        /// <unmanaged>CLSID_WICImagingFactory</unmanaged>
        public static readonly System.Guid WICImagingFactoryClsid = new System.Guid("cacaf262-9370-4615-a13b-9f5539da4c0a");
        
        /// <summary>	
        /// <p>Creates a new instance of the <strong><see cref="SharpDX.WIC.BitmapDecoder"/></strong> class based on the given file.</p>	
        /// </summary>	
        /// <param name="filename">No documentation.</param>	
        /// <param name="guidVendorRef">No documentation.</param>	
        /// <param name="desiredAccess">No documentation.</param>	
        /// <param name="metadataOptions">No documentation.</param>	
        /// <param name="decoderOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateDecoderFromFilename']/*"/>	
        /// <msdn-id>ee690307</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromFilename([In] const wchar_t* wzFilename,[In, Optional] const GUID* pguidVendor,[In] unsigned int dwDesiredAccess,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateDecoderFromFilename</unmanaged-short>	
        internal void CreateDecoderFromFilename(string filename, System.Guid? guidVendorRef, int desiredAccess, SharpDX.WIC.DecodeOptions metadataOptions, SharpDX.WIC.BitmapDecoder decoderOut) {
            unsafe {
                IntPtr filename_ = Utilities.StringToHGlobalUni(filename);
                System.Guid guidVendorRef_;
                if (guidVendorRef.HasValue)
                    guidVendorRef_ = guidVendorRef.Value;				
                IntPtr decoderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)filename_, (guidVendorRef.HasValue)?&guidVendorRef_:(void*)IntPtr.Zero, desiredAccess, unchecked((int)metadataOptions), &decoderOut_,((void**)(*(void**)_nativePointer))[3]);		
                Marshal.FreeHGlobal(filename_ );
                ((SharpDX.WIC.BitmapDecoder)decoderOut).NativePointer = decoderOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of the <strong><see cref="SharpDX.WIC.BitmapDecoder"/></strong> class based on the given <see cref="SharpDX.Win32.IStream"/>.</p>	
        /// </summary>	
        /// <param name="streamRef">No documentation.</param>	
        /// <param name="guidVendorRef">No documentation.</param>	
        /// <param name="metadataOptions">No documentation.</param>	
        /// <param name="decoderOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateDecoderFromStream']/*"/>	
        /// <msdn-id>ee690309</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromStream([In, Optional] IStream* pIStream,[In, Optional] const GUID* pguidVendor,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateDecoderFromStream</unmanaged-short>	
        internal void CreateDecoderFromStream_(System.IntPtr streamRef, System.Guid? guidVendorRef, SharpDX.WIC.DecodeOptions metadataOptions, SharpDX.WIC.BitmapDecoder decoderOut) {
            unsafe {
                System.Guid guidVendorRef_;
                if (guidVendorRef.HasValue)
                    guidVendorRef_ = guidVendorRef.Value;				
                IntPtr decoderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)streamRef, (guidVendorRef.HasValue)?&guidVendorRef_:(void*)IntPtr.Zero, unchecked((int)metadataOptions), &decoderOut_,((void**)(*(void**)_nativePointer))[4]);		
                ((SharpDX.WIC.BitmapDecoder)decoderOut).NativePointer = decoderOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of the <strong><see cref="SharpDX.WIC.BitmapDecoder"/></strong> based on the given file handle.</p>	
        /// </summary>	
        /// <param name="hFile">No documentation.</param>	
        /// <param name="guidVendorRef">No documentation.</param>	
        /// <param name="metadataOptions">No documentation.</param>	
        /// <param name="decoderOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>When a decoder is created using this method, the file handle must remain alive during the lifetime of the decoder.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateDecoderFromFileHandle']/*"/>	
        /// <msdn-id>ee690305</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromFileHandle([In] ULONG_PTR hFile,[In, Optional] const GUID* pguidVendor,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateDecoderFromFileHandle</unmanaged-short>	
        internal void CreateDecoderFromFileHandle(System.IntPtr hFile, System.Guid? guidVendorRef, SharpDX.WIC.DecodeOptions metadataOptions, SharpDX.WIC.BitmapDecoder decoderOut) {
            unsafe {
                System.Guid guidVendorRef_;
                if (guidVendorRef.HasValue)
                    guidVendorRef_ = guidVendorRef.Value;				
                IntPtr decoderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)hFile, (guidVendorRef.HasValue)?&guidVendorRef_:(void*)IntPtr.Zero, unchecked((int)metadataOptions), &decoderOut_,((void**)(*(void**)_nativePointer))[5]);		
                ((SharpDX.WIC.BitmapDecoder)decoderOut).NativePointer = decoderOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of the <strong><see cref="SharpDX.WIC.ComponentInfo"/></strong> class for the given component class identifier (CLSID).</p>	
        /// </summary>	
        /// <param name="clsidComponent">No documentation.</param>	
        /// <param name="infoOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateComponentInfo']/*"/>	
        /// <msdn-id>ee690302</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateComponentInfo([In] const GUID&amp; clsidComponent,[Out, Fast] IWICComponentInfo** ppIInfo)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateComponentInfo</unmanaged-short>	
        internal void CreateComponentInfo(System.Guid clsidComponent, SharpDX.WIC.ComponentInfo infoOut) {
            unsafe {
                IntPtr infoOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &clsidComponent, &infoOut_,((void**)(*(void**)_nativePointer))[6]);		
                ((SharpDX.WIC.ComponentInfo)infoOut).NativePointer = infoOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of <strong><see cref="SharpDX.WIC.BitmapDecoder"/></strong>.</p>	
        /// </summary>	
        /// <param name="guidContainerFormat">No documentation.</param>	
        /// <param name="guidVendorRef">No documentation.</param>	
        /// <param name="decoderOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Other values may be available for both <em>guidContainerFormat</em> and <em>pguidVendor</em> depending on the installed WIC-enabled encoders. The values listed are those that are natively supported by the operating system. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateDecoder']/*"/>	
        /// <msdn-id>ee690304</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateDecoder([In] const GUID&amp; guidContainerFormat,[In, Optional] const GUID* pguidVendor,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateDecoder</unmanaged-short>	
        internal void CreateDecoder(System.Guid guidContainerFormat, System.Guid? guidVendorRef, SharpDX.WIC.BitmapDecoder decoderOut) {
            unsafe {
                System.Guid guidVendorRef_;
                if (guidVendorRef.HasValue)
                    guidVendorRef_ = guidVendorRef.Value;				
                IntPtr decoderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &guidContainerFormat, (guidVendorRef.HasValue)?&guidVendorRef_:(void*)IntPtr.Zero, &decoderOut_,((void**)(*(void**)_nativePointer))[7]);		
                ((SharpDX.WIC.BitmapDecoder)decoderOut).NativePointer = decoderOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of the <strong><see cref="SharpDX.WIC.BitmapEncoder"/></strong> class.</p>	
        /// </summary>	
        /// <param name="guidContainerFormat">No documentation.</param>	
        /// <param name="guidVendorRef">No documentation.</param>	
        /// <param name="encoderOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> Other values may be available for both <em>guidContainerFormat</em> and <em>pguidVendor</em> depending on the installed WIC-enabled encoders. The values listed are those that are natively supported by the operating system. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateEncoder']/*"/>	
        /// <msdn-id>ee690311</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateEncoder([In] const GUID&amp; guidContainerFormat,[In, Optional] const GUID* pguidVendor,[Out, Fast] IWICBitmapEncoder** ppIEncoder)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateEncoder</unmanaged-short>	
        internal void CreateEncoder(System.Guid guidContainerFormat, System.Guid? guidVendorRef, SharpDX.WIC.BitmapEncoder encoderOut) {
            unsafe {
                System.Guid guidVendorRef_;
                if (guidVendorRef.HasValue)
                    guidVendorRef_ = guidVendorRef.Value;				
                IntPtr encoderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &guidContainerFormat, (guidVendorRef.HasValue)?&guidVendorRef_:(void*)IntPtr.Zero, &encoderOut_,((void**)(*(void**)_nativePointer))[8]);		
                ((SharpDX.WIC.BitmapEncoder)encoderOut).NativePointer = encoderOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of the <strong><see cref="SharpDX.WIC.Palette"/></strong> class.</p>	
        /// </summary>	
        /// <param name="paletteOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreatePalette']/*"/>	
        /// <msdn-id>ee690319</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreatePalette([Out, Fast] IWICPalette** ppIPalette)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreatePalette</unmanaged-short>	
        internal void CreatePalette(SharpDX.WIC.Palette paletteOut) {
            unsafe {
                IntPtr paletteOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &paletteOut_,((void**)(*(void**)_nativePointer))[9]);		
                ((SharpDX.WIC.Palette)paletteOut).NativePointer = paletteOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of the <strong><see cref="SharpDX.WIC.FormatConverter"/></strong> class.</p>	
        /// </summary>	
        /// <param name="formatConverterOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateFormatConverter']/*"/>	
        /// <msdn-id>ee690317</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateFormatConverter([Out, Fast] IWICFormatConverter** ppIFormatConverter)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateFormatConverter</unmanaged-short>	
        internal void CreateFormatConverter(SharpDX.WIC.FormatConverter formatConverterOut) {
            unsafe {
                IntPtr formatConverterOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &formatConverterOut_,((void**)(*(void**)_nativePointer))[10]);		
                ((SharpDX.WIC.FormatConverter)formatConverterOut).NativePointer = formatConverterOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of an <strong><see cref="SharpDX.WIC.BitmapScaler"/></strong>.</p>	
        /// </summary>	
        /// <param name="bitmapScalerOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateBitmapScaler']/*"/>	
        /// <msdn-id>ee690296</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapScaler([Out, Fast] IWICBitmapScaler** ppIBitmapScaler)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapScaler</unmanaged-short>	
        internal void CreateBitmapScaler(SharpDX.WIC.BitmapScaler bitmapScalerOut) {
            unsafe {
                IntPtr bitmapScalerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &bitmapScalerOut_,((void**)(*(void**)_nativePointer))[11]);		
                ((SharpDX.WIC.BitmapScaler)bitmapScalerOut).NativePointer = bitmapScalerOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of an <strong><see cref="SharpDX.WIC.BitmapClipper"/></strong> object.</p>	
        /// </summary>	
        /// <param name="bitmapClipperOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateBitmapClipper']/*"/>	
        /// <msdn-id>ee690283</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapClipper([Out, Fast] IWICBitmapClipper** ppIBitmapClipper)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapClipper</unmanaged-short>	
        internal void CreateBitmapClipper(SharpDX.WIC.BitmapClipper bitmapClipperOut) {
            unsafe {
                IntPtr bitmapClipperOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &bitmapClipperOut_,((void**)(*(void**)_nativePointer))[12]);		
                ((SharpDX.WIC.BitmapClipper)bitmapClipperOut).NativePointer = bitmapClipperOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of an <strong><see cref="SharpDX.WIC.BitmapFlipRotator"/></strong> object.</p>	
        /// </summary>	
        /// <param name="bitmapFlipRotatorOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateBitmapFlipRotator']/*"/>	
        /// <msdn-id>ee690285</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFlipRotator([Out, Fast] IWICBitmapFlipRotator** ppIBitmapFlipRotator)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapFlipRotator</unmanaged-short>	
        internal void CreateBitmapFlipRotator(SharpDX.WIC.BitmapFlipRotator bitmapFlipRotatorOut) {
            unsafe {
                IntPtr bitmapFlipRotatorOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &bitmapFlipRotatorOut_,((void**)(*(void**)_nativePointer))[13]);		
                ((SharpDX.WIC.BitmapFlipRotator)bitmapFlipRotatorOut).NativePointer = bitmapFlipRotatorOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of the <strong><see cref="SharpDX.WIC.WICStream"/></strong> class.</p>	
        /// </summary>	
        /// <param name="wICStreamOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateStream']/*"/>	
        /// <msdn-id>ee690325</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateStream([Out, Fast] IWICStream** ppIWICStream)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateStream</unmanaged-short>	
        internal void CreateStream(SharpDX.WIC.WICStream wICStreamOut) {
            unsafe {
                IntPtr wICStreamOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &wICStreamOut_,((void**)(*(void**)_nativePointer))[14]);		
                ((SharpDX.WIC.WICStream)wICStreamOut).NativePointer = wICStreamOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of the <strong><see cref="SharpDX.WIC.ColorContext"/></strong> class.</p>	
        /// </summary>	
        /// <param name="wICColorContextOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateColorContext']/*"/>	
        /// <msdn-id>ee690299</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateColorContext([Out, Fast] IWICColorContext** ppIWICColorContext)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateColorContext</unmanaged-short>	
        internal void CreateColorContext(SharpDX.WIC.ColorContext wICColorContextOut) {
            unsafe {
                IntPtr wICColorContextOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &wICColorContextOut_,((void**)(*(void**)_nativePointer))[15]);		
                ((SharpDX.WIC.ColorContext)wICColorContextOut).NativePointer = wICColorContextOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of the <strong><see cref="SharpDX.WIC.ColorTransform"/></strong> class.</p>	
        /// </summary>	
        /// <param name="wICColorTransformOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateColorTransformer']/*"/>	
        /// <msdn-id>ee690300</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateColorTransformer([Out, Fast] IWICColorTransform** ppIWICColorTransform)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateColorTransformer</unmanaged-short>	
        internal void CreateColorTransformer(SharpDX.WIC.ColorTransform wICColorTransformOut) {
            unsafe {
                IntPtr wICColorTransformOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &wICColorTransformOut_,((void**)(*(void**)_nativePointer))[16]);		
                ((SharpDX.WIC.ColorTransform)wICColorTransformOut).NativePointer = wICColorTransformOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.WIC.Bitmap"/></strong> object.</p>	
        /// </summary>	
        /// <param name="width">No documentation.</param>	
        /// <param name="height">No documentation.</param>	
        /// <param name="ixelFormatRef">No documentation.</param>	
        /// <param name="option">No documentation.</param>	
        /// <param name="bitmapOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateBitmap']/*"/>	
        /// <msdn-id>ee690282</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmap([In] unsigned int uiWidth,[In] unsigned int uiHeight,[In] const GUID&amp; pixelFormat,[In] WICBitmapCreateCacheOption option,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateBitmap</unmanaged-short>	
        internal void CreateBitmap(int width, int height, System.Guid ixelFormatRef, SharpDX.WIC.BitmapCreateCacheOption option, SharpDX.WIC.Bitmap bitmapOut) {
            unsafe {
                IntPtr bitmapOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, width, height, &ixelFormatRef, unchecked((int)option), &bitmapOut_,((void**)(*(void**)_nativePointer))[17]);		
                ((SharpDX.WIC.Bitmap)bitmapOut).NativePointer = bitmapOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a <strong><see cref="SharpDX.WIC.Bitmap"/></strong> from a <strong><see cref="SharpDX.WIC.BitmapSource"/></strong>.</p>	
        /// </summary>	
        /// <param name="bitmapSourceRef">No documentation.</param>	
        /// <param name="option">No documentation.</param>	
        /// <param name="bitmapOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateBitmapFromSource']/*"/>	
        /// <msdn-id>ee690293</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromSource([In, Optional] IWICBitmapSource* pIBitmapSource,[In] WICBitmapCreateCacheOption option,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapFromSource</unmanaged-short>	
        internal void CreateBitmapFromSource(SharpDX.WIC.BitmapSource bitmapSourceRef, SharpDX.WIC.BitmapCreateCacheOption option, SharpDX.WIC.Bitmap bitmapOut) {
            unsafe {
                IntPtr bitmapOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((bitmapSourceRef == null)?IntPtr.Zero:bitmapSourceRef.NativePointer), unchecked((int)option), &bitmapOut_,((void**)(*(void**)_nativePointer))[18]);		
                ((SharpDX.WIC.Bitmap)bitmapOut).NativePointer = bitmapOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.WIC.Bitmap"/></strong> from a specified rectangle of an <strong><see cref="SharpDX.WIC.BitmapSource"/></strong>.</p>	
        /// </summary>	
        /// <param name="bitmapSourceRef">No documentation.</param>	
        /// <param name="x">No documentation.</param>	
        /// <param name="y">No documentation.</param>	
        /// <param name="width">No documentation.</param>	
        /// <param name="height">No documentation.</param>	
        /// <param name="bitmapOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Providing a rectangle that is larger than the source will produce undefined results.</p><p>This method always creates a separate copy of the source image, similar to the cache option <strong><see cref="SharpDX.WIC.BitmapCreateCacheOption.CacheOnLoad"/></strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateBitmapFromSourceRect']/*"/>	
        /// <msdn-id>ee690294</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromSourceRect([In, Optional] IWICBitmapSource* pIBitmapSource,[In] unsigned int x,[In] unsigned int y,[In] unsigned int width,[In] unsigned int height,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapFromSourceRect</unmanaged-short>	
        internal void CreateBitmapFromSourceRect(SharpDX.WIC.BitmapSource bitmapSourceRef, int x, int y, int width, int height, SharpDX.WIC.Bitmap bitmapOut) {
            unsafe {
                IntPtr bitmapOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((bitmapSourceRef == null)?IntPtr.Zero:bitmapSourceRef.NativePointer), x, y, width, height, &bitmapOut_,((void**)(*(void**)_nativePointer))[19]);		
                ((SharpDX.WIC.Bitmap)bitmapOut).NativePointer = bitmapOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.WIC.Bitmap"/></strong> from a memory block.</p>	
        /// </summary>	
        /// <param name="width">No documentation.</param>	
        /// <param name="height">No documentation.</param>	
        /// <param name="ixelFormatRef">No documentation.</param>	
        /// <param name="stride">No documentation.</param>	
        /// <param name="bufferSize">No documentation.</param>	
        /// <param name="bufferRef">No documentation.</param>	
        /// <param name="bitmapOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The size of the <see cref="SharpDX.WIC.Bitmap"/> to be created must be smaller than or equal to the size of the image in <em>pbBuffer</em>.</p><p>The stride of the destination bitmap will equal the <em>stride</em> of the source data, regardless of the width and height specified.</p><p>The <em>pixelFormat</em> parameter defines the pixel format for both the input data and the output bitmap.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateBitmapFromMemory']/*"/>	
        /// <msdn-id>ee690291</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromMemory([In] unsigned int uiWidth,[In] unsigned int uiHeight,[In] const GUID&amp; pixelFormat,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapFromMemory</unmanaged-short>	
        internal void CreateBitmapFromMemory(int width, int height, System.Guid ixelFormatRef, int stride, int bufferSize, System.IntPtr bufferRef, SharpDX.WIC.Bitmap bitmapOut) {
            unsafe {
                IntPtr bitmapOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, width, height, &ixelFormatRef, stride, bufferSize, (void*)bufferRef, &bitmapOut_,((void**)(*(void**)_nativePointer))[20]);		
                ((SharpDX.WIC.Bitmap)bitmapOut).NativePointer = bitmapOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.WIC.Bitmap"/></strong> from a bitmap handle.</p>	
        /// </summary>	
        /// <param name="hBitmap">No documentation.</param>	
        /// <param name="hPalette">No documentation.</param>	
        /// <param name="options">No documentation.</param>	
        /// <param name="bitmapOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>For a non-palletized bitmap, set <c>null</c> for the <em>hPalette</em> parameter.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateBitmapFromHBITMAP']/*"/>	
        /// <msdn-id>ee690287</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromHBITMAP([In] HBITMAP hBitmap,[In, Optional] HPALETTE hPalette,[In] WICBitmapAlphaChannelOption options,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapFromHBITMAP</unmanaged-short>	
        internal void CreateBitmapFromHBITMAP(System.IntPtr hBitmap, System.IntPtr hPalette, SharpDX.WIC.BitmapAlphaChannelOption options, SharpDX.WIC.Bitmap bitmapOut) {
            unsafe {
                IntPtr bitmapOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)hBitmap, (void*)hPalette, unchecked((int)options), &bitmapOut_,((void**)(*(void**)_nativePointer))[21]);		
                ((SharpDX.WIC.Bitmap)bitmapOut).NativePointer = bitmapOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.WIC.Bitmap"/></strong> from an icon handle.</p>	
        /// </summary>	
        /// <param name="hIcon">No documentation.</param>	
        /// <param name="bitmapOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateBitmapFromHICON']/*"/>	
        /// <msdn-id>ee690289</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromHICON([In] HICON hIcon,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateBitmapFromHICON</unmanaged-short>	
        internal void CreateBitmapFromHICON(System.IntPtr hIcon, SharpDX.WIC.Bitmap bitmapOut) {
            unsafe {
                IntPtr bitmapOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)hIcon, &bitmapOut_,((void**)(*(void**)_nativePointer))[22]);		
                ((SharpDX.WIC.Bitmap)bitmapOut).NativePointer = bitmapOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an <see cref="SharpDX.ComObject"/> object of the specified component types.</p>	
        /// </summary>	
        /// <param name="componentTypes">No documentation.</param>	
        /// <param name="options">No documentation.</param>	
        /// <param name="enumUnknownOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Component types must be enumerated seperately. Combinations of component types and <strong><see cref="SharpDX.WIC.ComponentType.AllComponents"/></strong> are unsupported.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateComponentEnumerator']/*"/>	
        /// <msdn-id>ee690301</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateComponentEnumerator([In] unsigned int componentTypes,[In] unsigned int options,[Out, Fast] IEnumUnknown** ppIEnumUnknown)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateComponentEnumerator</unmanaged-short>	
        internal void CreateComponentEnumerator(int componentTypes, int options, SharpDX.ComObject enumUnknownOut) {
            unsafe {
                IntPtr enumUnknownOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, componentTypes, options, &enumUnknownOut_,((void**)(*(void**)_nativePointer))[23]);		
                ((SharpDX.ComObject)enumUnknownOut).NativePointer = enumUnknownOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of the fast metadata encoder based on the given <strong><see cref="SharpDX.WIC.BitmapDecoder"/></strong>.</p>	
        /// </summary>	
        /// <param name="decoderRef">No documentation.</param>	
        /// <param name="fastEncoderOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The Windows provided codecs do not support fast metadata encoding at the decoder level, and only support fast metadata encoding at the frame level. To create a fast metadata encoder from a frame, see <strong>CreateFastMetadataEncoderFromFrameDecode</strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateFastMetadataEncoderFromDecoder']/*"/>	
        /// <msdn-id>ee690313</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateFastMetadataEncoderFromDecoder([In, Optional] IWICBitmapDecoder* pIDecoder,[Out, Fast] IWICFastMetadataEncoder** ppIFastEncoder)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateFastMetadataEncoderFromDecoder</unmanaged-short>	
        internal void CreateFastMetadataEncoderFromDecoder(SharpDX.WIC.BitmapDecoder decoderRef, SharpDX.WIC.FastMetadataEncoder fastEncoderOut) {
            unsafe {
                IntPtr fastEncoderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((decoderRef == null)?IntPtr.Zero:decoderRef.NativePointer), &fastEncoderOut_,((void**)(*(void**)_nativePointer))[24]);		
                ((SharpDX.WIC.FastMetadataEncoder)fastEncoderOut).NativePointer = fastEncoderOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of the fast metadata encoder based on the given image frame.</p>	
        /// </summary>	
        /// <param name="frameDecoderRef"><dd>  <p>The <strong><see cref="SharpDX.WIC.BitmapFrameDecode"/></strong> to create the <strong><see cref="SharpDX.WIC.FastMetadataEncoder"/></strong> from.</p> </dd></param>	
        /// <param name="fastEncoderOut"><dd>  <p>When this method returns, contains a reference to a new fast metadata encoder.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>For a list of support metadata formats for fast metadata encoding, see WIC Metadata Overview.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateFastMetadataEncoderFromFrameDecode']/*"/>	
        /// <msdn-id>ee690315</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateFastMetadataEncoderFromFrameDecode([In, Optional] IWICBitmapFrameDecode* pIFrameDecoder,[Out, Fast] IWICFastMetadataEncoder** ppIFastEncoder)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateFastMetadataEncoderFromFrameDecode</unmanaged-short>	
        internal void CreateFastMetadataEncoderFromFrameDecode(SharpDX.WIC.BitmapFrameDecode frameDecoderRef, SharpDX.WIC.FastMetadataEncoder fastEncoderOut) {
            unsafe {
                IntPtr fastEncoderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((frameDecoderRef == null)?IntPtr.Zero:frameDecoderRef.NativePointer), &fastEncoderOut_,((void**)(*(void**)_nativePointer))[25]);		
                ((SharpDX.WIC.FastMetadataEncoder)fastEncoderOut).NativePointer = fastEncoderOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of a query writer.</p>	
        /// </summary>	
        /// <param name="guidMetadataFormat"><dd>  <p>The <see cref="System.Guid"/> for the desired metadata format. </p> </dd></param>	
        /// <param name="guidVendorRef"><dd>  <p>The <see cref="System.Guid"/> for the preferred metadata writer vendor. Use <strong><c>null</c></strong> if no preferred vendor.</p> </dd></param>	
        /// <param name="queryWriterOut"><dd>  <p>When this method returns, contains a reference to a new <strong><see cref="SharpDX.WIC.MetadataQueryWriter"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateQueryWriter']/*"/>	
        /// <msdn-id>ee690321</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateQueryWriter([In] const GUID&amp; guidMetadataFormat,[In, Optional] const GUID* pguidVendor,[Out, Fast] IWICMetadataQueryWriter** ppIQueryWriter)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateQueryWriter</unmanaged-short>	
        internal void CreateQueryWriter(System.Guid guidMetadataFormat, System.Guid? guidVendorRef, SharpDX.WIC.MetadataQueryWriter queryWriterOut) {
            unsafe {
                System.Guid guidVendorRef_;
                if (guidVendorRef.HasValue)
                    guidVendorRef_ = guidVendorRef.Value;				
                IntPtr queryWriterOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &guidMetadataFormat, (guidVendorRef.HasValue)?&guidVendorRef_:(void*)IntPtr.Zero, &queryWriterOut_,((void**)(*(void**)_nativePointer))[26]);		
                ((SharpDX.WIC.MetadataQueryWriter)queryWriterOut).NativePointer = queryWriterOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new instance of a query writer based on the given query reader. The query writer will be pre-populated with metadata from the query reader.</p>	
        /// </summary>	
        /// <param name="queryReaderRef"><dd>  <p>The <strong><see cref="SharpDX.WIC.MetadataQueryReader"/></strong> to create the <strong><see cref="SharpDX.WIC.MetadataQueryWriter"/></strong> from.</p> </dd></param>	
        /// <param name="guidVendorRef"><dd>  <p>The <see cref="System.Guid"/> for the preferred metadata writer vendor. Use <strong><c>null</c></strong> if no preferred vendor.</p> </dd></param>	
        /// <param name="queryWriterOut"><dd>  <p>When this method returns, contains a reference to a new metadata writer.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory::CreateQueryWriterFromReader']/*"/>	
        /// <msdn-id>ee690322</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory::CreateQueryWriterFromReader([In, Optional] IWICMetadataQueryReader* pIQueryReader,[In, Optional] const GUID* pguidVendor,[Out, Fast] IWICMetadataQueryWriter** ppIQueryWriter)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory::CreateQueryWriterFromReader</unmanaged-short>	
        internal void CreateQueryWriterFromReader(SharpDX.WIC.MetadataQueryReader queryReaderRef, System.Guid? guidVendorRef, SharpDX.WIC.MetadataQueryWriter queryWriterOut) {
            unsafe {
                System.Guid guidVendorRef_;
                if (guidVendorRef.HasValue)
                    guidVendorRef_ = guidVendorRef.Value;				
                IntPtr queryWriterOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((queryReaderRef == null)?IntPtr.Zero:queryReaderRef.NativePointer), (guidVendorRef.HasValue)?&guidVendorRef_:(void*)IntPtr.Zero, &queryWriterOut_,((void**)(*(void**)_nativePointer))[27]);		
                ((SharpDX.WIC.MetadataQueryWriter)queryWriterOut).NativePointer = queryWriterOut_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods used to create components for the Windows Imaging Component (WIC) such as decoders, encoders and pixel format converters.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory2']/*"/>	
    /// <msdn-id>ee690281</msdn-id>	
    /// <unmanaged>IWICImagingFactory2</unmanaged>	
    /// <unmanaged-short>IWICImagingFactory2</unmanaged-short>	
    [Guid("7B816B45-1996-4476-B132-DE9E247C8AF0")]
    public partial class ImagingFactory2 : SharpDX.WIC.ImagingFactory {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.ImagingFactory2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ImagingFactory2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.ImagingFactory2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.ImagingFactory2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.ImagingFactory2(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Creates a new image encoder object.</p>	
        /// </summary>	
        /// <param name="d2DDeviceRef"><dd> <p>The <strong><see cref="SharpDX.Direct2D1.Device"/></strong> object on which the corresponding image encoder is created.</p> </dd></param>	
        /// <param name="wICImageEncoderOut"><dd> <p>A reference to a variable that receives a reference to the <strong><see cref="SharpDX.WIC.ImageEncoder"/></strong> interface for the encoder object that you can use to encode Direct2D images.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>You must create images to pass to the image encoder  on the same Direct2D device that you pass to this method. </p><p>You are responsible for setting up the bitmap encoder itself through the existing <strong><see cref="SharpDX.WIC.BitmapEncoder"/></strong> APIs. The <strong><see cref="SharpDX.WIC.BitmapEncoder"/></strong> or the <see cref="SharpDX.WIC.BitmapFrameEncode"/> object is passed to each of the <strong><see cref="SharpDX.WIC.ImageEncoder"/></strong> methods: <strong>WriteThumbnail</strong>, <strong>WriteFrame</strong>, and <strong>WriteFrameThumbnail</strong>. 	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICImagingFactory2::CreateImageEncoder']/*"/>	
        /// <msdn-id>hh880849</msdn-id>	
        /// <unmanaged>HRESULT IWICImagingFactory2::CreateImageEncoder([In] ID2D1Device* pD2DDevice,[Out, Fast] IWICImageEncoder** ppWICImageEncoder)</unmanaged>	
        /// <unmanaged-short>IWICImagingFactory2::CreateImageEncoder</unmanaged-short>	
        internal void CreateImageEncoder(SharpDX.Direct2D1.Device d2DDeviceRef, SharpDX.WIC.ImageEncoder wICImageEncoderOut) {
            unsafe {
                IntPtr wICImageEncoderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((d2DDeviceRef == null)?IntPtr.Zero:d2DDeviceRef.NativePointer), &wICImageEncoderOut_,((void**)(*(void**)_nativePointer))[28]);		
                ((SharpDX.WIC.ImageEncoder)wICImageEncoderOut).NativePointer = wICImageEncoderOut_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods for decoding JPEG images. Provides access to the Start Of Frame (SOF) header, Start of Scan (SOS) header, the Huffman and Quantization tables, and the compressed JPEG JPEG data. Also enables indexing for efficient random access. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Obtain this interface by calling <strong>IUnknown::QueryInterface</strong> on the Windows-provided <strong><see cref="SharpDX.WIC.BitmapFrameDecode"/></strong> interface for the JPEG decoder.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameDecode']/*"/>	
    /// <msdn-id>dn903834</msdn-id>	
    /// <unmanaged>IWICJpegFrameDecode</unmanaged>	
    /// <unmanaged-short>IWICJpegFrameDecode</unmanaged-short>	
    [Guid("8939F66E-C46A-4c21-A9D1-98B327CE1679")]
    public partial class JpegFrameDecode : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.JpegFrameDecode"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public JpegFrameDecode(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.JpegFrameDecode"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.JpegFrameDecode(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.JpegFrameDecode(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Represents a JPEG frame header.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Get the frame header for an image by calling <strong><see cref="SharpDX.WIC.JpegFrameDecode.GetFrameHeader"/></strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameDecode::GetFrameHeader']/*"/>	
        /// <msdn-id>dn903878</msdn-id>	
        /// <unmanaged>GetFrameHeader</unmanaged>	
        /// <unmanaged-short>GetFrameHeader</unmanaged-short>	
        /// <unmanaged>HRESULT IWICJpegFrameDecode::GetFrameHeader([Out] WICJpegFrameHeader* pFrameHeader)</unmanaged>
        public SharpDX.WIC.JpegFrameHeader FrameHeader {
                get { SharpDX.WIC.JpegFrameHeader __output__; GetFrameHeader(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves a value indicating whether this decoder supports indexing for efficient random access.</p>	
        /// </summary>	
        /// <param name="fIndexingSupportedRef"><dd>  <p>True if indexing is supported; otherwise, false.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> on successful completion.</p></returns>	
        /// <remarks>	
        /// <p>Indexing is only supported for some JPEG types. Call this method</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameDecode::DoesSupportIndexing']/*"/>	
        /// <msdn-id>dn903843</msdn-id>	
        /// <unmanaged>HRESULT IWICJpegFrameDecode::DoesSupportIndexing([Out] BOOL* pfIndexingSupported)</unmanaged>	
        /// <unmanaged-short>IWICJpegFrameDecode::DoesSupportIndexing</unmanaged-short>	
        public void DoesSupportIndexing(out SharpDX.Mathematics.Interop.RawBool fIndexingSupportedRef) {
            unsafe {
                fIndexingSupportedRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fIndexingSupportedRef_ = &fIndexingSupportedRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, fIndexingSupportedRef_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Enables indexing of the JPEG for efficient random access.</p>	
        /// </summary>	
        /// <param name="options"><dd>  <p>A value specifying whether indexes should be generated immediately or deferred until a future call to <strong><see cref="SharpDX.WIC.BitmapSource.CopyPixels"/></strong>.</p> </dd></param>	
        /// <param name="horizontalIntervalSize"><dd>  <p>The granularity of the indexing, in pixels.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> upon successful completion.</p></returns>	
        /// <remarks>	
        /// <p>This method enables efficient random-access to the image pixels at the expense of memory usage.  The amount of memory required for indexing depends on the requested index granularity.   Unless <strong>SetIndexing</strong> is called, it is much more efficient to access a JPEG by progressing through its pixels top-down during calls to <strong><see cref="SharpDX.WIC.BitmapSource.CopyPixels"/></strong>.	
        /// </p><p>This method will fail if indexing is unsupported on the file.  <strong><see cref="SharpDX.WIC.JpegFrameDecode.DoesSupportIndexing"/></strong> should be called to first determine whether indexing is supported.  If this method is called multiple times, the final call changes the index granularity to the requested size.	
        /// </p><p>The provided interval size controls horizontal spacing of index entries.  This value is internally rounded up according to the JPEG?s MCU (minimum coded unit) size, which is typically either 8 or 16 unscaled pixels.  The vertical size of the index interval is always equal to one MCU size.</p><p> Indexes can be generated immediately, or during future calls to <strong><see cref="SharpDX.WIC.BitmapSource.CopyPixels"/></strong> to reduce redundant decompression work. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameDecode::SetIndexing']/*"/>	
        /// <msdn-id>dn903861</msdn-id>	
        /// <unmanaged>HRESULT IWICJpegFrameDecode::SetIndexing([In] WICJpegIndexingOptions options,[In] unsigned int horizontalIntervalSize)</unmanaged>	
        /// <unmanaged-short>IWICJpegFrameDecode::SetIndexing</unmanaged-short>	
        public void SetIndexing(SharpDX.WIC.JpegIndexingOptions options, int horizontalIntervalSize) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, unchecked((int)options), horizontalIntervalSize,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes the indexing from a JPEG that has been indexed using <strong><see cref="SharpDX.WIC.JpegFrameDecode.SetIndexing"/></strong>.</p>	
        /// </summary>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> upons successful completion.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameDecode::ClearIndexing']/*"/>	
        /// <msdn-id>dn903837</msdn-id>	
        /// <unmanaged>HRESULT IWICJpegFrameDecode::ClearIndexing()</unmanaged>	
        /// <unmanaged-short>IWICJpegFrameDecode::ClearIndexing</unmanaged-short>	
        public void ClearIndexing() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a copy of the AC Huffman table for the specified scan and table.</p>	
        /// </summary>	
        /// <param name="scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>	
        /// <param name="tableIndex"><dd>  <p>The index of the AC Huffman table to retrieve. Valid indices for a given scan can be determined by retrieving the scan header with <strong><see cref="SharpDX.WIC.JpegFrameDecode.GetScanHeader"/></strong>.</p> </dd></param>	
        /// <param name="acHuffmanTableRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref="SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref="SharpDX.WIC.ResultCode.InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref="SharpDX.WIC.ResultCode.InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pAcHuffmanTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameDecode::GetAcHuffmanTable']/*"/>	
        /// <msdn-id>dn903845</msdn-id>	
        /// <unmanaged>HRESULT IWICJpegFrameDecode::GetAcHuffmanTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_AC_HUFFMAN_TABLE* pAcHuffmanTable)</unmanaged>	
        /// <unmanaged-short>IWICJpegFrameDecode::GetAcHuffmanTable</unmanaged-short>	
        public void GetAcHuffmanTable(int scanIndex, int tableIndex, out SharpDX.DXGI.JpegAcHuffmanTable acHuffmanTableRef) {
            unsafe {
                var acHuffmanTableRef_ = new SharpDX.DXGI.JpegAcHuffmanTable.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, scanIndex, tableIndex, &acHuffmanTableRef_,((void**)(*(void**)_nativePointer))[6]);		
                acHuffmanTableRef = new SharpDX.DXGI.JpegAcHuffmanTable();
                acHuffmanTableRef.__MarshalFrom(ref acHuffmanTableRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a copy of the DC Huffman table for the specified scan and table.</p>	
        /// </summary>	
        /// <param name="scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>	
        /// <param name="tableIndex"><dd>  <p>The index of the DC Huffman table to retrieve. Valid indices for a given scan can be determined by retrieving the scan header with <strong><see cref="SharpDX.WIC.JpegFrameDecode.GetScanHeader"/></strong>.</p> </dd></param>	
        /// <param name="dcHuffmanTableRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref="SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref="SharpDX.WIC.ResultCode.InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref="SharpDX.WIC.ResultCode.InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameDecode::GetDcHuffmanTable']/*"/>	
        /// <msdn-id>dn903848</msdn-id>	
        /// <unmanaged>HRESULT IWICJpegFrameDecode::GetDcHuffmanTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_DC_HUFFMAN_TABLE* pDcHuffmanTable)</unmanaged>	
        /// <unmanaged-short>IWICJpegFrameDecode::GetDcHuffmanTable</unmanaged-short>	
        public void GetDcHuffmanTable(int scanIndex, int tableIndex, out SharpDX.DXGI.JpegDeviceContextHuffmanTable dcHuffmanTableRef) {
            unsafe {
                var dcHuffmanTableRef_ = new SharpDX.DXGI.JpegDeviceContextHuffmanTable.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, scanIndex, tableIndex, &dcHuffmanTableRef_,((void**)(*(void**)_nativePointer))[7]);		
                dcHuffmanTableRef = new SharpDX.DXGI.JpegDeviceContextHuffmanTable();
                dcHuffmanTableRef.__MarshalFrom(ref dcHuffmanTableRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="scanIndex">No documentation.</param>	
        /// <param name="tableIndex">No documentation.</param>	
        /// <param name="quantizationTableRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameDecode::GetQuantizationTable']/*"/>	
        /// <unmanaged>HRESULT IWICJpegFrameDecode::GetQuantizationTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_QUANTIZATION_TABLE* pQuantizationTable)</unmanaged>	
        /// <unmanaged-short>IWICJpegFrameDecode::GetQuantizationTable</unmanaged-short>	
        public void GetQuantizationTable(int scanIndex, int tableIndex, out SharpDX.DXGI.JpegQuantizationTable quantizationTableRef) {
            unsafe {
                var quantizationTableRef_ = new SharpDX.DXGI.JpegQuantizationTable.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, scanIndex, tableIndex, &quantizationTableRef_,((void**)(*(void**)_nativePointer))[8]);		
                quantizationTableRef = new SharpDX.DXGI.JpegQuantizationTable();
                quantizationTableRef.__MarshalFrom(ref quantizationTableRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Represents a JPEG frame header.</p>	
        /// </summary>	
        /// <param name="frameHeaderRef"><dd> <p>The width of the JPEG frame.</p> </dd></param>	
        /// <returns>No documentation.</returns>	
        /// <remarks>	
        /// <p>Get the frame header for an image by calling <strong><see cref="SharpDX.WIC.JpegFrameDecode.GetFrameHeader"/></strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameDecode::GetFrameHeader']/*"/>	
        /// <msdn-id>dn903878</msdn-id>	
        /// <unmanaged>HRESULT IWICJpegFrameDecode::GetFrameHeader([Out] WICJpegFrameHeader* pFrameHeader)</unmanaged>	
        /// <unmanaged-short>IWICJpegFrameDecode::GetFrameHeader</unmanaged-short>	
        internal void GetFrameHeader(out SharpDX.WIC.JpegFrameHeader frameHeaderRef) {
            unsafe {
                frameHeaderRef = new SharpDX.WIC.JpegFrameHeader();
                SharpDX.Result __result__;
                fixed (void* frameHeaderRef_ = &frameHeaderRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, frameHeaderRef_,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves parameters from the Start Of Scan (SOS) marker for the scan with the specified index.</p>	
        /// </summary>	
        /// <param name="scanIndex"><dd>  <p>The index of the scan for which header data is retrieved.</p> </dd></param>	
        /// <param name="scanHeaderRef"><dd>  <p>A reference that receives the frame header data.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> on successful completion.</p></returns>	
        /// <remarks>	
        /// <p>This method ... TBD</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameDecode::GetScanHeader']/*"/>	
        /// <msdn-id>dn903858</msdn-id>	
        /// <unmanaged>HRESULT IWICJpegFrameDecode::GetScanHeader([In] unsigned int scanIndex,[Out] WICJpegScanHeader* pScanHeader)</unmanaged>	
        /// <unmanaged-short>IWICJpegFrameDecode::GetScanHeader</unmanaged-short>	
        public void GetScanHeader(int scanIndex, out SharpDX.WIC.JpegScanHeader scanHeaderRef) {
            unsafe {
                scanHeaderRef = new SharpDX.WIC.JpegScanHeader();
                SharpDX.Result __result__;
                fixed (void* scanHeaderRef_ = &scanHeaderRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, scanIndex, scanHeaderRef_,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a copy of the compressed JPEG scan directly from the WIC decoder frame's output stream.</p>	
        /// </summary>	
        /// <param name="scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>	
        /// <param name="scanOffset"><dd>  <p>The byte position in the scan data to begin copying.  Use 0 on the first call.  If the output buffer size is insufficient to store the entire scan, this offset allows you to resume copying from the end of the previous copy operation.</p> </dd></param>	
        /// <param name="scanData"><dd>  <p>The size, in bytes, of the <em>pbScanData</em> array.</p> </dd></param>	
        /// <param name="scanDataRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <param name="scanDataActualRef"><dd>  <p>A reference that receives the size of the scan data actually copied into <em>pbScanData</em>. The size returned may be smaller that the size of <em>cbScanData</em>. This  parameter may be <c>null</c>.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref="SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref="SharpDX.WIC.ResultCode.InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameDecode::CopyScan']/*"/>	
        /// <msdn-id>dn903841</msdn-id>	
        /// <unmanaged>HRESULT IWICJpegFrameDecode::CopyScan([In] unsigned int scanIndex,[In] unsigned int scanOffset,[In] unsigned int cbScanData,[Out, Buffer] unsigned char* pbScanData,[Out] unsigned int* pcbScanDataActual)</unmanaged>	
        /// <unmanaged-short>IWICJpegFrameDecode::CopyScan</unmanaged-short>	
        public void CopyScan(int scanIndex, int scanOffset, int scanData, byte[] scanDataRef, out int scanDataActualRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* scanDataRef_ = scanDataRef)
                    fixed (void* scanDataActualRef_ = &scanDataActualRef)
                        __result__= 
        				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, scanIndex, scanOffset, scanData, scanDataRef_, scanDataActualRef_,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="streamOffset">No documentation.</param>	
        /// <param name="streamData">No documentation.</param>	
        /// <param name="streamDataRef">No documentation.</param>	
        /// <param name="streamDataActualRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameDecode::CopyMinimalStream']/*"/>	
        /// <unmanaged>HRESULT IWICJpegFrameDecode::CopyMinimalStream([In] unsigned int streamOffset,[In] unsigned int cbStreamData,[Out, Buffer] unsigned char* pbStreamData,[Out] unsigned int* pcbStreamDataActual)</unmanaged>	
        /// <unmanaged-short>IWICJpegFrameDecode::CopyMinimalStream</unmanaged-short>	
        public void CopyMinimalStream(int streamOffset, int streamData, byte[] streamDataRef, out int streamDataActualRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* streamDataRef_ = streamDataRef)
                    fixed (void* streamDataActualRef_ = &streamDataActualRef)
                        __result__= 
        				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, streamOffset, streamData, streamDataRef_, streamDataActualRef_,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods for writing compressed JPEG scan data directly to the WIC encoder's output stream. Also provides access to the Huffman and quantization tables.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Obtain this interface by calling <strong>IUnknown::QueryInterface</strong> on the Windows-provided <strong><see cref="SharpDX.WIC.BitmapFrameEncode"/></strong> interface for the JPEG encoder</p><p>The WIC JPEG encoder supports a smaller subset of JPEG features than the decoder does.</p><ul> <li>The encoder is limited to a single scan. It does not support encoding images that are multi-scan, either for progressive encoding or planar component data.</li> <li>The encoder supports two quantization tables, two AC Huffman tables, and two DC Huffman tables. The luma tables are used for the Y channel and, in the case of YCCK, the black channel.  The chroma tables are used for the CbCr channels. </li> <li>The encoder supports encoding gray, YCbCr (RGB), and YCCK (CMYK).</li> <li>The encoder supports 4 fixed compontent subsampling, 4:2:0, 4:2:2, 4:4:0, and 4:4:4.  This subsamples chroma only.</li> <li>The encoder does not support  restart markers.</li> </ul>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameEncode']/*"/>	
    /// <msdn-id>dn903864</msdn-id>	
    /// <unmanaged>IWICJpegFrameEncode</unmanaged>	
    /// <unmanaged-short>IWICJpegFrameEncode</unmanaged-short>	
    [Guid("2F0C601F-D2C6-468C-ABFA-49495D983ED1")]
    public partial class JpegFrameEncode : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.JpegFrameEncode"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public JpegFrameEncode(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.JpegFrameEncode"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.JpegFrameEncode(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.JpegFrameEncode(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves a copy of the AC Huffman table for the specified scan and table.</p>	
        /// </summary>	
        /// <param name="scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>	
        /// <param name="tableIndex"><dd>  <p>The index of the AC Huffman table to retrieve.</p> </dd></param>	
        /// <param name="acHuffmanTableRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref="SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref="SharpDX.WIC.ResultCode.InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref="SharpDX.WIC.ResultCode.InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pAcHuffmanTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameEncode::GetAcHuffmanTable']/*"/>	
        /// <msdn-id>dn903867</msdn-id>	
        /// <unmanaged>HRESULT IWICJpegFrameEncode::GetAcHuffmanTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_AC_HUFFMAN_TABLE* pAcHuffmanTable)</unmanaged>	
        /// <unmanaged-short>IWICJpegFrameEncode::GetAcHuffmanTable</unmanaged-short>	
        public void GetAcHuffmanTable(int scanIndex, int tableIndex, out SharpDX.DXGI.JpegAcHuffmanTable acHuffmanTableRef) {
            unsafe {
                var acHuffmanTableRef_ = new SharpDX.DXGI.JpegAcHuffmanTable.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, scanIndex, tableIndex, &acHuffmanTableRef_,((void**)(*(void**)_nativePointer))[3]);		
                acHuffmanTableRef = new SharpDX.DXGI.JpegAcHuffmanTable();
                acHuffmanTableRef.__MarshalFrom(ref acHuffmanTableRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a copy of the DC Huffman table for the specified scan and table.</p>	
        /// </summary>	
        /// <param name="scanIndex"><dd> <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>	
        /// <param name="tableIndex"><dd> <p>The index of the DC Huffman table to retrieve. </p> </dd></param>	
        /// <param name="dcHuffmanTableRef"><dd> <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref="SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref="SharpDX.WIC.ResultCode.InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref="SharpDX.WIC.ResultCode.InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameEncode::GetDcHuffmanTable']/*"/>	
        /// <msdn-id>dn903870</msdn-id>	
        /// <unmanaged>HRESULT IWICJpegFrameEncode::GetDcHuffmanTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_DC_HUFFMAN_TABLE* pDcHuffmanTable)</unmanaged>	
        /// <unmanaged-short>IWICJpegFrameEncode::GetDcHuffmanTable</unmanaged-short>	
        public void GetDcHuffmanTable(int scanIndex, int tableIndex, out SharpDX.DXGI.JpegDeviceContextHuffmanTable dcHuffmanTableRef) {
            unsafe {
                var dcHuffmanTableRef_ = new SharpDX.DXGI.JpegDeviceContextHuffmanTable.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, scanIndex, tableIndex, &dcHuffmanTableRef_,((void**)(*(void**)_nativePointer))[4]);		
                dcHuffmanTableRef = new SharpDX.DXGI.JpegDeviceContextHuffmanTable();
                dcHuffmanTableRef.__MarshalFrom(ref dcHuffmanTableRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a copy of the quantization table.</p>	
        /// </summary>	
        /// <param name="scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>	
        /// <param name="tableIndex"><dd>  <p>The index of the quantization table to retrieve. </p> </dd></param>	
        /// <param name="quantizationTableRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>	
        /// <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref="SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref="SharpDX.WIC.ResultCode.InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref="SharpDX.WIC.ResultCode.InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameEncode::GetQuantizationTable']/*"/>	
        /// <msdn-id>dn903873</msdn-id>	
        /// <unmanaged>HRESULT IWICJpegFrameEncode::GetQuantizationTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_QUANTIZATION_TABLE* pQuantizationTable)</unmanaged>	
        /// <unmanaged-short>IWICJpegFrameEncode::GetQuantizationTable</unmanaged-short>	
        public void GetQuantizationTable(int scanIndex, int tableIndex, out SharpDX.DXGI.JpegQuantizationTable quantizationTableRef) {
            unsafe {
                var quantizationTableRef_ = new SharpDX.DXGI.JpegQuantizationTable.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, scanIndex, tableIndex, &quantizationTableRef_,((void**)(*(void**)_nativePointer))[5]);		
                quantizationTableRef = new SharpDX.DXGI.JpegQuantizationTable();
                quantizationTableRef.__MarshalFrom(ref quantizationTableRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Writes scan data to a JPEG frame.</p>	
        /// </summary>	
        /// <param name="scanData"><dd>  <p>The size of the data in the <em>pbScanData</em> parameter.</p> </dd></param>	
        /// <param name="scanDataRef"><dd>  <p>The scan data to write.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> on successful completion.</p></returns>	
        /// <remarks>	
        /// <p><strong>WriteScan</strong> may be called multiple times.  Each call appends the scan data specified to any previous scan data.  Complete the scan by calling <strong><see cref="SharpDX.WIC.BitmapFrameEncode.Commit"/></strong>. </p><p>Any calls to set encoder parameters or image metadata that will appear before the scan data in the resulting JPEG file must be completed before the first call to this method.  This includes calls to <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetColorContexts"/></strong> , <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPalette"/></strong>, <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPixelFormat"/></strong>, <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetResolution"/></strong>, and <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetThumbnail"/></strong>.  <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetSize"/></strong> is required as it has no default value for encoded image size.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICJpegFrameEncode::WriteScan']/*"/>	
        /// <msdn-id>dn903875</msdn-id>	
        /// <unmanaged>HRESULT IWICJpegFrameEncode::WriteScan([In] unsigned int cbScanData,[In, Buffer] const unsigned char* pbScanData)</unmanaged>	
        /// <unmanaged-short>IWICJpegFrameEncode::WriteScan</unmanaged-short>	
        public void WriteScan(int scanData, byte[] scanDataRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* scanDataRef_ = scanDataRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, scanData, scanDataRef_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods for retrieving metadata blocks and items from a decoder or its image frames using a metadata query expression.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A metadata query reader uses metadata query expressions to access embedded metadata. For more information on the metadata query language, see the Metadata Query Language Overview.</p><p>The benefit of the query reader is the ability to access a metadata item in a single step.	
    /// </p><p>The query reader also provides the way to traverse the whole set of metadata hierarchy with the help of the <strong>GetEnumerator</strong> method.	
    /// However, it is not recommended to use this method since <strong>IWICMetadataBlockReader</strong> and <strong>IWICMetadataReader</strong> provide a more convenient and cheaper way.	
    /// </p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICMetadataQueryReader']/*"/>	
    /// <msdn-id>ee719708</msdn-id>	
    /// <unmanaged>IWICMetadataQueryReader</unmanaged>	
    /// <unmanaged-short>IWICMetadataQueryReader</unmanaged-short>	
    [Guid("30989668-E1C9-4597-B395-458EEDB808DF")]
    public partial class MetadataQueryReader : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.MetadataQueryReader"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MetadataQueryReader(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.MetadataQueryReader"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.MetadataQueryReader(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.MetadataQueryReader(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the metadata query readers container format.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICMetadataQueryReader::GetContainerFormat']/*"/>	
        /// <msdn-id>ee719709</msdn-id>	
        /// <unmanaged>GetContainerFormat</unmanaged>	
        /// <unmanaged-short>GetContainerFormat</unmanaged-short>	
        /// <unmanaged>HRESULT IWICMetadataQueryReader::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>
        public System.Guid ContainerFormat {
                get { System.Guid __output__; GetContainerFormat(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the metadata query readers container format.</p>	
        /// </summary>	
        /// <param name="guidContainerFormatRef"><dd>  <p>Pointer that receives the cointainer format <see cref="System.Guid"/>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICMetadataQueryReader::GetContainerFormat']/*"/>	
        /// <msdn-id>ee719709</msdn-id>	
        /// <unmanaged>HRESULT IWICMetadataQueryReader::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>	
        /// <unmanaged-short>IWICMetadataQueryReader::GetContainerFormat</unmanaged-short>	
        internal void GetContainerFormat(out System.Guid guidContainerFormatRef) {
            unsafe {
                guidContainerFormatRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* guidContainerFormatRef_ = &guidContainerFormatRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, guidContainerFormatRef_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the current path relative to the root metadata block.</p>	
        /// </summary>	
        /// <param name="cchMaxLength"><dd>  <p>The length of the <em>wzNamespace</em> buffer.</p> </dd></param>	
        /// <param name="@namespace"><dd>  <p>Pointer that receives the current namespace location.</p> </dd></param>	
        /// <param name="cchActualLengthRef"><dd>  <p>The actual buffer length that was needed to retrieve the current namespace location.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If you pass <strong><c>null</c></strong> to <em>wzNamespace</em>, <strong>GetLocation</strong> ignores <em>cchMaxLength</em> and returns the required buffer length to store the path in the variable that <em>pcchActualLength</em> points to.	
        /// </p><p>If the query reader is relative to the top of the metadata hierarchy, it will return a single-char string.</p><p>If the query reader is relative to a nested metadata block, this method will return the path to the current query reader.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICMetadataQueryReader::GetLocation']/*"/>	
        /// <msdn-id>ee719713</msdn-id>	
        /// <unmanaged>HRESULT IWICMetadataQueryReader::GetLocation([In] unsigned int cchMaxLength,[In] void* wzNamespace,[Out] unsigned int* pcchActualLength)</unmanaged>	
        /// <unmanaged-short>IWICMetadataQueryReader::GetLocation</unmanaged-short>	
        internal void GetLocation(int cchMaxLength, System.IntPtr @namespace, out int cchActualLengthRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* cchActualLengthRef_ = &cchActualLengthRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, cchMaxLength, (void*)@namespace, cchActualLengthRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the metadata block or item identified by a metadata query expression. </p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>The query expression to the requested metadata block or item.</p> </dd></param>	
        /// <param name="varValueRef"><dd>  <p>When this method returns, contains the metadata block or item requested.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><strong>GetMetadataByName</strong> uses metadata query expressions to access embedded metadata. For more information on the metadata query language, see the Metadata Query Language Overview.</p><p>If multiple blocks or items exist that are expressed by the same query expression, the first metadata block or item found will be returned.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICMetadataQueryReader::GetMetadataByName']/*"/>	
        /// <msdn-id>ee719715</msdn-id>	
        /// <unmanaged>HRESULT IWICMetadataQueryReader::GetMetadataByName([In] const wchar_t* wzName,[In] void* pvarValue)</unmanaged>	
        /// <unmanaged-short>IWICMetadataQueryReader::GetMetadataByName</unmanaged-short>	
        internal SharpDX.Result GetMetadataByName(string name, System.IntPtr varValueRef) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalUni(name);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)name_, (void*)varValueRef,((void**)(*(void**)_nativePointer))[5]);		
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets an enumerator of all metadata items at the current relative location within the metadata hierarchy.</p>	
        /// </summary>	
        /// <returns><dd>  <p>A reference to a variable that receives a reference to the <strong><see cref="SharpDX.ComObject"/></strong> interface for the enumerator that contains query strings that can be used in the current <strong><see cref="SharpDX.WIC.MetadataQueryReader"/></strong>.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The retrieved enumerator only contains query strings for the metadata blocks and items in the current level of the hierarchy.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICMetadataQueryReader::GetEnumerator']/*"/>	
        /// <msdn-id>ee719711</msdn-id>	
        /// <unmanaged>HRESULT IWICMetadataQueryReader::GetEnumerator([Out] void** ppIEnumString)</unmanaged>	
        /// <unmanaged-short>IWICMetadataQueryReader::GetEnumerator</unmanaged-short>	
        internal System.IntPtr GetEnumerator() {
            unsafe {
                System.IntPtr enumStringOut;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &enumStringOut,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
                return enumStringOut;
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods for setting or removing metadata blocks and items to an encoder or its image frames using a metadata query expression.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A metadata query writer uses metadata query expressions to set or remove metadata. For more information on the metadata query language, see the Metadata Query Language Overview.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICMetadataQueryWriter']/*"/>	
    /// <msdn-id>ee719717</msdn-id>	
    /// <unmanaged>IWICMetadataQueryWriter</unmanaged>	
    /// <unmanaged-short>IWICMetadataQueryWriter</unmanaged-short>	
    [Guid("A721791A-0DEF-4d06-BD91-2118BF1DB10B")]
    public partial class MetadataQueryWriter : SharpDX.WIC.MetadataQueryReader {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.MetadataQueryWriter"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public MetadataQueryWriter(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.MetadataQueryWriter"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.MetadataQueryWriter(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.MetadataQueryWriter(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Sets a metadata item to a specific location.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>The name of the metadata item.</p> </dd></param>	
        /// <param name="varValueRef"><dd>  <p>The metadata to set.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><strong>SetMetadataByName</strong> uses metadata query expressions to remove metadata. For more information on the metadata query language, see the Metadata Query Language Overview.</p><p> If the value set is a nested metadata block then use variant type <code>VT_UNKNOWN</code> and <em>pvarValue</em> pointing to the <strong><see cref="SharpDX.WIC.MetadataQueryWriter"/></strong> of the new metadata block.   The ordering of metadata items is at the discretion of the query writer since relative locations are not specified. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICMetadataQueryWriter::SetMetadataByName']/*"/>	
        /// <msdn-id>ee719720</msdn-id>	
        /// <unmanaged>HRESULT IWICMetadataQueryWriter::SetMetadataByName([In] const wchar_t* wzName,[In] const void* pvarValue)</unmanaged>	
        /// <unmanaged-short>IWICMetadataQueryWriter::SetMetadataByName</unmanaged-short>	
        internal void SetMetadataByName(string name, System.IntPtr varValueRef) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalUni(name);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)name_, (void*)varValueRef,((void**)(*(void**)_nativePointer))[7]);		
                Marshal.FreeHGlobal(name_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes a metadata item from a specific location using a metadata query expression.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>The name of the metadata item to remove.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><strong>RemoveMetadataByName</strong> uses metadata query expressions to remove metadata. For more information on the metadata query language, see the Metadata Query Language Overview.</p><p>If the metadata item is a metadata block, it is removed from the metadata hierarchy.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICMetadataQueryWriter::RemoveMetadataByName']/*"/>	
        /// <msdn-id>ee719718</msdn-id>	
        /// <unmanaged>HRESULT IWICMetadataQueryWriter::RemoveMetadataByName([In] const wchar_t* wzName)</unmanaged>	
        /// <unmanaged-short>IWICMetadataQueryWriter::RemoveMetadataByName</unmanaged-short>	
        public void RemoveMetadataByName(string name) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalUni(name);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)name_,((void**)(*(void**)_nativePointer))[8]);		
                Marshal.FreeHGlobal(name_ );
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods for accessing and building a color table, primarily for indexed pixel formats.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>If the <strong><see cref="SharpDX.WIC.BitmapPaletteType"/></strong> is not <strong>WICBitmapPaletteCustom</strong>, then the colors are automatically generated based on the table above.  If the user subsequently changes a color palette entry the WICBitmapPalette is set to Custom by that action.</p><p> <strong>InitializeFromBitmap</strong>'s <em>fAddTransparentColor</em> parameter will add a transparent color to the end of the color collection if its size if less than 256, otherwise index 255 will be replaced with the transparent color.  If a pre-defined palette type is used, it will change to BitmapPaletteTypeCustom since it no longer matches the predefined palette.</p><p>The palette interface is an auxiliary imaging interface in that it does not directly concern bitmaps and pixels; rather it provides indexed color translation for indexed bitmaps. For an indexed pixel format with M bits per pixels: (The number of colors in the palette) greater than 2^M.</p><p>Traditionally the basic operation of the palette is to provide a translation from a byte (or smaller) index into a 32bpp color value. This is often accomplished by a 256 entry table of color values.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPalette']/*"/>	
    /// <msdn-id>ee719741</msdn-id>	
    /// <unmanaged>IWICPalette</unmanaged>	
    /// <unmanaged-short>IWICPalette</unmanaged-short>	
    [Guid("00000040-a8f2-4877-ba0a-fd2b6645fb94")]
    public partial class Palette : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.Palette"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Palette(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.Palette"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.Palette(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.Palette(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the <strong><see cref="SharpDX.WIC.BitmapPaletteType"/></strong> that describes the palette. </p>	
        /// </summary>	
        /// <remarks>	
        /// <p><strong>WICBitmapPaletteCustom</strong> is used for palettes initialized from both <strong>InitializeCustom</strong> and <strong>InitializeFromBitmap</strong>. There is no distinction is made between optimized and custom palettes.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPalette::GetType']/*"/>	
        /// <msdn-id>ee719746</msdn-id>	
        /// <unmanaged>GetType</unmanaged>	
        /// <unmanaged-short>GetType</unmanaged-short>	
        /// <unmanaged>HRESULT IWICPalette::GetType([Out] WICBitmapPaletteType* pePaletteType)</unmanaged>
        public SharpDX.WIC.BitmapPaletteType TypeInfo {
                get { SharpDX.WIC.BitmapPaletteType __output__; GetTypeInfo(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the number of colors in the color table.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPalette::GetColorCount']/*"/>	
        /// <msdn-id>ee719742</msdn-id>	
        /// <unmanaged>GetColorCount</unmanaged>	
        /// <unmanaged-short>GetColorCount</unmanaged-short>	
        /// <unmanaged>HRESULT IWICPalette::GetColorCount([Out] unsigned int* pcCount)</unmanaged>
        public int ColorCount {
                get { int __output__; GetColorCount(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves a value that describes whether the palette is black and white.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>A palette is considered to be black and white only if it contains exactly two entries, one full black (0xFF000000) and one full white (0xFFFFFFF).	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPalette::IsBlackWhite']/*"/>	
        /// <msdn-id>ee719758</msdn-id>	
        /// <unmanaged>IsBlackWhite</unmanaged>	
        /// <unmanaged-short>IsBlackWhite</unmanaged-short>	
        /// <unmanaged>HRESULT IWICPalette::IsBlackWhite([Out] BOOL* pfIsBlackWhite)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsBlackWhite {
                get { SharpDX.Mathematics.Interop.RawBool __output__; IsBlackWhite_(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves a value that describes whether a palette is grayscale.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>A palette is considered grayscale only if, for every entry, the alpha value is 0xFF and the red, green and blue values match.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPalette::IsGrayscale']/*"/>	
        /// <msdn-id>ee719759</msdn-id>	
        /// <unmanaged>IsGrayscale</unmanaged>	
        /// <unmanaged-short>IsGrayscale</unmanaged-short>	
        /// <unmanaged>HRESULT IWICPalette::IsGrayscale([Out] BOOL* pfIsGrayscale)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsGrayscale {
                get { SharpDX.Mathematics.Interop.RawBool __output__; IsGrayscale_(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Initializes the palette to one of the pre-defined palettes specified by <strong><see cref="SharpDX.WIC.BitmapPaletteType"/></strong> and optionally adds a transparent color.</p>	
        /// </summary>	
        /// <param name="ePaletteType">No documentation.</param>	
        /// <param name="fAddTransparentColor">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If a transparent color is added to a palette, the palette is no longer predefined and is returned as <strong><see cref="SharpDX.WIC.BitmapPaletteType.Custom"/></strong>. For palettes with less than 256 entries, the transparent entry is added to the end of the palette (that is, a 16-color palette becomes a 17-color palette). For palettes with 256 colors, the transparent palette entry will replace the last entry in the pre-defined palette.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPalette::InitializePredefined']/*"/>	
        /// <msdn-id>ee719756</msdn-id>	
        /// <unmanaged>HRESULT IWICPalette::InitializePredefined([In] WICBitmapPaletteType ePaletteType,[In] BOOL fAddTransparentColor)</unmanaged>	
        /// <unmanaged-short>IWICPalette::InitializePredefined</unmanaged-short>	
        public void Initialize(SharpDX.WIC.BitmapPaletteType ePaletteType, SharpDX.Mathematics.Interop.RawBool fAddTransparentColor) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint72(_nativePointer, unchecked((int)ePaletteType), fAddTransparentColor,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Initializes a palette to the custom color entries provided.</p>	
        /// </summary>	
        /// <param name="colorsRef"><dd>  <p>Pointer to the color array.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of colors in <em>pColors</em>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If a transparent color is required, provide it as part of the custom entries. To add a transparent value to the palette, its alpha value must be 0 (0x00RRGGBB).	
        /// </p><p>The entry count is limited to 256.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPalette::InitializeCustom']/*"/>	
        /// <msdn-id>ee719750</msdn-id>	
        /// <unmanaged>HRESULT IWICPalette::InitializeCustom([In, Buffer] void* pColors,[In] unsigned int cCount)</unmanaged>	
        /// <unmanaged-short>IWICPalette::InitializeCustom</unmanaged-short>	
        internal void Initialize(System.IntPtr colorsRef, int count) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)colorsRef, count,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Initializes a palette using a computed optimized values based on the reference bitmap.</p>	
        /// </summary>	
        /// <param name="surfaceRef"><dd>  <p>Pointer to the source bitmap.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of colors to initialize the palette with.</p> </dd></param>	
        /// <param name="fAddTransparentColor"><dd>  <p>A value to indicate whether to add a transparent color.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The resulting palette contains the specified number of colors which best represent the colors present in the bitmap. The algorithm operates on the opaque RGB color value of each pixel in the reference bitmap and hence ignores any alpha values. If a transparent color is required, set the fAddTransparentColor parameter to <strong>TRUE</strong> and one fewer optimized color will be computed, reducing the <em>colorCount</em>, and a fully transparent color entry will be added. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPalette::InitializeFromBitmap']/*"/>	
        /// <msdn-id>ee719752</msdn-id>	
        /// <unmanaged>HRESULT IWICPalette::InitializeFromBitmap([In, Optional] IWICBitmapSource* pISurface,[In] unsigned int cCount,[In] BOOL fAddTransparentColor)</unmanaged>	
        /// <unmanaged-short>IWICPalette::InitializeFromBitmap</unmanaged-short>	
        public void Initialize(SharpDX.WIC.BitmapSource surfaceRef, int count, SharpDX.Mathematics.Interop.RawBool fAddTransparentColor) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint73(_nativePointer, (void*)((surfaceRef == null)?IntPtr.Zero:surfaceRef.NativePointer), count, fAddTransparentColor,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Initialize the palette based on a given palette.</p>	
        /// </summary>	
        /// <param name="paletteRef"><dd>  <p>Pointer to the source palette.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPalette::InitializeFromPalette']/*"/>	
        /// <msdn-id>ee719754</msdn-id>	
        /// <unmanaged>HRESULT IWICPalette::InitializeFromPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>	
        /// <unmanaged-short>IWICPalette::InitializeFromPalette</unmanaged-short>	
        public void Initialize(SharpDX.WIC.Palette paletteRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((paletteRef == null)?IntPtr.Zero:paletteRef.NativePointer),((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the <strong><see cref="SharpDX.WIC.BitmapPaletteType"/></strong> that describes the palette. </p>	
        /// </summary>	
        /// <param name="ePaletteTypeRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p><strong>WICBitmapPaletteCustom</strong> is used for palettes initialized from both <strong>InitializeCustom</strong> and <strong>InitializeFromBitmap</strong>. There is no distinction is made between optimized and custom palettes.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPalette::GetType']/*"/>	
        /// <msdn-id>ee719746</msdn-id>	
        /// <unmanaged>HRESULT IWICPalette::GetType([Out] WICBitmapPaletteType* pePaletteType)</unmanaged>	
        /// <unmanaged-short>IWICPalette::GetType</unmanaged-short>	
        internal void GetTypeInfo(out SharpDX.WIC.BitmapPaletteType ePaletteTypeRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* ePaletteTypeRef_ = &ePaletteTypeRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, ePaletteTypeRef_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the number of colors in the color table.</p>	
        /// </summary>	
        /// <param name="countRef"><dd>  <p>Pointer that receives the number of colors in the color table.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPalette::GetColorCount']/*"/>	
        /// <msdn-id>ee719742</msdn-id>	
        /// <unmanaged>HRESULT IWICPalette::GetColorCount([Out] unsigned int* pcCount)</unmanaged>	
        /// <unmanaged-short>IWICPalette::GetColorCount</unmanaged-short>	
        internal void GetColorCount(out int countRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* countRef_ = &countRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, countRef_,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Fills out the supplied color array with the colors from the internal color table. The color array should be sized according to the return results from <strong>GetColorCount</strong>.</p>	
        /// </summary>	
        /// <param name="count">No documentation.</param>	
        /// <param name="colorsRef">No documentation.</param>	
        /// <param name="actualColorsRef">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPalette::GetColors']/*"/>	
        /// <msdn-id>ee719744</msdn-id>	
        /// <unmanaged>HRESULT IWICPalette::GetColors([In] unsigned int cCount,[Out, Buffer] void* pColors,[Out] unsigned int* pcActualColors)</unmanaged>	
        /// <unmanaged-short>IWICPalette::GetColors</unmanaged-short>	
        internal void GetColors(int count, System.IntPtr colorsRef, out int actualColorsRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* actualColorsRef_ = &actualColorsRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, count, (void*)colorsRef, actualColorsRef_,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a value that describes whether the palette is black and white.</p>	
        /// </summary>	
        /// <param name="fIsBlackWhiteRef"><dd>  <p>A reference to a variable  that receives a boolean value that indicates whether the palette is black and white. <strong>TRUE</strong> indicates that the palette is black and white; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>A palette is considered to be black and white only if it contains exactly two entries, one full black (0xFF000000) and one full white (0xFFFFFFF).	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPalette::IsBlackWhite']/*"/>	
        /// <msdn-id>ee719758</msdn-id>	
        /// <unmanaged>HRESULT IWICPalette::IsBlackWhite([Out] BOOL* pfIsBlackWhite)</unmanaged>	
        /// <unmanaged-short>IWICPalette::IsBlackWhite</unmanaged-short>	
        internal void IsBlackWhite_(out SharpDX.Mathematics.Interop.RawBool fIsBlackWhiteRef) {
            unsafe {
                fIsBlackWhiteRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fIsBlackWhiteRef_ = &fIsBlackWhiteRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, fIsBlackWhiteRef_,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a value that describes whether a palette is grayscale.</p>	
        /// </summary>	
        /// <param name="fIsGrayscaleRef"><dd>  <p>A reference to a variable that receives a boolean value that indicates whether the palette is grayscale. <strong>TRUE</strong> indicates that the palette is grayscale; otherwise <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>A palette is considered grayscale only if, for every entry, the alpha value is 0xFF and the red, green and blue values match.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPalette::IsGrayscale']/*"/>	
        /// <msdn-id>ee719759</msdn-id>	
        /// <unmanaged>HRESULT IWICPalette::IsGrayscale([Out] BOOL* pfIsGrayscale)</unmanaged>	
        /// <unmanaged-short>IWICPalette::IsGrayscale</unmanaged-short>	
        internal void IsGrayscale_(out SharpDX.Mathematics.Interop.RawBool fIsGrayscaleRef) {
            unsafe {
                fIsGrayscaleRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fIsGrayscaleRef_ = &fIsGrayscaleRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, fIsGrayscaleRef_,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Indicates whether the palette contains an entry that is non-opaque (that is, an entry with an alpha that is less than 1).	
        /// </p>	
        /// </summary>	
        /// <param name="fHasAlphaRef"><dd>  <p>Pointer that receives <code>TRUE</code> if the palette contains a transparent color; otherwise, <code><see cref="SharpDX.Result.False"/></code>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Various image formats support alpha in different ways. PNG has full alpha support by supporting partially transparent palette entries. GIF stores colors as 24bpp, without alpha, but allows one palette entry to be specified as fully transparent. If a palette has multiple fully transparent entries (0x00RRGGBB), GIF will use the last one as its transparent index.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPalette::HasAlpha']/*"/>	
        /// <msdn-id>ee719748</msdn-id>	
        /// <unmanaged>HRESULT IWICPalette::HasAlpha([Out] BOOL* pfHasAlpha)</unmanaged>	
        /// <unmanaged-short>IWICPalette::HasAlpha</unmanaged-short>	
        public void HasAlpha(out SharpDX.Mathematics.Interop.RawBool fHasAlphaRef) {
            unsafe {
                fHasAlphaRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fHasAlphaRef_ = &fHasAlphaRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, fHasAlphaRef_,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods that provide information about a pixel format.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPixelFormatInfo']/*"/>	
    /// <msdn-id>ee719763</msdn-id>	
    /// <unmanaged>IWICPixelFormatInfo</unmanaged>	
    /// <unmanaged-short>IWICPixelFormatInfo</unmanaged-short>	
    [Guid("E8EDA601-3D48-431a-AB44-69059BE88BBE")]
    public partial class PixelFormatInfo : SharpDX.WIC.ComponentInfo {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.PixelFormatInfo"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PixelFormatInfo(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.PixelFormatInfo"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.PixelFormatInfo(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.PixelFormatInfo(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the pixel format <see cref="System.Guid"/>.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPixelFormatInfo::GetFormatGUID']/*"/>	
        /// <msdn-id>ee719774</msdn-id>	
        /// <unmanaged>GetFormatGUID</unmanaged>	
        /// <unmanaged-short>GetFormatGUID</unmanaged-short>	
        /// <unmanaged>HRESULT IWICPixelFormatInfo::GetFormatGUID([Out] GUID* pFormat)</unmanaged>
        public System.Guid FormatGUID {
                get { System.Guid __output__; GetFormatGUID(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the pixel format's <strong><see cref="SharpDX.WIC.ColorContext"/></strong>.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The returned color context is the default color space for the pixel format. However, if an <see cref="SharpDX.WIC.BitmapSource"/> specifies its own color context, the source's context should be preferred over the pixel format's default.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPixelFormatInfo::GetColorContext']/*"/>	
        /// <msdn-id>ee719773</msdn-id>	
        /// <unmanaged>GetColorContext</unmanaged>	
        /// <unmanaged-short>GetColorContext</unmanaged-short>	
        /// <unmanaged>HRESULT IWICPixelFormatInfo::GetColorContext([Out] IWICColorContext** ppIColorContext)</unmanaged>
        public SharpDX.WIC.ColorContext ColorContext {
                get { SharpDX.WIC.ColorContext __output__; GetColorContext(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the bits per pixel (BPP) of the pixel format.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPixelFormatInfo::GetBitsPerPixel']/*"/>	
        /// <msdn-id>ee719767</msdn-id>	
        /// <unmanaged>GetBitsPerPixel</unmanaged>	
        /// <unmanaged-short>GetBitsPerPixel</unmanaged-short>	
        /// <unmanaged>HRESULT IWICPixelFormatInfo::GetBitsPerPixel([Out] unsigned int* puiBitsPerPixel)</unmanaged>
        public int BitsPerPixel {
                get { int __output__; GetBitsPerPixel(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the number of channels the pixel format contains.</p>	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPixelFormatInfo::GetChannelCount']/*"/>	
        /// <msdn-id>ee719769</msdn-id>	
        /// <unmanaged>GetChannelCount</unmanaged>	
        /// <unmanaged-short>GetChannelCount</unmanaged-short>	
        /// <unmanaged>HRESULT IWICPixelFormatInfo::GetChannelCount([Out] unsigned int* puiChannelCount)</unmanaged>
        public int ChannelCount {
                get { int __output__; GetChannelCount(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the pixel format <see cref="System.Guid"/>.</p>	
        /// </summary>	
        /// <param name="formatRef"><dd>  <p>Pointer that receives the pixel format <see cref="System.Guid"/>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPixelFormatInfo::GetFormatGUID']/*"/>	
        /// <msdn-id>ee719774</msdn-id>	
        /// <unmanaged>HRESULT IWICPixelFormatInfo::GetFormatGUID([Out] GUID* pFormat)</unmanaged>	
        /// <unmanaged-short>IWICPixelFormatInfo::GetFormatGUID</unmanaged-short>	
        internal void GetFormatGUID(out System.Guid formatRef) {
            unsafe {
                formatRef = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* formatRef_ = &formatRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, formatRef_,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the pixel format's <strong><see cref="SharpDX.WIC.ColorContext"/></strong>.</p>	
        /// </summary>	
        /// <param name="colorContextOut">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The returned color context is the default color space for the pixel format. However, if an <see cref="SharpDX.WIC.BitmapSource"/> specifies its own color context, the source's context should be preferred over the pixel format's default.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPixelFormatInfo::GetColorContext']/*"/>	
        /// <msdn-id>ee719773</msdn-id>	
        /// <unmanaged>HRESULT IWICPixelFormatInfo::GetColorContext([Out] IWICColorContext** ppIColorContext)</unmanaged>	
        /// <unmanaged-short>IWICPixelFormatInfo::GetColorContext</unmanaged-short>	
        internal void GetColorContext(out SharpDX.WIC.ColorContext colorContextOut) {
            unsafe {
                IntPtr colorContextOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, &colorContextOut_,((void**)(*(void**)_nativePointer))[12]);		
                colorContextOut= (colorContextOut_ == IntPtr.Zero)?null:new SharpDX.WIC.ColorContext(colorContextOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the bits per pixel (BPP) of the pixel format.</p>	
        /// </summary>	
        /// <param name="bitsPerPixelRef"><dd>  <p>Pointer that receives the BPP of the pixel format.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPixelFormatInfo::GetBitsPerPixel']/*"/>	
        /// <msdn-id>ee719767</msdn-id>	
        /// <unmanaged>HRESULT IWICPixelFormatInfo::GetBitsPerPixel([Out] unsigned int* puiBitsPerPixel)</unmanaged>	
        /// <unmanaged-short>IWICPixelFormatInfo::GetBitsPerPixel</unmanaged-short>	
        internal void GetBitsPerPixel(out int bitsPerPixelRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* bitsPerPixelRef_ = &bitsPerPixelRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, bitsPerPixelRef_,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of channels the pixel format contains.</p>	
        /// </summary>	
        /// <param name="channelCountRef"><dd>  <p>Pointer that receives the channel count.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPixelFormatInfo::GetChannelCount']/*"/>	
        /// <msdn-id>ee719769</msdn-id>	
        /// <unmanaged>HRESULT IWICPixelFormatInfo::GetChannelCount([Out] unsigned int* puiChannelCount)</unmanaged>	
        /// <unmanaged-short>IWICPixelFormatInfo::GetChannelCount</unmanaged-short>	
        internal void GetChannelCount(out int channelCountRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* channelCountRef_ = &channelCountRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, channelCountRef_,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the pixel format's channel mask.</p>	
        /// </summary>	
        /// <param name="channelIndex"><dd>  <p>The index to the channel mask to retrieve.</p> </dd></param>	
        /// <param name="maskBuffer"><dd>  <p>The size of the <em>pbMaskBuffer</em> buffer.</p> </dd></param>	
        /// <param name="maskBufferRef"><dd>  <p>Pointer to the mask buffer.</p> </dd></param>	
        /// <param name="actualRef"><dd>  <p>The actual buffer size needed to obtain the channel mask.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>If 0 and <c>null</c> are passed in for <em>cbMaskBuffer</em> and <em>pbMaskBuffer</em>, respectively, the required buffer size will be returned through <em>pcbActual</em>.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPixelFormatInfo::GetChannelMask']/*"/>	
        /// <msdn-id>ee719771</msdn-id>	
        /// <unmanaged>HRESULT IWICPixelFormatInfo::GetChannelMask([In] unsigned int uiChannelIndex,[In] unsigned int cbMaskBuffer,[In] void* pbMaskBuffer,[Out] unsigned int* pcbActual)</unmanaged>	
        /// <unmanaged-short>IWICPixelFormatInfo::GetChannelMask</unmanaged-short>	
        internal void GetChannelMask(int channelIndex, int maskBuffer, System.IntPtr maskBufferRef, out int actualRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* actualRef_ = &actualRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, channelIndex, maskBuffer, (void*)maskBufferRef, actualRef_,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Extends <strong><see cref="SharpDX.WIC.PixelFormatInfo"/></strong> by providing additional information about a pixel format.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPixelFormatInfo2']/*"/>	
    /// <msdn-id>ee719764</msdn-id>	
    /// <unmanaged>IWICPixelFormatInfo2</unmanaged>	
    /// <unmanaged-short>IWICPixelFormatInfo2</unmanaged-short>	
    [Guid("A9DB33A2-AF5F-43C7-B679-74F5984B5AA4")]
    public partial class PixelFormatInfo2 : SharpDX.WIC.PixelFormatInfo {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.PixelFormatInfo2"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PixelFormatInfo2(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.PixelFormatInfo2"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.PixelFormatInfo2(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.PixelFormatInfo2(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Returns whether the format supports transparent pixels.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> An indexed pixel format will not return <strong>TRUE</strong> even though it may have some transparency support.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPixelFormatInfo2::SupportsTransparency']/*"/>	
        /// <msdn-id>ee719766</msdn-id>	
        /// <unmanaged>SupportsTransparency</unmanaged>	
        /// <unmanaged-short>SupportsTransparency</unmanaged-short>	
        /// <unmanaged>HRESULT IWICPixelFormatInfo2::SupportsTransparency([Out] BOOL* pfSupportsTransparency)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsSupportingTransparency {
                get { SharpDX.Mathematics.Interop.RawBool __output__; IsSupportingTransparency_(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPixelFormatInfo2::GetNumericRepresentation']/*"/>	
        /// <msdn-id>ee719765</msdn-id>	
        /// <unmanaged>GetNumericRepresentation</unmanaged>	
        /// <unmanaged-short>GetNumericRepresentation</unmanaged-short>	
        /// <unmanaged>HRESULT IWICPixelFormatInfo2::GetNumericRepresentation([Out] WICPixelFormatNumericRepresentation* pNumericRepresentation)</unmanaged>
        public SharpDX.WIC.PixelFormatNumericRepresentation NumericRepresentation {
                get { SharpDX.WIC.PixelFormatNumericRepresentation __output__; GetNumericRepresentation(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Returns whether the format supports transparent pixels.</p>	
        /// </summary>	
        /// <param name="fSupportsTransparencyRef"><dd>  <p>Returns <strong>TRUE</strong> if the pixel format supports transparency; otherwise, <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> An indexed pixel format will not return <strong>TRUE</strong> even though it may have some transparency support.	
        /// </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPixelFormatInfo2::SupportsTransparency']/*"/>	
        /// <msdn-id>ee719766</msdn-id>	
        /// <unmanaged>HRESULT IWICPixelFormatInfo2::SupportsTransparency([Out] BOOL* pfSupportsTransparency)</unmanaged>	
        /// <unmanaged-short>IWICPixelFormatInfo2::SupportsTransparency</unmanaged-short>	
        internal void IsSupportingTransparency_(out SharpDX.Mathematics.Interop.RawBool fSupportsTransparencyRef) {
            unsafe {
                fSupportsTransparencyRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* fSupportsTransparencyRef_ = &fSupportsTransparencyRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, fSupportsTransparencyRef_,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="numericRepresentationRef"><dd>  <p>Returns the <strong><see cref="SharpDX.WIC.PixelFormatNumericRepresentation"/></strong> of the pixel format.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPixelFormatInfo2::GetNumericRepresentation']/*"/>	
        /// <msdn-id>ee719765</msdn-id>	
        /// <unmanaged>HRESULT IWICPixelFormatInfo2::GetNumericRepresentation([Out] WICPixelFormatNumericRepresentation* pNumericRepresentation)</unmanaged>	
        /// <unmanaged-short>IWICPixelFormatInfo2::GetNumericRepresentation</unmanaged-short>	
        internal void GetNumericRepresentation(out SharpDX.WIC.PixelFormatNumericRepresentation numericRepresentationRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* numericRepresentationRef_ = &numericRepresentationRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, numericRepresentationRef_,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Allows planar component image pixels to be written to an encoder.   When supported by the encoder, this allows an application to encode planar component image data without first converting to an interleaved pixel format.</p><p>You can use QueryInterface to obtain this interface from the Windows provided implementation of <strong><see cref="SharpDX.WIC.BitmapFrameEncode"/></strong> for the JPEG encoder.  	
    /// </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Encoding YCbCr data using <strong><see cref="SharpDX.WIC.PlanarBitmapFrameEncode"/></strong> is similar but not identical to encoding interleaved data using <see cref="SharpDX.WIC.BitmapFrameEncode"/>. The planar interface only exposes the ability to write planar frame image data, and you should continue to use the frame encode interface to set metadata or a thumbnail and to commit at the end of the operation.	
    /// </p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPlanarBitmapFrameEncode']/*"/>	
    /// <msdn-id>dn302090</msdn-id>	
    /// <unmanaged>IWICPlanarBitmapFrameEncode</unmanaged>	
    /// <unmanaged-short>IWICPlanarBitmapFrameEncode</unmanaged-short>	
    [Guid("F928B7B8-2221-40C1-B72E-7E82F1974D1A")]
    public partial class PlanarBitmapFrameEncode : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.PlanarBitmapFrameEncode"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PlanarBitmapFrameEncode(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.PlanarBitmapFrameEncode"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.PlanarBitmapFrameEncode(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.PlanarBitmapFrameEncode(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Writes lines from the source planes to the encoded format.</p>	
        /// </summary>	
        /// <param name="lineCount"><dd>  <p>The number of lines to encode.  See the Remarks section for WIC Jpeg specific line count restrictions.</p> </dd></param>	
        /// <param name="planesRef"><dd>  <p>Specifies the source buffers for each component plane encoded.  </p> </dd></param>	
        /// <param name="planes"><dd>  <p>The number of component planes specified by the <em>pPlanes</em> parameter.</p> </dd></param>	
        /// <returns><p>If the planes and source rectangle do not meet the requirements, this method fails with <strong><see cref="SharpDX.WIC.ResultCode.Imagesizeoutofrange"/></strong>. If the <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> format does not meet the encoder requirements, this method fails with <strong><see cref="SharpDX.WIC.ResultCode.UnsupportedPixelFormat"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>Successive <strong>WritePixels</strong> calls are assumed sequentially add scanlines to the output image.  <strong><see cref="SharpDX.WIC.BitmapFrameEncode.Initialize"/></strong>, <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetSize"/></strong> and <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPixelFormat"/></strong> must be called before this method or it will fail.</p><p>The interleaved pixel format set via <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPixelFormat"/></strong> and the codec specific encode parameters determine the supported planar formats.	
        /// </p><p>WIC JPEG Encoder:	
        /// QueryInterface can be used to obtain this interface from the WIC JPEG <strong><see cref="SharpDX.WIC.BitmapFrameEncode"/></strong> implementation.  When using this method to encode Y?CbCr data with the WIC JPEG encoder, chroma subsampling can be configured with encoder options during frame creation.  See the Encoding Overview and <strong><see cref="SharpDX.WIC.BitmapEncoder.CreateNewFrame"/></strong> for more details.   </p><p>Depending upon the configured chroma subsampling, the lineCount parameter has the following restrictions:	
        /// </p><table> <tr><th>Chroma Subsampling</th><th>Line Count Restriction</th><th>Chroma Plane Width</th><th>Chroma  Plane Height</th></tr> <tr><td>4:2:0</td><td>Multiple of 2, unless the call covers the last scanline of the image</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight / 2 Rounded up to the nearest integer.</td></tr> <tr><td>4:2:2</td><td>Any</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>Any</td></tr> <tr><td>4:4:4</td><td>Any</td><td>Any</td><td>Any</td></tr> <tr><td>4:4:0</td><td>Multiple of 2, unless the call covers the last scanline of the image</td><td>Any</td><td>llumaHeight / 2 Rounded up to the nearest integer.</td></tr> </table><p>?</p><p>The full scanline width must be encoded, and the width of the bitmap sources must match their planar configuration.</p><p>Additionally, if a pixel format is set via <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPixelFormat"/></strong>, it must be <see cref="SharpDX.WIC.PixelFormat.Format24bppBGR"/>.   </p><p>The supported pixel formats of the bitmap sources passed into this method are as follows:	
        /// </p><table> <tr><th>Plane Count</th><th>Plane 1</th><th>Plane 2</th><th>Plane 3</th></tr> <tr><td>3</td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppY"/></td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppCb"/></td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppCr"/></td></tr> <tr><td>2</td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppY"/></td><td><see cref="SharpDX.WIC.PixelFormat.Format16bppCbCr"/></td><td>N/A</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPlanarBitmapFrameEncode::WritePixels']/*"/>	
        /// <msdn-id>dn302091</msdn-id>	
        /// <unmanaged>HRESULT IWICPlanarBitmapFrameEncode::WritePixels([In] unsigned int lineCount,[In, Buffer] WICBitmapPlane* pPlanes,[In] unsigned int cPlanes)</unmanaged>	
        /// <unmanaged-short>IWICPlanarBitmapFrameEncode::WritePixels</unmanaged-short>	
        public void WritePixels(int lineCount, SharpDX.WIC.BitmapPlane[] planesRef, int planes) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* planesRef_ = planesRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, lineCount, planesRef_, planes,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Writes lines from the source planes to the encoded format.</p>	
        /// </summary>	
        /// <param name="planesOut"><dd>  <p>Specifies an array of <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> that represent image planes.</p> </dd></param>	
        /// <param name="planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>	
        /// <param name="rcSourceRef"><dd>  <p>The source rectangle of pixels to encode from the <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> planes.  Null indicates the entire source.  The source rect width must match the width set through <strong>SetSize</strong>. Repeated <strong>WriteSource</strong> calls can be made as long as the total accumulated source rect height is the same as set through <strong>SetSize</strong>.  </p> </dd></param>	
        /// <returns><p>If the planes and source rectangle do not meet the requirements, this method fails with <strong><see cref="SharpDX.WIC.ResultCode.Imagesizeoutofrange"/></strong>. </p><p>If the <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> format does not meet the encoder requirements, this method fails with <strong><see cref="SharpDX.WIC.ResultCode.UnsupportedPixelFormat"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>Successive <strong>WriteSource</strong> calls are assumed sequentially add scanlines to the output image.  <strong><see cref="SharpDX.WIC.BitmapFrameEncode.Initialize"/></strong>, <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetSize"/></strong> and <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPixelFormat"/></strong> must be called before this method or it will fail.</p><p>The interleaved pixel format set via <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPixelFormat"/></strong> and the codec specific encode parameters determine the supported planar formats.	
        /// </p><p>WIC JPEG Encoder:	
        /// QueryInterface can be used to obtain this interface from the WIC JPEG <strong><see cref="SharpDX.WIC.BitmapFrameEncode"/></strong> implementation.  When using this method to encode Y?CbCr data with the WIC JPEG encoder, chroma subsampling can be configured with encoder options during frame creation.  See the Encoding Overview and <strong><see cref="SharpDX.WIC.BitmapEncoder.CreateNewFrame"/></strong> for more details.   </p><p>Depending upon the configured chroma subsampling, the lineCount parameter has the following restrictions:	
        /// </p><table> <tr><th>Chroma Subsampling</th><th>X Coordinate</th><th>Y Coordinate</th><th>Chroma Width</th><th>Chroma Height</th></tr> <tr><td>4:2:0</td><td>Multiple of 2</td><td>Multiple of 2</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight / 2 Rounded up to the nearest integer.</td></tr> <tr><td>4:2:2</td><td>Multiple of 2</td><td>Any</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>Any</td></tr> <tr><td>4:4:4</td><td>Any</td><td>Any</td><td>Any</td><td>Any</td></tr> <tr><td>4:4:0</td><td>Any</td><td>Multiple of 2</td><td>lumaWidth</td><td>llumaHeight / 2 Rounded up to the nearest integer.</td></tr> </table><p>?</p><p>The full scanline width must be encoded, and the width of the bitmap sources must match their planar configuration.</p><p>Additionally, if a pixel format is set via <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPixelFormat"/></strong>, it must be <see cref="SharpDX.WIC.PixelFormat.Format24bppBGR"/>.   </p><p>The supported pixel formats of the bitmap sources passed into this method are as follows:	
        /// </p><table> <tr><th>Plane Count</th><th>Plane 1</th><th>Plane 2</th><th>Plane 3</th></tr> <tr><td>3</td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppY"/></td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppCb"/></td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppCr"/></td></tr> <tr><td>2</td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppY"/></td><td><see cref="SharpDX.WIC.PixelFormat.Format16bppCbCr"/></td><td>N/A</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPlanarBitmapFrameEncode::WriteSource']/*"/>	
        /// <msdn-id>dn302092</msdn-id>	
        /// <unmanaged>HRESULT IWICPlanarBitmapFrameEncode::WriteSource([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In, Optional] WICRect* prcSource)</unmanaged>	
        /// <unmanaged-short>IWICPlanarBitmapFrameEncode::WriteSource</unmanaged-short>	
        public void WriteSource(SharpDX.WIC.BitmapSource[] planesOut, int planes, SharpDX.Mathematics.Interop.RawBox? rcSourceRef) {
            unsafe {
                IntPtr* planesOut_ = (IntPtr*)0;
                if ( planesOut != null ) {
                    IntPtr* planesOut__ = stackalloc IntPtr[planesOut.Length];
                    planesOut_ = planesOut__;
                    for (int i = 0; i < planesOut.Length; i++)                        
                        planesOut_[i] =  (planesOut[i] == null)? IntPtr.Zero : planesOut[i].NativePointer;
                }
                SharpDX.Mathematics.Interop.RawBox rcSourceRef_;
                if (rcSourceRef.HasValue)
                    rcSourceRef_ = rcSourceRef.Value;				
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, planesOut_, planes, (rcSourceRef.HasValue)?&rcSourceRef_:(void*)IntPtr.Zero,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Writes lines from the source planes to the encoded format.</p>	
        /// </summary>	
        /// <param name="planesOut"><dd>  <p>Specifies an array of <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> that represent image planes.</p> </dd></param>	
        /// <param name="planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>	
        /// <param name="rcSourceRef"><dd>  <p>The source rectangle of pixels to encode from the <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> planes.  Null indicates the entire source.  The source rect width must match the width set through <strong>SetSize</strong>. Repeated <strong>WriteSource</strong> calls can be made as long as the total accumulated source rect height is the same as set through <strong>SetSize</strong>.  </p> </dd></param>	
        /// <returns><p>If the planes and source rectangle do not meet the requirements, this method fails with <strong><see cref="SharpDX.WIC.ResultCode.Imagesizeoutofrange"/></strong>. </p><p>If the <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> format does not meet the encoder requirements, this method fails with <strong><see cref="SharpDX.WIC.ResultCode.UnsupportedPixelFormat"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>Successive <strong>WriteSource</strong> calls are assumed sequentially add scanlines to the output image.  <strong><see cref="SharpDX.WIC.BitmapFrameEncode.Initialize"/></strong>, <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetSize"/></strong> and <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPixelFormat"/></strong> must be called before this method or it will fail.</p><p>The interleaved pixel format set via <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPixelFormat"/></strong> and the codec specific encode parameters determine the supported planar formats.	
        /// </p><p>WIC JPEG Encoder:	
        /// QueryInterface can be used to obtain this interface from the WIC JPEG <strong><see cref="SharpDX.WIC.BitmapFrameEncode"/></strong> implementation.  When using this method to encode Y?CbCr data with the WIC JPEG encoder, chroma subsampling can be configured with encoder options during frame creation.  See the Encoding Overview and <strong><see cref="SharpDX.WIC.BitmapEncoder.CreateNewFrame"/></strong> for more details.   </p><p>Depending upon the configured chroma subsampling, the lineCount parameter has the following restrictions:	
        /// </p><table> <tr><th>Chroma Subsampling</th><th>X Coordinate</th><th>Y Coordinate</th><th>Chroma Width</th><th>Chroma Height</th></tr> <tr><td>4:2:0</td><td>Multiple of 2</td><td>Multiple of 2</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight / 2 Rounded up to the nearest integer.</td></tr> <tr><td>4:2:2</td><td>Multiple of 2</td><td>Any</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>Any</td></tr> <tr><td>4:4:4</td><td>Any</td><td>Any</td><td>Any</td><td>Any</td></tr> <tr><td>4:4:0</td><td>Any</td><td>Multiple of 2</td><td>lumaWidth</td><td>llumaHeight / 2 Rounded up to the nearest integer.</td></tr> </table><p>?</p><p>The full scanline width must be encoded, and the width of the bitmap sources must match their planar configuration.</p><p>Additionally, if a pixel format is set via <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPixelFormat"/></strong>, it must be <see cref="SharpDX.WIC.PixelFormat.Format24bppBGR"/>.   </p><p>The supported pixel formats of the bitmap sources passed into this method are as follows:	
        /// </p><table> <tr><th>Plane Count</th><th>Plane 1</th><th>Plane 2</th><th>Plane 3</th></tr> <tr><td>3</td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppY"/></td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppCb"/></td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppCr"/></td></tr> <tr><td>2</td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppY"/></td><td><see cref="SharpDX.WIC.PixelFormat.Format16bppCbCr"/></td><td>N/A</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPlanarBitmapFrameEncode::WriteSource']/*"/>	
        /// <msdn-id>dn302092</msdn-id>	
        /// <unmanaged>HRESULT IWICPlanarBitmapFrameEncode::WriteSource([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In, Optional] WICRect* prcSource)</unmanaged>	
        /// <unmanaged-short>IWICPlanarBitmapFrameEncode::WriteSource</unmanaged-short>	
        public void WriteSource(SharpDX.ComArray<SharpDX.WIC.BitmapSource> planesOut, int planes, SharpDX.Mathematics.Interop.RawBox? rcSourceRef) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBox rcSourceRef_;
                if (rcSourceRef.HasValue)
                    rcSourceRef_ = rcSourceRef.Value;				
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((planesOut == null)?IntPtr.Zero:planesOut.NativePointer), planes, (rcSourceRef.HasValue)?&rcSourceRef_:(void*)IntPtr.Zero,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Writes lines from the source planes to the encoded format.</p>	
        /// </summary>	
        /// <param name="planesOut"><dd>  <p>Specifies an array of <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> that represent image planes.</p> </dd></param>	
        /// <param name="planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>	
        /// <param name="rcSourceRef"><dd>  <p>The source rectangle of pixels to encode from the <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> planes.  Null indicates the entire source.  The source rect width must match the width set through <strong>SetSize</strong>. Repeated <strong>WriteSource</strong> calls can be made as long as the total accumulated source rect height is the same as set through <strong>SetSize</strong>.  </p> </dd></param>	
        /// <returns><p>If the planes and source rectangle do not meet the requirements, this method fails with <strong><see cref="SharpDX.WIC.ResultCode.Imagesizeoutofrange"/></strong>. </p><p>If the <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> format does not meet the encoder requirements, this method fails with <strong><see cref="SharpDX.WIC.ResultCode.UnsupportedPixelFormat"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>Successive <strong>WriteSource</strong> calls are assumed sequentially add scanlines to the output image.  <strong><see cref="SharpDX.WIC.BitmapFrameEncode.Initialize"/></strong>, <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetSize"/></strong> and <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPixelFormat"/></strong> must be called before this method or it will fail.</p><p>The interleaved pixel format set via <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPixelFormat"/></strong> and the codec specific encode parameters determine the supported planar formats.	
        /// </p><p>WIC JPEG Encoder:	
        /// QueryInterface can be used to obtain this interface from the WIC JPEG <strong><see cref="SharpDX.WIC.BitmapFrameEncode"/></strong> implementation.  When using this method to encode Y?CbCr data with the WIC JPEG encoder, chroma subsampling can be configured with encoder options during frame creation.  See the Encoding Overview and <strong><see cref="SharpDX.WIC.BitmapEncoder.CreateNewFrame"/></strong> for more details.   </p><p>Depending upon the configured chroma subsampling, the lineCount parameter has the following restrictions:	
        /// </p><table> <tr><th>Chroma Subsampling</th><th>X Coordinate</th><th>Y Coordinate</th><th>Chroma Width</th><th>Chroma Height</th></tr> <tr><td>4:2:0</td><td>Multiple of 2</td><td>Multiple of 2</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight / 2 Rounded up to the nearest integer.</td></tr> <tr><td>4:2:2</td><td>Multiple of 2</td><td>Any</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>Any</td></tr> <tr><td>4:4:4</td><td>Any</td><td>Any</td><td>Any</td><td>Any</td></tr> <tr><td>4:4:0</td><td>Any</td><td>Multiple of 2</td><td>lumaWidth</td><td>llumaHeight / 2 Rounded up to the nearest integer.</td></tr> </table><p>?</p><p>The full scanline width must be encoded, and the width of the bitmap sources must match their planar configuration.</p><p>Additionally, if a pixel format is set via <strong><see cref="SharpDX.WIC.BitmapFrameEncode.SetPixelFormat"/></strong>, it must be <see cref="SharpDX.WIC.PixelFormat.Format24bppBGR"/>.   </p><p>The supported pixel formats of the bitmap sources passed into this method are as follows:	
        /// </p><table> <tr><th>Plane Count</th><th>Plane 1</th><th>Plane 2</th><th>Plane 3</th></tr> <tr><td>3</td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppY"/></td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppCb"/></td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppCr"/></td></tr> <tr><td>2</td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppY"/></td><td><see cref="SharpDX.WIC.PixelFormat.Format16bppCbCr"/></td><td>N/A</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPlanarBitmapFrameEncode::WriteSource']/*"/>	
        /// <msdn-id>dn302092</msdn-id>	
        /// <unmanaged>HRESULT IWICPlanarBitmapFrameEncode::WriteSource([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In, Optional] WICRect* prcSource)</unmanaged>	
        /// <unmanaged-short>IWICPlanarBitmapFrameEncode::WriteSource</unmanaged-short>	
        private void WriteSource(System.IntPtr planesOut, int planes, System.IntPtr rcSourceRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)planesOut, planes, (void*)rcSourceRef,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Provides access to planar Y?CbCr pixel formats where pixel components are stored in separate component planes.  This interface also allows access to other codec optimizations for flip/rotate, scale, and format conversion to other Y?CbCr planar formats; this is similar to the pre-existing <strong><see cref="SharpDX.WIC.BitmapSourceTransform"/></strong> interface.</p><p>QueryInterface can be used to obtain this interface from the Windows provided implementations of <strong><see cref="SharpDX.WIC.BitmapFrameDecode"/></strong> for the JPEG decoder, <strong><see cref="SharpDX.WIC.BitmapScaler"/></strong>, <strong><see cref="SharpDX.WIC.BitmapFlipRotator"/></strong>, and <strong><see cref="SharpDX.WIC.ColorTransform"/></strong>.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPlanarBitmapSourceTransform']/*"/>	
    /// <msdn-id>dn302093</msdn-id>	
    /// <unmanaged>IWICPlanarBitmapSourceTransform</unmanaged>	
    /// <unmanaged-short>IWICPlanarBitmapSourceTransform</unmanaged-short>	
    [Guid("3AFF9CCE-BE95-4303-B927-E7D16FF4A613")]
    public partial class PlanarBitmapSourceTransform : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.PlanarBitmapSourceTransform"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PlanarBitmapSourceTransform(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.PlanarBitmapSourceTransform"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.PlanarBitmapSourceTransform(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.PlanarBitmapSourceTransform(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Use this method to determine if a desired planar output is supported and allow the caller to choose an optimized code path if it is.   Otherwise, callers should fall back to <strong><see cref="SharpDX.WIC.BitmapSourceTransform"/></strong> or <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> and retrieve interleaved pixels.</p><p> The following transforms can be checked:</p><ul> <li> Determine if the flip/rotate option specified via <strong><see cref="SharpDX.WIC.BitmapTransformOptions"/></strong> is supported.</li> <li>Determine if the requested planar pixel format configuration is supported.</li> <li>Determine the closest dimensions the implementation can natively scale to given the desired dimensions. 	
        /// </li> </ul><p>When a transform is supported, this method returns the description of the resulting planes in the <em>pPlaneDescriptions</em> parameter.	
        /// </p>	
        /// </summary>	
        /// <param name="widthRef">No documentation.</param>	
        /// <param name="heightRef">No documentation.</param>	
        /// <param name="dstTransform">No documentation.</param>	
        /// <param name="dstPlanarOptions">No documentation.</param>	
        /// <param name="guidDstFormatsRef">No documentation.</param>	
        /// <param name="planeDescriptionsRef">No documentation.</param>	
        /// <param name="planes">No documentation.</param>	
        /// <param name="fIsSupportedRef">No documentation.</param>	
        /// <returns><p>Check the value of <em>pfIsSupported</em> to determine if the transform is supported via <strong><see cref="SharpDX.WIC.PlanarBitmapSourceTransform.CopyPixels"/></strong>.  If this method fails, the output parameters for width, height, and plane descriptions are zero initialized.Other return values indicate failure. </p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPlanarBitmapSourceTransform::DoesSupportTransform']/*"/>	
        /// <msdn-id>dn302095</msdn-id>	
        /// <unmanaged>HRESULT IWICPlanarBitmapSourceTransform::DoesSupportTransform([InOut] unsigned int* puiWidth,[InOut] unsigned int* puiHeight,[In] WICBitmapTransformOptions dstTransform,[In] WICPlanarOptions dstPlanarOptions,[In, Buffer] const GUID* pguidDstFormats,[Out, Buffer] WICBitmapPlaneDescription* pPlaneDescriptions,[In] unsigned int cPlanes,[Out] BOOL* pfIsSupported)</unmanaged>	
        /// <unmanaged-short>IWICPlanarBitmapSourceTransform::DoesSupportTransform</unmanaged-short>	
        public void DoesSupportTransform(ref int widthRef, ref int heightRef, SharpDX.WIC.BitmapTransformOptions dstTransform, SharpDX.WIC.PlanarOptions dstPlanarOptions, System.Guid[] guidDstFormatsRef, SharpDX.WIC.BitmapPlaneDescription[] planeDescriptionsRef, int planes, out SharpDX.Mathematics.Interop.RawBool fIsSupportedRef) {
            unsafe {
                fIsSupportedRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* widthRef_ = &widthRef)
                    fixed (void* heightRef_ = &heightRef)
                        fixed (void* guidDstFormatsRef_ = guidDstFormatsRef)
                            fixed (void* planeDescriptionsRef_ = planeDescriptionsRef)
                                fixed (void* fIsSupportedRef_ = &fIsSupportedRef)
                                    __result__= 
                    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, widthRef_, heightRef_, unchecked((int)dstTransform), unchecked((int)dstPlanarOptions), guidDstFormatsRef_, planeDescriptionsRef_, planes, fIsSupportedRef_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Copies pixels into the destination planes.  Configured by the supplied input parameters.  </p><p>If a <em>dstTransform</em>, scale, or format conversion is specified, <em>cbStride</em> is the transformed stride and is based on the destination pixel format of the <em>pDstPlanes</em> parameter, not the original source's pixel format.</p>	
        /// </summary>	
        /// <param name="rcSourceRef"><dd>  <p>The source rectangle of pixels to copy.  </p> </dd></param>	
        /// <param name="width"><dd>  <p>The width to scale the source bitmap.  This parameter must be equal to a value obtainable through <strong>IWICPlanarBitmapSourceTransform:: DoesSupportTransform</strong>.</p> </dd></param>	
        /// <param name="height"><dd>  <p>The height to scale the source bitmap.  This parameter must be equal to a value obtainable through <strong>IWICPlanarBitmapSourceTransform:: DoesSupportTransform</strong>.</p> </dd></param>	
        /// <param name="dstTransform"><dd>  <p>The desired rotation or flip to perform prior to the pixel copy.  A rotate can be combined with a flip horizontal or a flip vertical, see <strong><see cref="SharpDX.WIC.BitmapTransformOptions"/></strong>.</p> </dd></param>	
        /// <param name="dstPlanarOptions"><dd>  <p>Used to specify additional configuration options for the transform.  See <strong><see cref="SharpDX.WIC.PlanarOptions"/></strong> for more detail.</p> <p>WIC JPEG Decoder:<strong><see cref="SharpDX.WIC.PlanarOptions.PlanarOptionsPreserveSubsampling"/></strong> can be specified to retain the subsampling ratios when downscaling.  By default, the JPEG decoder attempts to preserve quality by downscaling only the Y plane in some cases, changing the image to 4:4:4 chroma subsampling.</p> </dd></param>	
        /// <param name="dstPlanesRef"><dd>  <p>Specifies the pixel format and output buffer for each component plane.  The number of planes and pixel format of each plane must match values obtainable through  <strong><see cref="SharpDX.WIC.PlanarBitmapSourceTransform.DoesSupportTransform"/></strong>.</p> </dd></param>	
        /// <param name="planes"><dd>  <p>The number of component planes specified by the <em>pDstPlanes</em> parameter.</p> </dd></param>	
        /// <returns><p>If the specified scale, flip/rotate, and planar format configuration is not supported this method fails with <strong><see cref="SharpDX.WIC.ResultCode.InvalidParameter"/></strong>.  You can check if a transform is supported by calling <strong><see cref="SharpDX.WIC.PlanarBitmapSourceTransform.DoesSupportTransform"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>WIC JPEG Decoder:	
        /// Depending on the configured chroma subsampling of the image, the source rectangle has the following restrictions:	
        /// </p><table> <tr><th>Chroma Subsampling</th><th>X Coordinate</th><th>Y Coordinate</th><th>Chroma Width</th><th>Chroma Height</th></tr> <tr><td>4:2:0</td><td>Multiple of 2</td><td>Multiple of 2</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight / 2 Rounded up to the nearest integer.</td></tr> <tr><td>4:2:2</td><td>Multiple of 2</td><td>Any</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight</td></tr> <tr><td>4:4:4</td><td>Any</td><td>Any</td><td>llumaWidth</td><td>llumaHeight</td></tr> <tr><td>4:4:0</td><td>Any</td><td>Multiple of 2</td><td>lumaWidth</td><td>llumaHeight / 2 Rounded up to the nearest integer.</td></tr> </table><p>?</p><p>The <em>pDstPlanes</em> parameter supports the following pixel formats.</p><table> <tr><th>Plane Count</th><th>Plane 1</th><th>Plane 2</th><th>Plane 3</th></tr> <tr><td>3</td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppY"/></td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppCb"/></td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppCr"/></td></tr> <tr><td>2</td><td><see cref="SharpDX.WIC.PixelFormat.Format8bppY"/></td><td><see cref="SharpDX.WIC.PixelFormat.Format16bppCbCr"/></td><td>N/A</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPlanarBitmapSourceTransform::CopyPixels']/*"/>	
        /// <msdn-id>dn302094</msdn-id>	
        /// <unmanaged>HRESULT IWICPlanarBitmapSourceTransform::CopyPixels([In, Optional] const WICRect* prcSource,[In] unsigned int uiWidth,[In] unsigned int uiHeight,[In] WICBitmapTransformOptions dstTransform,[In] WICPlanarOptions dstPlanarOptions,[In, Buffer] const WICBitmapPlane* pDstPlanes,[In] unsigned int cPlanes)</unmanaged>	
        /// <unmanaged-short>IWICPlanarBitmapSourceTransform::CopyPixels</unmanaged-short>	
        public void CopyPixels(SharpDX.Mathematics.Interop.RawBox? rcSourceRef, int width, int height, SharpDX.WIC.BitmapTransformOptions dstTransform, SharpDX.WIC.PlanarOptions dstPlanarOptions, SharpDX.WIC.BitmapPlane[] dstPlanesRef, int planes) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBox rcSourceRef_;
                if (rcSourceRef.HasValue)
                    rcSourceRef_ = rcSourceRef.Value;				
                SharpDX.Result __result__;
                fixed (void* dstPlanesRef_ = dstPlanesRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (rcSourceRef.HasValue)?&rcSourceRef_:(void*)IntPtr.Zero, width, height, unchecked((int)dstTransform), unchecked((int)dstPlanarOptions), dstPlanesRef_, planes,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Allows a format converter to be initialized with a planar source. You can use QueryInterface to obtain this interface from the Windows provided implementation of <strong><see cref="SharpDX.WIC.FormatConverter"/></strong>.</p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPlanarFormatConverter']/*"/>	
    /// <msdn-id>dn302096</msdn-id>	
    /// <unmanaged>IWICPlanarFormatConverter</unmanaged>	
    /// <unmanaged-short>IWICPlanarFormatConverter</unmanaged-short>	
    [Guid("BEBEE9CB-83B0-4DCC-8132-B0AAA55EAC96")]
    public partial class PlanarFormatConverter : SharpDX.WIC.BitmapSource {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.PlanarFormatConverter"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PlanarFormatConverter(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.PlanarFormatConverter"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.PlanarFormatConverter(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.PlanarFormatConverter(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Initializes a format converter with a planar source, and specifies the interleaved output pixel format.</p>	
        /// </summary>	
        /// <param name="planesOut"><dd>  <p>An array of <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> that represents image planes.</p> </dd></param>	
        /// <param name="planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>	
        /// <param name="dstFormat"><dd>  <p>The destination interleaved pixel format.</p> </dd></param>	
        /// <param name="dither"><dd>  <p>The <strong><see cref="SharpDX.WIC.BitmapDitherType"/></strong> used for conversion.</p> </dd></param>	
        /// <param name="paletteRef"><dd>  <p>The palette to use for conversion.</p> </dd></param>	
        /// <param name="alphaThresholdPercent"><dd>  <p>The alpha threshold to use for conversion.</p> </dd></param>	
        /// <param name="paletteTranslate"><dd>  <p>The palette translation type to use for conversion.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPlanarFormatConverter::Initialize']/*"/>	
        /// <msdn-id>dn302098</msdn-id>	
        /// <unmanaged>HRESULT IWICPlanarFormatConverter::Initialize([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In] const GUID&amp; dstFormat,[In] WICBitmapDitherType dither,[In, Optional] IWICPalette* pIPalette,[In] double alphaThresholdPercent,[In] WICBitmapPaletteType paletteTranslate)</unmanaged>	
        /// <unmanaged-short>IWICPlanarFormatConverter::Initialize</unmanaged-short>	
        public void Initialize(SharpDX.WIC.BitmapSource[] planesOut, int planes, System.Guid dstFormat, SharpDX.WIC.BitmapDitherType dither, SharpDX.WIC.Palette paletteRef, double alphaThresholdPercent, SharpDX.WIC.BitmapPaletteType paletteTranslate) {
            unsafe {
                IntPtr* planesOut_ = (IntPtr*)0;
                if ( planesOut != null ) {
                    IntPtr* planesOut__ = stackalloc IntPtr[planesOut.Length];
                    planesOut_ = planesOut__;
                    for (int i = 0; i < planesOut.Length; i++)                        
                        planesOut_[i] =  (planesOut[i] == null)? IntPtr.Zero : planesOut[i].NativePointer;
                }
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, planesOut_, planes, &dstFormat, unchecked((int)dither), (void*)((paletteRef == null)?IntPtr.Zero:paletteRef.NativePointer), alphaThresholdPercent, unchecked((int)paletteTranslate),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Initializes a format converter with a planar source, and specifies the interleaved output pixel format.</p>	
        /// </summary>	
        /// <param name="planesOut"><dd>  <p>An array of <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> that represents image planes.</p> </dd></param>	
        /// <param name="planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>	
        /// <param name="dstFormat"><dd>  <p>The destination interleaved pixel format.</p> </dd></param>	
        /// <param name="dither"><dd>  <p>The <strong><see cref="SharpDX.WIC.BitmapDitherType"/></strong> used for conversion.</p> </dd></param>	
        /// <param name="paletteRef"><dd>  <p>The palette to use for conversion.</p> </dd></param>	
        /// <param name="alphaThresholdPercent"><dd>  <p>The alpha threshold to use for conversion.</p> </dd></param>	
        /// <param name="paletteTranslate"><dd>  <p>The palette translation type to use for conversion.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPlanarFormatConverter::Initialize']/*"/>	
        /// <msdn-id>dn302098</msdn-id>	
        /// <unmanaged>HRESULT IWICPlanarFormatConverter::Initialize([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In] const GUID&amp; dstFormat,[In] WICBitmapDitherType dither,[In, Optional] IWICPalette* pIPalette,[In] double alphaThresholdPercent,[In] WICBitmapPaletteType paletteTranslate)</unmanaged>	
        /// <unmanaged-short>IWICPlanarFormatConverter::Initialize</unmanaged-short>	
        public void Initialize(SharpDX.ComArray<SharpDX.WIC.BitmapSource> planesOut, int planes, System.Guid dstFormat, SharpDX.WIC.BitmapDitherType dither, SharpDX.WIC.Palette paletteRef, double alphaThresholdPercent, SharpDX.WIC.BitmapPaletteType paletteTranslate) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)((planesOut == null)?IntPtr.Zero:planesOut.NativePointer), planes, &dstFormat, unchecked((int)dither), (void*)((paletteRef == null)?IntPtr.Zero:paletteRef.NativePointer), alphaThresholdPercent, unchecked((int)paletteTranslate),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Initializes a format converter with a planar source, and specifies the interleaved output pixel format.</p>	
        /// </summary>	
        /// <param name="planesOut"><dd>  <p>An array of <strong><see cref="SharpDX.WIC.BitmapSource"/></strong> that represents image planes.</p> </dd></param>	
        /// <param name="planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>	
        /// <param name="dstFormat"><dd>  <p>The destination interleaved pixel format.</p> </dd></param>	
        /// <param name="dither"><dd>  <p>The <strong><see cref="SharpDX.WIC.BitmapDitherType"/></strong> used for conversion.</p> </dd></param>	
        /// <param name="paletteRef"><dd>  <p>The palette to use for conversion.</p> </dd></param>	
        /// <param name="alphaThresholdPercent"><dd>  <p>The alpha threshold to use for conversion.</p> </dd></param>	
        /// <param name="paletteTranslate"><dd>  <p>The palette translation type to use for conversion.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPlanarFormatConverter::Initialize']/*"/>	
        /// <msdn-id>dn302098</msdn-id>	
        /// <unmanaged>HRESULT IWICPlanarFormatConverter::Initialize([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In] const GUID&amp; dstFormat,[In] WICBitmapDitherType dither,[In, Optional] IWICPalette* pIPalette,[In] double alphaThresholdPercent,[In] WICBitmapPaletteType paletteTranslate)</unmanaged>	
        /// <unmanaged-short>IWICPlanarFormatConverter::Initialize</unmanaged-short>	
        private void Initialize(System.IntPtr planesOut, int planes, System.IntPtr dstFormat, SharpDX.WIC.BitmapDitherType dither, System.IntPtr paletteRef, double alphaThresholdPercent, SharpDX.WIC.BitmapPaletteType paletteTranslate) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)planesOut, planes, (void*)dstFormat, unchecked((int)dither), (void*)paletteRef, alphaThresholdPercent, unchecked((int)paletteTranslate),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Query if the format converter can convert from one format to another.</p>	
        /// </summary>	
        /// <param name="srcPixelFormatsRef"><dd> <p>An array of WIC pixel formats that represents source image planes.</p> </dd></param>	
        /// <param name="srcPlanes"><dd> <p>The number of source pixel formats specified by the <em>pSrcFormats</em> parameter.</p> </dd></param>	
        /// <param name="dstPixelFormat"><dd> <p>The destination interleaved pixel format.</p> </dd></param>	
        /// <param name="fCanConvertRef"><dd> <p>True if the conversion is supported.</p> </dd></param>	
        /// <returns><p>If the conversion is not supported, this method returns <see cref="SharpDX.Result.Ok"/>, but *<em>pfCanConvert</em> is set to <see cref="SharpDX.Result.False"/>. </p><p>If this method fails, the out parameter <em>pfCanConvert</em> is invalid.</p></returns>	
        /// <remarks>	
        /// <p>To specify an interleaved input pixel format, provide a length 1 array to <em>pSrcPixelFormats</em>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICPlanarFormatConverter::CanConvert']/*"/>	
        /// <msdn-id>dn302097</msdn-id>	
        /// <unmanaged>HRESULT IWICPlanarFormatConverter::CanConvert([In, Buffer] const GUID* pSrcPixelFormats,[In] unsigned int cSrcPlanes,[In] const GUID&amp; dstPixelFormat,[Out] BOOL* pfCanConvert)</unmanaged>	
        /// <unmanaged-short>IWICPlanarFormatConverter::CanConvert</unmanaged-short>	
        public void CanConvert(System.Guid[] srcPixelFormatsRef, int srcPlanes, System.Guid dstPixelFormat, out SharpDX.Mathematics.Interop.RawBool fCanConvertRef) {
            unsafe {
                fCanConvertRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* srcPixelFormatsRef_ = srcPixelFormatsRef)
                    fixed (void* fCanConvertRef_ = &fCanConvertRef)
                        __result__= 
        				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, srcPixelFormatsRef_, srcPlanes, &dstPixelFormat, fCanConvertRef_,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p><strong><see cref="SharpDX.WIC.ProgressCallback"/></strong> interface is documented only for compliance; its use is not recommended and may be altered or unavailable in the future. Instead, and use <strong>RegisterProgressNotification</strong>. 	
    /// </p>	
    /// </summary>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICProgressCallback']/*"/>	
    /// <msdn-id>ee719775</msdn-id>	
    /// <unmanaged>IWICProgressCallback</unmanaged>	
    /// <unmanaged-short>IWICProgressCallback</unmanaged-short>	
    [Guid("4776F9CD-9517-45FA-BF24-E89C5EC5C60C")]
    internal partial class ProgressCallback : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.ProgressCallback"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ProgressCallback(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.ProgressCallback"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.ProgressCallback(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.ProgressCallback(nativePointer);
		}
        
        
        /// <summary>	
        /// <p><strong>Notify</strong> method is documented only for compliance; its use is not recommended and may be altered or unavailable in the future. Instead, and use <strong>RegisterProgressNotification</strong>. 	
        /// </p>	
        /// </summary>	
        /// <param name="frameNum">No documentation.</param>	
        /// <param name="operation">No documentation.</param>	
        /// <param name="dblProgress">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICProgressCallback::Notify']/*"/>	
        /// <msdn-id>ee719776</msdn-id>	
        /// <unmanaged>HRESULT IWICProgressCallback::Notify([In] unsigned int uFrameNum,[In] WICProgressOperation operation,[In] double dblProgress)</unmanaged>	
        /// <unmanaged-short>IWICProgressCallback::Notify</unmanaged-short>	
        public void Notify(int frameNum, SharpDX.WIC.ProgressOperation operation, double dblProgress) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, frameNum, unchecked((int)operation), dblProgress,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Exposes methods for obtaining information about and controlling progressive decoding.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Images can only be progressively decoded if they were progressively encoded. Progressive images automatically start at the highest (best quality) progressive level. The caller must manually set the decoder to a lower progressive level.</p><p>E_NOTIMPL is returned if the codec does not support progressive level decoding.</p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICProgressiveLevelControl']/*"/>	
    /// <msdn-id>ee719778</msdn-id>	
    /// <unmanaged>IWICProgressiveLevelControl</unmanaged>	
    /// <unmanaged-short>IWICProgressiveLevelControl</unmanaged-short>	
    [Guid("DAAC296F-7AA5-4dbf-8D15-225C5976F891")]
    public partial class ProgressiveLevelControl : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.ProgressiveLevelControl"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ProgressiveLevelControl(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.ProgressiveLevelControl"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.ProgressiveLevelControl(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.ProgressiveLevelControl(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the number of levels of progressive decoding supported by the CODEC.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Users should not use this function to iterate through the progressive levels of a progressive JPEG image. JPEG progressive levels are determined by the image and do not have a fixed level count. Using this method will force the application to wait for all progressive levels to be downloaded before it can return. Instead, applications should use the following code to iterate through the progressive levels of a progressive JPEG image.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICProgressiveLevelControl::GetLevelCount']/*"/>	
        /// <msdn-id>ee719780</msdn-id>	
        /// <unmanaged>GetLevelCount</unmanaged>	
        /// <unmanaged-short>GetLevelCount</unmanaged-short>	
        /// <unmanaged>HRESULT IWICProgressiveLevelControl::GetLevelCount([Out] unsigned int* pcLevels)</unmanaged>
        public int LevelCount {
                get { int __output__; GetLevelCount(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets or sets the decoder's current progressive level.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The level always defaults to the highest progressive level. In order to decode a lower progressive level, <strong>SetCurrentLevel</strong> must first be called.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICProgressiveLevelControl::GetCurrentLevel']/*"/>	
        /// <msdn-id>ee719779</msdn-id>	
        /// <unmanaged>GetCurrentLevel / SetCurrentLevel</unmanaged>	
        /// <unmanaged-short>GetCurrentLevel</unmanaged-short>	
        /// <unmanaged>HRESULT IWICProgressiveLevelControl::GetCurrentLevel([Out] unsigned int* pnLevel)</unmanaged>
        public int CurrentLevel {
                get { int __output__; GetCurrentLevel(out __output__); return __output__; }
                set { SetCurrentLevel(value); }
        }
        
        /// <summary>	
        /// <p>Gets the number of levels of progressive decoding supported by the CODEC.</p>	
        /// </summary>	
        /// <param name="levelsRef"><dd>  <p>Indicates the number of levels supported by the CODEC.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>Users should not use this function to iterate through the progressive levels of a progressive JPEG image. JPEG progressive levels are determined by the image and do not have a fixed level count. Using this method will force the application to wait for all progressive levels to be downloaded before it can return. Instead, applications should use the following code to iterate through the progressive levels of a progressive JPEG image.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICProgressiveLevelControl::GetLevelCount']/*"/>	
        /// <msdn-id>ee719780</msdn-id>	
        /// <unmanaged>HRESULT IWICProgressiveLevelControl::GetLevelCount([Out] unsigned int* pcLevels)</unmanaged>	
        /// <unmanaged-short>IWICProgressiveLevelControl::GetLevelCount</unmanaged-short>	
        internal void GetLevelCount(out int levelsRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* levelsRef_ = &levelsRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, levelsRef_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the decoder's current progressive level.</p>	
        /// </summary>	
        /// <param name="nLevelRef"><dd>  <p>Indicates the current level specified.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The level always defaults to the highest progressive level. In order to decode a lower progressive level, <strong>SetCurrentLevel</strong> must first be called.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICProgressiveLevelControl::GetCurrentLevel']/*"/>	
        /// <msdn-id>ee719779</msdn-id>	
        /// <unmanaged>HRESULT IWICProgressiveLevelControl::GetCurrentLevel([Out] unsigned int* pnLevel)</unmanaged>	
        /// <unmanaged-short>IWICProgressiveLevelControl::GetCurrentLevel</unmanaged-short>	
        internal void GetCurrentLevel(out int nLevelRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* nLevelRef_ = &nLevelRef)
                    __result__= 
    				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, nLevelRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Specifies the level to retrieve on the next call to <strong>CopyPixels</strong>.</p>	
        /// </summary>	
        /// <param name="nLevel">No documentation.</param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> A call does not have to request every level supported. If a caller requests level 1, without having previously requested level 0, the bits returned by the next call to <strong>CopyPixels</strong> will include both levels. </p><p> If the requested level is invalid, the error returned is <see cref="SharpDX.WIC.ResultCode.InvalidProgressivelevel"/>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICProgressiveLevelControl::SetCurrentLevel']/*"/>	
        /// <msdn-id>ee719781</msdn-id>	
        /// <unmanaged>HRESULT IWICProgressiveLevelControl::SetCurrentLevel([In] unsigned int nLevel)</unmanaged>	
        /// <unmanaged-short>IWICProgressiveLevelControl::SetCurrentLevel</unmanaged-short>	
        internal void SetCurrentLevel(int nLevel) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, nLevel,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Represents a Windows Imaging Component (WIC) stream for referencing imaging and metadata content.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Decoders and metadata handlers are expected to create sub streams of whatever stream they hold when handing off control for embedded metadata to another metadata handler.  If the stream is not restricted then use MAXLONGLONG as the max size and offset 0.</p><p> The <strong><see cref="SharpDX.WIC.WICStream"/></strong> interface methods do not enable you to provide a file sharing option. To create a file stream for an image, use the SHCreateStreamOnFileEx function. This stream can then be used to create an <strong><see cref="SharpDX.WIC.BitmapDecoder"/></strong> using the <strong>CreateDecoderFromStream</strong> method. </p>	
    /// </remarks>	
    /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICStream']/*"/>	
    /// <msdn-id>ee719782</msdn-id>	
    /// <unmanaged>IWICStream</unmanaged>	
    /// <unmanaged-short>IWICStream</unmanaged-short>	
    [Guid("135FF860-22B7-4ddf-B0F6-218F4F299A43")]
    public partial class WICStream : SharpDX.Win32.ComStream {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.WIC.WICStream"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public WICStream(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.WIC.WICStream"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.WIC.WICStream(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.WIC.WICStream(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Initializes a stream from another stream. Access rights are inherited from the underlying stream.</p>	
        /// </summary>	
        /// <param name="streamRef"><dd>  <p>The initialize stream.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICStream::InitializeFromIStream']/*"/>	
        /// <msdn-id>ee719789</msdn-id>	
        /// <unmanaged>HRESULT IWICStream::InitializeFromIStream([In, Optional] IStream* pIStream)</unmanaged>	
        /// <unmanaged-short>IWICStream::InitializeFromIStream</unmanaged-short>	
        internal void InitializeFromIStream_(System.IntPtr streamRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)streamRef,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Initializes a stream from a particular file.</p>	
        /// </summary>	
        /// <param name="fileName"><dd>  <p>The file used to initialize the stream.</p> </dd></param>	
        /// <param name="desiredAccess"><dd>  <p>The desired file access mode.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>GENERIC_READ</strong></dt> </dl> </td><td> <p>Read access.</p> </td></tr> <tr><td><dl> <dt><strong>GENERIC_WRITE</strong></dt> </dl> </td><td> <p>Write access.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p> The <strong><see cref="SharpDX.WIC.WICStream"/></strong> interface methods do not enable you to provide a file sharing option. To create a shared file stream for an image, use the SHCreateStreamOnFileEx function. This stream can then be used to create an <strong><see cref="SharpDX.WIC.BitmapDecoder"/></strong> using the <strong>CreateDecoderFromStream</strong> method. </p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICStream::InitializeFromFilename']/*"/>	
        /// <msdn-id>ee719788</msdn-id>	
        /// <unmanaged>HRESULT IWICStream::InitializeFromFilename([In] const wchar_t* wzFileName,[In] unsigned int dwDesiredAccess)</unmanaged>	
        /// <unmanaged-short>IWICStream::InitializeFromFilename</unmanaged-short>	
        internal void InitializeFromFilename(string fileName, int desiredAccess) {
            unsafe {
                IntPtr fileName_ = Utilities.StringToHGlobalUni(fileName);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)fileName_, desiredAccess,((void**)(*(void**)_nativePointer))[15]);		
                Marshal.FreeHGlobal(fileName_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Initializes a stream to treat a block of memory as a stream. The stream cannot grow beyond the buffer size. </p>	
        /// </summary>	
        /// <param name="bufferRef"><dd>  <p>Pointer to the buffer used to initialize the stream.</p> </dd></param>	
        /// <param name="bufferSize"><dd>  <p>The size of buffer.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>This method should be avoided whenever possible. The caller is responsible for ensuring the memory block is valid for the lifetime of the stream when using <strong>InitializeFromMemory</strong>.  A workaround for this behavior is to create an <strong><see cref="SharpDX.Win32.IStream"/></strong> and use <strong>InitializeFromIStream</strong> to create the <strong><see cref="SharpDX.WIC.WICStream"/></strong>.</p><p>If you require a growable memory stream, use <strong>CreateStreamOnHGlobal</strong>.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICStream::InitializeFromMemory']/*"/>	
        /// <msdn-id>ee719792</msdn-id>	
        /// <unmanaged>HRESULT IWICStream::InitializeFromMemory([In] void* pbBuffer,[In] unsigned int cbBufferSize)</unmanaged>	
        /// <unmanaged-short>IWICStream::InitializeFromMemory</unmanaged-short>	
        internal void InitializeFromMemory(System.IntPtr bufferRef, int bufferSize) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)bufferRef, bufferSize,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Initializes the stream as a substream of another stream.</p>	
        /// </summary>	
        /// <param name="streamRef"><dd>  <p>Pointer to the input stream.</p> </dd></param>	
        /// <param name="ulOffset"><dd>  <p>The stream offset used to create the new stream.</p> </dd></param>	
        /// <param name="ulMaxSize"><dd>  <p>The maximum size of the stream.</p> </dd></param>	
        /// <returns><p>If this method succeeds, it returns <strong><see cref="SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="SharpDX.Result"/></strong> error code.</p></returns>	
        /// <remarks>	
        /// <p>The stream functions with its own stream position, independent of the underlying stream but restricted to a region.  All seek positions are relative to the sub region.  It is allowed, though not recommended, to have multiple writable sub streams overlapping the same range.</p>	
        /// </remarks>	
        /// <include file='..\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IWICStream::InitializeFromIStreamRegion']/*"/>	
        /// <msdn-id>ee719790</msdn-id>	
        /// <unmanaged>HRESULT IWICStream::InitializeFromIStreamRegion([In, Optional] IStream* pIStream,[In] ULARGE_INTEGER ulOffset,[In] ULARGE_INTEGER ulMaxSize)</unmanaged>	
        /// <unmanaged-short>IWICStream::InitializeFromIStreamRegion</unmanaged-short>	
        internal void InitializeFromIStreamRegion_(System.IntPtr streamRef, long ulOffset, long ulMaxSize) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct2D1.LocalInterop.Calliint(_nativePointer, (void*)streamRef, ulOffset, ulMaxSize,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
    }
}
